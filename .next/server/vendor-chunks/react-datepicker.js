"use strict";
/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
exports.id = "vendor-chunks/react-datepicker";
exports.ids = ["vendor-chunks/react-datepicker"];
exports.modules = {

/***/ "(ssr)/./node_modules/react-datepicker/dist/index.es.js":
/*!********************************************************!*\
  !*** ./node_modules/react-datepicker/dist/index.es.js ***!
  \********************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   CalendarContainer: () => (/* binding */ CalendarContainer),\n/* harmony export */   DatePicker: () => (/* binding */ DatePicker),\n/* harmony export */   \"default\": () => (/* binding */ DatePicker),\n/* harmony export */   getDefaultLocale: () => (/* binding */ getDefaultLocale),\n/* harmony export */   registerLocale: () => (/* binding */ registerLocale),\n/* harmony export */   setDefaultLocale: () => (/* binding */ setDefaultLocale)\n/* harmony export */ });\n/* harmony import */ var clsx__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! clsx */ \"(ssr)/./node_modules/clsx/dist/clsx.mjs\");\n/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! react */ \"(ssr)/./node_modules/next/dist/server/future/route-modules/app-page/vendored/ssr/react.js\");\n/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_1___default = /*#__PURE__*/__webpack_require__.n(react__WEBPACK_IMPORTED_MODULE_1__);\n/* harmony import */ var date_fns__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! date-fns */ \"(ssr)/./node_modules/date-fns/parseISO.js\");\n/* harmony import */ var date_fns__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! date-fns */ \"(ssr)/./node_modules/date-fns/toDate.js\");\n/* harmony import */ var date_fns__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! date-fns */ \"(ssr)/./node_modules/date-fns/parse.js\");\n/* harmony import */ var date_fns__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! date-fns */ \"(ssr)/./node_modules/date-fns/isValid.js\");\n/* harmony import */ var date_fns__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! date-fns */ \"(ssr)/./node_modules/date-fns/isBefore.js\");\n/* harmony import */ var date_fns__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(/*! date-fns */ \"(ssr)/./node_modules/date-fns/format.js\");\n/* harmony import */ var date_fns__WEBPACK_IMPORTED_MODULE_9__ = __webpack_require__(/*! date-fns */ \"(ssr)/./node_modules/date-fns/setHours.js\");\n/* harmony import */ var date_fns__WEBPACK_IMPORTED_MODULE_10__ = __webpack_require__(/*! date-fns */ \"(ssr)/./node_modules/date-fns/setMinutes.js\");\n/* harmony import */ var date_fns__WEBPACK_IMPORTED_MODULE_11__ = __webpack_require__(/*! date-fns */ \"(ssr)/./node_modules/date-fns/setSeconds.js\");\n/* harmony import */ var date_fns__WEBPACK_IMPORTED_MODULE_12__ = __webpack_require__(/*! date-fns */ \"(ssr)/./node_modules/date-fns/getISOWeek.js\");\n/* harmony import */ var date_fns__WEBPACK_IMPORTED_MODULE_13__ = __webpack_require__(/*! date-fns */ \"(ssr)/./node_modules/date-fns/startOfDay.js\");\n/* harmony import */ var date_fns__WEBPACK_IMPORTED_MODULE_14__ = __webpack_require__(/*! date-fns */ \"(ssr)/./node_modules/date-fns/startOfWeek.js\");\n/* harmony import */ var date_fns__WEBPACK_IMPORTED_MODULE_15__ = __webpack_require__(/*! date-fns */ \"(ssr)/./node_modules/date-fns/startOfMonth.js\");\n/* harmony import */ var date_fns__WEBPACK_IMPORTED_MODULE_16__ = __webpack_require__(/*! date-fns */ \"(ssr)/./node_modules/date-fns/startOfYear.js\");\n/* harmony import */ var date_fns__WEBPACK_IMPORTED_MODULE_17__ = __webpack_require__(/*! date-fns */ \"(ssr)/./node_modules/date-fns/startOfQuarter.js\");\n/* harmony import */ var date_fns__WEBPACK_IMPORTED_MODULE_18__ = __webpack_require__(/*! date-fns */ \"(ssr)/./node_modules/date-fns/endOfDay.js\");\n/* harmony import */ var date_fns__WEBPACK_IMPORTED_MODULE_19__ = __webpack_require__(/*! date-fns */ \"(ssr)/./node_modules/date-fns/endOfWeek.js\");\n/* harmony import */ var date_fns__WEBPACK_IMPORTED_MODULE_20__ = __webpack_require__(/*! date-fns */ \"(ssr)/./node_modules/date-fns/endOfMonth.js\");\n/* harmony import */ var date_fns__WEBPACK_IMPORTED_MODULE_21__ = __webpack_require__(/*! date-fns */ \"(ssr)/./node_modules/date-fns/isSameYear.js\");\n/* harmony import */ var date_fns__WEBPACK_IMPORTED_MODULE_22__ = __webpack_require__(/*! date-fns */ \"(ssr)/./node_modules/date-fns/isSameMonth.js\");\n/* harmony import */ var date_fns__WEBPACK_IMPORTED_MODULE_23__ = __webpack_require__(/*! date-fns */ \"(ssr)/./node_modules/date-fns/isSameQuarter.js\");\n/* harmony import */ var date_fns__WEBPACK_IMPORTED_MODULE_24__ = __webpack_require__(/*! date-fns */ \"(ssr)/./node_modules/date-fns/isSameDay.js\");\n/* harmony import */ var date_fns__WEBPACK_IMPORTED_MODULE_25__ = __webpack_require__(/*! date-fns */ \"(ssr)/./node_modules/date-fns/isEqual.js\");\n/* harmony import */ var date_fns__WEBPACK_IMPORTED_MODULE_26__ = __webpack_require__(/*! date-fns */ \"(ssr)/./node_modules/date-fns/isWithinInterval.js\");\n/* harmony import */ var date_fns__WEBPACK_IMPORTED_MODULE_27__ = __webpack_require__(/*! date-fns */ \"(ssr)/./node_modules/date-fns/setMonth.js\");\n/* harmony import */ var date_fns__WEBPACK_IMPORTED_MODULE_28__ = __webpack_require__(/*! date-fns */ \"(ssr)/./node_modules/date-fns/setQuarter.js\");\n/* harmony import */ var date_fns__WEBPACK_IMPORTED_MODULE_29__ = __webpack_require__(/*! date-fns */ \"(ssr)/./node_modules/date-fns/getYear.js\");\n/* harmony import */ var date_fns__WEBPACK_IMPORTED_MODULE_30__ = __webpack_require__(/*! date-fns */ \"(ssr)/./node_modules/date-fns/getMonth.js\");\n/* harmony import */ var date_fns__WEBPACK_IMPORTED_MODULE_31__ = __webpack_require__(/*! date-fns */ \"(ssr)/./node_modules/date-fns/endOfYear.js\");\n/* harmony import */ var date_fns__WEBPACK_IMPORTED_MODULE_32__ = __webpack_require__(/*! date-fns */ \"(ssr)/./node_modules/date-fns/getQuarter.js\");\n/* harmony import */ var date_fns__WEBPACK_IMPORTED_MODULE_33__ = __webpack_require__(/*! date-fns */ \"(ssr)/./node_modules/date-fns/differenceInCalendarDays.js\");\n/* harmony import */ var date_fns__WEBPACK_IMPORTED_MODULE_34__ = __webpack_require__(/*! date-fns */ \"(ssr)/./node_modules/date-fns/getHours.js\");\n/* harmony import */ var date_fns__WEBPACK_IMPORTED_MODULE_35__ = __webpack_require__(/*! date-fns */ \"(ssr)/./node_modules/date-fns/getMinutes.js\");\n/* harmony import */ var date_fns__WEBPACK_IMPORTED_MODULE_36__ = __webpack_require__(/*! date-fns */ \"(ssr)/./node_modules/date-fns/getSeconds.js\");\n/* harmony import */ var date_fns__WEBPACK_IMPORTED_MODULE_37__ = __webpack_require__(/*! date-fns */ \"(ssr)/./node_modules/date-fns/subMonths.js\");\n/* harmony import */ var date_fns__WEBPACK_IMPORTED_MODULE_38__ = __webpack_require__(/*! date-fns */ \"(ssr)/./node_modules/date-fns/differenceInCalendarMonths.js\");\n/* harmony import */ var date_fns__WEBPACK_IMPORTED_MODULE_39__ = __webpack_require__(/*! date-fns */ \"(ssr)/./node_modules/date-fns/addMonths.js\");\n/* harmony import */ var date_fns__WEBPACK_IMPORTED_MODULE_40__ = __webpack_require__(/*! date-fns */ \"(ssr)/./node_modules/date-fns/subQuarters.js\");\n/* harmony import */ var date_fns__WEBPACK_IMPORTED_MODULE_41__ = __webpack_require__(/*! date-fns */ \"(ssr)/./node_modules/date-fns/differenceInCalendarQuarters.js\");\n/* harmony import */ var date_fns__WEBPACK_IMPORTED_MODULE_42__ = __webpack_require__(/*! date-fns */ \"(ssr)/./node_modules/date-fns/addQuarters.js\");\n/* harmony import */ var date_fns__WEBPACK_IMPORTED_MODULE_43__ = __webpack_require__(/*! date-fns */ \"(ssr)/./node_modules/date-fns/subYears.js\");\n/* harmony import */ var date_fns__WEBPACK_IMPORTED_MODULE_44__ = __webpack_require__(/*! date-fns */ \"(ssr)/./node_modules/date-fns/differenceInCalendarYears.js\");\n/* harmony import */ var date_fns__WEBPACK_IMPORTED_MODULE_45__ = __webpack_require__(/*! date-fns */ \"(ssr)/./node_modules/date-fns/addYears.js\");\n/* harmony import */ var date_fns__WEBPACK_IMPORTED_MODULE_46__ = __webpack_require__(/*! date-fns */ \"(ssr)/./node_modules/date-fns/min.js\");\n/* harmony import */ var date_fns__WEBPACK_IMPORTED_MODULE_47__ = __webpack_require__(/*! date-fns */ \"(ssr)/./node_modules/date-fns/max.js\");\n/* harmony import */ var date_fns__WEBPACK_IMPORTED_MODULE_48__ = __webpack_require__(/*! date-fns */ \"(ssr)/./node_modules/date-fns/isDate.js\");\n/* harmony import */ var date_fns__WEBPACK_IMPORTED_MODULE_49__ = __webpack_require__(/*! date-fns */ \"(ssr)/./node_modules/date-fns/addHours.js\");\n/* harmony import */ var date_fns__WEBPACK_IMPORTED_MODULE_50__ = __webpack_require__(/*! date-fns */ \"(ssr)/./node_modules/date-fns/addMinutes.js\");\n/* harmony import */ var date_fns__WEBPACK_IMPORTED_MODULE_51__ = __webpack_require__(/*! date-fns */ \"(ssr)/./node_modules/date-fns/addSeconds.js\");\n/* harmony import */ var date_fns__WEBPACK_IMPORTED_MODULE_52__ = __webpack_require__(/*! date-fns */ \"(ssr)/./node_modules/date-fns/isAfter.js\");\n/* harmony import */ var date_fns__WEBPACK_IMPORTED_MODULE_53__ = __webpack_require__(/*! date-fns */ \"(ssr)/./node_modules/date-fns/getDay.js\");\n/* harmony import */ var date_fns__WEBPACK_IMPORTED_MODULE_54__ = __webpack_require__(/*! date-fns */ \"(ssr)/./node_modules/date-fns/getDate.js\");\n/* harmony import */ var date_fns__WEBPACK_IMPORTED_MODULE_55__ = __webpack_require__(/*! date-fns */ \"(ssr)/./node_modules/date-fns/addDays.js\");\n/* harmony import */ var date_fns__WEBPACK_IMPORTED_MODULE_56__ = __webpack_require__(/*! date-fns */ \"(ssr)/./node_modules/date-fns/addWeeks.js\");\n/* harmony import */ var date_fns__WEBPACK_IMPORTED_MODULE_57__ = __webpack_require__(/*! date-fns */ \"(ssr)/./node_modules/date-fns/getTime.js\");\n/* harmony import */ var date_fns__WEBPACK_IMPORTED_MODULE_58__ = __webpack_require__(/*! date-fns */ \"(ssr)/./node_modules/date-fns/setYear.js\");\n/* harmony import */ var date_fns__WEBPACK_IMPORTED_MODULE_59__ = __webpack_require__(/*! date-fns */ \"(ssr)/./node_modules/date-fns/differenceInDays.js\");\n/* harmony import */ var date_fns__WEBPACK_IMPORTED_MODULE_63__ = __webpack_require__(/*! date-fns */ \"(ssr)/./node_modules/date-fns/subWeeks.js\");\n/* harmony import */ var date_fns__WEBPACK_IMPORTED_MODULE_64__ = __webpack_require__(/*! date-fns */ \"(ssr)/./node_modules/date-fns/subDays.js\");\n/* harmony import */ var _floating_ui_react__WEBPACK_IMPORTED_MODULE_60__ = __webpack_require__(/*! @floating-ui/react */ \"(ssr)/./node_modules/react-datepicker/node_modules/@floating-ui/react/dist/floating-ui.react.mjs\");\n/* harmony import */ var _floating_ui_react__WEBPACK_IMPORTED_MODULE_61__ = __webpack_require__(/*! @floating-ui/react */ \"(ssr)/./node_modules/@floating-ui/dom/dist/floating-ui.dom.mjs\");\n/* harmony import */ var _floating_ui_react__WEBPACK_IMPORTED_MODULE_62__ = __webpack_require__(/*! @floating-ui/react */ \"(ssr)/./node_modules/react-datepicker/node_modules/@floating-ui/react/node_modules/@floating-ui/react-dom/dist/floating-ui.react-dom.mjs\");\n/* harmony import */ var react_dom__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! react-dom */ \"(ssr)/./node_modules/next/dist/server/future/route-modules/app-page/vendored/ssr/react-dom.js\");\n/* harmony import */ var react_dom__WEBPACK_IMPORTED_MODULE_2___default = /*#__PURE__*/__webpack_require__.n(react_dom__WEBPACK_IMPORTED_MODULE_2__);\n/*!\n  react-datepicker v8.10.0\n  https://github.com/Hacker0x01/react-datepicker\n  Released under the MIT License.\n*/\n\n\n\n\n\n\n/******************************************************************************\r\nCopyright (c) Microsoft Corporation.\r\n\r\nPermission to use, copy, modify, and/or distribute this software for any\r\npurpose with or without fee is hereby granted.\r\n\r\nTHE SOFTWARE IS PROVIDED \"AS IS\" AND THE AUTHOR DISCLAIMS ALL WARRANTIES WITH\r\nREGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY\r\nAND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY SPECIAL, DIRECT,\r\nINDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES WHATSOEVER RESULTING FROM\r\nLOSS OF USE, DATA OR PROFITS, WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE OR\r\nOTHER TORTIOUS ACTION, ARISING OUT OF OR IN CONNECTION WITH THE USE OR\r\nPERFORMANCE OF THIS SOFTWARE.\r\n***************************************************************************** */\n/* global Reflect, Promise, SuppressedError, Symbol, Iterator */\n\nvar _extendStatics = function extendStatics(d, b) {\n  _extendStatics = Object.setPrototypeOf || {\n    __proto__: []\n  } instanceof Array && function (d, b) {\n    d.__proto__ = b;\n  } || function (d, b) {\n    for (var p in b) if (Object.prototype.hasOwnProperty.call(b, p)) d[p] = b[p];\n  };\n  return _extendStatics(d, b);\n};\nfunction __extends(d, b) {\n  if (typeof b !== \"function\" && b !== null) throw new TypeError(\"Class extends value \" + String(b) + \" is not a constructor or null\");\n  _extendStatics(d, b);\n  function __() {\n    this.constructor = d;\n  }\n  d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\n}\nvar _assign = function __assign() {\n  _assign = Object.assign || function __assign(t) {\n    for (var s, i = 1, n = arguments.length; i < n; i++) {\n      s = arguments[i];\n      for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p)) t[p] = s[p];\n    }\n    return t;\n  };\n  return _assign.apply(this, arguments);\n};\nfunction __spreadArray(to, from, pack) {\n  if (pack || arguments.length === 2) for (var i = 0, l = from.length, ar; i < l; i++) {\n    if (ar || !(i in from)) {\n      if (!ar) ar = Array.prototype.slice.call(from, 0, i);\n      ar[i] = from[i];\n    }\n  }\n  return to.concat(ar || Array.prototype.slice.call(from));\n}\ntypeof SuppressedError === \"function\" ? SuppressedError : function (error, suppressed, message) {\n  var e = new Error(message);\n  return e.name = \"SuppressedError\", e.error = error, e.suppressed = suppressed, e;\n};\n\nvar CalendarContainer = function (_a) {\n    var _b = _a.showTimeSelectOnly, showTimeSelectOnly = _b === void 0 ? false : _b, _c = _a.showTime, showTime = _c === void 0 ? false : _c, className = _a.className, children = _a.children, inline = _a.inline;\n    var ariaLabel = showTimeSelectOnly\n        ? \"Choose Time\"\n        : \"Choose Date\".concat(showTime ? \" and Time\" : \"\");\n    return (react__WEBPACK_IMPORTED_MODULE_1___default().createElement(\"div\", { className: className, \"aria-label\": ariaLabel, role: inline ? undefined : \"dialog\", \"aria-modal\": inline ? undefined : \"true\" }, children));\n};\n\nvar useDetectClickOutside = function (onClickOutside, ignoreClass) {\n    var ref = (0,react__WEBPACK_IMPORTED_MODULE_1__.useRef)(null);\n    var onClickOutsideRef = (0,react__WEBPACK_IMPORTED_MODULE_1__.useRef)(onClickOutside);\n    (0,react__WEBPACK_IMPORTED_MODULE_1__.useEffect)(function () {\n        onClickOutsideRef.current = onClickOutside;\n    }, [onClickOutside]);\n    var handleClickOutside = (0,react__WEBPACK_IMPORTED_MODULE_1__.useCallback)(function (event) {\n        var _a;\n        var target = (event.composed &&\n            event.composedPath &&\n            event\n                .composedPath()\n                .find(function (eventTarget) { return eventTarget instanceof Node; })) ||\n            event.target;\n        if (ref.current && !ref.current.contains(target)) {\n            if (!(ignoreClass &&\n                target instanceof HTMLElement &&\n                target.classList.contains(ignoreClass))) {\n                (_a = onClickOutsideRef.current) === null || _a === void 0 ? void 0 : _a.call(onClickOutsideRef, event);\n            }\n        }\n    }, [ignoreClass]);\n    (0,react__WEBPACK_IMPORTED_MODULE_1__.useEffect)(function () {\n        document.addEventListener(\"mousedown\", handleClickOutside);\n        return function () {\n            document.removeEventListener(\"mousedown\", handleClickOutside);\n        };\n    }, [handleClickOutside]);\n    return ref;\n};\nvar ClickOutsideWrapper = function (_a) {\n    var children = _a.children, onClickOutside = _a.onClickOutside, className = _a.className, containerRef = _a.containerRef, style = _a.style, ignoreClass = _a.ignoreClass;\n    var detectRef = useDetectClickOutside(onClickOutside, ignoreClass);\n    return (react__WEBPACK_IMPORTED_MODULE_1___default().createElement(\"div\", { className: className, style: style, ref: function (node) {\n            detectRef.current = node;\n            if (containerRef) {\n                containerRef.current = node;\n            }\n        } }, children));\n};\n\nvar KeyType;\n(function (KeyType) {\n    KeyType[\"ArrowUp\"] = \"ArrowUp\";\n    KeyType[\"ArrowDown\"] = \"ArrowDown\";\n    KeyType[\"ArrowLeft\"] = \"ArrowLeft\";\n    KeyType[\"ArrowRight\"] = \"ArrowRight\";\n    KeyType[\"PageUp\"] = \"PageUp\";\n    KeyType[\"PageDown\"] = \"PageDown\";\n    KeyType[\"Home\"] = \"Home\";\n    KeyType[\"End\"] = \"End\";\n    KeyType[\"Enter\"] = \"Enter\";\n    KeyType[\"Space\"] = \" \";\n    KeyType[\"Tab\"] = \"Tab\";\n    KeyType[\"Escape\"] = \"Escape\";\n    KeyType[\"Backspace\"] = \"Backspace\";\n    KeyType[\"X\"] = \"x\";\n})(KeyType || (KeyType = {}));\nfunction getLocaleScope() {\n    // Use this cast to avoid messing with users globalThis (like window) and the rest of keys in the globalThis object we don't care about\n    var scope = (typeof window !== \"undefined\"\n        ? window\n        : globalThis);\n    return scope;\n}\nvar DEFAULT_YEAR_ITEM_NUMBER = 12;\n// ** Date Constructors **\nfunction newDate(value) {\n    if (value == null) {\n        return new Date();\n    }\n    var d = typeof value === \"string\" ? (0,date_fns__WEBPACK_IMPORTED_MODULE_3__.parseISO)(value) : (0,date_fns__WEBPACK_IMPORTED_MODULE_4__.toDate)(value);\n    return isValid(d) ? d : new Date();\n}\n/**\n * Parses a date.\n *\n * @param value - The string representing the Date in a parsable form, e.g., ISO 1861\n * @param dateFormat - The date format.\n * @param locale - The locale.\n * @param strictParsing - The strict parsing flag.\n * @param refDate - The base date to be passed to date-fns parse() function.\n * @returns - The parsed date or null.\n */\nfunction parseDate(value, dateFormat, locale, strictParsing, refDate) {\n    if (refDate === void 0) { refDate = newDate(); }\n    var localeObject = getLocaleObject(locale) || getLocaleObject(getDefaultLocale());\n    var formats = Array.isArray(dateFormat) ? dateFormat : [dateFormat];\n    for (var _i = 0, formats_1 = formats; _i < formats_1.length; _i++) {\n        var format_1 = formats_1[_i];\n        var parsedDate = (0,date_fns__WEBPACK_IMPORTED_MODULE_5__.parse)(value, format_1, refDate, {\n            locale: localeObject,\n            useAdditionalWeekYearTokens: true,\n            useAdditionalDayOfYearTokens: true,\n        });\n        if (isValid(parsedDate) &&\n            (!strictParsing || value === formatDate(parsedDate, format_1, locale))) {\n            return parsedDate;\n        }\n    }\n    return null;\n}\n/**\n * Checks if a given date is valid and not before the minimum date.\n * @param date - The date to be checked.\n * @param minDate - The minimum date allowed. If not provided, defaults to \"1/1/1800\".\n * @returns A boolean value indicating whether the date is valid and not before the minimum date.\n */\nfunction isValid(date, minDate) {\n    /* the fallback date is essential to not break test case\n     * `should auto update calendar when the updated date text is after props.minDate`\n     * and backward compatibility respectfully\n     */\n    return (0,date_fns__WEBPACK_IMPORTED_MODULE_6__.isValid)(date) && !(0,date_fns__WEBPACK_IMPORTED_MODULE_7__.isBefore)(date, new Date(\"1/1/1800\"));\n}\n// ** Date Formatting **\n/**\n * Formats a date.\n *\n * @param date - The date.\n * @param formatStr - The format string.\n * @param locale - The locale.\n * @returns - The formatted date.\n */\nfunction formatDate(date, formatStr, locale) {\n    if (locale === \"en\") {\n        return (0,date_fns__WEBPACK_IMPORTED_MODULE_8__.format)(date, formatStr, {\n            useAdditionalWeekYearTokens: true,\n            useAdditionalDayOfYearTokens: true,\n        });\n    }\n    var localeObj = locale ? getLocaleObject(locale) : undefined;\n    if (locale && !localeObj) {\n        console.warn(\"A locale object was not found for the provided string [\\\"\".concat(locale, \"\\\"].\"));\n    }\n    localeObj = localeObj || getLocaleObject(getDefaultLocale());\n    return (0,date_fns__WEBPACK_IMPORTED_MODULE_8__.format)(date, formatStr, {\n        locale: localeObj,\n        useAdditionalWeekYearTokens: true,\n        useAdditionalDayOfYearTokens: true,\n    });\n}\n/**\n * Safely formats a date.\n *\n * @param date - The date.\n * @param options - An object containing the dateFormat and locale.\n * @returns - The formatted date or an empty string.\n */\nfunction safeDateFormat(date, _a) {\n    var dateFormat = _a.dateFormat, locale = _a.locale;\n    var formatStr = (Array.isArray(dateFormat) && dateFormat.length > 0\n        ? dateFormat[0]\n        : dateFormat); // Cast to string because it's impossible to get `string | string[] | undefined` here and typescript doesn't know that\n    return (date && formatDate(date, formatStr, locale)) || \"\";\n}\n/**\n * Used as a delimiter to separate two dates when formatting a date range\n */\nvar DATE_RANGE_SEPARATOR = \" - \";\n/**\n * Safely formats a date range.\n *\n * @param startDate - The start date.\n * @param endDate - The end date.\n * @param props - The props.\n * @returns - The formatted date range or an empty string.\n */\nfunction safeDateRangeFormat(startDate, endDate, props) {\n    if (!startDate && !endDate) {\n        return \"\";\n    }\n    var formattedStartDate = startDate ? safeDateFormat(startDate, props) : \"\";\n    var formattedEndDate = endDate ? safeDateFormat(endDate, props) : \"\";\n    var dateRangeSeparator = props.rangeSeparator || DATE_RANGE_SEPARATOR;\n    return \"\".concat(formattedStartDate).concat(dateRangeSeparator).concat(formattedEndDate);\n}\n/**\n * Safely formats multiple dates.\n *\n * @param dates - The dates.\n * @param props - The props.\n * @returns - The formatted dates or an empty string.\n */\nfunction safeMultipleDatesFormat(dates, props) {\n    if (!(dates === null || dates === void 0 ? void 0 : dates.length)) {\n        return \"\";\n    }\n    var formattedFirstDate = dates[0] ? safeDateFormat(dates[0], props) : \"\";\n    if (dates.length === 1) {\n        return formattedFirstDate;\n    }\n    if (dates.length === 2 && dates[1]) {\n        var formattedSecondDate = safeDateFormat(dates[1], props);\n        return \"\".concat(formattedFirstDate, \", \").concat(formattedSecondDate);\n    }\n    var extraDatesCount = dates.length - 1;\n    return \"\".concat(formattedFirstDate, \" (+\").concat(extraDatesCount, \")\");\n}\n// ** Date Setters **\n/**\n * Sets the time for a given date.\n *\n * @param date - The date.\n * @param time - An object containing the hour, minute, and second.\n * @returns - The date with the time set.\n */\nfunction setTime(date, _a) {\n    var _b = _a.hour, hour = _b === void 0 ? 0 : _b, _c = _a.minute, minute = _c === void 0 ? 0 : _c, _d = _a.second, second = _d === void 0 ? 0 : _d;\n    return (0,date_fns__WEBPACK_IMPORTED_MODULE_9__.setHours)((0,date_fns__WEBPACK_IMPORTED_MODULE_10__.setMinutes)((0,date_fns__WEBPACK_IMPORTED_MODULE_11__.setSeconds)(date, second), minute), hour);\n}\n/**\n * Gets the week of the year for a given date.\n *\n * @param date - The date.\n * @returns - The week of the year.\n */\nfunction getWeek(date) {\n    return (0,date_fns__WEBPACK_IMPORTED_MODULE_12__.getISOWeek)(date);\n}\n/**\n * Gets the day of the week code for a given day.\n *\n * @param day - The day.\n * @param locale - The locale.\n * @returns - The day of the week code.\n */\nfunction getDayOfWeekCode(day, locale) {\n    return formatDate(day, \"ddd\", locale);\n}\n// *** Start of ***\n/**\n * Gets the start of the day for a given date.\n *\n * @param date - The date.\n * @returns - The start of the day.\n */\nfunction getStartOfDay(date) {\n    return (0,date_fns__WEBPACK_IMPORTED_MODULE_13__.startOfDay)(date);\n}\n/**\n * Gets the start of the week for a given date.\n *\n * @param date - The date.\n * @param locale - The locale.\n * @param calendarStartDay - The day the calendar starts on.\n * @returns - The start of the week.\n */\nfunction getStartOfWeek(date, locale, calendarStartDay) {\n    var localeObj = locale\n        ? getLocaleObject(locale)\n        : getLocaleObject(getDefaultLocale());\n    return (0,date_fns__WEBPACK_IMPORTED_MODULE_14__.startOfWeek)(date, {\n        locale: localeObj,\n        weekStartsOn: calendarStartDay,\n    });\n}\n/**\n * Gets the start of the month for a given date.\n *\n * @param date - The date.\n * @returns - The start of the month.\n */\nfunction getStartOfMonth(date) {\n    return (0,date_fns__WEBPACK_IMPORTED_MODULE_15__.startOfMonth)(date);\n}\n/**\n * Gets the start of the year for a given date.\n *\n * @param date - The date.\n * @returns - The start of the year.\n */\nfunction getStartOfYear(date) {\n    return (0,date_fns__WEBPACK_IMPORTED_MODULE_16__.startOfYear)(date);\n}\n/**\n * Gets the start of the quarter for a given date.\n *\n * @param date - The date.\n * @returns - The start of the quarter.\n */\nfunction getStartOfQuarter(date) {\n    return (0,date_fns__WEBPACK_IMPORTED_MODULE_17__.startOfQuarter)(date);\n}\n/**\n * Gets the start of today.\n *\n * @returns - The start of today.\n */\nfunction getStartOfToday() {\n    return (0,date_fns__WEBPACK_IMPORTED_MODULE_13__.startOfDay)(newDate());\n}\n// *** End of ***\n/**\n * Gets the end of the day for a given date.\n *\n * @param date - The date.\n * @returns - The end of the day.\n */\nfunction getEndOfDay(date) {\n    return (0,date_fns__WEBPACK_IMPORTED_MODULE_18__.endOfDay)(date);\n}\n/**\n * Gets the end of the week for a given date.\n *\n * @param date - The date.\n * @returns - The end of the week.\n */\nfunction getEndOfWeek(date) {\n    return (0,date_fns__WEBPACK_IMPORTED_MODULE_19__.endOfWeek)(date);\n}\n/**\n * Gets the end of the month for a given date.\n *\n * @param date - The date.\n * @returns - The end of the month.\n */\nfunction getEndOfMonth(date) {\n    return (0,date_fns__WEBPACK_IMPORTED_MODULE_20__.endOfMonth)(date);\n}\n/**\n * Checks if two dates are in the same year.\n *\n * @param date1 - The first date.\n * @param date2 - The second date.\n * @returns - True if the dates are in the same year, false otherwise.\n */\nfunction isSameYear(date1, date2) {\n    if (date1 && date2) {\n        return (0,date_fns__WEBPACK_IMPORTED_MODULE_21__.isSameYear)(date1, date2);\n    }\n    else {\n        return !date1 && !date2;\n    }\n}\n/**\n * Checks if two dates are in the same month.\n *\n * @param date1 - The first date.\n * @param date2 - The second date.\n * @returns - True if the dates are in the same month, false otherwise.\n */\nfunction isSameMonth(date1, date2) {\n    if (date1 && date2) {\n        return (0,date_fns__WEBPACK_IMPORTED_MODULE_22__.isSameMonth)(date1, date2);\n    }\n    else {\n        return !date1 && !date2;\n    }\n}\n/**\n * Checks if two dates are in the same quarter.\n *\n * @param date1 - The first date.\n * @param date2 - The second date.\n * @returns - True if the dates are in the same quarter, false otherwise.\n */\nfunction isSameQuarter(date1, date2) {\n    if (date1 && date2) {\n        return (0,date_fns__WEBPACK_IMPORTED_MODULE_23__.isSameQuarter)(date1, date2);\n    }\n    else {\n        return !date1 && !date2;\n    }\n}\n/**\n * Checks if two dates are on the same day.\n *\n * @param date1 - The first date.\n * @param date2 - The second date.\n * @returns - True if the dates are on the same day, false otherwise.\n */\nfunction isSameDay(date1, date2) {\n    if (date1 && date2) {\n        return (0,date_fns__WEBPACK_IMPORTED_MODULE_24__.isSameDay)(date1, date2);\n    }\n    else {\n        return !date1 && !date2;\n    }\n}\n/**\n * Checks if two dates are equal.\n *\n * @param date1 - The first date.\n * @param date2 - The second date.\n * @returns - True if the dates are equal, false otherwise.\n */\nfunction isEqual(date1, date2) {\n    if (date1 && date2) {\n        return (0,date_fns__WEBPACK_IMPORTED_MODULE_25__.isEqual)(date1, date2);\n    }\n    else {\n        return !date1 && !date2;\n    }\n}\n/**\n * Checks if a day is within a date range.\n *\n * @param day - The day to check.\n * @param startDate - The start date of the range.\n * @param endDate - The end date of the range.\n * @returns - True if the day is within the range, false otherwise.\n */\nfunction isDayInRange(day, startDate, endDate) {\n    var valid;\n    var start = (0,date_fns__WEBPACK_IMPORTED_MODULE_13__.startOfDay)(startDate);\n    var end = (0,date_fns__WEBPACK_IMPORTED_MODULE_18__.endOfDay)(endDate);\n    try {\n        valid = (0,date_fns__WEBPACK_IMPORTED_MODULE_26__.isWithinInterval)(day, { start: start, end: end });\n    }\n    catch (err) {\n        valid = false;\n    }\n    return valid;\n}\n// ** Date Localization **\n/**\n * Registers a locale.\n *\n * @param localeName - The name of the locale.\n * @param localeData - The data of the locale.\n */\nfunction registerLocale(localeName, localeData) {\n    var scope = getLocaleScope();\n    if (!scope.__localeData__) {\n        scope.__localeData__ = {};\n    }\n    scope.__localeData__[localeName] = localeData;\n}\n/**\n * Sets the default locale.\n *\n * @param localeName - The name of the locale.\n */\nfunction setDefaultLocale(localeName) {\n    var scope = getLocaleScope();\n    scope.__localeId__ = localeName;\n}\n/**\n * Gets the default locale.\n *\n * @returns - The default locale.\n */\nfunction getDefaultLocale() {\n    var scope = getLocaleScope();\n    return scope.__localeId__;\n}\n/**\n * Gets the locale object.\n *\n * @param localeSpec - The locale specification.\n * @returns - The locale object.\n */\nfunction getLocaleObject(localeSpec) {\n    if (typeof localeSpec === \"string\") {\n        // Treat it as a locale name registered by registerLocale\n        var scope = getLocaleScope();\n        // Null was replaced with undefined to avoid type coercion\n        return scope.__localeData__ ? scope.__localeData__[localeSpec] : undefined;\n    }\n    else {\n        // Treat it as a raw date-fns locale object\n        return localeSpec;\n    }\n}\n/**\n * Formats the weekday in a given locale.\n *\n * @param date - The date to format.\n * @param formatFunc - The formatting function.\n * @param locale - The locale to use for formatting.\n * @returns - The formatted weekday.\n */\nfunction getFormattedWeekdayInLocale(date, formatFunc, locale) {\n    return formatFunc(formatDate(date, \"EEEE\", locale));\n}\n/**\n * Gets the minimum weekday in a given locale.\n *\n * @param date - The date to format.\n * @param locale - The locale to use for formatting.\n * @returns - The minimum weekday.\n */\nfunction getWeekdayMinInLocale(date, locale) {\n    return formatDate(date, \"EEEEEE\", locale);\n}\n/**\n * Gets the short weekday in a given locale.\n *\n * @param date - The date to format.\n * @param locale - The locale to use for formatting.\n * @returns - The short weekday.\n */\nfunction getWeekdayShortInLocale(date, locale) {\n    return formatDate(date, \"EEE\", locale);\n}\n/**\n * Gets the month in a given locale.\n *\n * @param month - The month to format.\n * @param locale - The locale to use for formatting.\n * @returns - The month.\n */\nfunction getMonthInLocale(month, locale) {\n    return formatDate((0,date_fns__WEBPACK_IMPORTED_MODULE_27__.setMonth)(newDate(), month), \"LLLL\", locale);\n}\n/**\n * Gets the short month in a given locale.\n *\n * @param month - The month to format.\n * @param locale - The locale to use for formatting.\n * @returns - The short month.\n */\nfunction getMonthShortInLocale(month, locale) {\n    return formatDate((0,date_fns__WEBPACK_IMPORTED_MODULE_27__.setMonth)(newDate(), month), \"LLL\", locale);\n}\n/**\n * Gets the short quarter in a given locale.\n *\n * @param quarter - The quarter to format.\n * @param locale - The locale to use for formatting.\n * @returns - The short quarter.\n */\nfunction getQuarterShortInLocale(quarter, locale) {\n    return formatDate((0,date_fns__WEBPACK_IMPORTED_MODULE_28__.setQuarter)(newDate(), quarter), \"QQQ\", locale);\n}\n/**\n * Checks if a day is disabled.\n *\n * @param day - The day to check.\n * @param options - The options to consider when checking.\n * @returns - Returns true if the day is disabled, false otherwise.\n */\nfunction isDayDisabled(day, _a) {\n    var _b = _a === void 0 ? {} : _a, minDate = _b.minDate, maxDate = _b.maxDate, excludeDates = _b.excludeDates, excludeDateIntervals = _b.excludeDateIntervals, includeDates = _b.includeDates, includeDateIntervals = _b.includeDateIntervals, filterDate = _b.filterDate, disabled = _b.disabled;\n    if (disabled) {\n        return true;\n    }\n    return (isOutOfBounds(day, { minDate: minDate, maxDate: maxDate }) ||\n        (excludeDates &&\n            excludeDates.some(function (excludeDate) {\n                if (excludeDate instanceof Date) {\n                    return isSameDay(day, excludeDate);\n                }\n                else {\n                    return isSameDay(day, excludeDate.date);\n                }\n            })) ||\n        (excludeDateIntervals &&\n            excludeDateIntervals.some(function (_a) {\n                var start = _a.start, end = _a.end;\n                return (0,date_fns__WEBPACK_IMPORTED_MODULE_26__.isWithinInterval)(day, { start: start, end: end });\n            })) ||\n        (includeDates &&\n            !includeDates.some(function (includeDate) { return isSameDay(day, includeDate); })) ||\n        (includeDateIntervals &&\n            !includeDateIntervals.some(function (_a) {\n                var start = _a.start, end = _a.end;\n                return (0,date_fns__WEBPACK_IMPORTED_MODULE_26__.isWithinInterval)(day, { start: start, end: end });\n            })) ||\n        (filterDate && !filterDate(newDate(day))) ||\n        false);\n}\n/**\n * Checks if a day is excluded.\n *\n * @param day - The day to check.\n * @param options - The options to consider when checking.\n * @returns - Returns true if the day is excluded, false otherwise.\n */\nfunction isDayExcluded(day, _a) {\n    var _b = _a === void 0 ? {} : _a, excludeDates = _b.excludeDates, excludeDateIntervals = _b.excludeDateIntervals;\n    if (excludeDateIntervals && excludeDateIntervals.length > 0) {\n        return excludeDateIntervals.some(function (_a) {\n            var start = _a.start, end = _a.end;\n            return (0,date_fns__WEBPACK_IMPORTED_MODULE_26__.isWithinInterval)(day, { start: start, end: end });\n        });\n    }\n    return ((excludeDates &&\n        excludeDates.some(function (excludeDate) {\n            var _a;\n            if (excludeDate instanceof Date) {\n                return isSameDay(day, excludeDate);\n            }\n            else {\n                return isSameDay(day, (_a = excludeDate.date) !== null && _a !== void 0 ? _a : new Date());\n            }\n        })) ||\n        false);\n}\nfunction isMonthDisabled(month, _a) {\n    var _b = _a === void 0 ? {} : _a, minDate = _b.minDate, maxDate = _b.maxDate, excludeDates = _b.excludeDates, includeDates = _b.includeDates, filterDate = _b.filterDate;\n    return (isOutOfBounds(month, {\n        minDate: minDate ? (0,date_fns__WEBPACK_IMPORTED_MODULE_15__.startOfMonth)(minDate) : undefined,\n        maxDate: maxDate ? (0,date_fns__WEBPACK_IMPORTED_MODULE_20__.endOfMonth)(maxDate) : undefined,\n    }) ||\n        (excludeDates === null || excludeDates === void 0 ? void 0 : excludeDates.some(function (excludeDate) {\n            return isSameMonth(month, excludeDate instanceof Date ? excludeDate : excludeDate.date);\n        })) ||\n        (includeDates &&\n            !includeDates.some(function (includeDate) { return isSameMonth(month, includeDate); })) ||\n        (filterDate && !filterDate(newDate(month))) ||\n        false);\n}\nfunction isMonthInRange(startDate, endDate, m, day) {\n    var startDateYear = (0,date_fns__WEBPACK_IMPORTED_MODULE_29__.getYear)(startDate);\n    var startDateMonth = (0,date_fns__WEBPACK_IMPORTED_MODULE_30__.getMonth)(startDate);\n    var endDateYear = (0,date_fns__WEBPACK_IMPORTED_MODULE_29__.getYear)(endDate);\n    var endDateMonth = (0,date_fns__WEBPACK_IMPORTED_MODULE_30__.getMonth)(endDate);\n    var dayYear = (0,date_fns__WEBPACK_IMPORTED_MODULE_29__.getYear)(day);\n    if (startDateYear === endDateYear && startDateYear === dayYear) {\n        return startDateMonth <= m && m <= endDateMonth;\n    }\n    else if (startDateYear < endDateYear) {\n        return ((dayYear === startDateYear && startDateMonth <= m) ||\n            (dayYear === endDateYear && endDateMonth >= m) ||\n            (dayYear < endDateYear && dayYear > startDateYear));\n    }\n    return false;\n}\n/**\n * To check if a date's month and year are disabled/excluded\n * @param date Date to check\n * @returns {boolean} true if month and year are disabled/excluded, false otherwise\n */\nfunction isMonthYearDisabled(date, _a) {\n    var _b = _a === void 0 ? {} : _a, minDate = _b.minDate, maxDate = _b.maxDate, excludeDates = _b.excludeDates, includeDates = _b.includeDates;\n    return (isOutOfBounds(date, { minDate: minDate, maxDate: maxDate }) ||\n        (excludeDates &&\n            excludeDates.some(function (excludedDate) {\n                return isSameMonth(excludedDate instanceof Date ? excludedDate : excludedDate.date, date);\n            })) ||\n        (includeDates &&\n            !includeDates.some(function (includedDate) { return isSameMonth(includedDate, date); })) ||\n        false);\n}\nfunction isQuarterDisabled(quarter, _a) {\n    var _b = _a === void 0 ? {} : _a, minDate = _b.minDate, maxDate = _b.maxDate, excludeDates = _b.excludeDates, includeDates = _b.includeDates, filterDate = _b.filterDate, disabled = _b.disabled;\n    if (disabled) {\n        return true;\n    }\n    return (isOutOfBounds(quarter, { minDate: minDate, maxDate: maxDate }) ||\n        (excludeDates === null || excludeDates === void 0 ? void 0 : excludeDates.some(function (excludeDate) {\n            return isSameQuarter(quarter, excludeDate instanceof Date ? excludeDate : excludeDate.date);\n        })) ||\n        (includeDates &&\n            !includeDates.some(function (includeDate) {\n                return isSameQuarter(quarter, includeDate);\n            })) ||\n        (filterDate && !filterDate(newDate(quarter))) ||\n        false);\n}\nfunction isYearInRange(year, start, end) {\n    if (!start || !end)\n        return false;\n    if (!(0,date_fns__WEBPACK_IMPORTED_MODULE_6__.isValid)(start) || !(0,date_fns__WEBPACK_IMPORTED_MODULE_6__.isValid)(end))\n        return false;\n    var startYear = (0,date_fns__WEBPACK_IMPORTED_MODULE_29__.getYear)(start);\n    var endYear = (0,date_fns__WEBPACK_IMPORTED_MODULE_29__.getYear)(end);\n    return startYear <= year && endYear >= year;\n}\nfunction isYearDisabled(year, _a) {\n    var _b = _a === void 0 ? {} : _a, minDate = _b.minDate, maxDate = _b.maxDate, excludeDates = _b.excludeDates, includeDates = _b.includeDates, filterDate = _b.filterDate, disabled = _b.disabled;\n    if (disabled) {\n        return true;\n    }\n    var date = new Date(year, 0, 1);\n    return (isOutOfBounds(date, {\n        minDate: minDate ? (0,date_fns__WEBPACK_IMPORTED_MODULE_16__.startOfYear)(minDate) : undefined,\n        maxDate: maxDate ? (0,date_fns__WEBPACK_IMPORTED_MODULE_31__.endOfYear)(maxDate) : undefined,\n    }) ||\n        (excludeDates === null || excludeDates === void 0 ? void 0 : excludeDates.some(function (excludeDate) {\n            return isSameYear(date, excludeDate instanceof Date ? excludeDate : excludeDate.date);\n        })) ||\n        (includeDates &&\n            !includeDates.some(function (includeDate) { return isSameYear(date, includeDate); })) ||\n        (filterDate && !filterDate(newDate(date))) ||\n        false);\n}\nfunction isQuarterInRange(startDate, endDate, q, day) {\n    var startDateYear = (0,date_fns__WEBPACK_IMPORTED_MODULE_29__.getYear)(startDate);\n    var startDateQuarter = (0,date_fns__WEBPACK_IMPORTED_MODULE_32__.getQuarter)(startDate);\n    var endDateYear = (0,date_fns__WEBPACK_IMPORTED_MODULE_29__.getYear)(endDate);\n    var endDateQuarter = (0,date_fns__WEBPACK_IMPORTED_MODULE_32__.getQuarter)(endDate);\n    var dayYear = (0,date_fns__WEBPACK_IMPORTED_MODULE_29__.getYear)(day);\n    if (startDateYear === endDateYear && startDateYear === dayYear) {\n        return startDateQuarter <= q && q <= endDateQuarter;\n    }\n    else if (startDateYear < endDateYear) {\n        return ((dayYear === startDateYear && startDateQuarter <= q) ||\n            (dayYear === endDateYear && endDateQuarter >= q) ||\n            (dayYear < endDateYear && dayYear > startDateYear));\n    }\n    return false;\n}\nfunction isOutOfBounds(day, _a) {\n    var _b;\n    var _c = _a === void 0 ? {} : _a, minDate = _c.minDate, maxDate = _c.maxDate;\n    return ((_b = ((minDate && (0,date_fns__WEBPACK_IMPORTED_MODULE_33__.differenceInCalendarDays)(day, minDate) < 0) ||\n        (maxDate && (0,date_fns__WEBPACK_IMPORTED_MODULE_33__.differenceInCalendarDays)(day, maxDate) > 0))) !== null && _b !== void 0 ? _b : false);\n}\nfunction isTimeInList(time, times) {\n    return times.some(function (listTime) {\n        return (0,date_fns__WEBPACK_IMPORTED_MODULE_34__.getHours)(listTime) === (0,date_fns__WEBPACK_IMPORTED_MODULE_34__.getHours)(time) &&\n            (0,date_fns__WEBPACK_IMPORTED_MODULE_35__.getMinutes)(listTime) === (0,date_fns__WEBPACK_IMPORTED_MODULE_35__.getMinutes)(time) &&\n            (0,date_fns__WEBPACK_IMPORTED_MODULE_36__.getSeconds)(listTime) === (0,date_fns__WEBPACK_IMPORTED_MODULE_36__.getSeconds)(time);\n    });\n}\nfunction isTimeDisabled(time, _a) {\n    var _b = _a === void 0 ? {} : _a, excludeTimes = _b.excludeTimes, includeTimes = _b.includeTimes, filterTime = _b.filterTime;\n    return ((excludeTimes && isTimeInList(time, excludeTimes)) ||\n        (includeTimes && !isTimeInList(time, includeTimes)) ||\n        (filterTime && !filterTime(time)) ||\n        false);\n}\nfunction isTimeInDisabledRange(time, _a) {\n    var minTime = _a.minTime, maxTime = _a.maxTime;\n    if (!minTime || !maxTime) {\n        throw new Error(\"Both minTime and maxTime props required\");\n    }\n    var baseTime = newDate();\n    baseTime = (0,date_fns__WEBPACK_IMPORTED_MODULE_9__.setHours)(baseTime, (0,date_fns__WEBPACK_IMPORTED_MODULE_34__.getHours)(time));\n    baseTime = (0,date_fns__WEBPACK_IMPORTED_MODULE_10__.setMinutes)(baseTime, (0,date_fns__WEBPACK_IMPORTED_MODULE_35__.getMinutes)(time));\n    baseTime = (0,date_fns__WEBPACK_IMPORTED_MODULE_11__.setSeconds)(baseTime, (0,date_fns__WEBPACK_IMPORTED_MODULE_36__.getSeconds)(time));\n    var min = newDate();\n    min = (0,date_fns__WEBPACK_IMPORTED_MODULE_9__.setHours)(min, (0,date_fns__WEBPACK_IMPORTED_MODULE_34__.getHours)(minTime));\n    min = (0,date_fns__WEBPACK_IMPORTED_MODULE_10__.setMinutes)(min, (0,date_fns__WEBPACK_IMPORTED_MODULE_35__.getMinutes)(minTime));\n    min = (0,date_fns__WEBPACK_IMPORTED_MODULE_11__.setSeconds)(min, (0,date_fns__WEBPACK_IMPORTED_MODULE_36__.getSeconds)(minTime));\n    var max = newDate();\n    max = (0,date_fns__WEBPACK_IMPORTED_MODULE_9__.setHours)(max, (0,date_fns__WEBPACK_IMPORTED_MODULE_34__.getHours)(maxTime));\n    max = (0,date_fns__WEBPACK_IMPORTED_MODULE_10__.setMinutes)(max, (0,date_fns__WEBPACK_IMPORTED_MODULE_35__.getMinutes)(maxTime));\n    max = (0,date_fns__WEBPACK_IMPORTED_MODULE_11__.setSeconds)(max, (0,date_fns__WEBPACK_IMPORTED_MODULE_36__.getSeconds)(maxTime));\n    var valid;\n    try {\n        valid = !(0,date_fns__WEBPACK_IMPORTED_MODULE_26__.isWithinInterval)(baseTime, { start: min, end: max });\n    }\n    catch (err) {\n        /* istanbul ignore next - date-fns historically threw on invalid intervals */\n        valid = false;\n    }\n    return valid;\n}\nfunction monthDisabledBefore(day, _a) {\n    var _b = _a === void 0 ? {} : _a, minDate = _b.minDate, includeDates = _b.includeDates;\n    var previousMonth = (0,date_fns__WEBPACK_IMPORTED_MODULE_37__.subMonths)(day, 1);\n    return ((minDate && (0,date_fns__WEBPACK_IMPORTED_MODULE_38__.differenceInCalendarMonths)(minDate, previousMonth) > 0) ||\n        (includeDates &&\n            includeDates.every(function (includeDate) {\n                return (0,date_fns__WEBPACK_IMPORTED_MODULE_38__.differenceInCalendarMonths)(includeDate, previousMonth) > 0;\n            })) ||\n        false);\n}\nfunction monthDisabledAfter(day, _a) {\n    var _b = _a === void 0 ? {} : _a, maxDate = _b.maxDate, includeDates = _b.includeDates;\n    var nextMonth = (0,date_fns__WEBPACK_IMPORTED_MODULE_39__.addMonths)(day, 1);\n    return ((maxDate && (0,date_fns__WEBPACK_IMPORTED_MODULE_38__.differenceInCalendarMonths)(nextMonth, maxDate) > 0) ||\n        (includeDates &&\n            includeDates.every(function (includeDate) { return (0,date_fns__WEBPACK_IMPORTED_MODULE_38__.differenceInCalendarMonths)(nextMonth, includeDate) > 0; })) ||\n        false);\n}\nfunction quarterDisabledBefore(date, _a) {\n    var _b = _a === void 0 ? {} : _a, minDate = _b.minDate, includeDates = _b.includeDates;\n    var firstDateOfYear = (0,date_fns__WEBPACK_IMPORTED_MODULE_16__.startOfYear)(date);\n    var previousQuarter = (0,date_fns__WEBPACK_IMPORTED_MODULE_40__.subQuarters)(firstDateOfYear, 1);\n    return ((minDate && (0,date_fns__WEBPACK_IMPORTED_MODULE_41__.differenceInCalendarQuarters)(minDate, previousQuarter) > 0) ||\n        (includeDates &&\n            includeDates.every(function (includeDate) {\n                return (0,date_fns__WEBPACK_IMPORTED_MODULE_41__.differenceInCalendarQuarters)(includeDate, previousQuarter) > 0;\n            })) ||\n        false);\n}\nfunction quarterDisabledAfter(date, _a) {\n    var _b = _a === void 0 ? {} : _a, maxDate = _b.maxDate, includeDates = _b.includeDates;\n    var lastDateOfYear = (0,date_fns__WEBPACK_IMPORTED_MODULE_31__.endOfYear)(date);\n    var nextQuarter = (0,date_fns__WEBPACK_IMPORTED_MODULE_42__.addQuarters)(lastDateOfYear, 1);\n    return ((maxDate && (0,date_fns__WEBPACK_IMPORTED_MODULE_41__.differenceInCalendarQuarters)(nextQuarter, maxDate) > 0) ||\n        (includeDates &&\n            includeDates.every(function (includeDate) {\n                return (0,date_fns__WEBPACK_IMPORTED_MODULE_41__.differenceInCalendarQuarters)(nextQuarter, includeDate) > 0;\n            })) ||\n        false);\n}\nfunction yearDisabledBefore(day, _a) {\n    var _b = _a === void 0 ? {} : _a, minDate = _b.minDate, includeDates = _b.includeDates;\n    var previousYear = (0,date_fns__WEBPACK_IMPORTED_MODULE_43__.subYears)(day, 1);\n    return ((minDate && (0,date_fns__WEBPACK_IMPORTED_MODULE_44__.differenceInCalendarYears)(minDate, previousYear) > 0) ||\n        (includeDates &&\n            includeDates.every(function (includeDate) {\n                return (0,date_fns__WEBPACK_IMPORTED_MODULE_44__.differenceInCalendarYears)(includeDate, previousYear) > 0;\n            })) ||\n        false);\n}\nfunction yearsDisabledBefore(day, _a) {\n    var _b = _a === void 0 ? {} : _a, minDate = _b.minDate, _c = _b.yearItemNumber, yearItemNumber = _c === void 0 ? DEFAULT_YEAR_ITEM_NUMBER : _c;\n    var previousYear = getStartOfYear((0,date_fns__WEBPACK_IMPORTED_MODULE_43__.subYears)(day, yearItemNumber));\n    var endPeriod = getYearsPeriod(previousYear, yearItemNumber).endPeriod;\n    var minDateYear = minDate && (0,date_fns__WEBPACK_IMPORTED_MODULE_29__.getYear)(minDate);\n    return (minDateYear && minDateYear > endPeriod) || false;\n}\nfunction yearDisabledAfter(day, _a) {\n    var _b = _a === void 0 ? {} : _a, maxDate = _b.maxDate, includeDates = _b.includeDates;\n    var nextYear = (0,date_fns__WEBPACK_IMPORTED_MODULE_45__.addYears)(day, 1);\n    return ((maxDate && (0,date_fns__WEBPACK_IMPORTED_MODULE_44__.differenceInCalendarYears)(nextYear, maxDate) > 0) ||\n        (includeDates &&\n            includeDates.every(function (includeDate) { return (0,date_fns__WEBPACK_IMPORTED_MODULE_44__.differenceInCalendarYears)(nextYear, includeDate) > 0; })) ||\n        false);\n}\nfunction yearsDisabledAfter(day, _a) {\n    var _b = _a === void 0 ? {} : _a, maxDate = _b.maxDate, _c = _b.yearItemNumber, yearItemNumber = _c === void 0 ? DEFAULT_YEAR_ITEM_NUMBER : _c;\n    var nextYear = (0,date_fns__WEBPACK_IMPORTED_MODULE_45__.addYears)(day, yearItemNumber);\n    var startPeriod = getYearsPeriod(nextYear, yearItemNumber).startPeriod;\n    var maxDateYear = maxDate && (0,date_fns__WEBPACK_IMPORTED_MODULE_29__.getYear)(maxDate);\n    return (maxDateYear && maxDateYear < startPeriod) || false;\n}\nfunction getEffectiveMinDate(_a) {\n    var minDate = _a.minDate, includeDates = _a.includeDates;\n    if (includeDates && minDate) {\n        var minDates = includeDates.filter(function (includeDate) { return (0,date_fns__WEBPACK_IMPORTED_MODULE_33__.differenceInCalendarDays)(includeDate, minDate) >= 0; });\n        return (0,date_fns__WEBPACK_IMPORTED_MODULE_46__.min)(minDates);\n    }\n    else if (includeDates) {\n        return (0,date_fns__WEBPACK_IMPORTED_MODULE_46__.min)(includeDates);\n    }\n    else {\n        return minDate;\n    }\n}\nfunction getEffectiveMaxDate(_a) {\n    var maxDate = _a.maxDate, includeDates = _a.includeDates;\n    if (includeDates && maxDate) {\n        var maxDates = includeDates.filter(function (includeDate) { return (0,date_fns__WEBPACK_IMPORTED_MODULE_33__.differenceInCalendarDays)(includeDate, maxDate) <= 0; });\n        return (0,date_fns__WEBPACK_IMPORTED_MODULE_47__.max)(maxDates);\n    }\n    else if (includeDates) {\n        return (0,date_fns__WEBPACK_IMPORTED_MODULE_47__.max)(includeDates);\n    }\n    else {\n        return maxDate;\n    }\n}\n/**\n * Get a map of highlighted dates with their corresponding classes.\n * @param highlightDates The dates to highlight.\n * @param defaultClassName The default class to use for highlighting.\n * @returns A map with dates as keys and arrays of class names as values.\n */\nfunction getHighLightDaysMap(highlightDates, defaultClassName) {\n    var _a;\n    if (highlightDates === void 0) { highlightDates = []; }\n    if (defaultClassName === void 0) { defaultClassName = \"react-datepicker__day--highlighted\"; }\n    var dateClasses = new Map();\n    for (var i = 0, len = highlightDates.length; i < len; i++) {\n        var obj = highlightDates[i];\n        if ((0,date_fns__WEBPACK_IMPORTED_MODULE_48__.isDate)(obj)) {\n            var key = formatDate(obj, \"MM.dd.yyyy\");\n            var classNamesArr = dateClasses.get(key) || [];\n            if (!classNamesArr.includes(defaultClassName)) {\n                classNamesArr.push(defaultClassName);\n                dateClasses.set(key, classNamesArr);\n            }\n        }\n        else if (typeof obj === \"object\") {\n            var keys = Object.keys(obj);\n            var className = (_a = keys[0]) !== null && _a !== void 0 ? _a : \"\";\n            var arrOfDates = obj[className];\n            if (typeof className === \"string\" && Array.isArray(arrOfDates)) {\n                for (var k = 0, len_1 = arrOfDates.length; k < len_1; k++) {\n                    var dateK = arrOfDates[k];\n                    if (dateK) {\n                        var key = formatDate(dateK, \"MM.dd.yyyy\");\n                        var classNamesArr = dateClasses.get(key) || [];\n                        if (!classNamesArr.includes(className)) {\n                            classNamesArr.push(className);\n                            dateClasses.set(key, classNamesArr);\n                        }\n                    }\n                }\n            }\n        }\n    }\n    return dateClasses;\n}\n/**\n * Compare the two arrays\n * @param array1 The first array to compare.\n * @param array2 The second array to compare.\n * @returns true, if the passed arrays are equal, false otherwise.\n */\nfunction arraysAreEqual(array1, array2) {\n    if (array1.length !== array2.length) {\n        return false;\n    }\n    return array1.every(function (value, index) { return value === array2[index]; });\n}\n/**\n * Assign the custom class to each date\n * @param holidayDates array of object containing date and name of the holiday\n * @param defaultClassName className to be added.\n * @returns Map containing date as key and array of className and holiday name as value\n */\nfunction getHolidaysMap(holidayDates, defaultClassName) {\n    if (holidayDates === void 0) { holidayDates = []; }\n    if (defaultClassName === void 0) { defaultClassName = \"react-datepicker__day--holidays\"; }\n    var dateClasses = new Map();\n    holidayDates.forEach(function (holiday) {\n        var dateObj = holiday.date, holidayName = holiday.holidayName;\n        if (!(0,date_fns__WEBPACK_IMPORTED_MODULE_48__.isDate)(dateObj)) {\n            return;\n        }\n        var key = formatDate(dateObj, \"MM.dd.yyyy\");\n        var classNamesObj = dateClasses.get(key) || {\n            className: \"\",\n            holidayNames: [],\n        };\n        if (\"className\" in classNamesObj &&\n            classNamesObj[\"className\"] === defaultClassName &&\n            arraysAreEqual(classNamesObj[\"holidayNames\"], [holidayName])) {\n            return;\n        }\n        classNamesObj[\"className\"] = defaultClassName;\n        var holidayNameArr = classNamesObj[\"holidayNames\"];\n        classNamesObj[\"holidayNames\"] = holidayNameArr\n            ? __spreadArray(__spreadArray([], holidayNameArr, true), [holidayName], false) : [holidayName];\n        dateClasses.set(key, classNamesObj);\n    });\n    return dateClasses;\n}\n/**\n * Determines the times to inject after a given start of day, current time, and multiplier.\n * @param startOfDay The start of the day.\n * @param currentTime The current time.\n * @param currentMultiplier The current multiplier.\n * @param intervals The intervals.\n * @param injectedTimes The times to potentially inject.\n * @returns An array of times to inject.\n */\nfunction timesToInjectAfter(startOfDay, currentTime, currentMultiplier, intervals, injectedTimes) {\n    var l = injectedTimes.length;\n    var times = [];\n    for (var i = 0; i < l; i++) {\n        var injectedTime = startOfDay;\n        var injectedTimeValue = injectedTimes[i];\n        if (injectedTimeValue) {\n            injectedTime = (0,date_fns__WEBPACK_IMPORTED_MODULE_49__.addHours)(injectedTime, (0,date_fns__WEBPACK_IMPORTED_MODULE_34__.getHours)(injectedTimeValue));\n            injectedTime = (0,date_fns__WEBPACK_IMPORTED_MODULE_50__.addMinutes)(injectedTime, (0,date_fns__WEBPACK_IMPORTED_MODULE_35__.getMinutes)(injectedTimeValue));\n            injectedTime = (0,date_fns__WEBPACK_IMPORTED_MODULE_51__.addSeconds)(injectedTime, (0,date_fns__WEBPACK_IMPORTED_MODULE_36__.getSeconds)(injectedTimeValue));\n        }\n        var nextTime = (0,date_fns__WEBPACK_IMPORTED_MODULE_50__.addMinutes)(startOfDay, (currentMultiplier + 1) * intervals);\n        if ((0,date_fns__WEBPACK_IMPORTED_MODULE_52__.isAfter)(injectedTime, currentTime) &&\n            (0,date_fns__WEBPACK_IMPORTED_MODULE_7__.isBefore)(injectedTime, nextTime) &&\n            injectedTimeValue != undefined) {\n            times.push(injectedTimeValue);\n        }\n    }\n    return times;\n}\n/**\n * Adds a leading zero to a number if it's less than 10.\n * @param i The number to add a leading zero to.\n * @returns The number as a string, with a leading zero if it was less than 10.\n */\nfunction addZero(i) {\n    return i < 10 ? \"0\".concat(i) : \"\".concat(i);\n}\n/**\n * Gets the start and end years for a period.\n * @param date The date to get the period for.\n * @param yearItemNumber The number of years in the period. Defaults to DEFAULT_YEAR_ITEM_NUMBER.\n * @returns An object with the start and end years for the period.\n */\nfunction getYearsPeriod(date, yearItemNumber) {\n    if (yearItemNumber === void 0) { yearItemNumber = DEFAULT_YEAR_ITEM_NUMBER; }\n    var endPeriod = Math.ceil((0,date_fns__WEBPACK_IMPORTED_MODULE_29__.getYear)(date) / yearItemNumber) * yearItemNumber;\n    var startPeriod = endPeriod - (yearItemNumber - 1);\n    return { startPeriod: startPeriod, endPeriod: endPeriod };\n}\n/**\n * Gets the number of hours in a day.\n * @param d The date to get the number of hours for.\n * @returns The number of hours in the day.\n */\nfunction getHoursInDay(d) {\n    var startOfDay = new Date(d.getFullYear(), d.getMonth(), d.getDate());\n    var startOfTheNextDay = new Date(d.getFullYear(), d.getMonth(), d.getDate(), 24);\n    return Math.round((+startOfTheNextDay - +startOfDay) / 3600000);\n}\n/**\n * Returns the start of the minute for the given date\n *\n * NOTE: this function is a DST and timezone-safe analog of `date-fns/startOfMinute`\n * do not make changes unless you know what you're doing\n *\n * See comments on https://github.com/Hacker0x01/react-datepicker/pull/4244\n * for more details\n *\n * @param d date\n * @returns start of the minute\n */\nfunction startOfMinute(d) {\n    var seconds = d.getSeconds();\n    var milliseconds = d.getMilliseconds();\n    return (0,date_fns__WEBPACK_IMPORTED_MODULE_4__.toDate)(d.getTime() - seconds * 1000 - milliseconds);\n}\n/**\n * Returns whether the given dates are in the same minute\n *\n * This function is a DST and timezone-safe analog of `date-fns/isSameMinute`\n *\n * @param d1\n * @param d2\n * @returns\n */\nfunction isSameMinute(d1, d2) {\n    return startOfMinute(d1).getTime() === startOfMinute(d2).getTime();\n}\n/**\n * Returns a new datetime object representing the input date with midnight time\n * @param date The date to get the midnight time for\n * @returns A new datetime object representing the input date with midnight time\n */\nfunction getMidnightDate(date) {\n    if (!(0,date_fns__WEBPACK_IMPORTED_MODULE_48__.isDate)(date)) {\n        throw new Error(\"Invalid date\");\n    }\n    var dateWithoutTime = new Date(date);\n    dateWithoutTime.setHours(0, 0, 0, 0);\n    return dateWithoutTime;\n}\n/**\n * Is the first date before the second one?\n * @param date The date that should be before the other one to return true\n * @param dateToCompare The date to compare with\n * @returns The first date is before the second date\n *\n * Note:\n *  This function considers the mid-night of the given dates for comparison.\n *  It evaluates whether date is before dateToCompare based on their mid-night timestamps.\n */\nfunction isDateBefore(date, dateToCompare) {\n    if (!(0,date_fns__WEBPACK_IMPORTED_MODULE_48__.isDate)(date) || !(0,date_fns__WEBPACK_IMPORTED_MODULE_48__.isDate)(dateToCompare)) {\n        throw new Error(\"Invalid date received\");\n    }\n    var midnightDate = getMidnightDate(date);\n    var midnightDateToCompare = getMidnightDate(dateToCompare);\n    return (0,date_fns__WEBPACK_IMPORTED_MODULE_7__.isBefore)(midnightDate, midnightDateToCompare);\n}\n/**\n * Checks if the space key was pressed down.\n *\n * @param event - The keyboard event.\n * @returns - Returns true if the space key was pressed down, false otherwise.\n */\nfunction isSpaceKeyDown(event) {\n    return event.key === KeyType.Space;\n}\n\n/**\n * `InputTime` is a React component that manages time input.\n *\n * @component\n * @example\n * <InputTime timeString=\"12:00\" />\n *\n * @param props - The properties that define the `InputTime` component.\n * @param props.onChange - Function that is called when the date changes.\n * @param props.date - The initial date value.\n * @param props.timeString - The initial time string value.\n * @param props.timeInputLabel - The label for the time input.\n * @param props.customTimeInput - An optional custom time input element.\n *\n * @returns The `InputTime` component.\n */\nvar InputTime = /** @class */ (function (_super) {\n    __extends(InputTime, _super);\n    function InputTime(props) {\n        var _this = _super.call(this, props) || this;\n        _this.inputRef = react__WEBPACK_IMPORTED_MODULE_1___default().createRef();\n        _this.onTimeChange = function (time) {\n            var _a, _b;\n            _this.setState({ time: time });\n            var propDate = _this.props.date;\n            var isPropDateValid = propDate instanceof Date && !isNaN(+propDate);\n            var date = isPropDateValid ? propDate : new Date();\n            if (time === null || time === void 0 ? void 0 : time.includes(\":\")) {\n                var _c = time.split(\":\"), hours = _c[0], minutes = _c[1];\n                date.setHours(Number(hours));\n                date.setMinutes(Number(minutes));\n            }\n            (_b = (_a = _this.props).onChange) === null || _b === void 0 ? void 0 : _b.call(_a, date);\n        };\n        _this.renderTimeInput = function () {\n            var time = _this.state.time;\n            var _a = _this.props, date = _a.date, timeString = _a.timeString, customTimeInput = _a.customTimeInput;\n            if (customTimeInput) {\n                return (0,react__WEBPACK_IMPORTED_MODULE_1__.cloneElement)(customTimeInput, {\n                    date: date,\n                    value: time,\n                    onChange: _this.onTimeChange,\n                });\n            }\n            return (react__WEBPACK_IMPORTED_MODULE_1___default().createElement(\"input\", { type: \"time\", className: \"react-datepicker-time__input\", placeholder: \"Time\", name: \"time-input\", ref: _this.inputRef, onClick: function () {\n                    var _a;\n                    (_a = _this.inputRef.current) === null || _a === void 0 ? void 0 : _a.focus();\n                }, required: true, value: time, onChange: function (event) {\n                    _this.onTimeChange(event.target.value || timeString);\n                } }));\n        };\n        _this.state = {\n            time: _this.props.timeString,\n        };\n        return _this;\n    }\n    InputTime.getDerivedStateFromProps = function (props, state) {\n        if (props.timeString !== state.time) {\n            return {\n                time: props.timeString,\n            };\n        }\n        // Return null to indicate no change to state.\n        return null;\n    };\n    InputTime.prototype.render = function () {\n        return (react__WEBPACK_IMPORTED_MODULE_1___default().createElement(\"div\", { className: \"react-datepicker__input-time-container\" },\n            react__WEBPACK_IMPORTED_MODULE_1___default().createElement(\"div\", { className: \"react-datepicker-time__caption\" }, this.props.timeInputLabel),\n            react__WEBPACK_IMPORTED_MODULE_1___default().createElement(\"div\", { className: \"react-datepicker-time__input-container\" },\n                react__WEBPACK_IMPORTED_MODULE_1___default().createElement(\"div\", { className: \"react-datepicker-time__input\" }, this.renderTimeInput()))));\n    };\n    return InputTime;\n}(react__WEBPACK_IMPORTED_MODULE_1__.Component));\n\n/**\n * `Day` is a React component that represents a single day in a date picker.\n * It handles the rendering and interaction of a day.\n *\n * @prop ariaLabelPrefixWhenEnabled - Aria label prefix when the day is enabled.\n * @prop ariaLabelPrefixWhenDisabled - Aria label prefix when the day is disabled.\n * @prop disabledKeyboardNavigation - Whether keyboard navigation is disabled.\n * @prop day - The day to be displayed.\n * @prop dayClassName - Function to customize the CSS class of the day.\n * @prop endDate - The end date in a range.\n * @prop highlightDates - Map of dates to be highlighted.\n * @prop holidays - Map of holiday dates.\n * @prop inline - Whether the date picker is inline.\n * @prop shouldFocusDayInline - Whether the day should be focused when date picker is inline.\n * @prop month - The month the day belongs to.\n * @prop onClick - Click event handler.\n * @prop onMouseEnter - Mouse enter event handler.\n * @prop handleOnKeyDown - Key down event handler.\n * @prop usePointerEvent - Whether to use pointer events.\n * @prop preSelection - The date that is currently selected.\n * @prop selected - The selected date.\n * @prop selectingDate - The date currently being selected.\n * @prop selectsEnd - Whether the day can be the end date in a range.\n * @prop selectsStart - Whether the day can be the start date in a range.\n * @prop selectsRange - Whether the day can be in a range.\n * @prop showWeekPicker - Whether to show week picker.\n * @prop showWeekNumber - Whether to show week numbers.\n * @prop selectsDisabledDaysInRange - Whether to select disabled days in a range.\n * @prop selectsMultiple - Whether to allow multiple date selection.\n * @prop selectedDates - Array of selected dates.\n * @prop startDate - The start date in a range.\n * @prop renderDayContents - Function to customize the rendering of the day's contents.\n * @prop containerRef - Ref for the container.\n * @prop excludeDates - Array of dates to be excluded.\n * @prop calendarStartDay - The start day of the week.\n * @prop locale - The locale object.\n * @prop monthShowsDuplicateDaysEnd - Whether to show duplicate days at the end of the month.\n * @prop monthShowsDuplicateDaysStart - Whether to show duplicate days at the start of the month.\n * @prop includeDates - Array of dates to be included.\n * @prop includeDateIntervals - Array of date intervals to be included.\n * @prop minDate - The minimum date that can be selected.\n * @prop maxDate - The maximum date that can be selected.\n *\n * @example\n * ```tsx\n * import React from 'react';\n * import Day from './day';\n *\n * function MyComponent() {\n *   const handleDayClick = (event) => {\n *     console.log('Day clicked', event);\n *   };\n *\n *   const handleDayMouseEnter = (event) => {\n *     console.log('Mouse entered day', event);\n *   };\n *\n *   const renderDayContents = (date) => {\n *     return <div>{date.getDate()}</div>;\n *   };\n *\n *   return (\n *     <Day\n *       day={new Date()}\n *       onClick={handleDayClick}\n *       onMouseEnter={handleDayMouseEnter}\n *       renderDayContents={renderDayContents}\n *     />\n *   );\n * }\n *\n * export default MyComponent;\n * ```\n */\nvar Day = /** @class */ (function (_super) {\n    __extends(Day, _super);\n    function Day() {\n        var _this = _super !== null && _super.apply(this, arguments) || this;\n        _this.dayEl = (0,react__WEBPACK_IMPORTED_MODULE_1__.createRef)();\n        _this.handleClick = function (event) {\n            if (!_this.isDisabled() && _this.props.onClick) {\n                _this.props.onClick(event);\n            }\n        };\n        _this.handleMouseEnter = function (event) {\n            if (!_this.isDisabled() && _this.props.onMouseEnter) {\n                _this.props.onMouseEnter(event);\n            }\n        };\n        _this.handleOnKeyDown = function (event) {\n            var _a, _b;\n            var eventKey = event.key;\n            if (eventKey === KeyType.Space) {\n                event.preventDefault();\n                event.key = KeyType.Enter;\n            }\n            (_b = (_a = _this.props).handleOnKeyDown) === null || _b === void 0 ? void 0 : _b.call(_a, event);\n        };\n        _this.isSameDay = function (other) {\n            return isSameDay(_this.props.day, other);\n        };\n        _this.isKeyboardSelected = function () {\n            var _a;\n            if (_this.props.disabledKeyboardNavigation) {\n                return false;\n            }\n            var isSelectedDate = _this.props.selectsMultiple\n                ? (_a = _this.props.selectedDates) === null || _a === void 0 ? void 0 : _a.some(function (date) { return _this.isSameDayOrWeek(date); })\n                : _this.isSameDayOrWeek(_this.props.selected);\n            var isDisabled = _this.props.preSelection && _this.isDisabled(_this.props.preSelection);\n            return (!isSelectedDate &&\n                _this.isSameDayOrWeek(_this.props.preSelection) &&\n                !isDisabled);\n        };\n        _this.isDisabled = function (day) {\n            if (day === void 0) { day = _this.props.day; }\n            // Almost all props previously were passed as this.props w/o proper typing with prop-types\n            // after the migration to TS i made it explicit\n            return isDayDisabled(day, {\n                minDate: _this.props.minDate,\n                maxDate: _this.props.maxDate,\n                excludeDates: _this.props.excludeDates,\n                excludeDateIntervals: _this.props.excludeDateIntervals,\n                includeDateIntervals: _this.props.includeDateIntervals,\n                includeDates: _this.props.includeDates,\n                filterDate: _this.props.filterDate,\n                disabled: _this.props.disabled,\n            });\n        };\n        _this.isExcluded = function () {\n            // Almost all props previously were passed as this.props w/o proper typing with prop-types\n            // after the migration to TS i made it explicit\n            return isDayExcluded(_this.props.day, {\n                excludeDates: _this.props.excludeDates,\n                excludeDateIntervals: _this.props.excludeDateIntervals,\n            });\n        };\n        _this.isStartOfWeek = function () {\n            return isSameDay(_this.props.day, getStartOfWeek(_this.props.day, _this.props.locale, _this.props.calendarStartDay));\n        };\n        _this.isSameWeek = function (other) {\n            return _this.props.showWeekPicker &&\n                isSameDay(other, getStartOfWeek(_this.props.day, _this.props.locale, _this.props.calendarStartDay));\n        };\n        _this.isSameDayOrWeek = function (other) {\n            return _this.isSameDay(other) || _this.isSameWeek(other);\n        };\n        _this.getHighLightedClass = function () {\n            var _a = _this.props, day = _a.day, highlightDates = _a.highlightDates;\n            if (!highlightDates) {\n                return false;\n            }\n            // Looking for className in the Map of {'day string, 'className'}\n            var dayStr = formatDate(day, \"MM.dd.yyyy\");\n            return highlightDates.get(dayStr);\n        };\n        // Function to return the array containing className associated to the date\n        _this.getHolidaysClass = function () {\n            var _a;\n            var _b = _this.props, day = _b.day, holidays = _b.holidays;\n            if (!holidays) {\n                // For type consistency no other reasons\n                return [undefined];\n            }\n            var dayStr = formatDate(day, \"MM.dd.yyyy\");\n            // Looking for className in the Map of {day string: {className, holidayName}}\n            if (holidays.has(dayStr)) {\n                return [(_a = holidays.get(dayStr)) === null || _a === void 0 ? void 0 : _a.className];\n            }\n            // For type consistency no other reasons\n            return [undefined];\n        };\n        _this.isInRange = function () {\n            var _a = _this.props, day = _a.day, startDate = _a.startDate, endDate = _a.endDate;\n            if (!startDate || !endDate) {\n                return false;\n            }\n            return isDayInRange(day, startDate, endDate);\n        };\n        _this.isInSelectingRange = function () {\n            var _a;\n            var _b = _this.props, day = _b.day, selectsStart = _b.selectsStart, selectsEnd = _b.selectsEnd, selectsRange = _b.selectsRange, selectsDisabledDaysInRange = _b.selectsDisabledDaysInRange, startDate = _b.startDate, swapRange = _b.swapRange, endDate = _b.endDate;\n            var selectingDate = (_a = _this.props.selectingDate) !== null && _a !== void 0 ? _a : _this.props.preSelection;\n            if (!(selectsStart || selectsEnd || selectsRange) ||\n                !selectingDate ||\n                (!selectsDisabledDaysInRange && _this.isDisabled())) {\n                return false;\n            }\n            if (selectsStart &&\n                endDate &&\n                ((0,date_fns__WEBPACK_IMPORTED_MODULE_7__.isBefore)(selectingDate, endDate) || isEqual(selectingDate, endDate))) {\n                return isDayInRange(day, selectingDate, endDate);\n            }\n            if (selectsEnd &&\n                startDate &&\n                ((0,date_fns__WEBPACK_IMPORTED_MODULE_52__.isAfter)(selectingDate, startDate) || isEqual(selectingDate, startDate))) {\n                return isDayInRange(day, startDate, selectingDate);\n            }\n            if (selectsRange && startDate && !endDate) {\n                if (isEqual(selectingDate, startDate)) {\n                    return isDayInRange(day, startDate, selectingDate);\n                }\n                if ((0,date_fns__WEBPACK_IMPORTED_MODULE_52__.isAfter)(selectingDate, startDate)) {\n                    return isDayInRange(day, startDate, selectingDate);\n                }\n                if (swapRange && (0,date_fns__WEBPACK_IMPORTED_MODULE_7__.isBefore)(selectingDate, startDate)) {\n                    return isDayInRange(day, selectingDate, startDate);\n                }\n            }\n            return false;\n        };\n        _this.isSelectingRangeStart = function () {\n            var _a;\n            if (!_this.isInSelectingRange()) {\n                return false;\n            }\n            var _b = _this.props, day = _b.day, startDate = _b.startDate, selectsStart = _b.selectsStart, swapRange = _b.swapRange, selectsRange = _b.selectsRange;\n            var selectingDate = (_a = _this.props.selectingDate) !== null && _a !== void 0 ? _a : _this.props.preSelection;\n            if (selectsStart) {\n                return isSameDay(day, selectingDate);\n            }\n            if (selectsRange && swapRange && startDate && selectingDate) {\n                return isSameDay(day, (0,date_fns__WEBPACK_IMPORTED_MODULE_7__.isBefore)(selectingDate, startDate) ? selectingDate : startDate);\n            }\n            return isSameDay(day, startDate);\n        };\n        _this.isSelectingRangeEnd = function () {\n            var _a;\n            if (!_this.isInSelectingRange()) {\n                return false;\n            }\n            var _b = _this.props, day = _b.day, endDate = _b.endDate, selectsEnd = _b.selectsEnd, selectsRange = _b.selectsRange, swapRange = _b.swapRange, startDate = _b.startDate;\n            var selectingDate = (_a = _this.props.selectingDate) !== null && _a !== void 0 ? _a : _this.props.preSelection;\n            if (selectsEnd) {\n                return isSameDay(day, selectingDate);\n            }\n            if (selectsRange && swapRange && startDate && selectingDate) {\n                return isSameDay(day, (0,date_fns__WEBPACK_IMPORTED_MODULE_7__.isBefore)(selectingDate, startDate) ? startDate : selectingDate);\n            }\n            if (selectsRange) {\n                return isSameDay(day, selectingDate);\n            }\n            return isSameDay(day, endDate);\n        };\n        _this.isRangeStart = function () {\n            var _a = _this.props, day = _a.day, startDate = _a.startDate, endDate = _a.endDate;\n            if (!startDate || !endDate) {\n                return false;\n            }\n            return isSameDay(startDate, day);\n        };\n        _this.isRangeEnd = function () {\n            var _a = _this.props, day = _a.day, startDate = _a.startDate, endDate = _a.endDate;\n            if (!startDate || !endDate) {\n                return false;\n            }\n            return isSameDay(endDate, day);\n        };\n        _this.isWeekend = function () {\n            var weekday = (0,date_fns__WEBPACK_IMPORTED_MODULE_53__.getDay)(_this.props.day);\n            return weekday === 0 || weekday === 6;\n        };\n        _this.isAfterMonth = function () {\n            return (_this.props.month !== undefined &&\n                (_this.props.month + 1) % 12 === (0,date_fns__WEBPACK_IMPORTED_MODULE_30__.getMonth)(_this.props.day));\n        };\n        _this.isBeforeMonth = function () {\n            return (_this.props.month !== undefined &&\n                ((0,date_fns__WEBPACK_IMPORTED_MODULE_30__.getMonth)(_this.props.day) + 1) % 12 === _this.props.month);\n        };\n        _this.isCurrentDay = function () { return _this.isSameDay(newDate()); };\n        _this.isSelected = function () {\n            var _a;\n            if (_this.props.selectsMultiple) {\n                return (_a = _this.props.selectedDates) === null || _a === void 0 ? void 0 : _a.some(function (date) {\n                    return _this.isSameDayOrWeek(date);\n                });\n            }\n            return _this.isSameDayOrWeek(_this.props.selected);\n        };\n        _this.getClassNames = function (date) {\n            var dayClassName = _this.props.dayClassName\n                ? _this.props.dayClassName(date)\n                : undefined;\n            return (0,clsx__WEBPACK_IMPORTED_MODULE_0__.clsx)(\"react-datepicker__day\", dayClassName, \"react-datepicker__day--\" + getDayOfWeekCode(_this.props.day), {\n                \"react-datepicker__day--disabled\": _this.isDisabled(),\n                \"react-datepicker__day--excluded\": _this.isExcluded(),\n                \"react-datepicker__day--selected\": _this.isSelected(),\n                \"react-datepicker__day--keyboard-selected\": _this.isKeyboardSelected(),\n                \"react-datepicker__day--range-start\": _this.isRangeStart(),\n                \"react-datepicker__day--range-end\": _this.isRangeEnd(),\n                \"react-datepicker__day--in-range\": _this.isInRange(),\n                \"react-datepicker__day--in-selecting-range\": _this.isInSelectingRange(),\n                \"react-datepicker__day--selecting-range-start\": _this.isSelectingRangeStart(),\n                \"react-datepicker__day--selecting-range-end\": _this.isSelectingRangeEnd(),\n                \"react-datepicker__day--today\": _this.isCurrentDay(),\n                \"react-datepicker__day--weekend\": _this.isWeekend(),\n                \"react-datepicker__day--outside-month\": _this.isAfterMonth() || _this.isBeforeMonth(),\n            }, _this.getHighLightedClass(), _this.getHolidaysClass());\n        };\n        _this.getAriaLabel = function () {\n            var _a = _this.props, day = _a.day, _b = _a.ariaLabelPrefixWhenEnabled, ariaLabelPrefixWhenEnabled = _b === void 0 ? \"Choose\" : _b, _c = _a.ariaLabelPrefixWhenDisabled, ariaLabelPrefixWhenDisabled = _c === void 0 ? \"Not available\" : _c;\n            var prefix = _this.isDisabled() || _this.isExcluded()\n                ? ariaLabelPrefixWhenDisabled\n                : ariaLabelPrefixWhenEnabled;\n            return \"\".concat(prefix, \" \").concat(formatDate(day, \"PPPP\", _this.props.locale));\n        };\n        // A function to return the holiday's name as title's content\n        _this.getTitle = function () {\n            var _a = _this.props, day = _a.day, _b = _a.holidays, holidays = _b === void 0 ? new Map() : _b, excludeDates = _a.excludeDates;\n            var compareDt = formatDate(day, \"MM.dd.yyyy\");\n            var titles = [];\n            if (holidays.has(compareDt)) {\n                titles.push.apply(titles, holidays.get(compareDt).holidayNames);\n            }\n            if (_this.isExcluded()) {\n                titles.push(excludeDates === null || excludeDates === void 0 ? void 0 : excludeDates.filter(function (excludeDate) {\n                    if (excludeDate instanceof Date) {\n                        return isSameDay(excludeDate, day);\n                    }\n                    return isSameDay(excludeDate === null || excludeDate === void 0 ? void 0 : excludeDate.date, day);\n                }).map(function (excludeDate) {\n                    if (excludeDate instanceof Date) {\n                        return undefined;\n                    }\n                    return excludeDate === null || excludeDate === void 0 ? void 0 : excludeDate.message;\n                }));\n            }\n            // I'm not sure that this is a right output, but all tests are green\n            return titles.join(\", \");\n        };\n        _this.getTabIndex = function () {\n            var selectedDay = _this.props.selected;\n            var preSelectionDay = _this.props.preSelection;\n            var tabIndex = !(_this.props.showWeekPicker &&\n                (_this.props.showWeekNumber || !_this.isStartOfWeek())) &&\n                (_this.isKeyboardSelected() ||\n                    (_this.isSameDay(selectedDay) &&\n                        isSameDay(preSelectionDay, selectedDay)))\n                ? 0\n                : -1;\n            return tabIndex;\n        };\n        // various cases when we need to apply focus to the preselected day\n        // focus the day on mount/update so that keyboard navigation works while cycling through months with up or down keys (not for prev and next month buttons)\n        // prevent focus for these activeElement cases so we don't pull focus from the input as the calendar opens\n        _this.handleFocusDay = function () {\n            var _a;\n            // only do this while the input isn't focused\n            // otherwise, typing/backspacing the date manually may steal focus away from the input\n            _this.shouldFocusDay() && ((_a = _this.dayEl.current) === null || _a === void 0 ? void 0 : _a.focus({ preventScroll: true }));\n        };\n        _this.renderDayContents = function () {\n            if (_this.props.monthShowsDuplicateDaysEnd && _this.isAfterMonth())\n                return null;\n            if (_this.props.monthShowsDuplicateDaysStart && _this.isBeforeMonth())\n                return null;\n            return _this.props.renderDayContents\n                ? _this.props.renderDayContents((0,date_fns__WEBPACK_IMPORTED_MODULE_54__.getDate)(_this.props.day), _this.props.day)\n                : (0,date_fns__WEBPACK_IMPORTED_MODULE_54__.getDate)(_this.props.day);\n        };\n        _this.render = function () { return (\n        // TODO: Use <option> instead of the \"option\" role to ensure accessibility across all devices.\n        react__WEBPACK_IMPORTED_MODULE_1___default().createElement(\"div\", { ref: _this.dayEl, className: _this.getClassNames(_this.props.day), onKeyDown: _this.handleOnKeyDown, onClick: _this.handleClick, onMouseEnter: !_this.props.usePointerEvent ? _this.handleMouseEnter : undefined, onPointerEnter: _this.props.usePointerEvent ? _this.handleMouseEnter : undefined, tabIndex: _this.getTabIndex(), \"aria-label\": _this.getAriaLabel(), role: \"gridcell\", title: _this.getTitle(), \"aria-disabled\": _this.isDisabled(), \"aria-current\": _this.isCurrentDay() ? \"date\" : undefined, \"aria-selected\": _this.isSelected() || _this.isInRange() },\n            _this.renderDayContents(),\n            _this.getTitle() !== \"\" && (react__WEBPACK_IMPORTED_MODULE_1___default().createElement(\"span\", { className: \"overlay\" }, _this.getTitle())))); };\n        return _this;\n    }\n    Day.prototype.componentDidMount = function () {\n        this.handleFocusDay();\n    };\n    Day.prototype.componentDidUpdate = function () {\n        this.handleFocusDay();\n    };\n    Day.prototype.shouldFocusDay = function () {\n        var shouldFocusDay = false;\n        if (this.getTabIndex() === 0 && this.isSameDay(this.props.preSelection)) {\n            // there is currently no activeElement and not inline\n            if (!document.activeElement || document.activeElement === document.body) {\n                shouldFocusDay = true;\n            }\n            // inline version:\n            // do not focus on initial render to prevent autoFocus issue\n            // focus after month has changed via keyboard\n            if (this.props.inline && !this.props.shouldFocusDayInline) {\n                shouldFocusDay = false;\n            }\n            if (this.isDayActiveElement()) {\n                shouldFocusDay = true;\n            }\n            if (this.isDuplicateDay()) {\n                shouldFocusDay = false;\n            }\n        }\n        return shouldFocusDay;\n    };\n    // the activeElement is in the container, and it is another instance of Day\n    Day.prototype.isDayActiveElement = function () {\n        var _a, _b, _c;\n        return (((_b = (_a = this.props.containerRef) === null || _a === void 0 ? void 0 : _a.current) === null || _b === void 0 ? void 0 : _b.contains(document.activeElement)) &&\n            ((_c = document.activeElement) === null || _c === void 0 ? void 0 : _c.classList.contains(\"react-datepicker__day\")));\n    };\n    Day.prototype.isDuplicateDay = function () {\n        return (\n        //day is one of the non rendered duplicate days\n        (this.props.monthShowsDuplicateDaysEnd && this.isAfterMonth()) ||\n            (this.props.monthShowsDuplicateDaysStart && this.isBeforeMonth()));\n    };\n    return Day;\n}(react__WEBPACK_IMPORTED_MODULE_1__.Component));\n\nvar WeekNumber = /** @class */ (function (_super) {\n    __extends(WeekNumber, _super);\n    function WeekNumber() {\n        var _this = _super !== null && _super.apply(this, arguments) || this;\n        _this.weekNumberEl = (0,react__WEBPACK_IMPORTED_MODULE_1__.createRef)();\n        _this.handleClick = function (event) {\n            if (_this.props.onClick) {\n                _this.props.onClick(event);\n            }\n        };\n        _this.handleOnKeyDown = function (event) {\n            var _a, _b;\n            var eventKey = event.key;\n            if (eventKey === KeyType.Space) {\n                event.preventDefault();\n                event.key = KeyType.Enter;\n            }\n            (_b = (_a = _this.props).handleOnKeyDown) === null || _b === void 0 ? void 0 : _b.call(_a, event);\n        };\n        _this.isKeyboardSelected = function () {\n            return !_this.props.disabledKeyboardNavigation &&\n                !isSameDay(_this.props.date, _this.props.selected) &&\n                isSameDay(_this.props.date, _this.props.preSelection);\n        };\n        _this.getTabIndex = function () {\n            return _this.props.showWeekPicker &&\n                _this.props.showWeekNumber &&\n                (_this.isKeyboardSelected() ||\n                    (isSameDay(_this.props.date, _this.props.selected) &&\n                        isSameDay(_this.props.preSelection, _this.props.selected)))\n                ? 0\n                : -1;\n        };\n        // various cases when we need to apply focus to the preselected week-number\n        // focus the week-number on mount/update so that keyboard navigation works while cycling through months with up or down keys (not for prev and next month buttons)\n        // prevent focus for these activeElement cases so we don't pull focus from the input as the calendar opens\n        _this.handleFocusWeekNumber = function (prevProps) {\n            var shouldFocusWeekNumber = false;\n            // only do this while the input isn't focused\n            // otherwise, typing/backspacing the date manually may steal focus away from the input\n            if (_this.getTabIndex() === 0 &&\n                !(prevProps === null || prevProps === void 0 ? void 0 : prevProps.isInputFocused) &&\n                isSameDay(_this.props.date, _this.props.preSelection)) {\n                // there is currently no activeElement and not inline\n                if (!document.activeElement || document.activeElement === document.body) {\n                    shouldFocusWeekNumber = true;\n                }\n                // inline version:\n                // do not focus on initial render to prevent autoFocus issue\n                // focus after month has changed via keyboard\n                if (_this.props.inline && !_this.props.shouldFocusDayInline) {\n                    shouldFocusWeekNumber = false;\n                }\n                // the activeElement is in the container, and it is another instance of WeekNumber\n                if (_this.props.containerRef &&\n                    _this.props.containerRef.current &&\n                    _this.props.containerRef.current.contains(document.activeElement) &&\n                    document.activeElement &&\n                    document.activeElement.classList.contains(\"react-datepicker__week-number\")) {\n                    shouldFocusWeekNumber = true;\n                }\n            }\n            shouldFocusWeekNumber &&\n                _this.weekNumberEl.current &&\n                _this.weekNumberEl.current.focus({ preventScroll: true });\n        };\n        return _this;\n    }\n    Object.defineProperty(WeekNumber, \"defaultProps\", {\n        get: function () {\n            return {\n                ariaLabelPrefix: \"week \",\n            };\n        },\n        enumerable: false,\n        configurable: true\n    });\n    WeekNumber.prototype.componentDidMount = function () {\n        this.handleFocusWeekNumber();\n    };\n    WeekNumber.prototype.componentDidUpdate = function (prevProps) {\n        this.handleFocusWeekNumber(prevProps);\n    };\n    WeekNumber.prototype.render = function () {\n        var _a = this.props, weekNumber = _a.weekNumber, isWeekDisabled = _a.isWeekDisabled, _b = _a.ariaLabelPrefix, ariaLabelPrefix = _b === void 0 ? WeekNumber.defaultProps.ariaLabelPrefix : _b, onClick = _a.onClick;\n        var weekNumberClasses = {\n            \"react-datepicker__week-number\": true,\n            \"react-datepicker__week-number--clickable\": !!onClick && !isWeekDisabled,\n            \"react-datepicker__week-number--selected\": !!onClick && isSameDay(this.props.date, this.props.selected),\n        };\n        return (react__WEBPACK_IMPORTED_MODULE_1___default().createElement(\"div\", { ref: this.weekNumberEl, className: (0,clsx__WEBPACK_IMPORTED_MODULE_0__.clsx)(weekNumberClasses), \"aria-label\": \"\".concat(ariaLabelPrefix, \" \").concat(this.props.weekNumber), onClick: this.handleClick, onKeyDown: this.handleOnKeyDown, tabIndex: this.getTabIndex(), role: \"gridcell\" }, weekNumber));\n    };\n    return WeekNumber;\n}(react__WEBPACK_IMPORTED_MODULE_1__.Component));\n\nvar Week = /** @class */ (function (_super) {\n    __extends(Week, _super);\n    function Week() {\n        var _this = _super !== null && _super.apply(this, arguments) || this;\n        _this.isDisabled = function (day) {\n            return isDayDisabled(day, {\n                minDate: _this.props.minDate,\n                maxDate: _this.props.maxDate,\n                excludeDates: _this.props.excludeDates,\n                excludeDateIntervals: _this.props.excludeDateIntervals,\n                includeDateIntervals: _this.props.includeDateIntervals,\n                includeDates: _this.props.includeDates,\n                filterDate: _this.props.filterDate,\n            });\n        };\n        _this.handleDayClick = function (day, event) {\n            if (_this.props.onDayClick) {\n                _this.props.onDayClick(day, event);\n            }\n        };\n        _this.handleDayMouseEnter = function (day) {\n            if (_this.props.onDayMouseEnter) {\n                _this.props.onDayMouseEnter(day);\n            }\n        };\n        _this.handleWeekClick = function (day, weekNumber, event) {\n            var _a, _b, _c;\n            var enabledWeekDay = new Date(day);\n            for (var i = 0; i < 7; i++) {\n                var processingDay = new Date(day);\n                processingDay.setDate(processingDay.getDate() + i);\n                var isEnabled = !_this.isDisabled(processingDay);\n                if (isEnabled) {\n                    enabledWeekDay = processingDay;\n                    break;\n                }\n            }\n            if (typeof _this.props.onWeekSelect === \"function\") {\n                _this.props.onWeekSelect(enabledWeekDay, weekNumber, event);\n            }\n            if (_this.props.showWeekPicker) {\n                _this.handleDayClick(enabledWeekDay, event);\n            }\n            if ((_a = _this.props.shouldCloseOnSelect) !== null && _a !== void 0 ? _a : Week.defaultProps.shouldCloseOnSelect) {\n                (_c = (_b = _this.props).setOpen) === null || _c === void 0 ? void 0 : _c.call(_b, false);\n            }\n        };\n        _this.formatWeekNumber = function (date) {\n            if (_this.props.formatWeekNumber) {\n                return _this.props.formatWeekNumber(date);\n            }\n            return getWeek(date);\n        };\n        _this.isWeekDisabled = function () {\n            var startOfWeek = _this.startOfWeek();\n            var endOfWeek = (0,date_fns__WEBPACK_IMPORTED_MODULE_55__.addDays)(startOfWeek, 6);\n            var processingDate = new Date(startOfWeek);\n            while (processingDate <= endOfWeek) {\n                if (!_this.isDisabled(processingDate))\n                    return false;\n                processingDate = (0,date_fns__WEBPACK_IMPORTED_MODULE_55__.addDays)(processingDate, 1);\n            }\n            return true;\n        };\n        _this.renderDays = function () {\n            var startOfWeek = _this.startOfWeek();\n            var days = [];\n            var weekNumber = _this.formatWeekNumber(startOfWeek);\n            if (_this.props.showWeekNumber) {\n                var onClickAction = _this.props.onWeekSelect || _this.props.showWeekPicker\n                    ? _this.handleWeekClick.bind(_this, startOfWeek, weekNumber)\n                    : undefined;\n                days.push(react__WEBPACK_IMPORTED_MODULE_1___default().createElement(WeekNumber, _assign({ key: \"W\" }, Week.defaultProps, _this.props, { weekNumber: weekNumber, isWeekDisabled: _this.isWeekDisabled(), date: startOfWeek, onClick: onClickAction })));\n            }\n            return days.concat([0, 1, 2, 3, 4, 5, 6].map(function (offset) {\n                var day = (0,date_fns__WEBPACK_IMPORTED_MODULE_55__.addDays)(startOfWeek, offset);\n                return (react__WEBPACK_IMPORTED_MODULE_1___default().createElement(Day, _assign({}, Week.defaultProps, _this.props, { ariaLabelPrefixWhenEnabled: _this.props.chooseDayAriaLabelPrefix, ariaLabelPrefixWhenDisabled: _this.props.disabledDayAriaLabelPrefix, key: day.valueOf(), day: day, onClick: _this.handleDayClick.bind(_this, day), onMouseEnter: _this.handleDayMouseEnter.bind(_this, day) })));\n            }));\n        };\n        _this.startOfWeek = function () {\n            return getStartOfWeek(_this.props.day, _this.props.locale, _this.props.calendarStartDay);\n        };\n        _this.isKeyboardSelected = function () {\n            return !_this.props.disabledKeyboardNavigation &&\n                !isSameDay(_this.startOfWeek(), _this.props.selected) &&\n                isSameDay(_this.startOfWeek(), _this.props.preSelection);\n        };\n        return _this;\n    }\n    Object.defineProperty(Week, \"defaultProps\", {\n        get: function () {\n            return {\n                shouldCloseOnSelect: true,\n            };\n        },\n        enumerable: false,\n        configurable: true\n    });\n    Week.prototype.render = function () {\n        var weekNumberClasses = {\n            \"react-datepicker__week\": true,\n            \"react-datepicker__week--selected\": isSameDay(this.startOfWeek(), this.props.selected),\n            \"react-datepicker__week--keyboard-selected\": this.isKeyboardSelected(),\n        };\n        var customWeekClassName = this.props.weekClassName\n            ? this.props.weekClassName(this.startOfWeek())\n            : undefined;\n        return (react__WEBPACK_IMPORTED_MODULE_1___default().createElement(\"div\", { className: (0,clsx__WEBPACK_IMPORTED_MODULE_0__.clsx)(weekNumberClasses, customWeekClassName), role: \"row\" }, this.renderDays()));\n    };\n    return Week;\n}(react__WEBPACK_IMPORTED_MODULE_1__.Component));\n\nvar _a;\nvar FIXED_HEIGHT_STANDARD_WEEK_COUNT = 6;\nvar MONTH_COLUMNS_LAYOUT = {\n    TWO_COLUMNS: \"two_columns\",\n    THREE_COLUMNS: \"three_columns\",\n    FOUR_COLUMNS: \"four_columns\",\n};\nvar MONTH_COLUMNS = (_a = {},\n    _a[MONTH_COLUMNS_LAYOUT.TWO_COLUMNS] = {\n        grid: [\n            [0, 1],\n            [2, 3],\n            [4, 5],\n            [6, 7],\n            [8, 9],\n            [10, 11],\n        ],\n        verticalNavigationOffset: 2,\n    },\n    _a[MONTH_COLUMNS_LAYOUT.THREE_COLUMNS] = {\n        grid: [\n            [0, 1, 2],\n            [3, 4, 5],\n            [6, 7, 8],\n            [9, 10, 11],\n        ],\n        verticalNavigationOffset: 3,\n    },\n    _a[MONTH_COLUMNS_LAYOUT.FOUR_COLUMNS] = {\n        grid: [\n            [0, 1, 2, 3],\n            [4, 5, 6, 7],\n            [8, 9, 10, 11],\n        ],\n        verticalNavigationOffset: 4,\n    },\n    _a);\nvar MONTH_NAVIGATION_HORIZONTAL_OFFSET = 1;\nfunction getMonthColumnsLayout(showFourColumnMonthYearPicker, showTwoColumnMonthYearPicker) {\n    if (showFourColumnMonthYearPicker) {\n        return MONTH_COLUMNS_LAYOUT.FOUR_COLUMNS;\n    }\n    if (showTwoColumnMonthYearPicker) {\n        return MONTH_COLUMNS_LAYOUT.TWO_COLUMNS;\n    }\n    return MONTH_COLUMNS_LAYOUT.THREE_COLUMNS;\n}\n/**\n * `Month` is a React component that represents a month in a calendar.\n * It accepts a `MonthProps` object as props which provides various configurations and event handlers.\n *\n * @prop dayClassName - Function to determine the class name for a day.\n * @prop monthClassName - Function to determine the class name for a month.\n * @prop filterDate - Function to filter dates.\n * @prop formatWeekNumber - Function to format the week number.\n * @prop onDayClick - Function to handle day click events.\n * @prop onDayMouseEnter - Function to handle mouse enter events on a day.\n * @prop onMouseLeave - Function to handle mouse leave events.\n * @prop onWeekSelect - Function to handle week selection.\n * @prop setPreSelection - Function to set pre-selection.\n * @prop setOpen - Function to set open state.\n * @prop renderDayContents - Function to render day contents.\n * @prop renderMonthContent - Function to render month content.\n * @prop renderQuarterContent - Function to render quarter content.\n * @prop handleOnKeyDown - Function to handle key down events.\n * @prop handleOnMonthKeyDown - Function to handle key down events on a month.\n * @prop ariaLabelPrefix - Aria label prefix.\n * @prop chooseDayAriaLabelPrefix - Aria label prefix for choosing a day.\n * @prop disabledDayAriaLabelPrefix - Aria label prefix for disabled day.\n * @prop disabledKeyboardNavigation - Flag to disable keyboard navigation.\n * @prop day - The day.\n * @prop endDate - The end date.\n * @prop orderInDisplay - The order in display.\n * @prop excludeDates - Dates to exclude.\n * @prop excludeDateIntervals - Date intervals to exclude.\n * @prop fixedHeight - Flag to set fixed height.\n * @prop highlightDates - Dates to highlight.\n * @prop holidays - Holidays.\n * @prop includeDates - Dates to include.\n * @prop includeDateIntervals - Date intervals to include.\n * @prop inline - Flag to set inline.\n * @prop shouldFocusDayInline - Flag to set focus on day inline.\n * @prop locale - The locale.\n * @prop maxDate - The maximum date.\n * @prop minDate - The minimum date.\n * @prop usePointerEvent - Flag to use pointer event.\n * @prop peekNextMonth - Flag to peek next month.\n * @prop preSelection - The pre-selection.\n * @prop selected - The selected date.\n * @prop selectingDate - The selecting date.\n * @prop calendarStartDay - The calendar start day.\n * @prop selectsEnd - Flag to select end.\n * @prop selectsStart - Flag to select start.\n * @prop selectsRange - Flag to select range.\n * @prop selectsDisabledDaysInRange - Flag to select disabled days in range.\n * @prop selectsMultiple - Flag to select multiple.\n * @prop selectedDates - The selected dates.\n * @prop showWeekNumbers - Flag to show week numbers.\n * @prop startDate - The start date.\n * @prop shouldCloseOnSelect - Flag to close on select.\n * @prop showMonthYearPicker - Flag to show month year picker.\n * @prop showFullMonthYearPicker - Flag to show full month year picker.\n * @prop showTwoColumnMonthYearPicker - Flag to show two column month year picker.\n * @prop showFourColumnMonthYearPicker - Flag to show four column month year picker.\n * @prop showQuarterYearPicker - Flag to show quarter year picker.\n * @prop showWeekPicker - Flag to show week picker.\n * @prop isInputFocused - Flag to set input focus.\n * @prop weekAriaLabelPrefix - Aria label prefix for week.\n * @prop containerRef - The container reference.\n * @prop monthShowsDuplicateDaysEnd - Flag to show duplicate days at the end of the month.\n * @prop monthShowsDuplicateDaysStart - Flag to show duplicate days at the start of the month.\n *\n * @example\n * ```tsx\n * function App() {\n *  const handleDayClick = (date) => {\n *     console.log('Day clicked: ', date);\n *   };\n *\n *   const handleDayMouseEnter = (date) => {\n *     console.log('Mouse entered on day: ', date);\n *   };\n *\n *   return (\n *     <div>\n *       <Month\n *         day={new Date()}\n *         endDate={new Date()}\n *         onDayClick={handleDayClick}\n *         onDayMouseEnter={handleDayMouseEnter}\n *         disabledKeyboardNavigation={false}\n *         showWeekNumbers={true}\n *         showMonthYearPicker={false}\n *       />\n *     </div>\n *   );\n * }\n * ```\n */\nvar Month = /** @class */ (function (_super) {\n    __extends(Month, _super);\n    function Month() {\n        var _this = _super !== null && _super.apply(this, arguments) || this;\n        _this.MONTH_REFS = __spreadArray([], Array(12), true).map(function () { return (0,react__WEBPACK_IMPORTED_MODULE_1__.createRef)(); });\n        _this.QUARTER_REFS = __spreadArray([], Array(4), true).map(function () { return (0,react__WEBPACK_IMPORTED_MODULE_1__.createRef)(); });\n        _this.isDisabled = function (day) {\n            // Almost all props previously were passed as this.props w/o proper typing with prop-types\n            // after the migration to TS i made it explicit\n            return isDayDisabled(day, {\n                minDate: _this.props.minDate,\n                maxDate: _this.props.maxDate,\n                excludeDates: _this.props.excludeDates,\n                excludeDateIntervals: _this.props.excludeDateIntervals,\n                includeDateIntervals: _this.props.includeDateIntervals,\n                includeDates: _this.props.includeDates,\n                filterDate: _this.props.filterDate,\n                disabled: _this.props.disabled,\n            });\n        };\n        _this.isExcluded = function (day) {\n            // Almost all props previously were passed as this.props w/o proper typing with prop-types\n            // after the migration to TS i made it explicit\n            return isDayExcluded(day, {\n                excludeDates: _this.props.excludeDates,\n                excludeDateIntervals: _this.props.excludeDateIntervals,\n            });\n        };\n        _this.handleDayClick = function (day, event) {\n            var _a, _b;\n            (_b = (_a = _this.props).onDayClick) === null || _b === void 0 ? void 0 : _b.call(_a, day, event, _this.props.orderInDisplay);\n        };\n        _this.handleDayMouseEnter = function (day) {\n            var _a, _b;\n            (_b = (_a = _this.props).onDayMouseEnter) === null || _b === void 0 ? void 0 : _b.call(_a, day);\n        };\n        _this.handleMouseLeave = function () {\n            var _a, _b;\n            (_b = (_a = _this.props).onMouseLeave) === null || _b === void 0 ? void 0 : _b.call(_a);\n        };\n        _this.isRangeStartMonth = function (m) {\n            var _a = _this.props, day = _a.day, startDate = _a.startDate, endDate = _a.endDate;\n            if (!startDate || !endDate) {\n                return false;\n            }\n            return isSameMonth((0,date_fns__WEBPACK_IMPORTED_MODULE_27__.setMonth)(day, m), startDate);\n        };\n        _this.isRangeStartQuarter = function (q) {\n            var _a = _this.props, day = _a.day, startDate = _a.startDate, endDate = _a.endDate;\n            if (!startDate || !endDate) {\n                return false;\n            }\n            return isSameQuarter((0,date_fns__WEBPACK_IMPORTED_MODULE_28__.setQuarter)(day, q), startDate);\n        };\n        _this.isRangeEndMonth = function (m) {\n            var _a = _this.props, day = _a.day, startDate = _a.startDate, endDate = _a.endDate;\n            if (!startDate || !endDate) {\n                return false;\n            }\n            return isSameMonth((0,date_fns__WEBPACK_IMPORTED_MODULE_27__.setMonth)(day, m), endDate);\n        };\n        _this.isRangeEndQuarter = function (q) {\n            var _a = _this.props, day = _a.day, startDate = _a.startDate, endDate = _a.endDate;\n            if (!startDate || !endDate) {\n                return false;\n            }\n            return isSameQuarter((0,date_fns__WEBPACK_IMPORTED_MODULE_28__.setQuarter)(day, q), endDate);\n        };\n        _this.isInSelectingRangeMonth = function (m) {\n            var _a;\n            var _b = _this.props, day = _b.day, selectsStart = _b.selectsStart, selectsEnd = _b.selectsEnd, selectsRange = _b.selectsRange, startDate = _b.startDate, endDate = _b.endDate;\n            var selectingDate = (_a = _this.props.selectingDate) !== null && _a !== void 0 ? _a : _this.props.preSelection;\n            if (!(selectsStart || selectsEnd || selectsRange) || !selectingDate) {\n                return false;\n            }\n            if (selectsStart && endDate) {\n                return isMonthInRange(selectingDate, endDate, m, day);\n            }\n            if (selectsEnd && startDate) {\n                return isMonthInRange(startDate, selectingDate, m, day);\n            }\n            if (selectsRange && startDate && !endDate) {\n                return isMonthInRange(startDate, selectingDate, m, day);\n            }\n            return false;\n        };\n        _this.isSelectingMonthRangeStart = function (m) {\n            var _a;\n            if (!_this.isInSelectingRangeMonth(m)) {\n                return false;\n            }\n            var _b = _this.props, day = _b.day, startDate = _b.startDate, selectsStart = _b.selectsStart;\n            var _month = (0,date_fns__WEBPACK_IMPORTED_MODULE_27__.setMonth)(day, m);\n            var selectingDate = (_a = _this.props.selectingDate) !== null && _a !== void 0 ? _a : _this.props.preSelection;\n            if (selectsStart) {\n                return isSameMonth(_month, selectingDate);\n            }\n            else {\n                return isSameMonth(_month, startDate);\n            }\n        };\n        _this.isSelectingMonthRangeEnd = function (m) {\n            var _a;\n            if (!_this.isInSelectingRangeMonth(m)) {\n                return false;\n            }\n            var _b = _this.props, day = _b.day, endDate = _b.endDate, selectsEnd = _b.selectsEnd, selectsRange = _b.selectsRange;\n            var _month = (0,date_fns__WEBPACK_IMPORTED_MODULE_27__.setMonth)(day, m);\n            var selectingDate = (_a = _this.props.selectingDate) !== null && _a !== void 0 ? _a : _this.props.preSelection;\n            if (selectsEnd || selectsRange) {\n                return isSameMonth(_month, selectingDate);\n            }\n            else {\n                return isSameMonth(_month, endDate);\n            }\n        };\n        _this.isInSelectingRangeQuarter = function (q) {\n            var _a;\n            var _b = _this.props, day = _b.day, selectsStart = _b.selectsStart, selectsEnd = _b.selectsEnd, selectsRange = _b.selectsRange, startDate = _b.startDate, endDate = _b.endDate;\n            var selectingDate = (_a = _this.props.selectingDate) !== null && _a !== void 0 ? _a : _this.props.preSelection;\n            if (!(selectsStart || selectsEnd || selectsRange) || !selectingDate) {\n                return false;\n            }\n            if (selectsStart && endDate) {\n                return isQuarterInRange(selectingDate, endDate, q, day);\n            }\n            if (selectsEnd && startDate) {\n                return isQuarterInRange(startDate, selectingDate, q, day);\n            }\n            if (selectsRange && startDate && !endDate) {\n                return isQuarterInRange(startDate, selectingDate, q, day);\n            }\n            return false;\n        };\n        _this.isWeekInMonth = function (startOfWeek) {\n            var day = _this.props.day;\n            var endOfWeek = (0,date_fns__WEBPACK_IMPORTED_MODULE_55__.addDays)(startOfWeek, 6);\n            return isSameMonth(startOfWeek, day) || isSameMonth(endOfWeek, day);\n        };\n        _this.isCurrentMonth = function (day, m) {\n            return (0,date_fns__WEBPACK_IMPORTED_MODULE_29__.getYear)(day) === (0,date_fns__WEBPACK_IMPORTED_MODULE_29__.getYear)(newDate()) && m === (0,date_fns__WEBPACK_IMPORTED_MODULE_30__.getMonth)(newDate());\n        };\n        _this.isCurrentQuarter = function (day, q) {\n            return (0,date_fns__WEBPACK_IMPORTED_MODULE_29__.getYear)(day) === (0,date_fns__WEBPACK_IMPORTED_MODULE_29__.getYear)(newDate()) && q === (0,date_fns__WEBPACK_IMPORTED_MODULE_32__.getQuarter)(newDate());\n        };\n        _this.isSelectedMonth = function (day, m, selected) {\n            return (0,date_fns__WEBPACK_IMPORTED_MODULE_30__.getMonth)(selected) === m && (0,date_fns__WEBPACK_IMPORTED_MODULE_29__.getYear)(day) === (0,date_fns__WEBPACK_IMPORTED_MODULE_29__.getYear)(selected);\n        };\n        _this.isSelectMonthInList = function (day, m, selectedDates) {\n            return selectedDates.some(function (selectedDate) {\n                return _this.isSelectedMonth(day, m, selectedDate);\n            });\n        };\n        _this.isSelectedQuarter = function (day, q, selected) {\n            return (0,date_fns__WEBPACK_IMPORTED_MODULE_32__.getQuarter)(selected) === q && (0,date_fns__WEBPACK_IMPORTED_MODULE_29__.getYear)(day) === (0,date_fns__WEBPACK_IMPORTED_MODULE_29__.getYear)(selected);\n        };\n        _this.isSelectQuarterInList = function (day, q, selectedDates) {\n            return selectedDates.some(function (selectedDate) {\n                return _this.isSelectedQuarter(day, q, selectedDate);\n            });\n        };\n        _this.isMonthSelected = function () {\n            var _a = _this.props, day = _a.day, selected = _a.selected, selectedDates = _a.selectedDates, selectsMultiple = _a.selectsMultiple;\n            var monthIdx = (0,date_fns__WEBPACK_IMPORTED_MODULE_30__.getMonth)(day);\n            if (selectsMultiple) {\n                return selectedDates === null || selectedDates === void 0 ? void 0 : selectedDates.some(function (date) {\n                    return _this.isSelectedMonth(day, monthIdx, date);\n                });\n            }\n            return !!selected && _this.isSelectedMonth(day, monthIdx, selected);\n        };\n        _this.isQuarterSelected = function () {\n            var _a = _this.props, day = _a.day, selected = _a.selected, selectedDates = _a.selectedDates, selectsMultiple = _a.selectsMultiple;\n            var quarterIdx = (0,date_fns__WEBPACK_IMPORTED_MODULE_32__.getQuarter)(day);\n            if (selectsMultiple) {\n                return selectedDates === null || selectedDates === void 0 ? void 0 : selectedDates.some(function (selectedDate) {\n                    return _this.isSelectedQuarter(day, quarterIdx, selectedDate);\n                });\n            }\n            return !!selected && _this.isSelectedQuarter(day, quarterIdx, selected);\n        };\n        _this.renderWeeks = function () {\n            // Return empty array if day is invalid\n            if (!isValid(_this.props.day)) {\n                return [];\n            }\n            var weeks = [];\n            var isFixedHeight = _this.props.fixedHeight;\n            var i = 0;\n            var breakAfterNextPush = false;\n            var currentWeekStart = getStartOfWeek(getStartOfMonth(_this.props.day), _this.props.locale, _this.props.calendarStartDay);\n            var isPreSelected = function (preSelection) {\n                return _this.props.showWeekPicker\n                    ? getStartOfWeek(preSelection, _this.props.locale, _this.props.calendarStartDay)\n                    : _this.props.preSelection;\n            };\n            var isSelected = function (selected) {\n                return _this.props.showWeekPicker\n                    ? getStartOfWeek(selected, _this.props.locale, _this.props.calendarStartDay)\n                    : _this.props.selected;\n            };\n            var selected = _this.props.selected\n                ? isSelected(_this.props.selected)\n                : undefined;\n            var preSelection = _this.props.preSelection\n                ? isPreSelected(_this.props.preSelection)\n                : undefined;\n            while (true) {\n                weeks.push(react__WEBPACK_IMPORTED_MODULE_1___default().createElement(Week, _assign({}, _this.props, { ariaLabelPrefix: _this.props.weekAriaLabelPrefix, key: i, day: currentWeekStart, month: (0,date_fns__WEBPACK_IMPORTED_MODULE_30__.getMonth)(_this.props.day), onDayClick: _this.handleDayClick, onDayMouseEnter: _this.handleDayMouseEnter, selected: selected, preSelection: preSelection, showWeekNumber: _this.props.showWeekNumbers })));\n                if (breakAfterNextPush)\n                    break;\n                i++;\n                currentWeekStart = (0,date_fns__WEBPACK_IMPORTED_MODULE_56__.addWeeks)(currentWeekStart, 1);\n                // If one of these conditions is true, we will either break on this week\n                // or break on the next week\n                var isFixedAndFinalWeek = isFixedHeight && i >= FIXED_HEIGHT_STANDARD_WEEK_COUNT;\n                var isNonFixedAndOutOfMonth = !isFixedHeight && !_this.isWeekInMonth(currentWeekStart);\n                if (isFixedAndFinalWeek || isNonFixedAndOutOfMonth) {\n                    if (_this.props.peekNextMonth) {\n                        breakAfterNextPush = true;\n                    }\n                    else {\n                        break;\n                    }\n                }\n            }\n            return weeks;\n        };\n        _this.onMonthClick = function (event, m) {\n            var _a = _this.isMonthDisabledForLabelDate(m), isDisabled = _a.isDisabled, labelDate = _a.labelDate;\n            if (isDisabled) {\n                return;\n            }\n            _this.handleDayClick(getStartOfMonth(labelDate), event);\n        };\n        _this.onMonthMouseEnter = function (m) {\n            var _a = _this.isMonthDisabledForLabelDate(m), isDisabled = _a.isDisabled, labelDate = _a.labelDate;\n            if (isDisabled) {\n                return;\n            }\n            _this.handleDayMouseEnter(getStartOfMonth(labelDate));\n        };\n        _this.handleMonthNavigation = function (newMonth, newDate) {\n            var _a, _b, _c, _d;\n            (_b = (_a = _this.props).setPreSelection) === null || _b === void 0 ? void 0 : _b.call(_a, newDate);\n            (_d = (_c = _this.MONTH_REFS[newMonth]) === null || _c === void 0 ? void 0 : _c.current) === null || _d === void 0 ? void 0 : _d.focus();\n        };\n        _this.handleKeyboardNavigation = function (event, eventKey, month) {\n            var _a;\n            var _b = _this.props, selected = _b.selected, preSelection = _b.preSelection, setPreSelection = _b.setPreSelection, minDate = _b.minDate, maxDate = _b.maxDate, showFourColumnMonthYearPicker = _b.showFourColumnMonthYearPicker, showTwoColumnMonthYearPicker = _b.showTwoColumnMonthYearPicker;\n            if (!preSelection)\n                return;\n            var monthColumnsLayout = getMonthColumnsLayout(showFourColumnMonthYearPicker, showTwoColumnMonthYearPicker);\n            var verticalOffset = _this.getVerticalOffset(monthColumnsLayout);\n            var monthsGrid = (_a = MONTH_COLUMNS[monthColumnsLayout]) === null || _a === void 0 ? void 0 : _a.grid;\n            var calculateNewDateAndMonth = function (eventKey, date, month) {\n                var _a, _b;\n                var newCalculatedDate = date;\n                var newCalculatedMonth = month;\n                switch (eventKey) {\n                    case KeyType.ArrowRight:\n                        newCalculatedDate = (0,date_fns__WEBPACK_IMPORTED_MODULE_39__.addMonths)(date, MONTH_NAVIGATION_HORIZONTAL_OFFSET);\n                        newCalculatedMonth =\n                            month === 11 ? 0 : month + MONTH_NAVIGATION_HORIZONTAL_OFFSET;\n                        break;\n                    case KeyType.ArrowLeft:\n                        newCalculatedDate = (0,date_fns__WEBPACK_IMPORTED_MODULE_37__.subMonths)(date, MONTH_NAVIGATION_HORIZONTAL_OFFSET);\n                        newCalculatedMonth =\n                            month === 0 ? 11 : month - MONTH_NAVIGATION_HORIZONTAL_OFFSET;\n                        break;\n                    case KeyType.ArrowUp:\n                        newCalculatedDate = (0,date_fns__WEBPACK_IMPORTED_MODULE_37__.subMonths)(date, verticalOffset);\n                        newCalculatedMonth = ((_a = monthsGrid === null || monthsGrid === void 0 ? void 0 : monthsGrid[0]) === null || _a === void 0 ? void 0 : _a.includes(month))\n                            ? month + 12 - verticalOffset\n                            : month - verticalOffset;\n                        break;\n                    case KeyType.ArrowDown:\n                        newCalculatedDate = (0,date_fns__WEBPACK_IMPORTED_MODULE_39__.addMonths)(date, verticalOffset);\n                        newCalculatedMonth = ((_b = monthsGrid === null || monthsGrid === void 0 ? void 0 : monthsGrid[monthsGrid.length - 1]) === null || _b === void 0 ? void 0 : _b.includes(month))\n                            ? month - 12 + verticalOffset\n                            : month + verticalOffset;\n                        break;\n                }\n                return { newCalculatedDate: newCalculatedDate, newCalculatedMonth: newCalculatedMonth };\n            };\n            var getNewDateAndMonth = function (eventKey, selectedDate, month) {\n                var MAX_ITERATIONS = 40;\n                var eventKeyCopy = eventKey;\n                var validDateFound = false;\n                var iterations = 0;\n                var _a = calculateNewDateAndMonth(eventKeyCopy, selectedDate, month), newCalculatedDate = _a.newCalculatedDate, newCalculatedMonth = _a.newCalculatedMonth;\n                while (!validDateFound) {\n                    if (iterations >= MAX_ITERATIONS) {\n                        newCalculatedDate = selectedDate;\n                        newCalculatedMonth = month;\n                        break;\n                    }\n                    // if minDate exists and the new month is before the minimum month, it will try to find the next available month after\n                    if (minDate && newCalculatedDate < minDate) {\n                        eventKeyCopy = KeyType.ArrowRight;\n                        var obj = calculateNewDateAndMonth(eventKeyCopy, newCalculatedDate, newCalculatedMonth);\n                        newCalculatedDate = obj.newCalculatedDate;\n                        newCalculatedMonth = obj.newCalculatedMonth;\n                    }\n                    // if maxDate exists and the new month is after the maximum month, it will try to find the next available month before\n                    if (maxDate && newCalculatedDate > maxDate) {\n                        eventKeyCopy = KeyType.ArrowLeft;\n                        var obj = calculateNewDateAndMonth(eventKeyCopy, newCalculatedDate, newCalculatedMonth);\n                        newCalculatedDate = obj.newCalculatedDate;\n                        newCalculatedMonth = obj.newCalculatedMonth;\n                    }\n                    if (isMonthYearDisabled(newCalculatedDate, _this.props)) {\n                        var obj = calculateNewDateAndMonth(eventKeyCopy, newCalculatedDate, newCalculatedMonth);\n                        newCalculatedDate = obj.newCalculatedDate;\n                        newCalculatedMonth = obj.newCalculatedMonth;\n                    }\n                    else {\n                        validDateFound = true;\n                    }\n                    iterations++;\n                }\n                return { newCalculatedDate: newCalculatedDate, newCalculatedMonth: newCalculatedMonth };\n            };\n            if (eventKey === KeyType.Enter) {\n                if (!_this.isMonthDisabled(month)) {\n                    _this.onMonthClick(event, month);\n                    setPreSelection === null || setPreSelection === void 0 ? void 0 : setPreSelection(selected);\n                }\n                return;\n            }\n            var _c = getNewDateAndMonth(eventKey, preSelection, month), newCalculatedDate = _c.newCalculatedDate, newCalculatedMonth = _c.newCalculatedMonth;\n            switch (eventKey) {\n                case KeyType.ArrowRight:\n                case KeyType.ArrowLeft:\n                case KeyType.ArrowUp:\n                case KeyType.ArrowDown:\n                    _this.handleMonthNavigation(newCalculatedMonth, newCalculatedDate);\n                    break;\n            }\n        };\n        _this.getVerticalOffset = function (monthColumnsLayout) {\n            var _a, _b;\n            return (_b = (_a = MONTH_COLUMNS[monthColumnsLayout]) === null || _a === void 0 ? void 0 : _a.verticalNavigationOffset) !== null && _b !== void 0 ? _b : 0;\n        };\n        _this.onMonthKeyDown = function (event, month) {\n            var _a = _this.props, disabledKeyboardNavigation = _a.disabledKeyboardNavigation, handleOnMonthKeyDown = _a.handleOnMonthKeyDown;\n            var eventKey = event.key;\n            if (eventKey !== KeyType.Tab) {\n                // preventDefault on tab event blocks focus change\n                event.preventDefault();\n            }\n            if (!disabledKeyboardNavigation) {\n                _this.handleKeyboardNavigation(event, eventKey, month);\n            }\n            handleOnMonthKeyDown && handleOnMonthKeyDown(event);\n        };\n        _this.onQuarterClick = function (event, q) {\n            var labelDate = (0,date_fns__WEBPACK_IMPORTED_MODULE_28__.setQuarter)(_this.props.day, q);\n            if (isQuarterDisabled(labelDate, _this.props)) {\n                return;\n            }\n            _this.handleDayClick(getStartOfQuarter(labelDate), event);\n        };\n        _this.onQuarterMouseEnter = function (q) {\n            var labelDate = (0,date_fns__WEBPACK_IMPORTED_MODULE_28__.setQuarter)(_this.props.day, q);\n            if (isQuarterDisabled(labelDate, _this.props)) {\n                return;\n            }\n            _this.handleDayMouseEnter(getStartOfQuarter(labelDate));\n        };\n        _this.handleQuarterNavigation = function (newQuarter, newDate) {\n            var _a, _b, _c, _d;\n            if (_this.isDisabled(newDate) || _this.isExcluded(newDate)) {\n                return;\n            }\n            (_b = (_a = _this.props).setPreSelection) === null || _b === void 0 ? void 0 : _b.call(_a, newDate);\n            (_d = (_c = _this.QUARTER_REFS[newQuarter - 1]) === null || _c === void 0 ? void 0 : _c.current) === null || _d === void 0 ? void 0 : _d.focus();\n        };\n        _this.onQuarterKeyDown = function (event, quarter) {\n            var _a, _b;\n            var eventKey = event.key;\n            if (!_this.props.disabledKeyboardNavigation) {\n                switch (eventKey) {\n                    case KeyType.Enter:\n                        _this.onQuarterClick(event, quarter);\n                        (_b = (_a = _this.props).setPreSelection) === null || _b === void 0 ? void 0 : _b.call(_a, _this.props.selected);\n                        break;\n                    case KeyType.ArrowRight:\n                        if (!_this.props.preSelection) {\n                            break;\n                        }\n                        _this.handleQuarterNavigation(quarter === 4 ? 1 : quarter + 1, (0,date_fns__WEBPACK_IMPORTED_MODULE_42__.addQuarters)(_this.props.preSelection, 1));\n                        break;\n                    case KeyType.ArrowLeft:\n                        if (!_this.props.preSelection) {\n                            break;\n                        }\n                        _this.handleQuarterNavigation(quarter === 1 ? 4 : quarter - 1, (0,date_fns__WEBPACK_IMPORTED_MODULE_40__.subQuarters)(_this.props.preSelection, 1));\n                        break;\n                }\n            }\n        };\n        _this.isMonthDisabledForLabelDate = function (month) {\n            var _a;\n            var _b = _this.props, day = _b.day, disabled = _b.disabled, minDate = _b.minDate, maxDate = _b.maxDate, excludeDates = _b.excludeDates, includeDates = _b.includeDates;\n            var labelDate = (0,date_fns__WEBPACK_IMPORTED_MODULE_27__.setMonth)(day, month);\n            if (disabled) {\n                return {\n                    isDisabled: true,\n                    labelDate: (0,date_fns__WEBPACK_IMPORTED_MODULE_27__.setMonth)(day, month),\n                };\n            }\n            return {\n                isDisabled: (_a = ((minDate || maxDate || excludeDates || includeDates) &&\n                    isMonthDisabled(labelDate, _this.props))) !== null && _a !== void 0 ? _a : false,\n                labelDate: labelDate,\n            };\n        };\n        _this.isMonthDisabled = function (month) {\n            var isDisabled = _this.isMonthDisabledForLabelDate(month).isDisabled;\n            return isDisabled;\n        };\n        _this.getMonthClassNames = function (m) {\n            var _a = _this.props, day = _a.day, startDate = _a.startDate, endDate = _a.endDate, preSelection = _a.preSelection, monthClassName = _a.monthClassName;\n            var _monthClassName = monthClassName\n                ? monthClassName((0,date_fns__WEBPACK_IMPORTED_MODULE_27__.setMonth)(day, m))\n                : undefined;\n            var selection = _this.getSelection();\n            return (0,clsx__WEBPACK_IMPORTED_MODULE_0__.clsx)(\"react-datepicker__month-text\", \"react-datepicker__month-\".concat(m), _monthClassName, {\n                \"react-datepicker__month-text--disabled\": _this.isMonthDisabled(m),\n                \"react-datepicker__month-text--selected\": selection\n                    ? _this.isSelectMonthInList(day, m, selection)\n                    : undefined,\n                \"react-datepicker__month-text--keyboard-selected\": !_this.props.disabledKeyboardNavigation &&\n                    preSelection &&\n                    _this.isSelectedMonth(day, m, preSelection) &&\n                    !_this.isMonthSelected() &&\n                    !_this.isMonthDisabled(m),\n                \"react-datepicker__month-text--in-selecting-range\": _this.isInSelectingRangeMonth(m),\n                \"react-datepicker__month-text--in-range\": startDate && endDate\n                    ? isMonthInRange(startDate, endDate, m, day)\n                    : undefined,\n                \"react-datepicker__month-text--range-start\": _this.isRangeStartMonth(m),\n                \"react-datepicker__month-text--range-end\": _this.isRangeEndMonth(m),\n                \"react-datepicker__month-text--selecting-range-start\": _this.isSelectingMonthRangeStart(m),\n                \"react-datepicker__month-text--selecting-range-end\": _this.isSelectingMonthRangeEnd(m),\n                \"react-datepicker__month-text--today\": _this.isCurrentMonth(day, m),\n            });\n        };\n        _this.getTabIndex = function (m) {\n            if (_this.props.preSelection == null) {\n                return \"-1\";\n            }\n            var preSelectedMonth = (0,date_fns__WEBPACK_IMPORTED_MODULE_30__.getMonth)(_this.props.preSelection);\n            var isPreSelectedMonthDisabled = _this.isMonthDisabledForLabelDate(preSelectedMonth).isDisabled;\n            var tabIndex = m === preSelectedMonth &&\n                !(isPreSelectedMonthDisabled || _this.props.disabledKeyboardNavigation)\n                ? \"0\"\n                : \"-1\";\n            return tabIndex;\n        };\n        _this.getQuarterTabIndex = function (q) {\n            if (_this.props.preSelection == null) {\n                return \"-1\";\n            }\n            var preSelectedQuarter = (0,date_fns__WEBPACK_IMPORTED_MODULE_32__.getQuarter)(_this.props.preSelection);\n            var isCurrentQuarterDisabled = isQuarterDisabled(_this.props.day, _this.props);\n            var tabIndex = q === preSelectedQuarter &&\n                !(isCurrentQuarterDisabled || _this.props.disabledKeyboardNavigation)\n                ? \"0\"\n                : \"-1\";\n            return tabIndex;\n        };\n        _this.getAriaLabel = function (month) {\n            var _a = _this.props, _b = _a.chooseDayAriaLabelPrefix, chooseDayAriaLabelPrefix = _b === void 0 ? \"Choose\" : _b, _c = _a.disabledDayAriaLabelPrefix, disabledDayAriaLabelPrefix = _c === void 0 ? \"Not available\" : _c, day = _a.day, locale = _a.locale;\n            var labelDate = (0,date_fns__WEBPACK_IMPORTED_MODULE_27__.setMonth)(day, month);\n            var prefix = _this.isDisabled(labelDate) || _this.isExcluded(labelDate)\n                ? disabledDayAriaLabelPrefix\n                : chooseDayAriaLabelPrefix;\n            return \"\".concat(prefix, \" \").concat(formatDate(labelDate, \"MMMM yyyy\", locale));\n        };\n        _this.getQuarterClassNames = function (q) {\n            var _a = _this.props, day = _a.day, startDate = _a.startDate, endDate = _a.endDate, minDate = _a.minDate, maxDate = _a.maxDate, excludeDates = _a.excludeDates, includeDates = _a.includeDates, filterDate = _a.filterDate, preSelection = _a.preSelection, disabledKeyboardNavigation = _a.disabledKeyboardNavigation, disabled = _a.disabled;\n            var isDisabled = (minDate ||\n                maxDate ||\n                excludeDates ||\n                includeDates ||\n                filterDate ||\n                disabled) &&\n                isQuarterDisabled((0,date_fns__WEBPACK_IMPORTED_MODULE_28__.setQuarter)(day, q), _this.props);\n            var selection = _this.getSelection();\n            return (0,clsx__WEBPACK_IMPORTED_MODULE_0__.clsx)(\"react-datepicker__quarter-text\", \"react-datepicker__quarter-\".concat(q), {\n                \"react-datepicker__quarter-text--disabled\": isDisabled,\n                \"react-datepicker__quarter-text--selected\": selection\n                    ? _this.isSelectQuarterInList(day, q, selection)\n                    : undefined,\n                \"react-datepicker__quarter-text--keyboard-selected\": !disabledKeyboardNavigation &&\n                    preSelection &&\n                    _this.isSelectedQuarter(day, q, preSelection) &&\n                    !_this.isQuarterSelected() &&\n                    !isDisabled,\n                \"react-datepicker__quarter-text--in-selecting-range\": _this.isInSelectingRangeQuarter(q),\n                \"react-datepicker__quarter-text--in-range\": startDate && endDate\n                    ? isQuarterInRange(startDate, endDate, q, day)\n                    : undefined,\n                \"react-datepicker__quarter-text--range-start\": _this.isRangeStartQuarter(q),\n                \"react-datepicker__quarter-text--range-end\": _this.isRangeEndQuarter(q),\n                \"react-datepicker__quarter-text--today\": _this.isCurrentQuarter(day, q),\n            });\n        };\n        _this.getMonthContent = function (m) {\n            var _a = _this.props, showFullMonthYearPicker = _a.showFullMonthYearPicker, renderMonthContent = _a.renderMonthContent, locale = _a.locale, day = _a.day;\n            var shortMonthText = getMonthShortInLocale(m, locale);\n            var fullMonthText = getMonthInLocale(m, locale);\n            if (renderMonthContent) {\n                return renderMonthContent(m, shortMonthText, fullMonthText, day);\n            }\n            return showFullMonthYearPicker ? fullMonthText : shortMonthText;\n        };\n        _this.getQuarterContent = function (q) {\n            var _a;\n            var _b = _this.props, renderQuarterContent = _b.renderQuarterContent, locale = _b.locale;\n            var shortQuarter = getQuarterShortInLocale(q, locale);\n            return (_a = renderQuarterContent === null || renderQuarterContent === void 0 ? void 0 : renderQuarterContent(q, shortQuarter)) !== null && _a !== void 0 ? _a : shortQuarter;\n        };\n        _this.renderMonths = function () {\n            var _a;\n            var _b = _this.props, showTwoColumnMonthYearPicker = _b.showTwoColumnMonthYearPicker, showFourColumnMonthYearPicker = _b.showFourColumnMonthYearPicker, day = _b.day, selected = _b.selected;\n            var monthColumns = (_a = MONTH_COLUMNS[getMonthColumnsLayout(showFourColumnMonthYearPicker, showTwoColumnMonthYearPicker)]) === null || _a === void 0 ? void 0 : _a.grid;\n            return monthColumns === null || monthColumns === void 0 ? void 0 : monthColumns.map(function (month, i) { return (react__WEBPACK_IMPORTED_MODULE_1___default().createElement(\"div\", { className: \"react-datepicker__month-wrapper\", key: i }, month.map(function (m, j) { return (react__WEBPACK_IMPORTED_MODULE_1___default().createElement(\"div\", { ref: _this.MONTH_REFS[m], key: j, onClick: function (event) {\n                    _this.onMonthClick(event, m);\n                }, onKeyDown: function (event) {\n                    if (isSpaceKeyDown(event)) {\n                        event.preventDefault();\n                        event.key = KeyType.Enter;\n                    }\n                    _this.onMonthKeyDown(event, m);\n                }, onMouseEnter: !_this.props.usePointerEvent\n                    ? function () { return _this.onMonthMouseEnter(m); }\n                    : undefined, onPointerEnter: _this.props.usePointerEvent\n                    ? function () { return _this.onMonthMouseEnter(m); }\n                    : undefined, tabIndex: Number(_this.getTabIndex(m)), className: _this.getMonthClassNames(m), \"aria-disabled\": _this.isMonthDisabled(m), role: \"option\", \"aria-label\": _this.getAriaLabel(m), \"aria-current\": _this.isCurrentMonth(day, m) ? \"date\" : undefined, \"aria-selected\": selected ? _this.isSelectedMonth(day, m, selected) : undefined }, _this.getMonthContent(m))); }))); });\n        };\n        _this.renderQuarters = function () {\n            var _a = _this.props, day = _a.day, selected = _a.selected;\n            var quarters = [1, 2, 3, 4];\n            return (react__WEBPACK_IMPORTED_MODULE_1___default().createElement(\"div\", { className: \"react-datepicker__quarter-wrapper\" }, quarters.map(function (q, j) { return (react__WEBPACK_IMPORTED_MODULE_1___default().createElement(\"div\", { key: j, ref: _this.QUARTER_REFS[j], role: \"option\", onClick: function (event) {\n                    _this.onQuarterClick(event, q);\n                }, onKeyDown: function (event) {\n                    _this.onQuarterKeyDown(event, q);\n                }, onMouseEnter: !_this.props.usePointerEvent\n                    ? function () { return _this.onQuarterMouseEnter(q); }\n                    : undefined, onPointerEnter: _this.props.usePointerEvent\n                    ? function () { return _this.onQuarterMouseEnter(q); }\n                    : undefined, className: _this.getQuarterClassNames(q), \"aria-selected\": selected ? _this.isSelectedQuarter(day, q, selected) : undefined, tabIndex: Number(_this.getQuarterTabIndex(q)), \"aria-current\": _this.isCurrentQuarter(day, q) ? \"date\" : undefined }, _this.getQuarterContent(q))); })));\n        };\n        _this.getClassNames = function () {\n            var _a = _this.props, selectingDate = _a.selectingDate, selectsStart = _a.selectsStart, selectsEnd = _a.selectsEnd, showMonthYearPicker = _a.showMonthYearPicker, showQuarterYearPicker = _a.showQuarterYearPicker, showWeekPicker = _a.showWeekPicker;\n            return (0,clsx__WEBPACK_IMPORTED_MODULE_0__.clsx)(\"react-datepicker__month\", {\n                \"react-datepicker__month--selecting-range\": selectingDate && (selectsStart || selectsEnd),\n            }, { \"react-datepicker__monthPicker\": showMonthYearPicker }, { \"react-datepicker__quarterPicker\": showQuarterYearPicker }, { \"react-datepicker__weekPicker\": showWeekPicker });\n        };\n        return _this;\n    }\n    Month.prototype.getSelection = function () {\n        var _a = this.props, selected = _a.selected, selectedDates = _a.selectedDates, selectsMultiple = _a.selectsMultiple;\n        if (selectsMultiple) {\n            return selectedDates;\n        }\n        if (selected) {\n            return [selected];\n        }\n        return undefined;\n    };\n    Month.prototype.render = function () {\n        var _a = this.props, showMonthYearPicker = _a.showMonthYearPicker, showQuarterYearPicker = _a.showQuarterYearPicker, day = _a.day, _b = _a.ariaLabelPrefix, ariaLabelPrefix = _b === void 0 ? \"Month \" : _b;\n        var formattedAriaLabelPrefix = ariaLabelPrefix\n            ? ariaLabelPrefix.trim() + \" \"\n            : \"\";\n        // Format aria-label, return empty string if date is invalid\n        var formattedAriaLabel = isValid(day)\n            ? \"\".concat(formattedAriaLabelPrefix).concat(formatDate(day, \"MMMM, yyyy\", this.props.locale))\n            : \"\";\n        var shouldUseListboxRole = showMonthYearPicker || showQuarterYearPicker;\n        if (shouldUseListboxRole) {\n            return (react__WEBPACK_IMPORTED_MODULE_1___default().createElement(\"div\", { className: this.getClassNames(), onMouseLeave: !this.props.usePointerEvent ? this.handleMouseLeave : undefined, onPointerLeave: this.props.usePointerEvent ? this.handleMouseLeave : undefined, \"aria-label\": formattedAriaLabel, role: \"listbox\" }, showMonthYearPicker ? this.renderMonths() : this.renderQuarters()));\n        }\n        // For regular calendar view, use table structure\n        return (react__WEBPACK_IMPORTED_MODULE_1___default().createElement(\"div\", { role: \"table\" },\n            this.props.dayNamesHeader && (react__WEBPACK_IMPORTED_MODULE_1___default().createElement(\"div\", { role: \"rowgroup\" }, this.props.dayNamesHeader)),\n            react__WEBPACK_IMPORTED_MODULE_1___default().createElement(\"div\", { className: this.getClassNames(), onMouseLeave: !this.props.usePointerEvent ? this.handleMouseLeave : undefined, onPointerLeave: this.props.usePointerEvent ? this.handleMouseLeave : undefined, \"aria-label\": formattedAriaLabel, role: \"rowgroup\" }, this.renderWeeks())));\n    };\n    return Month;\n}(react__WEBPACK_IMPORTED_MODULE_1__.Component));\n\nvar MonthDropdownOptions = /** @class */ (function (_super) {\n    __extends(MonthDropdownOptions, _super);\n    function MonthDropdownOptions() {\n        var _this = _super !== null && _super.apply(this, arguments) || this;\n        _this.monthOptionButtonsRef = {};\n        _this.isSelectedMonth = function (i) { return _this.props.month === i; };\n        _this.handleOptionKeyDown = function (i, e) {\n            var _a;\n            switch (e.key) {\n                case \"Enter\":\n                    e.preventDefault();\n                    _this.onChange(i);\n                    break;\n                case \"Escape\":\n                    e.preventDefault();\n                    _this.props.onCancel();\n                    break;\n                case \"ArrowUp\":\n                case \"ArrowDown\": {\n                    e.preventDefault();\n                    var newMonth = (i + (e.key === \"ArrowUp\" ? -1 : 1) + _this.props.monthNames.length) %\n                        _this.props.monthNames.length;\n                    (_a = _this.monthOptionButtonsRef[newMonth]) === null || _a === void 0 ? void 0 : _a.focus();\n                    break;\n                }\n            }\n        };\n        _this.renderOptions = function () {\n            // Clear refs to prevent memory leaks on re-render\n            _this.monthOptionButtonsRef = {};\n            return _this.props.monthNames.map(function (month, i) { return (react__WEBPACK_IMPORTED_MODULE_1___default().createElement(\"div\", { ref: function (el) {\n                    _this.monthOptionButtonsRef[i] = el;\n                    if (_this.isSelectedMonth(i)) {\n                        el === null || el === void 0 ? void 0 : el.focus();\n                    }\n                }, role: \"button\", tabIndex: 0, className: _this.isSelectedMonth(i)\n                    ? \"react-datepicker__month-option react-datepicker__month-option--selected_month\"\n                    : \"react-datepicker__month-option\", key: month, onClick: _this.onChange.bind(_this, i), onKeyDown: _this.handleOptionKeyDown.bind(_this, i), \"aria-selected\": _this.isSelectedMonth(i) ? \"true\" : undefined },\n                _this.isSelectedMonth(i) ? (react__WEBPACK_IMPORTED_MODULE_1___default().createElement(\"span\", { className: \"react-datepicker__month-option--selected\" }, \"\\u2713\")) : (\"\"),\n                month)); });\n        };\n        _this.onChange = function (month) { return _this.props.onChange(month); };\n        _this.handleClickOutside = function () { return _this.props.onCancel(); };\n        return _this;\n    }\n    MonthDropdownOptions.prototype.render = function () {\n        return (react__WEBPACK_IMPORTED_MODULE_1___default().createElement(ClickOutsideWrapper, { className: \"react-datepicker__month-dropdown\", onClickOutside: this.handleClickOutside }, this.renderOptions()));\n    };\n    return MonthDropdownOptions;\n}(react__WEBPACK_IMPORTED_MODULE_1__.Component));\n\nvar MonthDropdown = /** @class */ (function (_super) {\n    __extends(MonthDropdown, _super);\n    function MonthDropdown() {\n        var _this = _super !== null && _super.apply(this, arguments) || this;\n        _this.state = {\n            dropdownVisible: false,\n        };\n        _this.renderSelectOptions = function (monthNames) {\n            return monthNames.map(function (m, i) { return (react__WEBPACK_IMPORTED_MODULE_1___default().createElement(\"option\", { key: m, value: i }, m)); });\n        };\n        _this.renderSelectMode = function (monthNames) { return (react__WEBPACK_IMPORTED_MODULE_1___default().createElement(\"select\", { value: _this.props.month, className: \"react-datepicker__month-select\", onChange: function (e) { return _this.onChange(parseInt(e.target.value)); } }, _this.renderSelectOptions(monthNames))); };\n        _this.renderReadView = function (visible, monthNames) { return (react__WEBPACK_IMPORTED_MODULE_1___default().createElement(\"button\", { key: \"read\", type: \"button\", style: { visibility: visible ? \"visible\" : \"hidden\" }, className: \"react-datepicker__month-read-view\", onClick: _this.toggleDropdown },\n            react__WEBPACK_IMPORTED_MODULE_1___default().createElement(\"span\", { className: \"react-datepicker__month-read-view--down-arrow\" }),\n            react__WEBPACK_IMPORTED_MODULE_1___default().createElement(\"span\", { className: \"react-datepicker__month-read-view--selected-month\" }, monthNames[_this.props.month]))); };\n        _this.renderDropdown = function (monthNames) { return (react__WEBPACK_IMPORTED_MODULE_1___default().createElement(MonthDropdownOptions, _assign({ key: \"dropdown\" }, _this.props, { monthNames: monthNames, onChange: _this.onChange, onCancel: _this.toggleDropdown }))); };\n        _this.renderScrollMode = function (monthNames) {\n            var dropdownVisible = _this.state.dropdownVisible;\n            var result = [_this.renderReadView(!dropdownVisible, monthNames)];\n            if (dropdownVisible) {\n                result.unshift(_this.renderDropdown(monthNames));\n            }\n            return result;\n        };\n        _this.onChange = function (month) {\n            _this.toggleDropdown();\n            if (month !== _this.props.month) {\n                _this.props.onChange(month);\n            }\n        };\n        _this.toggleDropdown = function () {\n            return _this.setState({\n                dropdownVisible: !_this.state.dropdownVisible,\n            });\n        };\n        return _this;\n    }\n    MonthDropdown.prototype.render = function () {\n        var _this = this;\n        var monthNames = [0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11].map(this.props.useShortMonthInDropdown\n            ? function (m) { return getMonthShortInLocale(m, _this.props.locale); }\n            : function (m) { return getMonthInLocale(m, _this.props.locale); });\n        var renderedDropdown;\n        switch (this.props.dropdownMode) {\n            case \"scroll\":\n                renderedDropdown = this.renderScrollMode(monthNames);\n                break;\n            case \"select\":\n                renderedDropdown = this.renderSelectMode(monthNames);\n                break;\n        }\n        return (react__WEBPACK_IMPORTED_MODULE_1___default().createElement(\"div\", { className: \"react-datepicker__month-dropdown-container react-datepicker__month-dropdown-container--\".concat(this.props.dropdownMode) }, renderedDropdown));\n    };\n    return MonthDropdown;\n}(react__WEBPACK_IMPORTED_MODULE_1__.Component));\n\nfunction generateMonthYears(minDate, maxDate) {\n    var list = [];\n    var currDate = getStartOfMonth(minDate);\n    var lastDate = getStartOfMonth(maxDate);\n    while (!(0,date_fns__WEBPACK_IMPORTED_MODULE_52__.isAfter)(currDate, lastDate)) {\n        list.push(newDate(currDate));\n        currDate = (0,date_fns__WEBPACK_IMPORTED_MODULE_39__.addMonths)(currDate, 1);\n    }\n    return list;\n}\nvar MonthYearDropdownOptions = /** @class */ (function (_super) {\n    __extends(MonthYearDropdownOptions, _super);\n    function MonthYearDropdownOptions(props) {\n        var _this = _super.call(this, props) || this;\n        _this.renderOptions = function () {\n            return _this.state.monthYearsList.map(function (monthYear) {\n                var monthYearPoint = (0,date_fns__WEBPACK_IMPORTED_MODULE_57__.getTime)(monthYear);\n                var isSameMonthYear = isSameYear(_this.props.date, monthYear) &&\n                    isSameMonth(_this.props.date, monthYear);\n                return (react__WEBPACK_IMPORTED_MODULE_1___default().createElement(\"div\", { className: isSameMonthYear\n                        ? \"react-datepicker__month-year-option--selected_month-year\"\n                        : \"react-datepicker__month-year-option\", key: monthYearPoint, onClick: _this.onChange.bind(_this, monthYearPoint), \"aria-selected\": isSameMonthYear ? \"true\" : undefined },\n                    isSameMonthYear ? (react__WEBPACK_IMPORTED_MODULE_1___default().createElement(\"span\", { className: \"react-datepicker__month-year-option--selected\" }, \"\\u2713\")) : (\"\"),\n                    formatDate(monthYear, _this.props.dateFormat, _this.props.locale)));\n            });\n        };\n        _this.onChange = function (monthYear) { return _this.props.onChange(monthYear); };\n        _this.handleClickOutside = function () {\n            _this.props.onCancel();\n        };\n        _this.state = {\n            monthYearsList: generateMonthYears(_this.props.minDate, _this.props.maxDate),\n        };\n        return _this;\n    }\n    MonthYearDropdownOptions.prototype.render = function () {\n        var dropdownClass = (0,clsx__WEBPACK_IMPORTED_MODULE_0__.clsx)({\n            \"react-datepicker__month-year-dropdown\": true,\n            \"react-datepicker__month-year-dropdown--scrollable\": this.props.scrollableMonthYearDropdown,\n        });\n        return (react__WEBPACK_IMPORTED_MODULE_1___default().createElement(ClickOutsideWrapper, { className: dropdownClass, onClickOutside: this.handleClickOutside }, this.renderOptions()));\n    };\n    return MonthYearDropdownOptions;\n}(react__WEBPACK_IMPORTED_MODULE_1__.Component));\n\nvar MonthYearDropdown = /** @class */ (function (_super) {\n    __extends(MonthYearDropdown, _super);\n    function MonthYearDropdown() {\n        var _this = _super !== null && _super.apply(this, arguments) || this;\n        _this.state = {\n            dropdownVisible: false,\n        };\n        _this.renderSelectOptions = function () {\n            var currDate = getStartOfMonth(_this.props.minDate);\n            var lastDate = getStartOfMonth(_this.props.maxDate);\n            var options = [];\n            while (!(0,date_fns__WEBPACK_IMPORTED_MODULE_52__.isAfter)(currDate, lastDate)) {\n                var timePoint = (0,date_fns__WEBPACK_IMPORTED_MODULE_57__.getTime)(currDate);\n                options.push(react__WEBPACK_IMPORTED_MODULE_1___default().createElement(\"option\", { key: timePoint, value: timePoint }, formatDate(currDate, _this.props.dateFormat, _this.props.locale)));\n                currDate = (0,date_fns__WEBPACK_IMPORTED_MODULE_39__.addMonths)(currDate, 1);\n            }\n            return options;\n        };\n        _this.onSelectChange = function (event) {\n            _this.onChange(parseInt(event.target.value));\n        };\n        _this.renderSelectMode = function () { return (react__WEBPACK_IMPORTED_MODULE_1___default().createElement(\"select\", { value: (0,date_fns__WEBPACK_IMPORTED_MODULE_57__.getTime)(getStartOfMonth(_this.props.date)), className: \"react-datepicker__month-year-select\", onChange: _this.onSelectChange }, _this.renderSelectOptions())); };\n        _this.renderReadView = function (visible) {\n            var yearMonth = formatDate(_this.props.date, _this.props.dateFormat, _this.props.locale);\n            return (react__WEBPACK_IMPORTED_MODULE_1___default().createElement(\"div\", { key: \"read\", style: { visibility: visible ? \"visible\" : \"hidden\" }, className: \"react-datepicker__month-year-read-view\", onClick: _this.toggleDropdown },\n                react__WEBPACK_IMPORTED_MODULE_1___default().createElement(\"span\", { className: \"react-datepicker__month-year-read-view--down-arrow\" }),\n                react__WEBPACK_IMPORTED_MODULE_1___default().createElement(\"span\", { className: \"react-datepicker__month-year-read-view--selected-month-year\" }, yearMonth)));\n        };\n        _this.renderDropdown = function () { return (react__WEBPACK_IMPORTED_MODULE_1___default().createElement(MonthYearDropdownOptions, _assign({ key: \"dropdown\" }, _this.props, { onChange: _this.onChange, onCancel: _this.toggleDropdown }))); };\n        _this.renderScrollMode = function () {\n            var dropdownVisible = _this.state.dropdownVisible;\n            var result = [_this.renderReadView(!dropdownVisible)];\n            if (dropdownVisible) {\n                result.unshift(_this.renderDropdown());\n            }\n            return result;\n        };\n        _this.onChange = function (monthYearPoint) {\n            _this.toggleDropdown();\n            var changedDate = newDate(monthYearPoint);\n            if (isSameYear(_this.props.date, changedDate) &&\n                isSameMonth(_this.props.date, changedDate)) {\n                return;\n            }\n            _this.props.onChange(changedDate);\n        };\n        _this.toggleDropdown = function () {\n            return _this.setState({\n                dropdownVisible: !_this.state.dropdownVisible,\n            });\n        };\n        return _this;\n    }\n    MonthYearDropdown.prototype.render = function () {\n        var renderedDropdown;\n        switch (this.props.dropdownMode) {\n            case \"scroll\":\n                renderedDropdown = this.renderScrollMode();\n                break;\n            case \"select\":\n                renderedDropdown = this.renderSelectMode();\n                break;\n        }\n        return (react__WEBPACK_IMPORTED_MODULE_1___default().createElement(\"div\", { className: \"react-datepicker__month-year-dropdown-container react-datepicker__month-year-dropdown-container--\".concat(this.props.dropdownMode) }, renderedDropdown));\n    };\n    return MonthYearDropdown;\n}(react__WEBPACK_IMPORTED_MODULE_1__.Component));\n\nvar Time = /** @class */ (function (_super) {\n    __extends(Time, _super);\n    function Time() {\n        var _this = _super !== null && _super.apply(this, arguments) || this;\n        _this.state = {\n            height: null,\n        };\n        _this.scrollToTheSelectedTime = function () {\n            requestAnimationFrame(function () {\n                var _a, _b, _c;\n                if (!_this.list)\n                    return;\n                _this.list.scrollTop =\n                    (_c = (_this.centerLi &&\n                        Time.calcCenterPosition(_this.props.monthRef\n                            ? _this.props.monthRef.clientHeight -\n                                ((_b = (_a = _this.header) === null || _a === void 0 ? void 0 : _a.clientHeight) !== null && _b !== void 0 ? _b : 0)\n                            : _this.list.clientHeight, _this.centerLi))) !== null && _c !== void 0 ? _c : 0;\n            });\n        };\n        _this.handleClick = function (time) {\n            var _a, _b;\n            if (((_this.props.minTime || _this.props.maxTime) &&\n                isTimeInDisabledRange(time, _this.props)) ||\n                ((_this.props.excludeTimes ||\n                    _this.props.includeTimes ||\n                    _this.props.filterTime) &&\n                    isTimeDisabled(time, _this.props))) {\n                return;\n            }\n            (_b = (_a = _this.props).onChange) === null || _b === void 0 ? void 0 : _b.call(_a, time);\n        };\n        _this.isSelectedTime = function (time) {\n            return _this.props.selected && isSameMinute(_this.props.selected, time);\n        };\n        _this.isDisabledTime = function (time) {\n            return ((_this.props.minTime || _this.props.maxTime) &&\n                isTimeInDisabledRange(time, _this.props)) ||\n                ((_this.props.excludeTimes ||\n                    _this.props.includeTimes ||\n                    _this.props.filterTime) &&\n                    isTimeDisabled(time, _this.props));\n        };\n        _this.liClasses = function (time) {\n            var _a;\n            var classes = [\n                \"react-datepicker__time-list-item\",\n                _this.props.timeClassName ? _this.props.timeClassName(time) : undefined,\n            ];\n            if (_this.isSelectedTime(time)) {\n                classes.push(\"react-datepicker__time-list-item--selected\");\n            }\n            if (_this.isDisabledTime(time)) {\n                classes.push(\"react-datepicker__time-list-item--disabled\");\n            }\n            //convert this.props.intervals and the relevant time to seconds and check if it it's a clean multiple of the interval\n            if (_this.props.injectTimes &&\n                ((0,date_fns__WEBPACK_IMPORTED_MODULE_34__.getHours)(time) * 3600 + (0,date_fns__WEBPACK_IMPORTED_MODULE_35__.getMinutes)(time) * 60 + (0,date_fns__WEBPACK_IMPORTED_MODULE_36__.getSeconds)(time)) %\n                    (((_a = _this.props.intervals) !== null && _a !== void 0 ? _a : Time.defaultProps.intervals) * 60) !==\n                    0) {\n                classes.push(\"react-datepicker__time-list-item--injected\");\n            }\n            return classes.join(\" \");\n        };\n        _this.handleOnKeyDown = function (event, time) {\n            var _a, _b;\n            if (event.key === KeyType.Space) {\n                event.preventDefault();\n                event.key = KeyType.Enter;\n            }\n            if ((event.key === KeyType.ArrowUp || event.key === KeyType.ArrowLeft) &&\n                event.target instanceof HTMLElement &&\n                event.target.previousSibling) {\n                event.preventDefault();\n                event.target.previousSibling instanceof HTMLElement &&\n                    event.target.previousSibling.focus();\n            }\n            if ((event.key === KeyType.ArrowDown || event.key === KeyType.ArrowRight) &&\n                event.target instanceof HTMLElement &&\n                event.target.nextSibling) {\n                event.preventDefault();\n                event.target.nextSibling instanceof HTMLElement &&\n                    event.target.nextSibling.focus();\n            }\n            if (event.key === KeyType.Enter) {\n                _this.handleClick(time);\n            }\n            (_b = (_a = _this.props).handleOnKeyDown) === null || _b === void 0 ? void 0 : _b.call(_a, event);\n        };\n        _this.renderTimes = function () {\n            var _a;\n            var times = [];\n            var format = typeof _this.props.format === \"string\" ? _this.props.format : \"p\";\n            var intervals = (_a = _this.props.intervals) !== null && _a !== void 0 ? _a : Time.defaultProps.intervals;\n            var activeDate = _this.props.selected || _this.props.openToDate || newDate();\n            var base = getStartOfDay(activeDate);\n            var sortedInjectTimes = _this.props.injectTimes &&\n                _this.props.injectTimes.sort(function (a, b) {\n                    return a.getTime() - b.getTime();\n                });\n            var minutesInDay = 60 * getHoursInDay(activeDate);\n            var multiplier = minutesInDay / intervals;\n            for (var i = 0; i < multiplier; i++) {\n                var currentTime = (0,date_fns__WEBPACK_IMPORTED_MODULE_50__.addMinutes)(base, i * intervals);\n                times.push(currentTime);\n                if (sortedInjectTimes) {\n                    var timesToInject = timesToInjectAfter(base, currentTime, i, intervals, sortedInjectTimes);\n                    times = times.concat(timesToInject);\n                }\n            }\n            // Determine which time to focus and scroll into view when component mounts\n            var timeToFocus = times.reduce(function (prev, time) {\n                if (time.getTime() <= activeDate.getTime()) {\n                    return time;\n                }\n                return prev;\n            }, times[0]);\n            return times.map(function (time) {\n                return (react__WEBPACK_IMPORTED_MODULE_1___default().createElement(\"li\", { key: time.valueOf(), onClick: _this.handleClick.bind(_this, time), className: _this.liClasses(time), ref: function (li) {\n                        if (time === timeToFocus) {\n                            _this.centerLi = li;\n                        }\n                    }, onKeyDown: function (event) {\n                        _this.handleOnKeyDown(event, time);\n                    }, tabIndex: time === timeToFocus ? 0 : -1, role: \"option\", \"aria-selected\": _this.isSelectedTime(time) ? \"true\" : undefined, \"aria-disabled\": _this.isDisabledTime(time) ? \"true\" : undefined }, formatDate(time, format, _this.props.locale)));\n            });\n        };\n        _this.renderTimeCaption = function () {\n            if (_this.props.showTimeCaption === false) {\n                return react__WEBPACK_IMPORTED_MODULE_1___default().createElement((react__WEBPACK_IMPORTED_MODULE_1___default().Fragment), null);\n            }\n            return (react__WEBPACK_IMPORTED_MODULE_1___default().createElement(\"div\", { className: \"react-datepicker__header react-datepicker__header--time \".concat(_this.props.showTimeSelectOnly\n                    ? \"react-datepicker__header--time--only\"\n                    : \"\"), ref: function (header) {\n                    _this.header = header;\n                } },\n                react__WEBPACK_IMPORTED_MODULE_1___default().createElement(\"div\", { className: \"react-datepicker-time__header\" }, _this.props.timeCaption)));\n        };\n        return _this;\n    }\n    Object.defineProperty(Time, \"defaultProps\", {\n        get: function () {\n            return {\n                intervals: 30,\n                todayButton: null,\n                timeCaption: \"Time\",\n                showTimeCaption: true,\n            };\n        },\n        enumerable: false,\n        configurable: true\n    });\n    Time.prototype.componentDidMount = function () {\n        // code to ensure selected time will always be in focus within time window when it first appears\n        this.scrollToTheSelectedTime();\n        this.observeDatePickerHeightChanges();\n    };\n    Time.prototype.componentWillUnmount = function () {\n        var _a;\n        (_a = this.resizeObserver) === null || _a === void 0 ? void 0 : _a.disconnect();\n    };\n    Time.prototype.observeDatePickerHeightChanges = function () {\n        var _this = this;\n        var monthRef = this.props.monthRef;\n        this.updateContainerHeight();\n        if (monthRef) {\n            this.resizeObserver = new ResizeObserver(function () {\n                _this.updateContainerHeight();\n            });\n            this.resizeObserver.observe(monthRef);\n        }\n    };\n    Time.prototype.updateContainerHeight = function () {\n        if (this.props.monthRef && this.header) {\n            this.setState({\n                height: this.props.monthRef.clientHeight - this.header.clientHeight,\n            });\n        }\n    };\n    Time.prototype.render = function () {\n        var _this = this;\n        var _a;\n        var height = this.state.height;\n        return (react__WEBPACK_IMPORTED_MODULE_1___default().createElement(\"div\", { className: \"react-datepicker__time-container \".concat(((_a = this.props.todayButton) !== null && _a !== void 0 ? _a : Time.defaultProps.todayButton)\n                ? \"react-datepicker__time-container--with-today-button\"\n                : \"\") },\n            this.renderTimeCaption(),\n            react__WEBPACK_IMPORTED_MODULE_1___default().createElement(\"div\", { className: \"react-datepicker__time\" },\n                react__WEBPACK_IMPORTED_MODULE_1___default().createElement(\"div\", { className: \"react-datepicker__time-box\" },\n                    react__WEBPACK_IMPORTED_MODULE_1___default().createElement(\"ul\", { className: \"react-datepicker__time-list\", ref: function (list) {\n                            _this.list = list;\n                        }, style: height ? { height: height } : {}, role: \"listbox\", \"aria-label\": this.props.timeCaption }, this.renderTimes())))));\n    };\n    Time.calcCenterPosition = function (listHeight, centerLiRef) {\n        return (centerLiRef.offsetTop - (listHeight / 2 - centerLiRef.clientHeight / 2));\n    };\n    return Time;\n}(react__WEBPACK_IMPORTED_MODULE_1__.Component));\n\nvar VERTICAL_NAVIGATION_OFFSET = 3;\n/**\n * `Year` is a component that represents a year in a date picker.\n *\n * @class\n * @param {YearProps} props - The properties that define the `Year` component.\n * @property {VoidFunction} [props.clearSelectingDate] - Function to clear the selected date.\n * @property {Date} [props.date] - The currently selected date.\n * @property {boolean} [props.disabledKeyboardNavigation] - If true, keyboard navigation is disabled.\n * @property {Date} [props.endDate] - The end date in a range selection.\n * @property {(date: Date) => void} props.onDayClick - Function to handle day click events.\n * @property {Date} props.preSelection - The date that is currently in focus.\n * @property {(date: Date) => void} props.setPreSelection - Function to set the pre-selected date.\n * @property {{ [key: string]: any }} props.selected - The selected date(s).\n * @property {boolean} props.inline - If true, the date picker is displayed inline.\n * @property {Date} props.maxDate - The maximum selectable date.\n * @property {Date} props.minDate - The minimum selectable date.\n * @property {boolean} props.usePointerEvent - If true, pointer events are used instead of mouse events.\n * @property {(date: Date) => void} props.onYearMouseEnter - Function to handle mouse enter events on a year.\n * @property {(date: Date) => void} props.onYearMouseLeave - Function to handle mouse leave events on a year.\n */\nvar Year = /** @class */ (function (_super) {\n    __extends(Year, _super);\n    function Year(props) {\n        var _this = _super.call(this, props) || this;\n        _this.YEAR_REFS = __spreadArray([], Array(_this.props.yearItemNumber), true).map(function () {\n            return (0,react__WEBPACK_IMPORTED_MODULE_1__.createRef)();\n        });\n        _this.isDisabled = function (date) {\n            return isDayDisabled(date, {\n                minDate: _this.props.minDate,\n                maxDate: _this.props.maxDate,\n                excludeDates: _this.props.excludeDates,\n                includeDates: _this.props.includeDates,\n                filterDate: _this.props.filterDate,\n            });\n        };\n        _this.isExcluded = function (date) {\n            return isDayExcluded(date, {\n                excludeDates: _this.props.excludeDates,\n            });\n        };\n        _this.selectingDate = function () { var _a; return (_a = _this.props.selectingDate) !== null && _a !== void 0 ? _a : _this.props.preSelection; };\n        _this.updateFocusOnPaginate = function (refIndex) {\n            var waitForReRender = function () {\n                var _a, _b;\n                (_b = (_a = _this.YEAR_REFS[refIndex]) === null || _a === void 0 ? void 0 : _a.current) === null || _b === void 0 ? void 0 : _b.focus();\n            };\n            window.requestAnimationFrame(waitForReRender);\n        };\n        _this.handleYearClick = function (day, event) {\n            if (_this.props.onDayClick) {\n                _this.props.onDayClick(day, event);\n            }\n        };\n        _this.handleYearNavigation = function (newYear, newDate) {\n            var _a, _b, _c, _d;\n            var _e = _this.props, date = _e.date, yearItemNumber = _e.yearItemNumber;\n            if (date === undefined || yearItemNumber === undefined) {\n                return;\n            }\n            var startPeriod = getYearsPeriod(date, yearItemNumber).startPeriod;\n            if (_this.isDisabled(newDate) || _this.isExcluded(newDate)) {\n                return;\n            }\n            (_b = (_a = _this.props).setPreSelection) === null || _b === void 0 ? void 0 : _b.call(_a, newDate);\n            if (newYear - startPeriod < 0) {\n                _this.updateFocusOnPaginate(yearItemNumber - (startPeriod - newYear));\n            }\n            else if (newYear - startPeriod >= yearItemNumber) {\n                _this.updateFocusOnPaginate(Math.abs(yearItemNumber - (newYear - startPeriod)));\n            }\n            else\n                (_d = (_c = _this.YEAR_REFS[newYear - startPeriod]) === null || _c === void 0 ? void 0 : _c.current) === null || _d === void 0 ? void 0 : _d.focus();\n        };\n        _this.isSameDay = function (y, other) { return isSameDay(y, other); };\n        _this.isCurrentYear = function (y) { return y === (0,date_fns__WEBPACK_IMPORTED_MODULE_29__.getYear)(newDate()); };\n        _this.isRangeStart = function (y) {\n            return _this.props.startDate &&\n                _this.props.endDate &&\n                isSameYear((0,date_fns__WEBPACK_IMPORTED_MODULE_58__.setYear)(newDate(), y), _this.props.startDate);\n        };\n        _this.isRangeEnd = function (y) {\n            return _this.props.startDate &&\n                _this.props.endDate &&\n                isSameYear((0,date_fns__WEBPACK_IMPORTED_MODULE_58__.setYear)(newDate(), y), _this.props.endDate);\n        };\n        _this.isInRange = function (y) {\n            return isYearInRange(y, _this.props.startDate, _this.props.endDate);\n        };\n        _this.isInSelectingRange = function (y) {\n            var _a = _this.props, selectsStart = _a.selectsStart, selectsEnd = _a.selectsEnd, selectsRange = _a.selectsRange, startDate = _a.startDate, endDate = _a.endDate;\n            if (!(selectsStart || selectsEnd || selectsRange) ||\n                !_this.selectingDate()) {\n                return false;\n            }\n            if (selectsStart && endDate) {\n                return isYearInRange(y, _this.selectingDate(), endDate);\n            }\n            if (selectsEnd && startDate) {\n                return isYearInRange(y, startDate, _this.selectingDate());\n            }\n            if (selectsRange && startDate && !endDate) {\n                return isYearInRange(y, startDate, _this.selectingDate());\n            }\n            return false;\n        };\n        _this.isSelectingRangeStart = function (y) {\n            var _a;\n            if (!_this.isInSelectingRange(y)) {\n                return false;\n            }\n            var _b = _this.props, startDate = _b.startDate, selectsStart = _b.selectsStart;\n            var _year = (0,date_fns__WEBPACK_IMPORTED_MODULE_58__.setYear)(newDate(), y);\n            if (selectsStart) {\n                return isSameYear(_year, (_a = _this.selectingDate()) !== null && _a !== void 0 ? _a : null);\n            }\n            return isSameYear(_year, startDate !== null && startDate !== void 0 ? startDate : null);\n        };\n        _this.isSelectingRangeEnd = function (y) {\n            var _a;\n            if (!_this.isInSelectingRange(y)) {\n                return false;\n            }\n            var _b = _this.props, endDate = _b.endDate, selectsEnd = _b.selectsEnd, selectsRange = _b.selectsRange;\n            var _year = (0,date_fns__WEBPACK_IMPORTED_MODULE_58__.setYear)(newDate(), y);\n            if (selectsEnd || selectsRange) {\n                return isSameYear(_year, (_a = _this.selectingDate()) !== null && _a !== void 0 ? _a : null);\n            }\n            return isSameYear(_year, endDate !== null && endDate !== void 0 ? endDate : null);\n        };\n        _this.isKeyboardSelected = function (y) {\n            if (_this.props.disabledKeyboardNavigation ||\n                _this.props.date === undefined ||\n                _this.props.preSelection == null) {\n                return;\n            }\n            var _a = _this.props, minDate = _a.minDate, maxDate = _a.maxDate, excludeDates = _a.excludeDates, includeDates = _a.includeDates, filterDate = _a.filterDate, selected = _a.selected;\n            var date = getStartOfYear((0,date_fns__WEBPACK_IMPORTED_MODULE_58__.setYear)(_this.props.date, y));\n            var isDisabled = (minDate || maxDate || excludeDates || includeDates || filterDate) &&\n                isYearDisabled(y, _this.props);\n            var isSelectedDay = !!selected && isSameDay(date, getStartOfYear(selected));\n            var isKeyboardSelectedDay = isSameDay(date, getStartOfYear(_this.props.preSelection));\n            return (!_this.props.inline &&\n                !isSelectedDay &&\n                isKeyboardSelectedDay &&\n                !isDisabled);\n        };\n        _this.isSelectedYear = function (year) {\n            var _a = _this.props, selectsMultiple = _a.selectsMultiple, selected = _a.selected, selectedDates = _a.selectedDates;\n            if (selectsMultiple) {\n                return selectedDates === null || selectedDates === void 0 ? void 0 : selectedDates.some(function (date) { return year === (0,date_fns__WEBPACK_IMPORTED_MODULE_29__.getYear)(date); });\n            }\n            return !!selected && year === (0,date_fns__WEBPACK_IMPORTED_MODULE_29__.getYear)(selected);\n        };\n        _this.onYearClick = function (event, y) {\n            var date = _this.props.date;\n            if (date === undefined) {\n                return;\n            }\n            _this.handleYearClick(getStartOfYear((0,date_fns__WEBPACK_IMPORTED_MODULE_58__.setYear)(date, y)), event);\n        };\n        _this.onYearKeyDown = function (event, y) {\n            var _a, _b;\n            var key = event.key;\n            var _c = _this.props, date = _c.date, yearItemNumber = _c.yearItemNumber, handleOnKeyDown = _c.handleOnKeyDown;\n            if (key !== KeyType.Tab) {\n                // preventDefault on tab event blocks focus change\n                event.preventDefault();\n            }\n            if (!_this.props.disabledKeyboardNavigation) {\n                switch (key) {\n                    case KeyType.Enter:\n                        if (_this.props.selected == null) {\n                            break;\n                        }\n                        _this.onYearClick(event, y);\n                        (_b = (_a = _this.props).setPreSelection) === null || _b === void 0 ? void 0 : _b.call(_a, _this.props.selected);\n                        break;\n                    case KeyType.ArrowRight:\n                        if (_this.props.preSelection == null) {\n                            break;\n                        }\n                        _this.handleYearNavigation(y + 1, (0,date_fns__WEBPACK_IMPORTED_MODULE_45__.addYears)(_this.props.preSelection, 1));\n                        break;\n                    case KeyType.ArrowLeft:\n                        if (_this.props.preSelection == null) {\n                            break;\n                        }\n                        _this.handleYearNavigation(y - 1, (0,date_fns__WEBPACK_IMPORTED_MODULE_43__.subYears)(_this.props.preSelection, 1));\n                        break;\n                    case KeyType.ArrowUp: {\n                        if (date === undefined ||\n                            yearItemNumber === undefined ||\n                            _this.props.preSelection == null) {\n                            break;\n                        }\n                        var startPeriod = getYearsPeriod(date, yearItemNumber).startPeriod;\n                        var offset = VERTICAL_NAVIGATION_OFFSET;\n                        var newYear = y - offset;\n                        if (newYear < startPeriod) {\n                            var leftOverOffset = yearItemNumber % offset;\n                            if (y >= startPeriod && y < startPeriod + leftOverOffset) {\n                                offset = leftOverOffset;\n                            }\n                            else {\n                                offset += leftOverOffset;\n                            }\n                            newYear = y - offset;\n                        }\n                        _this.handleYearNavigation(newYear, (0,date_fns__WEBPACK_IMPORTED_MODULE_43__.subYears)(_this.props.preSelection, offset));\n                        break;\n                    }\n                    case KeyType.ArrowDown: {\n                        if (date === undefined ||\n                            yearItemNumber === undefined ||\n                            _this.props.preSelection == null) {\n                            break;\n                        }\n                        var endPeriod = getYearsPeriod(date, yearItemNumber).endPeriod;\n                        var offset = VERTICAL_NAVIGATION_OFFSET;\n                        var newYear = y + offset;\n                        if (newYear > endPeriod) {\n                            var leftOverOffset = yearItemNumber % offset;\n                            if (y <= endPeriod && y > endPeriod - leftOverOffset) {\n                                offset = leftOverOffset;\n                            }\n                            else {\n                                offset += leftOverOffset;\n                            }\n                            newYear = y + offset;\n                        }\n                        _this.handleYearNavigation(newYear, (0,date_fns__WEBPACK_IMPORTED_MODULE_45__.addYears)(_this.props.preSelection, offset));\n                        break;\n                    }\n                }\n            }\n            handleOnKeyDown && handleOnKeyDown(event);\n        };\n        _this.getYearClassNames = function (y) {\n            var _a = _this.props, date = _a.date, disabled = _a.disabled, minDate = _a.minDate, maxDate = _a.maxDate, excludeDates = _a.excludeDates, includeDates = _a.includeDates, filterDate = _a.filterDate, yearClassName = _a.yearClassName;\n            return (0,clsx__WEBPACK_IMPORTED_MODULE_0__.clsx)(\"react-datepicker__year-text\", \"react-datepicker__year-\".concat(y), date ? yearClassName === null || yearClassName === void 0 ? void 0 : yearClassName((0,date_fns__WEBPACK_IMPORTED_MODULE_58__.setYear)(date, y)) : undefined, {\n                \"react-datepicker__year-text--selected\": _this.isSelectedYear(y),\n                \"react-datepicker__year-text--disabled\": (minDate ||\n                    maxDate ||\n                    excludeDates ||\n                    includeDates ||\n                    filterDate ||\n                    disabled) &&\n                    isYearDisabled(y, _this.props),\n                \"react-datepicker__year-text--keyboard-selected\": _this.isKeyboardSelected(y),\n                \"react-datepicker__year-text--range-start\": _this.isRangeStart(y),\n                \"react-datepicker__year-text--range-end\": _this.isRangeEnd(y),\n                \"react-datepicker__year-text--in-range\": _this.isInRange(y),\n                \"react-datepicker__year-text--in-selecting-range\": _this.isInSelectingRange(y),\n                \"react-datepicker__year-text--selecting-range-start\": _this.isSelectingRangeStart(y),\n                \"react-datepicker__year-text--selecting-range-end\": _this.isSelectingRangeEnd(y),\n                \"react-datepicker__year-text--today\": _this.isCurrentYear(y),\n            });\n        };\n        _this.getYearTabIndex = function (y) {\n            if (_this.props.disabledKeyboardNavigation ||\n                _this.props.preSelection == null) {\n                return \"-1\";\n            }\n            var preSelected = (0,date_fns__WEBPACK_IMPORTED_MODULE_29__.getYear)(_this.props.preSelection);\n            var isPreSelectedYearDisabled = isYearDisabled(y, _this.props);\n            return y === preSelected && !isPreSelectedYearDisabled ? \"0\" : \"-1\";\n        };\n        _this.getYearContent = function (y) {\n            return _this.props.renderYearContent ? _this.props.renderYearContent(y) : y;\n        };\n        return _this;\n    }\n    Year.prototype.render = function () {\n        var _this = this;\n        var yearsList = [];\n        var _a = this.props, date = _a.date, yearItemNumber = _a.yearItemNumber, onYearMouseEnter = _a.onYearMouseEnter, onYearMouseLeave = _a.onYearMouseLeave;\n        if (date === undefined) {\n            return null;\n        }\n        var _b = getYearsPeriod(date, yearItemNumber), startPeriod = _b.startPeriod, endPeriod = _b.endPeriod;\n        var _loop_1 = function (y) {\n            yearsList.push(react__WEBPACK_IMPORTED_MODULE_1___default().createElement(\"div\", { ref: this_1.YEAR_REFS[y - startPeriod], onClick: function (event) {\n                    _this.onYearClick(event, y);\n                }, onKeyDown: function (event) {\n                    if (isSpaceKeyDown(event)) {\n                        event.preventDefault();\n                        event.key = KeyType.Enter;\n                    }\n                    _this.onYearKeyDown(event, y);\n                }, tabIndex: Number(this_1.getYearTabIndex(y)), className: this_1.getYearClassNames(y), onMouseEnter: !this_1.props.usePointerEvent\n                    ? function (event) { return onYearMouseEnter(event, y); }\n                    : undefined, onPointerEnter: this_1.props.usePointerEvent\n                    ? function (event) { return onYearMouseEnter(event, y); }\n                    : undefined, onMouseLeave: !this_1.props.usePointerEvent\n                    ? function (event) { return onYearMouseLeave(event, y); }\n                    : undefined, onPointerLeave: this_1.props.usePointerEvent\n                    ? function (event) { return onYearMouseLeave(event, y); }\n                    : undefined, key: y, \"aria-current\": this_1.isCurrentYear(y) ? \"date\" : undefined }, this_1.getYearContent(y)));\n        };\n        var this_1 = this;\n        for (var y = startPeriod; y <= endPeriod; y++) {\n            _loop_1(y);\n        }\n        return (react__WEBPACK_IMPORTED_MODULE_1___default().createElement(\"div\", { className: \"react-datepicker__year\" },\n            react__WEBPACK_IMPORTED_MODULE_1___default().createElement(\"div\", { className: \"react-datepicker__year-wrapper\", onMouseLeave: !this.props.usePointerEvent\n                    ? this.props.clearSelectingDate\n                    : undefined, onPointerLeave: this.props.usePointerEvent\n                    ? this.props.clearSelectingDate\n                    : undefined }, yearsList)));\n    };\n    return Year;\n}(react__WEBPACK_IMPORTED_MODULE_1__.Component));\n\nfunction generateYears(year, noOfYear, minDate, maxDate) {\n    var list = [];\n    for (var i = 0; i < 2 * noOfYear + 1; i++) {\n        var newYear = year + noOfYear - i;\n        var isInRange = true;\n        if (minDate) {\n            isInRange = (0,date_fns__WEBPACK_IMPORTED_MODULE_29__.getYear)(minDate) <= newYear;\n        }\n        if (maxDate && isInRange) {\n            isInRange = (0,date_fns__WEBPACK_IMPORTED_MODULE_29__.getYear)(maxDate) >= newYear;\n        }\n        if (isInRange) {\n            list.push(newYear);\n        }\n    }\n    return list;\n}\nvar YearDropdownOptions = /** @class */ (function (_super) {\n    __extends(YearDropdownOptions, _super);\n    function YearDropdownOptions(props) {\n        var _this = _super.call(this, props) || this;\n        _this.yearOptionButtonsRef = {};\n        _this.handleOptionKeyDown = function (year, e) {\n            var _a;\n            switch (e.key) {\n                case \"Enter\":\n                    e.preventDefault();\n                    _this.onChange(year);\n                    break;\n                case \"Escape\":\n                    e.preventDefault();\n                    _this.props.onCancel();\n                    break;\n                case \"ArrowUp\":\n                case \"ArrowDown\": {\n                    e.preventDefault();\n                    var newYear = year + (e.key === \"ArrowUp\" ? 1 : -1);\n                    // Add bounds checking to ensure the year exists in our refs\n                    if (_this.yearOptionButtonsRef[newYear]) {\n                        (_a = _this.yearOptionButtonsRef[newYear]) === null || _a === void 0 ? void 0 : _a.focus();\n                    }\n                    break;\n                }\n            }\n        };\n        _this.renderOptions = function () {\n            // Clear refs to prevent memory leaks on re-render\n            _this.yearOptionButtonsRef = {};\n            var selectedYear = _this.props.year;\n            var options = _this.state.yearsList.map(function (year) { return (react__WEBPACK_IMPORTED_MODULE_1___default().createElement(\"div\", { ref: function (el) {\n                    _this.yearOptionButtonsRef[year] = el;\n                    if (year === selectedYear) {\n                        el === null || el === void 0 ? void 0 : el.focus();\n                    }\n                }, role: \"button\", tabIndex: 0, className: selectedYear === year\n                    ? \"react-datepicker__year-option react-datepicker__year-option--selected_year\"\n                    : \"react-datepicker__year-option\", key: year, onClick: _this.onChange.bind(_this, year), onKeyDown: _this.handleOptionKeyDown.bind(_this, year), \"aria-selected\": selectedYear === year ? \"true\" : undefined },\n                selectedYear === year ? (react__WEBPACK_IMPORTED_MODULE_1___default().createElement(\"span\", { className: \"react-datepicker__year-option--selected\" }, \"\\u2713\")) : (\"\"),\n                year)); });\n            var minYear = _this.props.minDate ? (0,date_fns__WEBPACK_IMPORTED_MODULE_29__.getYear)(_this.props.minDate) : null;\n            var maxYear = _this.props.maxDate ? (0,date_fns__WEBPACK_IMPORTED_MODULE_29__.getYear)(_this.props.maxDate) : null;\n            if (!maxYear || !_this.state.yearsList.find(function (year) { return year === maxYear; })) {\n                options.unshift(react__WEBPACK_IMPORTED_MODULE_1___default().createElement(\"div\", { className: \"react-datepicker__year-option\", key: \"upcoming\", onClick: _this.incrementYears },\n                    react__WEBPACK_IMPORTED_MODULE_1___default().createElement(\"a\", { className: \"react-datepicker__navigation react-datepicker__navigation--years react-datepicker__navigation--years-upcoming\" })));\n            }\n            if (!minYear || !_this.state.yearsList.find(function (year) { return year === minYear; })) {\n                options.push(react__WEBPACK_IMPORTED_MODULE_1___default().createElement(\"div\", { className: \"react-datepicker__year-option\", key: \"previous\", onClick: _this.decrementYears },\n                    react__WEBPACK_IMPORTED_MODULE_1___default().createElement(\"a\", { className: \"react-datepicker__navigation react-datepicker__navigation--years react-datepicker__navigation--years-previous\" })));\n            }\n            return options;\n        };\n        _this.onChange = function (year) {\n            _this.props.onChange(year);\n        };\n        _this.handleClickOutside = function () {\n            _this.props.onCancel();\n        };\n        _this.shiftYears = function (amount) {\n            var years = _this.state.yearsList.map(function (year) {\n                return year + amount;\n            });\n            _this.setState({\n                yearsList: years,\n            });\n        };\n        _this.incrementYears = function () {\n            return _this.shiftYears(1);\n        };\n        _this.decrementYears = function () {\n            return _this.shiftYears(-1);\n        };\n        var yearDropdownItemNumber = props.yearDropdownItemNumber, scrollableYearDropdown = props.scrollableYearDropdown;\n        var noOfYear = yearDropdownItemNumber || (scrollableYearDropdown ? 10 : 5);\n        _this.state = {\n            yearsList: generateYears(_this.props.year, noOfYear, _this.props.minDate, _this.props.maxDate),\n        };\n        _this.dropdownRef = (0,react__WEBPACK_IMPORTED_MODULE_1__.createRef)();\n        return _this;\n    }\n    YearDropdownOptions.prototype.componentDidMount = function () {\n        var dropdownCurrent = this.dropdownRef.current;\n        if (dropdownCurrent) {\n            // Get array from HTMLCollection\n            var dropdownCurrentChildren = dropdownCurrent.children\n                ? Array.from(dropdownCurrent.children)\n                : null;\n            var selectedYearOptionEl = dropdownCurrentChildren\n                ? dropdownCurrentChildren.find(function (childEl) { return childEl.ariaSelected; })\n                : null;\n            dropdownCurrent.scrollTop =\n                selectedYearOptionEl && selectedYearOptionEl instanceof HTMLElement\n                    ? selectedYearOptionEl.offsetTop +\n                        (selectedYearOptionEl.clientHeight - dropdownCurrent.clientHeight) /\n                            2\n                    : (dropdownCurrent.scrollHeight - dropdownCurrent.clientHeight) / 2;\n        }\n    };\n    YearDropdownOptions.prototype.render = function () {\n        var dropdownClass = (0,clsx__WEBPACK_IMPORTED_MODULE_0__.clsx)({\n            \"react-datepicker__year-dropdown\": true,\n            \"react-datepicker__year-dropdown--scrollable\": this.props.scrollableYearDropdown,\n        });\n        return (react__WEBPACK_IMPORTED_MODULE_1___default().createElement(ClickOutsideWrapper, { className: dropdownClass, containerRef: this.dropdownRef, onClickOutside: this.handleClickOutside }, this.renderOptions()));\n    };\n    return YearDropdownOptions;\n}(react__WEBPACK_IMPORTED_MODULE_1__.Component));\n\nvar YearDropdown = /** @class */ (function (_super) {\n    __extends(YearDropdown, _super);\n    function YearDropdown() {\n        var _this = _super !== null && _super.apply(this, arguments) || this;\n        _this.state = {\n            dropdownVisible: false,\n        };\n        _this.renderSelectOptions = function () {\n            var minYear = _this.props.minDate\n                ? (0,date_fns__WEBPACK_IMPORTED_MODULE_29__.getYear)(_this.props.minDate)\n                : 1900;\n            var maxYear = _this.props.maxDate\n                ? (0,date_fns__WEBPACK_IMPORTED_MODULE_29__.getYear)(_this.props.maxDate)\n                : 2100;\n            var options = [];\n            for (var i = minYear; i <= maxYear; i++) {\n                options.push(react__WEBPACK_IMPORTED_MODULE_1___default().createElement(\"option\", { key: i, value: i }, i));\n            }\n            return options;\n        };\n        _this.onSelectChange = function (event) {\n            _this.onChange(parseInt(event.target.value));\n        };\n        _this.renderSelectMode = function () { return (react__WEBPACK_IMPORTED_MODULE_1___default().createElement(\"select\", { value: _this.props.year, className: \"react-datepicker__year-select\", onChange: _this.onSelectChange }, _this.renderSelectOptions())); };\n        _this.renderReadView = function (visible) { return (react__WEBPACK_IMPORTED_MODULE_1___default().createElement(\"button\", { key: \"read\", type: \"button\", style: { visibility: visible ? \"visible\" : \"hidden\" }, className: \"react-datepicker__year-read-view\", onClick: _this.toggleDropdown },\n            react__WEBPACK_IMPORTED_MODULE_1___default().createElement(\"span\", { className: \"react-datepicker__year-read-view--down-arrow\" }),\n            react__WEBPACK_IMPORTED_MODULE_1___default().createElement(\"span\", { className: \"react-datepicker__year-read-view--selected-year\" }, _this.props.year))); };\n        _this.renderDropdown = function () { return (react__WEBPACK_IMPORTED_MODULE_1___default().createElement(YearDropdownOptions, _assign({ key: \"dropdown\" }, _this.props, { onChange: _this.onChange, onCancel: _this.toggleDropdown }))); };\n        _this.renderScrollMode = function () {\n            var dropdownVisible = _this.state.dropdownVisible;\n            var result = [_this.renderReadView(!dropdownVisible)];\n            if (dropdownVisible) {\n                result.unshift(_this.renderDropdown());\n            }\n            return result;\n        };\n        _this.onChange = function (year) {\n            _this.toggleDropdown();\n            if (year === _this.props.year)\n                return;\n            _this.props.onChange(year);\n        };\n        _this.toggleDropdown = function (event) {\n            _this.setState({\n                dropdownVisible: !_this.state.dropdownVisible,\n            }, function () {\n                if (_this.props.adjustDateOnChange) {\n                    _this.handleYearChange(_this.props.date, event);\n                }\n            });\n        };\n        _this.handleYearChange = function (date, event) {\n            var _a;\n            (_a = _this.onSelect) === null || _a === void 0 ? void 0 : _a.call(_this, date, event);\n            _this.setOpen();\n        };\n        _this.onSelect = function (date, event) {\n            var _a, _b;\n            (_b = (_a = _this.props).onSelect) === null || _b === void 0 ? void 0 : _b.call(_a, date, event);\n        };\n        _this.setOpen = function () {\n            var _a, _b;\n            (_b = (_a = _this.props).setOpen) === null || _b === void 0 ? void 0 : _b.call(_a, true);\n        };\n        return _this;\n    }\n    YearDropdown.prototype.render = function () {\n        var renderedDropdown;\n        switch (this.props.dropdownMode) {\n            case \"scroll\":\n                renderedDropdown = this.renderScrollMode();\n                break;\n            case \"select\":\n                renderedDropdown = this.renderSelectMode();\n                break;\n        }\n        return (react__WEBPACK_IMPORTED_MODULE_1___default().createElement(\"div\", { className: \"react-datepicker__year-dropdown-container react-datepicker__year-dropdown-container--\".concat(this.props.dropdownMode) }, renderedDropdown));\n    };\n    return YearDropdown;\n}(react__WEBPACK_IMPORTED_MODULE_1__.Component));\n\nvar DROPDOWN_FOCUS_CLASSNAMES = [\n    \"react-datepicker__year-select\",\n    \"react-datepicker__month-select\",\n    \"react-datepicker__month-year-select\",\n];\nvar OUTSIDE_CLICK_IGNORE_CLASS = \"react-datepicker-ignore-onclickoutside\";\nvar isDropdownSelect = function (element) {\n    var classNames = (element.className || \"\").split(/\\s+/);\n    return DROPDOWN_FOCUS_CLASSNAMES.some(function (testClassname) { return classNames.indexOf(testClassname) >= 0; });\n};\nvar Calendar = /** @class */ (function (_super) {\n    __extends(Calendar, _super);\n    function Calendar(props) {\n        var _this = _super.call(this, props) || this;\n        _this.monthContainer = undefined;\n        _this.handleClickOutside = function (event) {\n            _this.props.onClickOutside(event);\n        };\n        _this.setClickOutsideRef = function () {\n            return _this.containerRef.current;\n        };\n        _this.handleDropdownFocus = function (event) {\n            var _a, _b;\n            if (isDropdownSelect(event.target)) {\n                (_b = (_a = _this.props).onDropdownFocus) === null || _b === void 0 ? void 0 : _b.call(_a, event);\n            }\n        };\n        _this.getDateInView = function () {\n            var _a = _this.props, preSelection = _a.preSelection, selected = _a.selected, openToDate = _a.openToDate;\n            var minDate = getEffectiveMinDate(_this.props);\n            var maxDate = getEffectiveMaxDate(_this.props);\n            var current = newDate();\n            var initialDate = openToDate || selected || preSelection;\n            if (initialDate) {\n                return initialDate;\n            }\n            else {\n                if (minDate && (0,date_fns__WEBPACK_IMPORTED_MODULE_7__.isBefore)(current, minDate)) {\n                    return minDate;\n                }\n                else if (maxDate && (0,date_fns__WEBPACK_IMPORTED_MODULE_52__.isAfter)(current, maxDate)) {\n                    return maxDate;\n                }\n            }\n            return current;\n        };\n        _this.increaseMonth = function () {\n            _this.setState(function (_a) {\n                var date = _a.date;\n                return ({\n                    date: (0,date_fns__WEBPACK_IMPORTED_MODULE_39__.addMonths)(date, 1),\n                });\n            }, function () { return _this.handleMonthChange(_this.state.date); });\n        };\n        _this.decreaseMonth = function () {\n            _this.setState(function (_a) {\n                var date = _a.date;\n                return ({\n                    date: (0,date_fns__WEBPACK_IMPORTED_MODULE_37__.subMonths)(date, 1),\n                });\n            }, function () { return _this.handleMonthChange(_this.state.date); });\n        };\n        _this.handleDayClick = function (day, event, monthSelectedIn) {\n            _this.props.onSelect(day, event, monthSelectedIn);\n            _this.props.setPreSelection && _this.props.setPreSelection(day);\n        };\n        _this.handleDayMouseEnter = function (day) {\n            _this.setState({ selectingDate: day });\n            _this.props.onDayMouseEnter && _this.props.onDayMouseEnter(day);\n        };\n        _this.handleMonthMouseLeave = function () {\n            _this.setState({ selectingDate: undefined });\n            _this.props.onMonthMouseLeave && _this.props.onMonthMouseLeave();\n        };\n        _this.handleYearMouseEnter = function (event, year) {\n            _this.setState({ selectingDate: (0,date_fns__WEBPACK_IMPORTED_MODULE_58__.setYear)(newDate(), year) });\n            !!_this.props.onYearMouseEnter && _this.props.onYearMouseEnter(event, year);\n        };\n        _this.handleYearMouseLeave = function (event, year) {\n            !!_this.props.onYearMouseLeave && _this.props.onYearMouseLeave(event, year);\n        };\n        _this.handleYearChange = function (date) {\n            var _a, _b, _c, _d;\n            (_b = (_a = _this.props).onYearChange) === null || _b === void 0 ? void 0 : _b.call(_a, date);\n            _this.setState({ isRenderAriaLiveMessage: true });\n            if (_this.props.adjustDateOnChange) {\n                _this.props.onSelect(date);\n                (_d = (_c = _this.props).setOpen) === null || _d === void 0 ? void 0 : _d.call(_c, true);\n            }\n            _this.props.setPreSelection && _this.props.setPreSelection(date);\n        };\n        _this.getEnabledPreSelectionDateForMonth = function (date) {\n            if (!isDayDisabled(date, _this.props)) {\n                return date;\n            }\n            var startOfMonth = getStartOfMonth(date);\n            var endOfMonth = getEndOfMonth(date);\n            var totalDays = (0,date_fns__WEBPACK_IMPORTED_MODULE_59__.differenceInDays)(endOfMonth, startOfMonth);\n            var preSelectedDate = null;\n            for (var dayIdx = 0; dayIdx <= totalDays; dayIdx++) {\n                var processingDate = (0,date_fns__WEBPACK_IMPORTED_MODULE_55__.addDays)(startOfMonth, dayIdx);\n                if (!isDayDisabled(processingDate, _this.props)) {\n                    preSelectedDate = processingDate;\n                    break;\n                }\n            }\n            return preSelectedDate;\n        };\n        _this.handleMonthChange = function (date) {\n            var _a, _b, _c;\n            var enabledPreSelectionDate = (_a = _this.getEnabledPreSelectionDateForMonth(date)) !== null && _a !== void 0 ? _a : date;\n            _this.handleCustomMonthChange(enabledPreSelectionDate);\n            if (_this.props.adjustDateOnChange) {\n                _this.props.onSelect(enabledPreSelectionDate);\n                (_c = (_b = _this.props).setOpen) === null || _c === void 0 ? void 0 : _c.call(_b, true);\n            }\n            _this.props.setPreSelection &&\n                _this.props.setPreSelection(enabledPreSelectionDate);\n        };\n        _this.handleCustomMonthChange = function (date) {\n            var _a, _b;\n            (_b = (_a = _this.props).onMonthChange) === null || _b === void 0 ? void 0 : _b.call(_a, date);\n            _this.setState({ isRenderAriaLiveMessage: true });\n        };\n        _this.handleMonthYearChange = function (date) {\n            _this.handleYearChange(date);\n            _this.handleMonthChange(date);\n        };\n        _this.changeYear = function (year) {\n            _this.setState(function (_a) {\n                var date = _a.date;\n                return ({\n                    date: (0,date_fns__WEBPACK_IMPORTED_MODULE_58__.setYear)(date, Number(year)),\n                });\n            }, function () { return _this.handleYearChange(_this.state.date); });\n        };\n        _this.changeMonth = function (month) {\n            _this.setState(function (_a) {\n                var date = _a.date;\n                return ({\n                    date: (0,date_fns__WEBPACK_IMPORTED_MODULE_27__.setMonth)(date, Number(month)),\n                });\n            }, function () { return _this.handleMonthChange(_this.state.date); });\n        };\n        _this.changeMonthYear = function (monthYear) {\n            _this.setState(function (_a) {\n                var date = _a.date;\n                return ({\n                    date: (0,date_fns__WEBPACK_IMPORTED_MODULE_58__.setYear)((0,date_fns__WEBPACK_IMPORTED_MODULE_27__.setMonth)(date, (0,date_fns__WEBPACK_IMPORTED_MODULE_30__.getMonth)(monthYear)), (0,date_fns__WEBPACK_IMPORTED_MODULE_29__.getYear)(monthYear)),\n                });\n            }, function () { return _this.handleMonthYearChange(_this.state.date); });\n        };\n        _this.header = function (date) {\n            if (date === void 0) { date = _this.state.date; }\n            // Return empty array if date is invalid\n            if (!isValid(date)) {\n                return [];\n            }\n            var disabled = _this.props.disabled;\n            var startOfWeek = getStartOfWeek(date, _this.props.locale, _this.props.calendarStartDay);\n            var dayNames = [];\n            if (_this.props.showWeekNumbers) {\n                dayNames.push(react__WEBPACK_IMPORTED_MODULE_1___default().createElement(\"div\", { key: \"W\", className: \"react-datepicker__day-name \".concat(disabled ? \"react-datepicker__day-name--disabled\" : \"\"), role: \"columnheader\" },\n                    react__WEBPACK_IMPORTED_MODULE_1___default().createElement(\"span\", { className: \"react-datepicker__sr-only\" }, \"Week number\"),\n                    react__WEBPACK_IMPORTED_MODULE_1___default().createElement(\"span\", { \"aria-hidden\": \"true\" }, _this.props.weekLabel || \"#\")));\n            }\n            return dayNames.concat([0, 1, 2, 3, 4, 5, 6].map(function (offset) {\n                var day = (0,date_fns__WEBPACK_IMPORTED_MODULE_55__.addDays)(startOfWeek, offset);\n                var weekDayName = _this.formatWeekday(day, _this.props.locale);\n                var weekDayClassName = _this.props.weekDayClassName\n                    ? _this.props.weekDayClassName(day)\n                    : undefined;\n                return (react__WEBPACK_IMPORTED_MODULE_1___default().createElement(\"div\", { key: offset, role: \"columnheader\", className: (0,clsx__WEBPACK_IMPORTED_MODULE_0__.clsx)(\"react-datepicker__day-name\", weekDayClassName, disabled ? \"react-datepicker__day-name--disabled\" : \"\") },\n                    react__WEBPACK_IMPORTED_MODULE_1___default().createElement(\"span\", { className: \"react-datepicker__sr-only\" }, formatDate(day, \"EEEE\", _this.props.locale)),\n                    react__WEBPACK_IMPORTED_MODULE_1___default().createElement(\"span\", { \"aria-hidden\": \"true\" }, weekDayName)));\n            }));\n        };\n        _this.formatWeekday = function (day, locale) {\n            if (_this.props.formatWeekDay) {\n                return getFormattedWeekdayInLocale(day, _this.props.formatWeekDay, locale);\n            }\n            return _this.props.useWeekdaysShort\n                ? getWeekdayShortInLocale(day, locale)\n                : getWeekdayMinInLocale(day, locale);\n        };\n        _this.decreaseYear = function () {\n            _this.setState(function (_a) {\n                var _b;\n                var date = _a.date;\n                return ({\n                    date: (0,date_fns__WEBPACK_IMPORTED_MODULE_43__.subYears)(date, _this.props.showYearPicker\n                        ? ((_b = _this.props.yearItemNumber) !== null && _b !== void 0 ? _b : Calendar.defaultProps.yearItemNumber)\n                        : 1),\n                });\n            }, function () { return _this.handleYearChange(_this.state.date); });\n        };\n        _this.clearSelectingDate = function () {\n            _this.setState({ selectingDate: undefined });\n        };\n        _this.renderPreviousButton = function () {\n            var _a, _b, _c;\n            if (_this.props.renderCustomHeader) {\n                return;\n            }\n            var monthsShown = (_a = _this.props.monthsShown) !== null && _a !== void 0 ? _a : Calendar.defaultProps.monthsShown;\n            var monthsToSubtract = _this.props.showPreviousMonths\n                ? monthsShown - 1\n                : 0;\n            var monthSelectedIn = (_b = _this.props.monthSelectedIn) !== null && _b !== void 0 ? _b : monthsToSubtract;\n            var fromMonthDate = (0,date_fns__WEBPACK_IMPORTED_MODULE_37__.subMonths)(_this.state.date, monthSelectedIn);\n            var allPrevDaysDisabled;\n            switch (true) {\n                case _this.props.disabled:\n                    allPrevDaysDisabled = true;\n                    break;\n                case _this.props.showMonthYearPicker:\n                    allPrevDaysDisabled = yearDisabledBefore(_this.state.date, _this.props);\n                    break;\n                case _this.props.showYearPicker:\n                    allPrevDaysDisabled = yearsDisabledBefore(_this.state.date, _this.props);\n                    break;\n                case _this.props.showQuarterYearPicker:\n                    allPrevDaysDisabled = quarterDisabledBefore(_this.state.date, _this.props);\n                    break;\n                default:\n                    allPrevDaysDisabled = monthDisabledBefore(fromMonthDate, _this.props);\n                    break;\n            }\n            if ((!((_c = _this.props.forceShowMonthNavigation) !== null && _c !== void 0 ? _c : Calendar.defaultProps.forceShowMonthNavigation) &&\n                !_this.props.showDisabledMonthNavigation &&\n                allPrevDaysDisabled) ||\n                _this.props.showTimeSelectOnly) {\n                return;\n            }\n            var iconClasses = [\n                \"react-datepicker__navigation-icon\",\n                \"react-datepicker__navigation-icon--previous\",\n            ];\n            var classes = [\n                \"react-datepicker__navigation\",\n                \"react-datepicker__navigation--previous\",\n            ];\n            var clickHandler = _this.decreaseMonth;\n            if (_this.props.showMonthYearPicker ||\n                _this.props.showQuarterYearPicker ||\n                _this.props.showYearPicker) {\n                clickHandler = _this.decreaseYear;\n            }\n            if (allPrevDaysDisabled && _this.props.showDisabledMonthNavigation) {\n                classes.push(\"react-datepicker__navigation--previous--disabled\");\n                clickHandler = undefined;\n            }\n            var isForYear = _this.props.showMonthYearPicker ||\n                _this.props.showQuarterYearPicker ||\n                _this.props.showYearPicker;\n            var _d = _this.props, _e = _d.previousMonthButtonLabel, previousMonthButtonLabel = _e === void 0 ? Calendar.defaultProps.previousMonthButtonLabel : _e, _f = _d.previousYearButtonLabel, previousYearButtonLabel = _f === void 0 ? Calendar.defaultProps.previousYearButtonLabel : _f;\n            var _g = _this.props, _h = _g.previousMonthAriaLabel, previousMonthAriaLabel = _h === void 0 ? typeof previousMonthButtonLabel === \"string\"\n                ? previousMonthButtonLabel\n                : \"Previous Month\" : _h, _j = _g.previousYearAriaLabel, previousYearAriaLabel = _j === void 0 ? typeof previousYearButtonLabel === \"string\"\n                ? previousYearButtonLabel\n                : \"Previous Year\" : _j;\n            return (react__WEBPACK_IMPORTED_MODULE_1___default().createElement(\"button\", { type: \"button\", className: classes.join(\" \"), onClick: clickHandler, onKeyDown: _this.props.handleOnKeyDown, \"aria-label\": isForYear ? previousYearAriaLabel : previousMonthAriaLabel },\n                react__WEBPACK_IMPORTED_MODULE_1___default().createElement(\"span\", { className: iconClasses.join(\" \") }, isForYear ? previousYearButtonLabel : previousMonthButtonLabel)));\n        };\n        _this.increaseYear = function () {\n            _this.setState(function (_a) {\n                var _b;\n                var date = _a.date;\n                return ({\n                    date: (0,date_fns__WEBPACK_IMPORTED_MODULE_45__.addYears)(date, _this.props.showYearPicker\n                        ? ((_b = _this.props.yearItemNumber) !== null && _b !== void 0 ? _b : Calendar.defaultProps.yearItemNumber)\n                        : 1),\n                });\n            }, function () { return _this.handleYearChange(_this.state.date); });\n        };\n        _this.renderNextButton = function () {\n            var _a;\n            if (_this.props.renderCustomHeader) {\n                return;\n            }\n            var allNextDaysDisabled;\n            switch (true) {\n                case _this.props.disabled:\n                    allNextDaysDisabled = true;\n                    break;\n                case _this.props.showMonthYearPicker:\n                    allNextDaysDisabled = yearDisabledAfter(_this.state.date, _this.props);\n                    break;\n                case _this.props.showYearPicker:\n                    allNextDaysDisabled = yearsDisabledAfter(_this.state.date, _this.props);\n                    break;\n                case _this.props.showQuarterYearPicker:\n                    allNextDaysDisabled = quarterDisabledAfter(_this.state.date, _this.props);\n                    break;\n                default:\n                    allNextDaysDisabled = monthDisabledAfter(_this.state.date, _this.props);\n                    break;\n            }\n            if ((!((_a = _this.props.forceShowMonthNavigation) !== null && _a !== void 0 ? _a : Calendar.defaultProps.forceShowMonthNavigation) &&\n                !_this.props.showDisabledMonthNavigation &&\n                allNextDaysDisabled) ||\n                _this.props.showTimeSelectOnly) {\n                return;\n            }\n            var classes = [\n                \"react-datepicker__navigation\",\n                \"react-datepicker__navigation--next\",\n            ];\n            var iconClasses = [\n                \"react-datepicker__navigation-icon\",\n                \"react-datepicker__navigation-icon--next\",\n            ];\n            if (_this.props.showTimeSelect) {\n                classes.push(\"react-datepicker__navigation--next--with-time\");\n            }\n            if (_this.props.todayButton) {\n                classes.push(\"react-datepicker__navigation--next--with-today-button\");\n            }\n            var clickHandler = _this.increaseMonth;\n            if (_this.props.showMonthYearPicker ||\n                _this.props.showQuarterYearPicker ||\n                _this.props.showYearPicker) {\n                clickHandler = _this.increaseYear;\n            }\n            if (allNextDaysDisabled && _this.props.showDisabledMonthNavigation) {\n                classes.push(\"react-datepicker__navigation--next--disabled\");\n                clickHandler = undefined;\n            }\n            var isForYear = _this.props.showMonthYearPicker ||\n                _this.props.showQuarterYearPicker ||\n                _this.props.showYearPicker;\n            var _b = _this.props, _c = _b.nextMonthButtonLabel, nextMonthButtonLabel = _c === void 0 ? Calendar.defaultProps.nextMonthButtonLabel : _c, _d = _b.nextYearButtonLabel, nextYearButtonLabel = _d === void 0 ? Calendar.defaultProps.nextYearButtonLabel : _d;\n            var _e = _this.props, _f = _e.nextMonthAriaLabel, nextMonthAriaLabel = _f === void 0 ? typeof nextMonthButtonLabel === \"string\"\n                ? nextMonthButtonLabel\n                : \"Next Month\" : _f, _g = _e.nextYearAriaLabel, nextYearAriaLabel = _g === void 0 ? typeof nextYearButtonLabel === \"string\"\n                ? nextYearButtonLabel\n                : \"Next Year\" : _g;\n            return (react__WEBPACK_IMPORTED_MODULE_1___default().createElement(\"button\", { type: \"button\", className: classes.join(\" \"), onClick: clickHandler, onKeyDown: _this.props.handleOnKeyDown, \"aria-label\": isForYear ? nextYearAriaLabel : nextMonthAriaLabel },\n                react__WEBPACK_IMPORTED_MODULE_1___default().createElement(\"span\", { className: iconClasses.join(\" \") }, isForYear ? nextYearButtonLabel : nextMonthButtonLabel)));\n        };\n        _this.renderCurrentMonth = function (date) {\n            if (date === void 0) { date = _this.state.date; }\n            var classes = [\"react-datepicker__current-month\"];\n            if (_this.props.showYearDropdown) {\n                classes.push(\"react-datepicker__current-month--hasYearDropdown\");\n            }\n            if (_this.props.showMonthDropdown) {\n                classes.push(\"react-datepicker__current-month--hasMonthDropdown\");\n            }\n            if (_this.props.showMonthYearDropdown) {\n                classes.push(\"react-datepicker__current-month--hasMonthYearDropdown\");\n            }\n            return (react__WEBPACK_IMPORTED_MODULE_1___default().createElement(\"h2\", { className: classes.join(\" \") }, isValid(date)\n                ? formatDate(date, _this.props.dateFormat, _this.props.locale)\n                : \"\"));\n        };\n        _this.renderYearDropdown = function (overrideHide) {\n            if (overrideHide === void 0) { overrideHide = false; }\n            if (!_this.props.showYearDropdown || overrideHide) {\n                return;\n            }\n            return (react__WEBPACK_IMPORTED_MODULE_1___default().createElement(YearDropdown, _assign({}, Calendar.defaultProps, _this.props, { date: _this.state.date, onChange: _this.changeYear, year: (0,date_fns__WEBPACK_IMPORTED_MODULE_29__.getYear)(_this.state.date) })));\n        };\n        _this.renderMonthDropdown = function (overrideHide) {\n            if (overrideHide === void 0) { overrideHide = false; }\n            if (!_this.props.showMonthDropdown || overrideHide) {\n                return;\n            }\n            return (react__WEBPACK_IMPORTED_MODULE_1___default().createElement(MonthDropdown, _assign({}, Calendar.defaultProps, _this.props, { month: (0,date_fns__WEBPACK_IMPORTED_MODULE_30__.getMonth)(_this.state.date), onChange: _this.changeMonth })));\n        };\n        _this.renderMonthYearDropdown = function (overrideHide) {\n            if (overrideHide === void 0) { overrideHide = false; }\n            if (!_this.props.showMonthYearDropdown || overrideHide) {\n                return;\n            }\n            return (react__WEBPACK_IMPORTED_MODULE_1___default().createElement(MonthYearDropdown, _assign({}, Calendar.defaultProps, _this.props, { date: _this.state.date, onChange: _this.changeMonthYear })));\n        };\n        _this.handleTodayButtonClick = function (event) {\n            _this.props.onSelect(getStartOfToday(), event);\n            _this.props.setPreSelection && _this.props.setPreSelection(getStartOfToday());\n        };\n        _this.renderTodayButton = function () {\n            if (!_this.props.todayButton || _this.props.showTimeSelectOnly) {\n                return;\n            }\n            return (react__WEBPACK_IMPORTED_MODULE_1___default().createElement(\"div\", { className: \"react-datepicker__today-button\", onClick: _this.handleTodayButtonClick }, _this.props.todayButton));\n        };\n        _this.renderDayNamesHeader = function (monthDate) { return (react__WEBPACK_IMPORTED_MODULE_1___default().createElement(\"div\", { className: \"react-datepicker__day-names\", role: \"row\" }, _this.header(monthDate))); };\n        _this.renderDefaultHeader = function (_a) {\n            var monthDate = _a.monthDate, i = _a.i;\n            return (react__WEBPACK_IMPORTED_MODULE_1___default().createElement(\"div\", { className: \"react-datepicker__header \".concat(_this.props.showTimeSelect\n                    ? \"react-datepicker__header--has-time-select\"\n                    : \"\") },\n                _this.renderCurrentMonth(monthDate),\n                react__WEBPACK_IMPORTED_MODULE_1___default().createElement(\"div\", { className: \"react-datepicker__header__dropdown react-datepicker__header__dropdown--\".concat(_this.props.dropdownMode), onFocus: _this.handleDropdownFocus },\n                    _this.renderMonthDropdown(i !== 0),\n                    _this.renderMonthYearDropdown(i !== 0),\n                    _this.renderYearDropdown(i !== 0))));\n        };\n        _this.renderCustomHeader = function (headerArgs) {\n            var _a, _b;\n            var monthDate = headerArgs.monthDate, i = headerArgs.i;\n            if ((_this.props.showTimeSelect && !_this.state.monthContainer) ||\n                _this.props.showTimeSelectOnly) {\n                return null;\n            }\n            var _c = _this.props, showYearPicker = _c.showYearPicker, yearItemNumber = _c.yearItemNumber;\n            var visibleYearsRange;\n            if (showYearPicker) {\n                var _d = getYearsPeriod(monthDate, yearItemNumber), startYear = _d.startPeriod, endYear = _d.endPeriod;\n                visibleYearsRange = {\n                    startYear: startYear,\n                    endYear: endYear,\n                };\n            }\n            var prevMonthButtonDisabled = monthDisabledBefore(_this.state.date, _this.props);\n            var nextMonthButtonDisabled = monthDisabledAfter(_this.state.date, _this.props);\n            var prevYearButtonDisabled = yearDisabledBefore(_this.state.date, _this.props);\n            var nextYearButtonDisabled = yearDisabledAfter(_this.state.date, _this.props);\n            return (react__WEBPACK_IMPORTED_MODULE_1___default().createElement(\"div\", { className: \"react-datepicker__header react-datepicker__header--custom\", onFocus: _this.props.onDropdownFocus }, (_b = (_a = _this.props).renderCustomHeader) === null || _b === void 0 ? void 0 : _b.call(_a, _assign(_assign(_assign({}, _this.state), (showYearPicker && { visibleYearsRange: visibleYearsRange })), { customHeaderCount: i, monthDate: monthDate, changeMonth: _this.changeMonth, changeYear: _this.changeYear, decreaseMonth: _this.decreaseMonth, increaseMonth: _this.increaseMonth, decreaseYear: _this.decreaseYear, increaseYear: _this.increaseYear, prevMonthButtonDisabled: prevMonthButtonDisabled, nextMonthButtonDisabled: nextMonthButtonDisabled, prevYearButtonDisabled: prevYearButtonDisabled, nextYearButtonDisabled: nextYearButtonDisabled }))));\n        };\n        _this.renderYearHeader = function (_a) {\n            var monthDate = _a.monthDate;\n            var _b = _this.props, showYearPicker = _b.showYearPicker, _c = _b.yearItemNumber, yearItemNumber = _c === void 0 ? Calendar.defaultProps.yearItemNumber : _c;\n            var _d = getYearsPeriod(monthDate, yearItemNumber), startPeriod = _d.startPeriod, endPeriod = _d.endPeriod;\n            return (react__WEBPACK_IMPORTED_MODULE_1___default().createElement(\"div\", { className: \"react-datepicker__header react-datepicker-year-header\" }, showYearPicker ? \"\".concat(startPeriod, \" - \").concat(endPeriod) : (0,date_fns__WEBPACK_IMPORTED_MODULE_29__.getYear)(monthDate)));\n        };\n        _this.renderHeader = function (_a) {\n            var monthDate = _a.monthDate, _b = _a.i, i = _b === void 0 ? 0 : _b;\n            var headerArgs = { monthDate: monthDate, i: i };\n            switch (true) {\n                case _this.props.renderCustomHeader !== undefined:\n                    return _this.renderCustomHeader(headerArgs);\n                case _this.props.showMonthYearPicker ||\n                    _this.props.showQuarterYearPicker ||\n                    _this.props.showYearPicker:\n                    return _this.renderYearHeader(headerArgs);\n                default:\n                    return _this.renderDefaultHeader(headerArgs);\n            }\n        };\n        _this.renderMonths = function () {\n            var _a, _b;\n            if (_this.props.showTimeSelectOnly || _this.props.showYearPicker) {\n                return;\n            }\n            var monthList = [];\n            var monthsShown = (_a = _this.props.monthsShown) !== null && _a !== void 0 ? _a : Calendar.defaultProps.monthsShown;\n            var monthsToSubtract = _this.props.showPreviousMonths\n                ? monthsShown - 1\n                : 0;\n            var fromMonthDate = _this.props.showMonthYearPicker || _this.props.showQuarterYearPicker\n                ? (0,date_fns__WEBPACK_IMPORTED_MODULE_45__.addYears)(_this.state.date, monthsToSubtract)\n                : (0,date_fns__WEBPACK_IMPORTED_MODULE_37__.subMonths)(_this.state.date, monthsToSubtract);\n            var monthSelectedIn = (_b = _this.props.monthSelectedIn) !== null && _b !== void 0 ? _b : monthsToSubtract;\n            for (var i = 0; i < monthsShown; ++i) {\n                var monthsToAdd = i - monthSelectedIn + monthsToSubtract;\n                var monthDate = _this.props.showMonthYearPicker || _this.props.showQuarterYearPicker\n                    ? (0,date_fns__WEBPACK_IMPORTED_MODULE_45__.addYears)(fromMonthDate, monthsToAdd)\n                    : (0,date_fns__WEBPACK_IMPORTED_MODULE_39__.addMonths)(fromMonthDate, monthsToAdd);\n                var monthKey = \"month-\".concat(i);\n                var monthShowsDuplicateDaysEnd = i < monthsShown - 1;\n                var monthShowsDuplicateDaysStart = i > 0;\n                monthList.push(react__WEBPACK_IMPORTED_MODULE_1___default().createElement(\"div\", { key: monthKey, ref: function (div) {\n                        _this.monthContainer = div !== null && div !== void 0 ? div : undefined;\n                    }, className: \"react-datepicker__month-container\" },\n                    _this.renderHeader({ monthDate: monthDate, i: i }),\n                    react__WEBPACK_IMPORTED_MODULE_1___default().createElement(Month, _assign({}, Calendar.defaultProps, _this.props, { containerRef: _this.containerRef, ariaLabelPrefix: _this.props.monthAriaLabelPrefix, day: monthDate, onDayClick: _this.handleDayClick, handleOnKeyDown: _this.props.handleOnDayKeyDown, handleOnMonthKeyDown: _this.props.handleOnKeyDown, onDayMouseEnter: _this.handleDayMouseEnter, onMouseLeave: _this.handleMonthMouseLeave, orderInDisplay: i, selectingDate: _this.state.selectingDate, monthShowsDuplicateDaysEnd: monthShowsDuplicateDaysEnd, monthShowsDuplicateDaysStart: monthShowsDuplicateDaysStart, dayNamesHeader: _this.renderDayNamesHeader(monthDate) }))));\n            }\n            return monthList;\n        };\n        _this.renderYears = function () {\n            if (_this.props.showTimeSelectOnly) {\n                return;\n            }\n            if (_this.props.showYearPicker) {\n                return (react__WEBPACK_IMPORTED_MODULE_1___default().createElement(\"div\", { className: \"react-datepicker__year--container\" },\n                    _this.renderHeader({ monthDate: _this.state.date }),\n                    react__WEBPACK_IMPORTED_MODULE_1___default().createElement(Year, _assign({}, Calendar.defaultProps, _this.props, { selectingDate: _this.state.selectingDate, date: _this.state.date, onDayClick: _this.handleDayClick, clearSelectingDate: _this.clearSelectingDate, onYearMouseEnter: _this.handleYearMouseEnter, onYearMouseLeave: _this.handleYearMouseLeave }))));\n            }\n            return;\n        };\n        _this.renderTimeSection = function () {\n            if (_this.props.showTimeSelect &&\n                (_this.state.monthContainer || _this.props.showTimeSelectOnly)) {\n                return (react__WEBPACK_IMPORTED_MODULE_1___default().createElement(Time, _assign({}, Calendar.defaultProps, _this.props, { onChange: _this.props.onTimeChange, format: _this.props.timeFormat, intervals: _this.props.timeIntervals, monthRef: _this.state.monthContainer })));\n            }\n            return;\n        };\n        _this.renderInputTimeSection = function () {\n            var time = _this.props.selected\n                ? new Date(_this.props.selected)\n                : undefined;\n            var timeValid = time && isValid(time) && Boolean(_this.props.selected);\n            var timeString = timeValid\n                ? \"\".concat(addZero(time.getHours()), \":\").concat(addZero(time.getMinutes()))\n                : \"\";\n            if (_this.props.showTimeInput) {\n                return (react__WEBPACK_IMPORTED_MODULE_1___default().createElement(InputTime, _assign({}, Calendar.defaultProps, _this.props, { date: time, timeString: timeString, onChange: _this.props.onTimeChange })));\n            }\n            return;\n        };\n        _this.renderAriaLiveRegion = function () {\n            var _a;\n            // Don't render aria-live message if date is invalid\n            if (!isValid(_this.state.date)) {\n                return (react__WEBPACK_IMPORTED_MODULE_1___default().createElement(\"span\", { role: \"alert\", \"aria-live\": \"polite\", className: \"react-datepicker__aria-live\" }));\n            }\n            var _b = getYearsPeriod(_this.state.date, (_a = _this.props.yearItemNumber) !== null && _a !== void 0 ? _a : Calendar.defaultProps.yearItemNumber), startPeriod = _b.startPeriod, endPeriod = _b.endPeriod;\n            var ariaLiveMessage;\n            if (_this.props.showYearPicker) {\n                ariaLiveMessage = \"\".concat(startPeriod, \" - \").concat(endPeriod);\n            }\n            else if (_this.props.showMonthYearPicker ||\n                _this.props.showQuarterYearPicker) {\n                ariaLiveMessage = (0,date_fns__WEBPACK_IMPORTED_MODULE_29__.getYear)(_this.state.date);\n            }\n            else {\n                ariaLiveMessage = \"\".concat(getMonthInLocale((0,date_fns__WEBPACK_IMPORTED_MODULE_30__.getMonth)(_this.state.date), _this.props.locale), \" \").concat((0,date_fns__WEBPACK_IMPORTED_MODULE_29__.getYear)(_this.state.date));\n            }\n            return (react__WEBPACK_IMPORTED_MODULE_1___default().createElement(\"span\", { role: \"alert\", \"aria-live\": \"polite\", className: \"react-datepicker__aria-live\" }, _this.state.isRenderAriaLiveMessage && ariaLiveMessage));\n        };\n        _this.renderChildren = function () {\n            if (_this.props.children) {\n                return (react__WEBPACK_IMPORTED_MODULE_1___default().createElement(\"div\", { className: \"react-datepicker__children-container\" }, _this.props.children));\n            }\n            return;\n        };\n        _this.containerRef = (0,react__WEBPACK_IMPORTED_MODULE_1__.createRef)();\n        _this.state = {\n            date: _this.getDateInView(),\n            selectingDate: undefined,\n            monthContainer: undefined,\n            isRenderAriaLiveMessage: false,\n        };\n        return _this;\n    }\n    Object.defineProperty(Calendar, \"defaultProps\", {\n        get: function () {\n            return {\n                monthsShown: 1,\n                forceShowMonthNavigation: false,\n                outsideClickIgnoreClass: OUTSIDE_CLICK_IGNORE_CLASS,\n                timeCaption: \"Time\",\n                previousYearButtonLabel: \"Previous Year\",\n                nextYearButtonLabel: \"Next Year\",\n                previousMonthButtonLabel: \"Previous Month\",\n                nextMonthButtonLabel: \"Next Month\",\n                yearItemNumber: DEFAULT_YEAR_ITEM_NUMBER,\n            };\n        },\n        enumerable: false,\n        configurable: true\n    });\n    Calendar.prototype.componentDidMount = function () {\n        var _this = this;\n        // monthContainer height is needed in time component\n        // to determine the height for the ul in the time component\n        // setState here so height is given after final component\n        // layout is rendered\n        if (this.props.showTimeSelect) {\n            this.assignMonthContainer = (function () {\n                _this.setState({ monthContainer: _this.monthContainer });\n            })();\n        }\n    };\n    Calendar.prototype.componentDidUpdate = function (prevProps) {\n        var _this = this;\n        if (this.props.preSelection &&\n            isValid(this.props.preSelection) &&\n            (!isSameDay(this.props.preSelection, prevProps.preSelection) ||\n                this.props.monthSelectedIn !== prevProps.monthSelectedIn)) {\n            var hasMonthChanged_1 = !isSameMonth(this.state.date, this.props.preSelection);\n            this.setState({\n                date: this.props.preSelection,\n            }, function () { return hasMonthChanged_1 && _this.handleCustomMonthChange(_this.state.date); });\n        }\n        else if (this.props.openToDate &&\n            !isSameDay(this.props.openToDate, prevProps.openToDate)) {\n            this.setState({\n                date: this.props.openToDate,\n            });\n        }\n    };\n    Calendar.prototype.render = function () {\n        var Container = this.props.container || CalendarContainer;\n        return (react__WEBPACK_IMPORTED_MODULE_1___default().createElement(ClickOutsideWrapper, { onClickOutside: this.handleClickOutside, style: { display: \"contents\" }, ignoreClass: this.props.outsideClickIgnoreClass },\n            react__WEBPACK_IMPORTED_MODULE_1___default().createElement(\"div\", { style: { display: \"contents\" }, ref: this.containerRef },\n                react__WEBPACK_IMPORTED_MODULE_1___default().createElement(Container, { className: (0,clsx__WEBPACK_IMPORTED_MODULE_0__.clsx)(\"react-datepicker\", this.props.className, {\n                        \"react-datepicker--time-only\": this.props.showTimeSelectOnly,\n                    }), showTime: this.props.showTimeSelect || this.props.showTimeInput, showTimeSelectOnly: this.props.showTimeSelectOnly, inline: this.props.inline },\n                    this.renderAriaLiveRegion(),\n                    this.renderPreviousButton(),\n                    this.renderNextButton(),\n                    this.renderMonths(),\n                    this.renderYears(),\n                    this.renderTodayButton(),\n                    this.renderTimeSection(),\n                    this.renderInputTimeSection(),\n                    this.renderChildren()))));\n    };\n    return Calendar;\n}(react__WEBPACK_IMPORTED_MODULE_1__.Component));\n\n/**\n * `CalendarIcon` is a React component that renders an icon for a calendar.\n * The icon can be a string representing a CSS class, a React node, or a default SVG icon.\n *\n * @component\n * @prop  icon - The icon to be displayed. This can be a string representing a CSS class or a React node.\n * @prop  className - An optional string representing additional CSS classes to be applied to the icon.\n * @prop  onClick - An optional function to be called when the icon is clicked.\n *\n * @example\n * // To use a CSS class as the icon\n * <CalendarIcon icon=\"my-icon-class\" onClick={myClickHandler} />\n *\n * @example\n * // To use a React node as the icon\n * <CalendarIcon icon={<MyIconComponent />} onClick={myClickHandler} />\n *\n * @returns  The `CalendarIcon` component.\n */\nvar CalendarIcon = function (_a) {\n    var icon = _a.icon, _b = _a.className, className = _b === void 0 ? \"\" : _b, onClick = _a.onClick;\n    var defaultClass = \"react-datepicker__calendar-icon\";\n    if (typeof icon === \"string\") {\n        return (react__WEBPACK_IMPORTED_MODULE_1___default().createElement(\"i\", { className: \"\".concat(defaultClass, \" \").concat(icon, \" \").concat(className), \"aria-hidden\": \"true\", onClick: onClick }));\n    }\n    if (react__WEBPACK_IMPORTED_MODULE_1___default().isValidElement(icon)) {\n        // Because we are checking that typeof icon is string first, we can safely cast icon as React.ReactElement on types level and code level\n        var iconElement_1 = icon;\n        return react__WEBPACK_IMPORTED_MODULE_1___default().cloneElement(iconElement_1, {\n            className: \"\".concat(iconElement_1.props.className || \"\", \" \").concat(defaultClass, \" \").concat(className),\n            onClick: function (event) {\n                if (typeof iconElement_1.props.onClick === \"function\") {\n                    iconElement_1.props.onClick(event);\n                }\n                if (typeof onClick === \"function\") {\n                    onClick(event);\n                }\n            },\n        });\n    }\n    // Default SVG Icon\n    return (react__WEBPACK_IMPORTED_MODULE_1___default().createElement(\"svg\", { className: \"\".concat(defaultClass, \" \").concat(className), xmlns: \"http://www.w3.org/2000/svg\", viewBox: \"0 0 448 512\", onClick: onClick },\n        react__WEBPACK_IMPORTED_MODULE_1___default().createElement(\"path\", { d: \"M96 32V64H48C21.5 64 0 85.5 0 112v48H448V112c0-26.5-21.5-48-48-48H352V32c0-17.7-14.3-32-32-32s-32 14.3-32 32V64H160V32c0-17.7-14.3-32-32-32S96 14.3 96 32zM448 192H0V464c0 26.5 21.5 48 48 48H400c26.5 0 48-21.5 48-48V192z\" })));\n};\n\n/**\n * `Portal` is a React component that allows you to render children into a DOM node\n * that exists outside the DOM hierarchy of the parent component.\n *\n * @class\n * @param {PortalProps} props - The properties that define the `Portal` component.\n * @property {React.ReactNode} props.children - The children to be rendered into the `Portal`.\n * @property {string} props.portalId - The id of the DOM node into which the `Portal` will render.\n * @property {ShadowRoot} [props.portalHost] - The DOM node to host the `Portal`.\n */\nvar Portal = /** @class */ (function (_super) {\n    __extends(Portal, _super);\n    function Portal(props) {\n        var _this = _super.call(this, props) || this;\n        _this.portalRoot = null;\n        _this.el = document.createElement(\"div\");\n        return _this;\n    }\n    Portal.prototype.componentDidMount = function () {\n        this.portalRoot = (this.props.portalHost || document).getElementById(this.props.portalId);\n        if (!this.portalRoot) {\n            this.portalRoot = document.createElement(\"div\");\n            this.portalRoot.setAttribute(\"id\", this.props.portalId);\n            (this.props.portalHost || document.body).appendChild(this.portalRoot);\n        }\n        this.portalRoot.appendChild(this.el);\n    };\n    Portal.prototype.componentWillUnmount = function () {\n        if (this.portalRoot) {\n            this.portalRoot.removeChild(this.el);\n        }\n    };\n    Portal.prototype.render = function () {\n        return react_dom__WEBPACK_IMPORTED_MODULE_2___default().createPortal(this.props.children, this.el);\n    };\n    return Portal;\n}(react__WEBPACK_IMPORTED_MODULE_1__.Component));\n\nvar focusableElementsSelector = \"[tabindex], a, button, input, select, textarea\";\nvar focusableFilter = function (node) {\n    if (node instanceof HTMLAnchorElement) {\n        return node.tabIndex !== -1;\n    }\n    return !node.disabled && node.tabIndex !== -1;\n};\n/**\n * `TabLoop` is a React component that manages tabbing behavior for its children.\n *\n * TabLoop prevents the user from tabbing outside of the popper\n * It creates a tabindex loop so that \"Tab\" on the last element will focus the first element\n * and \"Shift Tab\" on the first element will focus the last element\n *\n * @component\n * @example\n * <TabLoop enableTabLoop={true}>\n *   <ChildComponent />\n * </TabLoop>\n *\n * @param props - The properties that define the `TabLoop` component.\n * @param props.children - The child components.\n * @param props.enableTabLoop - Whether to enable the tab loop.\n *\n * @returns The `TabLoop` component.\n */\nvar TabLoop = /** @class */ (function (_super) {\n    __extends(TabLoop, _super);\n    function TabLoop(props) {\n        var _this = _super.call(this, props) || this;\n        /**\n         * `getTabChildren` is a method of the `TabLoop` class that retrieves all tabbable children of the component.\n         *\n         * This method uses the `tabbable` library to find all tabbable elements within the `TabLoop` component.\n         * It then filters out any elements that are not visible.\n         *\n         * @returns An array of all tabbable and visible children of the `TabLoop` component.\n         */\n        _this.getTabChildren = function () {\n            var _a;\n            return Array.prototype.slice\n                .call((_a = _this.tabLoopRef.current) === null || _a === void 0 ? void 0 : _a.querySelectorAll(focusableElementsSelector), 1, -1)\n                .filter(focusableFilter);\n        };\n        _this.handleFocusStart = function () {\n            var tabChildren = _this.getTabChildren();\n            tabChildren &&\n                tabChildren.length > 1 &&\n                tabChildren[tabChildren.length - 1].focus();\n        };\n        _this.handleFocusEnd = function () {\n            var tabChildren = _this.getTabChildren();\n            tabChildren && tabChildren.length > 1 && tabChildren[0].focus();\n        };\n        _this.tabLoopRef = (0,react__WEBPACK_IMPORTED_MODULE_1__.createRef)();\n        return _this;\n    }\n    TabLoop.prototype.render = function () {\n        var _a;\n        if (!((_a = this.props.enableTabLoop) !== null && _a !== void 0 ? _a : TabLoop.defaultProps.enableTabLoop)) {\n            return this.props.children;\n        }\n        return (react__WEBPACK_IMPORTED_MODULE_1___default().createElement(\"div\", { className: \"react-datepicker__tab-loop\", ref: this.tabLoopRef },\n            react__WEBPACK_IMPORTED_MODULE_1___default().createElement(\"div\", { className: \"react-datepicker__tab-loop__start\", tabIndex: 0, onFocus: this.handleFocusStart }),\n            this.props.children,\n            react__WEBPACK_IMPORTED_MODULE_1___default().createElement(\"div\", { className: \"react-datepicker__tab-loop__end\", tabIndex: 0, onFocus: this.handleFocusEnd })));\n    };\n    TabLoop.defaultProps = {\n        enableTabLoop: true,\n    };\n    return TabLoop;\n}(react__WEBPACK_IMPORTED_MODULE_1__.Component));\n\n/**\n * `withFloating` is a higher-order component that adds floating behavior to a component.\n *\n * @param Component - The component to enhance.\n *\n * @example\n * const FloatingComponent = withFloating(MyComponent);\n * <FloatingComponent popperModifiers={[]} popperProps={{}} hidePopper={true} />\n *\n * @param popperModifiers - The modifiers to use for the popper.\n * @param popperProps - The props to pass to the popper.\n * @param hidePopper - Whether to hide the popper.\n * @param popperPlacement - The placement of the popper.\n *\n * @returns A new component with floating behavior.\n */\nfunction withFloating(Component) {\n    function WithFloating(props) {\n        var _a;\n        var hidePopper = typeof props.hidePopper === \"boolean\" ? props.hidePopper : true;\n        var arrowRef = (0,react__WEBPACK_IMPORTED_MODULE_1__.useRef)(null);\n        var floatingProps = (0,_floating_ui_react__WEBPACK_IMPORTED_MODULE_60__.useFloating)(_assign({ open: !hidePopper, whileElementsMounted: _floating_ui_react__WEBPACK_IMPORTED_MODULE_61__.autoUpdate, placement: props.popperPlacement, middleware: __spreadArray([\n                (0,_floating_ui_react__WEBPACK_IMPORTED_MODULE_62__.flip)({ padding: 15 }),\n                (0,_floating_ui_react__WEBPACK_IMPORTED_MODULE_62__.offset)(10),\n                // eslint-disable-next-line react-hooks/refs -- Floating UI requires refs to be passed during render\n                (0,_floating_ui_react__WEBPACK_IMPORTED_MODULE_62__.arrow)({ element: arrowRef })\n            ], ((_a = props.popperModifiers) !== null && _a !== void 0 ? _a : []), true) }, props.popperProps));\n        var componentProps = _assign(_assign({}, props), { hidePopper: hidePopper, popperProps: _assign(_assign({}, floatingProps), { arrowRef: arrowRef }) });\n        return react__WEBPACK_IMPORTED_MODULE_1___default().createElement(Component, _assign({}, componentProps));\n    }\n    WithFloating.displayName = \"withFloating(\".concat(Component.displayName || Component.name || \"Component\", \")\");\n    return WithFloating;\n}\n\n// Exported for testing purposes\nvar PopperComponent$1 = function (props) {\n    var className = props.className, wrapperClassName = props.wrapperClassName, _a = props.hidePopper, hidePopper = _a === void 0 ? true : _a, popperComponent = props.popperComponent, targetComponent = props.targetComponent, enableTabLoop = props.enableTabLoop, popperOnKeyDown = props.popperOnKeyDown, portalId = props.portalId, portalHost = props.portalHost, popperProps = props.popperProps, showArrow = props.showArrow;\n    var popper = undefined;\n    if (!hidePopper) {\n        var classes = (0,clsx__WEBPACK_IMPORTED_MODULE_0__.clsx)(\"react-datepicker-popper\", className);\n        popper = (react__WEBPACK_IMPORTED_MODULE_1___default().createElement(TabLoop, { enableTabLoop: enableTabLoop },\n            react__WEBPACK_IMPORTED_MODULE_1___default().createElement(\"div\", { ref: popperProps.refs.setFloating, style: popperProps.floatingStyles, className: classes, \"data-placement\": popperProps.placement, onKeyDown: popperOnKeyDown },\n                popperComponent,\n                showArrow && (react__WEBPACK_IMPORTED_MODULE_1___default().createElement(_floating_ui_react__WEBPACK_IMPORTED_MODULE_60__.FloatingArrow, { ref: popperProps.arrowRef, context: popperProps.context, fill: \"currentColor\", strokeWidth: 1, height: 8, width: 16, style: { transform: \"translateY(-1px)\" }, className: \"react-datepicker__triangle\" })))));\n    }\n    if (props.popperContainer) {\n        popper = (0,react__WEBPACK_IMPORTED_MODULE_1__.createElement)(props.popperContainer, {}, popper);\n    }\n    if (portalId && !hidePopper) {\n        popper = (react__WEBPACK_IMPORTED_MODULE_1___default().createElement(Portal, { portalId: portalId, portalHost: portalHost }, popper));\n    }\n    var wrapperClasses = (0,clsx__WEBPACK_IMPORTED_MODULE_0__.clsx)(\"react-datepicker-wrapper\", wrapperClassName);\n    return (react__WEBPACK_IMPORTED_MODULE_1___default().createElement((react__WEBPACK_IMPORTED_MODULE_1___default().Fragment), null,\n        react__WEBPACK_IMPORTED_MODULE_1___default().createElement(\"div\", { ref: popperProps.refs.setReference, className: wrapperClasses }, targetComponent),\n        popper));\n};\nvar PopperComponent = withFloating(PopperComponent$1);\n\n// Compares dates year+month combinations\nfunction hasPreSelectionChanged(date1, date2) {\n    if (date1 && date2) {\n        return ((0,date_fns__WEBPACK_IMPORTED_MODULE_30__.getMonth)(date1) !== (0,date_fns__WEBPACK_IMPORTED_MODULE_30__.getMonth)(date2) || (0,date_fns__WEBPACK_IMPORTED_MODULE_29__.getYear)(date1) !== (0,date_fns__WEBPACK_IMPORTED_MODULE_29__.getYear)(date2));\n    }\n    return date1 !== date2;\n}\n/**\n * General datepicker component.\n */\nvar INPUT_ERR_1 = \"Date input not valid.\";\nvar DatePicker = /** @class */ (function (_super) {\n    __extends(DatePicker, _super);\n    function DatePicker(props) {\n        var _this = _super.call(this, props) || this;\n        _this.calendar = null;\n        _this.input = null;\n        _this.getPreSelection = function () {\n            return _this.props.openToDate\n                ? _this.props.openToDate\n                : _this.props.selectsEnd && _this.props.startDate\n                    ? _this.props.startDate\n                    : _this.props.selectsStart && _this.props.endDate\n                        ? _this.props.endDate\n                        : newDate();\n        };\n        // Convert the date from string format to standard Date format\n        _this.modifyHolidays = function () {\n            var _a;\n            return (_a = _this.props.holidays) === null || _a === void 0 ? void 0 : _a.reduce(function (accumulator, holiday) {\n                var date = new Date(holiday.date);\n                if (!isValid(date)) {\n                    return accumulator;\n                }\n                return __spreadArray(__spreadArray([], accumulator, true), [_assign(_assign({}, holiday), { date: date })], false);\n            }, []);\n        };\n        _this.calcInitialState = function () {\n            var _a;\n            var defaultPreSelection = _this.getPreSelection();\n            var minDate = getEffectiveMinDate(_this.props);\n            var maxDate = getEffectiveMaxDate(_this.props);\n            var boundedPreSelection = minDate && (0,date_fns__WEBPACK_IMPORTED_MODULE_7__.isBefore)(defaultPreSelection, getStartOfDay(minDate))\n                ? minDate\n                : maxDate && (0,date_fns__WEBPACK_IMPORTED_MODULE_52__.isAfter)(defaultPreSelection, getEndOfDay(maxDate))\n                    ? maxDate\n                    : defaultPreSelection;\n            return {\n                open: _this.props.startOpen || false,\n                preventFocus: false,\n                inputValue: null,\n                preSelection: (_a = (_this.props.selectsRange\n                    ? _this.props.startDate\n                    : _this.props.selected)) !== null && _a !== void 0 ? _a : boundedPreSelection,\n                // transforming highlighted days (perhaps nested array)\n                // to flat Map for faster access in day.jsx\n                highlightDates: getHighLightDaysMap(_this.props.highlightDates),\n                focused: false,\n                // used to focus day in inline version after month has changed, but not on\n                // initial render\n                shouldFocusDayInline: false,\n                isRenderAriaLiveMessage: false,\n                wasHidden: false,\n            };\n        };\n        _this.getInputValue = function () {\n            var _a;\n            var _b = _this.props, locale = _b.locale, startDate = _b.startDate, endDate = _b.endDate, rangeSeparator = _b.rangeSeparator, selected = _b.selected, selectedDates = _b.selectedDates, selectsMultiple = _b.selectsMultiple, selectsRange = _b.selectsRange, value = _b.value;\n            var dateFormat = (_a = _this.props.dateFormat) !== null && _a !== void 0 ? _a : DatePicker.defaultProps.dateFormat;\n            var inputValue = _this.state.inputValue;\n            if (typeof value === \"string\") {\n                return value;\n            }\n            else if (typeof inputValue === \"string\") {\n                return inputValue;\n            }\n            else if (selectsRange) {\n                return safeDateRangeFormat(startDate, endDate, {\n                    dateFormat: dateFormat,\n                    locale: locale,\n                    rangeSeparator: rangeSeparator,\n                });\n            }\n            else if (selectsMultiple) {\n                return safeMultipleDatesFormat(selectedDates !== null && selectedDates !== void 0 ? selectedDates : [], {\n                    dateFormat: dateFormat,\n                    locale: locale,\n                });\n            }\n            return safeDateFormat(selected, {\n                dateFormat: dateFormat,\n                locale: locale,\n            });\n        };\n        _this.resetHiddenStatus = function () {\n            _this.setState(_assign(_assign({}, _this.state), { wasHidden: false }));\n        };\n        _this.setHiddenStatus = function () {\n            _this.setState(_assign(_assign({}, _this.state), { wasHidden: true }));\n        };\n        _this.setHiddenStateOnVisibilityHidden = function () {\n            if (document.visibilityState !== \"hidden\") {\n                return;\n            }\n            _this.setHiddenStatus();\n        };\n        _this.clearPreventFocusTimeout = function () {\n            if (_this.preventFocusTimeout) {\n                clearTimeout(_this.preventFocusTimeout);\n            }\n        };\n        _this.setFocus = function () {\n            var _a, _b;\n            (_b = (_a = _this.input) === null || _a === void 0 ? void 0 : _a.focus) === null || _b === void 0 ? void 0 : _b.call(_a, { preventScroll: true });\n        };\n        _this.setBlur = function () {\n            var _a, _b;\n            (_b = (_a = _this.input) === null || _a === void 0 ? void 0 : _a.blur) === null || _b === void 0 ? void 0 : _b.call(_a);\n            _this.cancelFocusInput();\n        };\n        _this.deferBlur = function () {\n            requestAnimationFrame(function () {\n                _this.setBlur();\n            });\n        };\n        _this.setOpen = function (open, skipSetBlur) {\n            if (skipSetBlur === void 0) { skipSetBlur = false; }\n            _this.setState({\n                open: open,\n                preSelection: open && _this.state.open\n                    ? _this.state.preSelection\n                    : _this.calcInitialState().preSelection,\n                lastPreSelectChange: PRESELECT_CHANGE_VIA_NAVIGATE,\n            }, function () {\n                if (!open) {\n                    _this.setState(function (prev) { return ({\n                        focused: skipSetBlur ? prev.focused : false,\n                    }); }, function () {\n                        !skipSetBlur && _this.deferBlur();\n                        _this.setState({ inputValue: null });\n                    });\n                }\n            });\n        };\n        _this.inputOk = function () { return (0,date_fns__WEBPACK_IMPORTED_MODULE_48__.isDate)(_this.state.preSelection); };\n        _this.isCalendarOpen = function () {\n            return _this.props.open === undefined\n                ? _this.state.open && !_this.props.disabled && !_this.props.readOnly\n                : _this.props.open;\n        };\n        _this.handleFocus = function (event) {\n            var _a, _b;\n            var isAutoReFocus = _this.state.wasHidden;\n            var isOpenAllowed = isAutoReFocus ? _this.state.open : true;\n            if (isAutoReFocus) {\n                _this.resetHiddenStatus();\n            }\n            if (!_this.state.preventFocus) {\n                (_b = (_a = _this.props).onFocus) === null || _b === void 0 ? void 0 : _b.call(_a, event);\n                if (isOpenAllowed &&\n                    !_this.props.preventOpenOnFocus &&\n                    !_this.props.readOnly) {\n                    _this.setOpen(true);\n                }\n            }\n            _this.setState({ focused: true });\n        };\n        _this.sendFocusBackToInput = function () {\n            // Clear previous timeout if it exists\n            if (_this.preventFocusTimeout) {\n                _this.clearPreventFocusTimeout();\n            }\n            // close the popper and refocus the input\n            // stop the input from auto opening onFocus\n            // setFocus to the input\n            _this.setState({ preventFocus: true }, function () {\n                _this.preventFocusTimeout = setTimeout(function () {\n                    _this.setFocus();\n                    _this.setState({ preventFocus: false });\n                });\n            });\n        };\n        _this.cancelFocusInput = function () {\n            clearTimeout(_this.inputFocusTimeout);\n            _this.inputFocusTimeout = undefined;\n        };\n        _this.deferFocusInput = function () {\n            _this.cancelFocusInput();\n            _this.inputFocusTimeout = setTimeout(function () { return _this.setFocus(); }, 1);\n        };\n        _this.handleDropdownFocus = function () {\n            _this.cancelFocusInput();\n        };\n        _this.resetInputValue = function () {\n            _this.setState(_assign(_assign({}, _this.state), { inputValue: null }));\n        };\n        _this.handleBlur = function (event) {\n            var _a, _b;\n            if (!_this.state.open || _this.props.withPortal || _this.props.showTimeInput) {\n                (_b = (_a = _this.props).onBlur) === null || _b === void 0 ? void 0 : _b.call(_a, event);\n            }\n            _this.resetInputValue();\n            if (_this.state.open && _this.props.open === false) {\n                _this.setOpen(false);\n            }\n            _this.setState({ focused: false });\n        };\n        _this.handleCalendarClickOutside = function (event) {\n            var _a, _b;\n            if (!_this.props.inline) {\n                _this.setOpen(false);\n            }\n            (_b = (_a = _this.props).onClickOutside) === null || _b === void 0 ? void 0 : _b.call(_a, event);\n            if (_this.props.withPortal) {\n                event.preventDefault();\n            }\n        };\n        // handleChange is called when user types in the textbox\n        _this.handleChange = function () {\n            var _a, _b, _c, _d, _e;\n            var allArgs = [];\n            for (var _i = 0; _i < arguments.length; _i++) {\n                allArgs[_i] = arguments[_i];\n            }\n            var event = allArgs[0];\n            if (_this.props.onChangeRaw) {\n                _this.props.onChangeRaw.apply(_this, allArgs);\n                if (!event ||\n                    typeof event.isDefaultPrevented !== \"function\" ||\n                    event.isDefaultPrevented()) {\n                    return;\n                }\n            }\n            _this.setState({\n                inputValue: (event === null || event === void 0 ? void 0 : event.target) instanceof HTMLInputElement ? event.target.value : null,\n                lastPreSelectChange: PRESELECT_CHANGE_VIA_INPUT,\n            });\n            var _f = _this.props, selectsRange = _f.selectsRange, startDate = _f.startDate, endDate = _f.endDate;\n            var dateFormat = (_a = _this.props.dateFormat) !== null && _a !== void 0 ? _a : DatePicker.defaultProps.dateFormat;\n            var strictParsing = (_b = _this.props.strictParsing) !== null && _b !== void 0 ? _b : DatePicker.defaultProps.strictParsing;\n            var value = (event === null || event === void 0 ? void 0 : event.target) instanceof HTMLInputElement ? event.target.value : \"\";\n            if (selectsRange) {\n                var rangeSeparator = _this.props.rangeSeparator;\n                var trimmedRangeSeparator = rangeSeparator.trim();\n                var _g = value\n                    .split(dateFormat.includes(trimmedRangeSeparator)\n                    ? rangeSeparator\n                    : trimmedRangeSeparator, 2)\n                    .map(function (val) { return val.trim(); }), valueStart = _g[0], valueEnd = _g[1];\n                var startDateNew = parseDate(valueStart !== null && valueStart !== void 0 ? valueStart : \"\", dateFormat, _this.props.locale, strictParsing);\n                var endDateNew = startDateNew\n                    ? parseDate(valueEnd !== null && valueEnd !== void 0 ? valueEnd : \"\", dateFormat, _this.props.locale, strictParsing)\n                    : null;\n                var startChanged = (startDate === null || startDate === void 0 ? void 0 : startDate.getTime()) !== (startDateNew === null || startDateNew === void 0 ? void 0 : startDateNew.getTime());\n                var endChanged = (endDate === null || endDate === void 0 ? void 0 : endDate.getTime()) !== (endDateNew === null || endDateNew === void 0 ? void 0 : endDateNew.getTime());\n                if (!startChanged && !endChanged) {\n                    return;\n                }\n                if (startDateNew && isDayDisabled(startDateNew, _this.props)) {\n                    return;\n                }\n                if (endDateNew && isDayDisabled(endDateNew, _this.props)) {\n                    return;\n                }\n                (_d = (_c = _this.props).onChange) === null || _d === void 0 ? void 0 : _d.call(_c, [startDateNew, endDateNew], event);\n            }\n            else {\n                // not selectsRange\n                var date = parseDate(value, dateFormat, _this.props.locale, strictParsing, (_e = _this.props.selected) !== null && _e !== void 0 ? _e : undefined);\n                // Update selection if either (1) date was successfully parsed, or (2) input field is empty\n                if (date || !value) {\n                    _this.setSelected(date, event, true);\n                }\n            }\n        };\n        _this.handleSelect = function (date, event, monthSelectedIn) {\n            var _a;\n            if (_this.props.readOnly)\n                return;\n            var _b = _this.props, selectsRange = _b.selectsRange, startDate = _b.startDate, endDate = _b.endDate, locale = _b.locale, swapRange = _b.swapRange;\n            var dateFormat = (_a = _this.props.dateFormat) !== null && _a !== void 0 ? _a : DatePicker.defaultProps.dateFormat;\n            var isDateSelectionComplete = !selectsRange ||\n                (startDate && !endDate && (swapRange || !isDateBefore(date, startDate)));\n            if (_this.props.shouldCloseOnSelect &&\n                !_this.props.showTimeSelect &&\n                isDateSelectionComplete) {\n                // Preventing onFocus event to fix issue\n                // https://github.com/Hacker0x01/react-datepicker/issues/628\n                _this.sendFocusBackToInput();\n            }\n            if (_this.props.onChangeRaw) {\n                var formattedDate = safeDateFormat(date, {\n                    dateFormat: dateFormat,\n                    locale: locale,\n                });\n                _this.props.onChangeRaw(event, { date: date, formattedDate: formattedDate });\n            }\n            _this.setSelected(date, event, false, monthSelectedIn);\n            if (_this.props.showDateSelect) {\n                _this.setState({ isRenderAriaLiveMessage: true });\n            }\n            if (!_this.props.shouldCloseOnSelect || _this.props.showTimeSelect) {\n                _this.setPreSelection(date);\n            }\n            else if (isDateSelectionComplete) {\n                _this.setOpen(false);\n            }\n        };\n        // setSelected is called either from handleChange (user typed date into textbox and it was parsed) or handleSelect (user selected date from calendar using mouse or keyboard)\n        _this.setSelected = function (date, event, keepInput, monthSelectedIn) {\n            var _a, _b;\n            var changedDate = date;\n            // Early return if selected year/month/day is disabled\n            if (_this.props.showYearPicker) {\n                if (changedDate !== null &&\n                    isYearDisabled((0,date_fns__WEBPACK_IMPORTED_MODULE_29__.getYear)(changedDate), _this.props)) {\n                    return;\n                }\n            }\n            else if (_this.props.showMonthYearPicker) {\n                if (changedDate !== null && isMonthDisabled(changedDate, _this.props)) {\n                    return;\n                }\n            }\n            else {\n                if (changedDate !== null && isDayDisabled(changedDate, _this.props)) {\n                    return;\n                }\n            }\n            var _c = _this.props, onChange = _c.onChange, selectsRange = _c.selectsRange, startDate = _c.startDate, endDate = _c.endDate, selectsMultiple = _c.selectsMultiple, selectedDates = _c.selectedDates, minTime = _c.minTime, swapRange = _c.swapRange;\n            if (!isEqual(_this.props.selected, changedDate) ||\n                _this.props.allowSameDay ||\n                selectsRange ||\n                selectsMultiple) {\n                if (changedDate !== null) {\n                    // Preserve previously selected time if only date is currently being changed\n                    if (_this.props.selected &&\n                        (!keepInput ||\n                            (!_this.props.showTimeSelect &&\n                                !_this.props.showTimeSelectOnly &&\n                                !_this.props.showTimeInput))) {\n                        changedDate = setTime(changedDate, {\n                            hour: (0,date_fns__WEBPACK_IMPORTED_MODULE_34__.getHours)(_this.props.selected),\n                            minute: (0,date_fns__WEBPACK_IMPORTED_MODULE_35__.getMinutes)(_this.props.selected),\n                            second: (0,date_fns__WEBPACK_IMPORTED_MODULE_36__.getSeconds)(_this.props.selected),\n                        });\n                    }\n                    // If minTime is present then set the time to minTime\n                    if (!keepInput &&\n                        (_this.props.showTimeSelect || _this.props.showTimeSelectOnly)) {\n                        if (minTime) {\n                            changedDate = setTime(changedDate, {\n                                hour: minTime.getHours(),\n                                minute: minTime.getMinutes(),\n                                second: minTime.getSeconds(),\n                            });\n                        }\n                    }\n                    if (!_this.props.inline) {\n                        _this.setState({\n                            preSelection: changedDate,\n                        });\n                    }\n                    if (!_this.props.focusSelectedMonth) {\n                        _this.setState({ monthSelectedIn: monthSelectedIn });\n                    }\n                }\n                if (selectsRange) {\n                    var noRanges = !startDate && !endDate;\n                    var hasStartRange = startDate && !endDate;\n                    var hasOnlyEndRange = !startDate && !!endDate;\n                    var isRangeFilled = startDate && endDate;\n                    if (noRanges) {\n                        onChange === null || onChange === void 0 ? void 0 : onChange([changedDate, null], event);\n                    }\n                    else if (hasStartRange) {\n                        if (changedDate === null) {\n                            onChange === null || onChange === void 0 ? void 0 : onChange([null, null], event);\n                        }\n                        else if (isDateBefore(changedDate, startDate)) {\n                            if (swapRange) {\n                                onChange === null || onChange === void 0 ? void 0 : onChange([changedDate, startDate], event);\n                            }\n                            else {\n                                onChange === null || onChange === void 0 ? void 0 : onChange([changedDate, null], event);\n                            }\n                        }\n                        else {\n                            onChange === null || onChange === void 0 ? void 0 : onChange([startDate, changedDate], event);\n                        }\n                    }\n                    else if (hasOnlyEndRange) {\n                        if (changedDate && isDateBefore(changedDate, endDate)) {\n                            onChange === null || onChange === void 0 ? void 0 : onChange([changedDate, endDate], event);\n                        }\n                        else {\n                            onChange === null || onChange === void 0 ? void 0 : onChange([changedDate, null], event);\n                        }\n                    }\n                    if (isRangeFilled) {\n                        onChange === null || onChange === void 0 ? void 0 : onChange([changedDate, null], event);\n                    }\n                }\n                else if (selectsMultiple) {\n                    if (changedDate !== null) {\n                        if (!(selectedDates === null || selectedDates === void 0 ? void 0 : selectedDates.length)) {\n                            onChange === null || onChange === void 0 ? void 0 : onChange([changedDate], event);\n                        }\n                        else {\n                            var isChangedDateAlreadySelected = selectedDates.some(function (selectedDate) { return isSameDay(selectedDate, changedDate); });\n                            if (isChangedDateAlreadySelected) {\n                                var nextDates = selectedDates.filter(function (selectedDate) { return !isSameDay(selectedDate, changedDate); });\n                                onChange === null || onChange === void 0 ? void 0 : onChange(nextDates, event);\n                            }\n                            else {\n                                onChange === null || onChange === void 0 ? void 0 : onChange(__spreadArray(__spreadArray([], selectedDates, true), [changedDate], false), event);\n                            }\n                        }\n                    }\n                }\n                else {\n                    onChange === null || onChange === void 0 ? void 0 : onChange(changedDate, event);\n                }\n            }\n            if (!keepInput) {\n                (_b = (_a = _this.props).onSelect) === null || _b === void 0 ? void 0 : _b.call(_a, changedDate, event);\n                _this.setState({ inputValue: null });\n            }\n        };\n        // When checking preSelection via min/maxDate, times need to be manipulated via getStartOfDay/getEndOfDay\n        _this.setPreSelection = function (date) {\n            if (_this.props.readOnly)\n                return;\n            var hasMinDate = (0,date_fns__WEBPACK_IMPORTED_MODULE_48__.isDate)(_this.props.minDate);\n            var hasMaxDate = (0,date_fns__WEBPACK_IMPORTED_MODULE_48__.isDate)(_this.props.maxDate);\n            var isValidDateSelection = true;\n            if (date) {\n                var dateStartOfDay = getStartOfDay(date);\n                if (hasMinDate && hasMaxDate) {\n                    // isDayInRange uses getStartOfDay internally, so not necessary to manipulate times here\n                    isValidDateSelection = isDayInRange(date, _this.props.minDate, _this.props.maxDate);\n                }\n                else if (hasMinDate) {\n                    var minDateStartOfDay = getStartOfDay(_this.props.minDate);\n                    isValidDateSelection =\n                        (0,date_fns__WEBPACK_IMPORTED_MODULE_52__.isAfter)(date, minDateStartOfDay) ||\n                            isEqual(dateStartOfDay, minDateStartOfDay);\n                }\n                else if (hasMaxDate) {\n                    var maxDateEndOfDay = getEndOfDay(_this.props.maxDate);\n                    isValidDateSelection =\n                        (0,date_fns__WEBPACK_IMPORTED_MODULE_7__.isBefore)(date, maxDateEndOfDay) ||\n                            isEqual(dateStartOfDay, maxDateEndOfDay);\n                }\n            }\n            if (isValidDateSelection) {\n                _this.setState({\n                    preSelection: date,\n                });\n            }\n        };\n        _this.toggleCalendar = function () {\n            _this.setOpen(!_this.state.open);\n        };\n        _this.handleTimeChange = function (time) {\n            var _a, _b;\n            if (_this.props.selectsRange || _this.props.selectsMultiple) {\n                return;\n            }\n            var selected = _this.props.selected\n                ? _this.props.selected\n                : _this.getPreSelection();\n            var changedDate = _this.props.selected\n                ? time\n                : setTime(selected, {\n                    hour: (0,date_fns__WEBPACK_IMPORTED_MODULE_34__.getHours)(time),\n                    minute: (0,date_fns__WEBPACK_IMPORTED_MODULE_35__.getMinutes)(time),\n                });\n            _this.setState({\n                preSelection: changedDate,\n            });\n            (_b = (_a = _this.props).onChange) === null || _b === void 0 ? void 0 : _b.call(_a, changedDate);\n            if (_this.props.shouldCloseOnSelect && !_this.props.showTimeInput) {\n                _this.sendFocusBackToInput();\n                _this.setOpen(false);\n            }\n            if (_this.props.showTimeInput) {\n                _this.setOpen(true);\n            }\n            if (_this.props.showTimeSelectOnly || _this.props.showTimeSelect) {\n                _this.setState({ isRenderAriaLiveMessage: true });\n            }\n            _this.setState({ inputValue: null });\n        };\n        _this.onInputClick = function () {\n            var _a, _b;\n            if (!_this.props.disabled && !_this.props.readOnly) {\n                _this.setOpen(true);\n            }\n            (_b = (_a = _this.props).onInputClick) === null || _b === void 0 ? void 0 : _b.call(_a);\n        };\n        _this.handleTimeOnlyArrowKey = function (eventKey) {\n            var _a, _b, _c, _d;\n            var currentTime = _this.props.selected || _this.state.preSelection || newDate();\n            var timeIntervals = (_a = _this.props.timeIntervals) !== null && _a !== void 0 ? _a : 30;\n            var dateFormat = (_b = _this.props.dateFormat) !== null && _b !== void 0 ? _b : DatePicker.defaultProps.dateFormat;\n            var formatStr = Array.isArray(dateFormat) ? dateFormat[0] : dateFormat;\n            var baseDate = getStartOfDay(currentTime);\n            var currentMinutes = (0,date_fns__WEBPACK_IMPORTED_MODULE_34__.getHours)(currentTime) * 60 + (0,date_fns__WEBPACK_IMPORTED_MODULE_35__.getMinutes)(currentTime);\n            var maxMinutes = 23 * 60 + 60 - timeIntervals; // Cap at last valid interval of the day\n            var newTime;\n            if (eventKey === KeyType.ArrowUp) {\n                var newMinutes = Math.max(0, currentMinutes - timeIntervals);\n                newTime = (0,date_fns__WEBPACK_IMPORTED_MODULE_50__.addMinutes)(baseDate, newMinutes);\n            }\n            else {\n                var newMinutes = Math.min(maxMinutes, currentMinutes + timeIntervals);\n                newTime = (0,date_fns__WEBPACK_IMPORTED_MODULE_50__.addMinutes)(baseDate, newMinutes);\n            }\n            var formattedTime = formatDate(newTime, formatStr || DatePicker.defaultProps.dateFormat, _this.props.locale);\n            _this.setState({\n                preSelection: newTime,\n                inputValue: formattedTime,\n            });\n            if (_this.props.selectsRange || _this.props.selectsMultiple) {\n                return;\n            }\n            var selected = _this.props.selected\n                ? _this.props.selected\n                : _this.getPreSelection();\n            var changedDate = _this.props.selected\n                ? newTime\n                : setTime(selected, {\n                    hour: (0,date_fns__WEBPACK_IMPORTED_MODULE_34__.getHours)(newTime),\n                    minute: (0,date_fns__WEBPACK_IMPORTED_MODULE_35__.getMinutes)(newTime),\n                });\n            (_d = (_c = _this.props).onChange) === null || _d === void 0 ? void 0 : _d.call(_c, changedDate);\n            if (_this.props.showTimeSelectOnly || _this.props.showTimeSelect) {\n                _this.setState({ isRenderAriaLiveMessage: true });\n            }\n            requestAnimationFrame(function () {\n                _this.scrollToTimeOption(newTime);\n            });\n        };\n        _this.handleTimeOnlyEnterKey = function (event) {\n            var _a, _b, _c, _d;\n            var inputElement = event.target;\n            var inputValue = inputElement.value;\n            var dateFormat = (_a = _this.props.dateFormat) !== null && _a !== void 0 ? _a : DatePicker.defaultProps.dateFormat;\n            var timeFormat = _this.props.timeFormat || \"p\";\n            var defaultTime = _this.state.preSelection || _this.props.selected || newDate();\n            var parsedDate = parseDate(inputValue, dateFormat, _this.props.locale, (_b = _this.props.strictParsing) !== null && _b !== void 0 ? _b : false, defaultTime);\n            var timeToCommit = defaultTime;\n            if (parsedDate && isValid(parsedDate)) {\n                timeToCommit = parsedDate;\n            }\n            else {\n                var highlightedItem = ((_c = _this.calendar) === null || _c === void 0 ? void 0 : _c.containerRef.current) instanceof Element &&\n                    _this.calendar.containerRef.current.querySelector(\".react-datepicker__time-list-item[tabindex='0']\");\n                if (highlightedItem instanceof HTMLElement) {\n                    var itemText = (_d = highlightedItem.textContent) === null || _d === void 0 ? void 0 : _d.trim();\n                    if (itemText) {\n                        var itemTime = parseDate(itemText, timeFormat, _this.props.locale, false, defaultTime);\n                        if (itemTime && isValid(itemTime)) {\n                            timeToCommit = itemTime;\n                        }\n                    }\n                }\n            }\n            _this.handleTimeChange(timeToCommit);\n            _this.setOpen(false);\n            _this.sendFocusBackToInput();\n        };\n        _this.scrollToTimeOption = function (time) {\n            var _a, _b;\n            if (!((_a = _this.calendar) === null || _a === void 0 ? void 0 : _a.containerRef.current)) {\n                return;\n            }\n            var container = _this.calendar.containerRef.current;\n            var timeListItems = Array.from(container.querySelectorAll(\".react-datepicker__time-list-item\"));\n            var targetItem = null;\n            var closestTimeDiff = Infinity;\n            var timeFormat = _this.props.timeFormat || \"p\";\n            for (var _i = 0, timeListItems_1 = timeListItems; _i < timeListItems_1.length; _i++) {\n                var item = timeListItems_1[_i];\n                var itemText = (_b = item.textContent) === null || _b === void 0 ? void 0 : _b.trim();\n                if (itemText) {\n                    var itemTime = parseDate(itemText, timeFormat, _this.props.locale, false, time);\n                    if (itemTime && isValid(itemTime)) {\n                        if (isSameMinute(itemTime, time)) {\n                            targetItem = item;\n                            break;\n                        }\n                        var timeDiff = Math.abs(itemTime.getTime() - time.getTime());\n                        if (timeDiff < closestTimeDiff) {\n                            closestTimeDiff = timeDiff;\n                            targetItem = item;\n                        }\n                    }\n                }\n            }\n            if (targetItem) {\n                timeListItems.forEach(function (item) {\n                    item.setAttribute(\"tabindex\", \"-1\");\n                });\n                targetItem.setAttribute(\"tabindex\", \"0\");\n                targetItem.scrollIntoView({\n                    behavior: \"smooth\",\n                    block: \"center\",\n                });\n            }\n        };\n        _this.onInputKeyDown = function (event) {\n            var _a, _b, _c, _d, _e, _f;\n            (_b = (_a = _this.props).onKeyDown) === null || _b === void 0 ? void 0 : _b.call(_a, event);\n            var eventKey = event.key;\n            if (!_this.state.open &&\n                !_this.props.inline &&\n                !_this.props.preventOpenOnFocus) {\n                if (eventKey === KeyType.ArrowDown ||\n                    eventKey === KeyType.ArrowUp ||\n                    eventKey === KeyType.Enter) {\n                    (_c = _this.onInputClick) === null || _c === void 0 ? void 0 : _c.call(_this);\n                }\n                return;\n            }\n            if (_this.state.open && _this.props.showTimeSelectOnly) {\n                if (eventKey === KeyType.ArrowDown || eventKey === KeyType.ArrowUp) {\n                    event.preventDefault();\n                    _this.handleTimeOnlyArrowKey(eventKey);\n                    return;\n                }\n                if (eventKey === KeyType.Enter) {\n                    event.preventDefault();\n                    _this.handleTimeOnlyEnterKey(event);\n                    return;\n                }\n            }\n            // if calendar is open, these keys will focus the selected item\n            if (_this.state.open) {\n                if (eventKey === KeyType.ArrowDown || eventKey === KeyType.ArrowUp) {\n                    event.preventDefault();\n                    var selectorString = _this.props.showTimeSelectOnly\n                        ? \".react-datepicker__time-list-item[tabindex='0']\"\n                        : _this.props.showWeekPicker && _this.props.showWeekNumbers\n                            ? '.react-datepicker__week-number[tabindex=\"0\"]'\n                            : _this.props.showFullMonthYearPicker ||\n                                _this.props.showMonthYearPicker\n                                ? '.react-datepicker__month-text[tabindex=\"0\"]'\n                                : '.react-datepicker__day[tabindex=\"0\"]';\n                    var selectedItem = ((_d = _this.calendar) === null || _d === void 0 ? void 0 : _d.containerRef.current) instanceof Element &&\n                        _this.calendar.containerRef.current.querySelector(selectorString);\n                    selectedItem instanceof HTMLElement &&\n                        selectedItem.focus({ preventScroll: true });\n                    return;\n                }\n                var copy = newDate(_this.state.preSelection);\n                if (eventKey === KeyType.Enter) {\n                    event.preventDefault();\n                    event.target.blur();\n                    if (_this.inputOk() &&\n                        _this.state.lastPreSelectChange === PRESELECT_CHANGE_VIA_NAVIGATE) {\n                        _this.handleSelect(copy, event);\n                        !_this.props.shouldCloseOnSelect && _this.setPreSelection(copy);\n                    }\n                    else {\n                        _this.setOpen(false);\n                    }\n                }\n                else if (eventKey === KeyType.Escape) {\n                    event.preventDefault();\n                    event.target.blur();\n                    _this.sendFocusBackToInput();\n                    _this.setOpen(false);\n                }\n                else if (eventKey === KeyType.Tab) {\n                    _this.setOpen(false);\n                }\n                if (!_this.inputOk()) {\n                    (_f = (_e = _this.props).onInputError) === null || _f === void 0 ? void 0 : _f.call(_e, { code: 1, msg: INPUT_ERR_1 });\n                }\n            }\n        };\n        _this.onPortalKeyDown = function (event) {\n            var eventKey = event.key;\n            if (eventKey === KeyType.Escape) {\n                event.preventDefault();\n                _this.setState({\n                    preventFocus: true,\n                }, function () {\n                    _this.setOpen(false);\n                    setTimeout(function () {\n                        _this.setFocus();\n                        _this.setState({ preventFocus: false });\n                    });\n                });\n            }\n        };\n        // keyDown events passed down to day.jsx\n        _this.onDayKeyDown = function (event) {\n            var _a, _b, _c, _d, _e, _f;\n            var _g = _this.props, minDate = _g.minDate, maxDate = _g.maxDate, disabledKeyboardNavigation = _g.disabledKeyboardNavigation, showWeekPicker = _g.showWeekPicker, shouldCloseOnSelect = _g.shouldCloseOnSelect, locale = _g.locale, calendarStartDay = _g.calendarStartDay, adjustDateOnChange = _g.adjustDateOnChange, inline = _g.inline;\n            (_b = (_a = _this.props).onKeyDown) === null || _b === void 0 ? void 0 : _b.call(_a, event);\n            if (disabledKeyboardNavigation)\n                return;\n            var eventKey = event.key;\n            var isShiftKeyActive = event.shiftKey;\n            var copy = newDate(_this.state.preSelection);\n            var calculateNewDate = function (eventKey, date) {\n                var newCalculatedDate = date;\n                switch (eventKey) {\n                    case KeyType.ArrowRight:\n                        newCalculatedDate = showWeekPicker\n                            ? (0,date_fns__WEBPACK_IMPORTED_MODULE_56__.addWeeks)(date, 1)\n                            : (0,date_fns__WEBPACK_IMPORTED_MODULE_55__.addDays)(date, 1);\n                        break;\n                    case KeyType.ArrowLeft:\n                        newCalculatedDate = showWeekPicker\n                            ? (0,date_fns__WEBPACK_IMPORTED_MODULE_63__.subWeeks)(date, 1)\n                            : (0,date_fns__WEBPACK_IMPORTED_MODULE_64__.subDays)(date, 1);\n                        break;\n                    case KeyType.ArrowUp:\n                        newCalculatedDate = (0,date_fns__WEBPACK_IMPORTED_MODULE_63__.subWeeks)(date, 1);\n                        break;\n                    case KeyType.ArrowDown:\n                        newCalculatedDate = (0,date_fns__WEBPACK_IMPORTED_MODULE_56__.addWeeks)(date, 1);\n                        break;\n                    case KeyType.PageUp:\n                        newCalculatedDate = isShiftKeyActive\n                            ? (0,date_fns__WEBPACK_IMPORTED_MODULE_43__.subYears)(date, 1)\n                            : (0,date_fns__WEBPACK_IMPORTED_MODULE_37__.subMonths)(date, 1);\n                        break;\n                    case KeyType.PageDown:\n                        newCalculatedDate = isShiftKeyActive\n                            ? (0,date_fns__WEBPACK_IMPORTED_MODULE_45__.addYears)(date, 1)\n                            : (0,date_fns__WEBPACK_IMPORTED_MODULE_39__.addMonths)(date, 1);\n                        break;\n                    case KeyType.Home:\n                        newCalculatedDate = getStartOfWeek(date, locale, calendarStartDay);\n                        break;\n                    case KeyType.End:\n                        newCalculatedDate = getEndOfWeek(date);\n                        break;\n                }\n                return newCalculatedDate;\n            };\n            var getNewDate = function (eventKey, date) {\n                var MAX_ITERATIONS = 40;\n                var eventKeyCopy = eventKey;\n                var validDateFound = false;\n                var iterations = 0;\n                var newSelection = calculateNewDate(eventKey, date);\n                while (!validDateFound) {\n                    if (iterations >= MAX_ITERATIONS) {\n                        newSelection = date;\n                        break;\n                    }\n                    // if minDate exists and the new selection is before the min date, get the nearest date that isn't disabled\n                    if (minDate && newSelection < minDate) {\n                        eventKeyCopy = KeyType.ArrowRight;\n                        newSelection = isDayDisabled(minDate, _this.props)\n                            ? calculateNewDate(eventKeyCopy, newSelection)\n                            : minDate;\n                    }\n                    // if maxDate exists and the new selection is after the max date, get the nearest date that isn't disabled\n                    if (maxDate && newSelection > maxDate) {\n                        eventKeyCopy = KeyType.ArrowLeft;\n                        newSelection = isDayDisabled(maxDate, _this.props)\n                            ? calculateNewDate(eventKeyCopy, newSelection)\n                            : maxDate;\n                    }\n                    if (isDayDisabled(newSelection, _this.props)) {\n                        // if PageUp and Home is pressed to a disabled date, it will try to find the next available date after\n                        if (eventKeyCopy === KeyType.PageUp ||\n                            eventKeyCopy === KeyType.Home) {\n                            eventKeyCopy = KeyType.ArrowRight;\n                        }\n                        // if PageDown and End is pressed to a disabled date, it will try to find the next available date before\n                        if (eventKeyCopy === KeyType.PageDown ||\n                            eventKeyCopy === KeyType.End) {\n                            eventKeyCopy = KeyType.ArrowLeft;\n                        }\n                        newSelection = calculateNewDate(eventKeyCopy, newSelection);\n                    }\n                    else {\n                        validDateFound = true;\n                    }\n                    iterations++;\n                }\n                return newSelection;\n            };\n            if (eventKey === KeyType.Enter) {\n                event.preventDefault();\n                _this.handleSelect(copy, event);\n                !shouldCloseOnSelect && _this.setPreSelection(copy);\n                return;\n            }\n            else if (eventKey === KeyType.Escape) {\n                event.preventDefault();\n                _this.setOpen(false);\n                if (!_this.inputOk()) {\n                    (_d = (_c = _this.props).onInputError) === null || _d === void 0 ? void 0 : _d.call(_c, { code: 1, msg: INPUT_ERR_1 });\n                }\n                return;\n            }\n            var newSelection = null;\n            switch (eventKey) {\n                case KeyType.ArrowLeft:\n                case KeyType.ArrowRight:\n                case KeyType.ArrowUp:\n                case KeyType.ArrowDown:\n                case KeyType.PageUp:\n                case KeyType.PageDown:\n                case KeyType.Home:\n                case KeyType.End:\n                    newSelection = getNewDate(eventKey, copy);\n                    break;\n            }\n            if (!newSelection) {\n                (_f = (_e = _this.props).onInputError) === null || _f === void 0 ? void 0 : _f.call(_e, { code: 1, msg: INPUT_ERR_1 });\n                return;\n            }\n            event.preventDefault();\n            _this.setState({ lastPreSelectChange: PRESELECT_CHANGE_VIA_NAVIGATE });\n            if (adjustDateOnChange) {\n                _this.setSelected(newSelection);\n            }\n            _this.setPreSelection(newSelection);\n            // In inline mode, always set shouldFocusDayInline to true when navigating via keyboard.\n            // This ensures focus is properly transferred to the new day element regardless of\n            // whether the month changed. The user initiated this navigation from a focused day,\n            // so we should always focus the destination day.\n            if (inline) {\n                _this.setState({ shouldFocusDayInline: true });\n            }\n        };\n        // handle generic key down events in the popper that do not adjust or select dates\n        // ex: while focusing prev and next month buttons\n        _this.onPopperKeyDown = function (event) {\n            var eventKey = event.key;\n            if (eventKey === KeyType.Escape) {\n                event.preventDefault();\n                _this.sendFocusBackToInput();\n                _this.setOpen(false);\n            }\n        };\n        _this.onClearClick = function (event) {\n            if (event) {\n                if (event.preventDefault) {\n                    event.preventDefault();\n                }\n            }\n            _this.sendFocusBackToInput();\n            var _a = _this.props, selectsRange = _a.selectsRange, onChange = _a.onChange;\n            if (selectsRange) {\n                onChange === null || onChange === void 0 ? void 0 : onChange([null, null], event);\n            }\n            else {\n                onChange === null || onChange === void 0 ? void 0 : onChange(null, event);\n            }\n            _this.setState({ inputValue: null });\n        };\n        _this.clear = function () {\n            _this.onClearClick();\n        };\n        _this.onScroll = function (event) {\n            if (typeof _this.props.closeOnScroll === \"boolean\" &&\n                _this.props.closeOnScroll) {\n                if (event.target === document ||\n                    event.target === document.documentElement ||\n                    event.target === document.body) {\n                    _this.setOpen(false);\n                }\n            }\n            else if (typeof _this.props.closeOnScroll === \"function\") {\n                if (_this.props.closeOnScroll(event)) {\n                    _this.setOpen(false);\n                }\n            }\n        };\n        _this.renderCalendar = function () {\n            var _a, _b;\n            if (!_this.props.inline && !_this.isCalendarOpen()) {\n                return null;\n            }\n            return (react__WEBPACK_IMPORTED_MODULE_1___default().createElement(Calendar, _assign({ showMonthYearDropdown: undefined, ref: function (elem) {\n                    _this.calendar = elem;\n                } }, _this.props, _this.state, { setOpen: _this.setOpen, dateFormat: (_a = _this.props.dateFormatCalendar) !== null && _a !== void 0 ? _a : DatePicker.defaultProps.dateFormatCalendar, onSelect: _this.handleSelect, onClickOutside: _this.handleCalendarClickOutside, holidays: getHolidaysMap(_this.modifyHolidays()), outsideClickIgnoreClass: _this.props.outsideClickIgnoreClass, onDropdownFocus: _this.handleDropdownFocus, onTimeChange: _this.handleTimeChange, className: _this.props.calendarClassName, container: _this.props.calendarContainer, handleOnKeyDown: _this.props.onKeyDown, handleOnDayKeyDown: _this.onDayKeyDown, setPreSelection: _this.setPreSelection, dropdownMode: (_b = _this.props.dropdownMode) !== null && _b !== void 0 ? _b : DatePicker.defaultProps.dropdownMode }), _this.props.children));\n        };\n        _this.renderAriaLiveRegion = function () {\n            var _a;\n            var locale = _this.props.locale;\n            var dateFormat = (_a = _this.props.dateFormat) !== null && _a !== void 0 ? _a : DatePicker.defaultProps.dateFormat;\n            var isContainsTime = _this.props.showTimeInput || _this.props.showTimeSelect;\n            var longDateFormat = isContainsTime ? \"PPPPp\" : \"PPPP\";\n            var ariaLiveMessage;\n            if (_this.props.selectsRange) {\n                ariaLiveMessage = \"Selected start date: \".concat(safeDateFormat(_this.props.startDate, {\n                    dateFormat: longDateFormat,\n                    locale: locale,\n                }), \". \").concat(_this.props.endDate\n                    ? \"End date: \" +\n                        safeDateFormat(_this.props.endDate, {\n                            dateFormat: longDateFormat,\n                            locale: locale,\n                        })\n                    : \"\");\n            }\n            else {\n                if (_this.props.showTimeSelectOnly) {\n                    ariaLiveMessage = \"Selected time: \".concat(safeDateFormat(_this.props.selected, { dateFormat: dateFormat, locale: locale }));\n                }\n                else if (_this.props.showYearPicker) {\n                    ariaLiveMessage = \"Selected year: \".concat(safeDateFormat(_this.props.selected, { dateFormat: \"yyyy\", locale: locale }));\n                }\n                else if (_this.props.showMonthYearPicker) {\n                    ariaLiveMessage = \"Selected month: \".concat(safeDateFormat(_this.props.selected, { dateFormat: \"MMMM yyyy\", locale: locale }));\n                }\n                else if (_this.props.showQuarterYearPicker) {\n                    ariaLiveMessage = \"Selected quarter: \".concat(safeDateFormat(_this.props.selected, {\n                        dateFormat: \"yyyy, QQQ\",\n                        locale: locale,\n                    }));\n                }\n                else {\n                    ariaLiveMessage = \"Selected date: \".concat(safeDateFormat(_this.props.selected, {\n                        dateFormat: longDateFormat,\n                        locale: locale,\n                    }));\n                }\n            }\n            return (react__WEBPACK_IMPORTED_MODULE_1___default().createElement(\"span\", { role: \"alert\", \"aria-live\": \"polite\", className: \"react-datepicker__aria-live\" }, ariaLiveMessage));\n        };\n        _this.renderDateInput = function () {\n            var _a, _b;\n            var _c, _d, _e, _f;\n            var className = (0,clsx__WEBPACK_IMPORTED_MODULE_0__.clsx)(_this.props.className, (_a = {},\n                _a[_this.props.outsideClickIgnoreClass ||\n                    DatePicker.defaultProps.outsideClickIgnoreClass] = _this.state.open,\n                _a));\n            var customInput = _this.props.customInput || react__WEBPACK_IMPORTED_MODULE_1___default().createElement(\"input\", { type: \"text\" });\n            var customInputRef = _this.props.customInputRef || \"ref\";\n            // Build aria props object, only including defined values to avoid\n            // overwriting aria attributes that may be set on the custom input\n            var ariaProps = {};\n            var ariaDescribedBy = (_c = _this.props[\"aria-describedby\"]) !== null && _c !== void 0 ? _c : _this.props.ariaDescribedBy;\n            var ariaInvalid = (_d = _this.props[\"aria-invalid\"]) !== null && _d !== void 0 ? _d : _this.props.ariaInvalid;\n            var ariaLabelledBy = (_e = _this.props[\"aria-labelledby\"]) !== null && _e !== void 0 ? _e : _this.props.ariaLabelledBy;\n            var ariaRequired = (_f = _this.props[\"aria-required\"]) !== null && _f !== void 0 ? _f : _this.props.ariaRequired;\n            if (ariaDescribedBy != null)\n                ariaProps[\"aria-describedby\"] = ariaDescribedBy;\n            if (ariaInvalid != null)\n                ariaProps[\"aria-invalid\"] = ariaInvalid;\n            if (ariaLabelledBy != null)\n                ariaProps[\"aria-labelledby\"] = ariaLabelledBy;\n            if (ariaRequired != null)\n                ariaProps[\"aria-required\"] = ariaRequired;\n            return (0,react__WEBPACK_IMPORTED_MODULE_1__.cloneElement)(customInput, _assign((_b = {}, _b[customInputRef] = function (input) {\n                _this.input = input;\n            }, _b.value = _this.getInputValue(), _b.onBlur = _this.handleBlur, _b.onChange = _this.handleChange, _b.onClick = _this.onInputClick, _b.onFocus = _this.handleFocus, _b.onKeyDown = _this.onInputKeyDown, _b.id = _this.props.id, _b.name = _this.props.name, _b.form = _this.props.form, _b.autoFocus = _this.props.autoFocus, _b.placeholder = _this.props.placeholderText, _b.disabled = _this.props.disabled, _b.autoComplete = _this.props.autoComplete, _b.className = (0,clsx__WEBPACK_IMPORTED_MODULE_0__.clsx)(customInput.props.className, className), _b.title = _this.props.title, _b.readOnly = _this.props.readOnly, _b.required = _this.props.required, _b.tabIndex = _this.props.tabIndex, _b), ariaProps));\n        };\n        _this.renderClearButton = function () {\n            var _a = _this.props, isClearable = _a.isClearable, disabled = _a.disabled, selected = _a.selected, startDate = _a.startDate, endDate = _a.endDate, clearButtonTitle = _a.clearButtonTitle, _b = _a.clearButtonClassName, clearButtonClassName = _b === void 0 ? \"\" : _b, _c = _a.ariaLabelClose, ariaLabelClose = _c === void 0 ? \"Close\" : _c, selectedDates = _a.selectedDates, readOnly = _a.readOnly;\n            if (isClearable &&\n                !readOnly &&\n                (selected != null ||\n                    startDate != null ||\n                    endDate != null ||\n                    (selectedDates === null || selectedDates === void 0 ? void 0 : selectedDates.length))) {\n                return (react__WEBPACK_IMPORTED_MODULE_1___default().createElement(\"button\", { type: \"button\", className: (0,clsx__WEBPACK_IMPORTED_MODULE_0__.clsx)(\"react-datepicker__close-icon\", clearButtonClassName, { \"react-datepicker__close-icon--disabled\": disabled }), disabled: disabled, \"aria-label\": ariaLabelClose, onClick: _this.onClearClick, title: clearButtonTitle, tabIndex: -1 }));\n            }\n            else {\n                return null;\n            }\n        };\n        _this.state = _this.calcInitialState();\n        _this.preventFocusTimeout = undefined;\n        return _this;\n    }\n    Object.defineProperty(DatePicker, \"defaultProps\", {\n        get: function () {\n            return {\n                allowSameDay: false,\n                dateFormat: \"MM/dd/yyyy\",\n                dateFormatCalendar: \"LLLL yyyy\",\n                disabled: false,\n                disabledKeyboardNavigation: false,\n                dropdownMode: \"scroll\",\n                preventOpenOnFocus: false,\n                monthsShown: 1,\n                outsideClickIgnoreClass: OUTSIDE_CLICK_IGNORE_CLASS,\n                readOnly: false,\n                rangeSeparator: DATE_RANGE_SEPARATOR,\n                withPortal: false,\n                selectsDisabledDaysInRange: false,\n                shouldCloseOnSelect: true,\n                showTimeSelect: false,\n                showTimeInput: false,\n                showPreviousMonths: false,\n                showMonthYearPicker: false,\n                showFullMonthYearPicker: false,\n                showTwoColumnMonthYearPicker: false,\n                showFourColumnMonthYearPicker: false,\n                showYearPicker: false,\n                showQuarterYearPicker: false,\n                showWeekPicker: false,\n                strictParsing: false,\n                swapRange: false,\n                timeIntervals: 30,\n                timeCaption: \"Time\",\n                previousMonthAriaLabel: \"Previous Month\",\n                previousMonthButtonLabel: \"Previous Month\",\n                nextMonthAriaLabel: \"Next Month\",\n                nextMonthButtonLabel: \"Next Month\",\n                previousYearAriaLabel: \"Previous Year\",\n                previousYearButtonLabel: \"Previous Year\",\n                nextYearAriaLabel: \"Next Year\",\n                nextYearButtonLabel: \"Next Year\",\n                timeInputLabel: \"Time\",\n                enableTabLoop: true,\n                yearItemNumber: DEFAULT_YEAR_ITEM_NUMBER,\n                focusSelectedMonth: false,\n                showPopperArrow: true,\n                excludeScrollbar: true,\n                customTimeInput: null,\n                calendarStartDay: undefined,\n                toggleCalendarOnIconClick: false,\n                usePointerEvent: false,\n            };\n        },\n        enumerable: false,\n        configurable: true\n    });\n    DatePicker.prototype.componentDidMount = function () {\n        window.addEventListener(\"scroll\", this.onScroll, true);\n        document.addEventListener(\"visibilitychange\", this.setHiddenStateOnVisibilityHidden);\n    };\n    DatePicker.prototype.componentDidUpdate = function (prevProps, prevState) {\n        var _a, _b, _c, _d;\n        if (prevProps.inline &&\n            hasPreSelectionChanged(prevProps.selected, this.props.selected)) {\n            this.setPreSelection(this.props.selected);\n        }\n        if (this.state.monthSelectedIn !== undefined &&\n            prevProps.monthsShown !== this.props.monthsShown) {\n            this.setState({ monthSelectedIn: 0 });\n        }\n        if (this.props.selectsRange && this.state.monthSelectedIn !== 0) {\n            this.setState({ monthSelectedIn: 0 });\n        }\n        if (prevProps.highlightDates !== this.props.highlightDates) {\n            this.setState({\n                highlightDates: getHighLightDaysMap(this.props.highlightDates),\n            });\n        }\n        if (!prevState.focused &&\n            !isEqual(prevProps.selected, this.props.selected)) {\n            this.setState({ inputValue: null });\n        }\n        if (prevState.open !== this.state.open) {\n            if (prevState.open === false && this.state.open === true) {\n                (_b = (_a = this.props).onCalendarOpen) === null || _b === void 0 ? void 0 : _b.call(_a);\n            }\n            if (prevState.open === true && this.state.open === false) {\n                (_d = (_c = this.props).onCalendarClose) === null || _d === void 0 ? void 0 : _d.call(_c);\n            }\n        }\n    };\n    DatePicker.prototype.componentWillUnmount = function () {\n        this.clearPreventFocusTimeout();\n        window.removeEventListener(\"scroll\", this.onScroll, true);\n        document.removeEventListener(\"visibilitychange\", this.setHiddenStateOnVisibilityHidden);\n    };\n    DatePicker.prototype.renderInputContainer = function () {\n        var _a = this.props, showIcon = _a.showIcon, icon = _a.icon, calendarIconClassname = _a.calendarIconClassname, calendarIconClassName = _a.calendarIconClassName, toggleCalendarOnIconClick = _a.toggleCalendarOnIconClick;\n        var open = this.state.open;\n        if (calendarIconClassname) {\n            console.warn(\"calendarIconClassname props is deprecated. should use calendarIconClassName props.\");\n        }\n        return (react__WEBPACK_IMPORTED_MODULE_1___default().createElement(\"div\", { className: \"react-datepicker__input-container\".concat(showIcon ? \" react-datepicker__view-calendar-icon\" : \"\") },\n            showIcon && (react__WEBPACK_IMPORTED_MODULE_1___default().createElement(CalendarIcon, _assign({ icon: icon, className: (0,clsx__WEBPACK_IMPORTED_MODULE_0__.clsx)(calendarIconClassName, !calendarIconClassName && calendarIconClassname, open && \"react-datepicker-ignore-onclickoutside\") }, (toggleCalendarOnIconClick\n                ? {\n                    onClick: this.toggleCalendar,\n                }\n                : null)))),\n            this.state.isRenderAriaLiveMessage && this.renderAriaLiveRegion(),\n            this.renderDateInput(),\n            this.renderClearButton()));\n    };\n    DatePicker.prototype.render = function () {\n        var calendar = this.renderCalendar();\n        if (this.props.inline)\n            return calendar;\n        if (this.props.withPortal) {\n            var portalContainer = this.state.open ? (react__WEBPACK_IMPORTED_MODULE_1___default().createElement(TabLoop, { enableTabLoop: this.props.enableTabLoop },\n                react__WEBPACK_IMPORTED_MODULE_1___default().createElement(\"div\", { className: \"react-datepicker__portal\", tabIndex: -1, onKeyDown: this.onPortalKeyDown }, calendar))) : null;\n            if (this.state.open && this.props.portalId) {\n                portalContainer = (react__WEBPACK_IMPORTED_MODULE_1___default().createElement(Portal, _assign({ portalId: this.props.portalId }, this.props), portalContainer));\n            }\n            return (react__WEBPACK_IMPORTED_MODULE_1___default().createElement(\"div\", null,\n                this.renderInputContainer(),\n                portalContainer));\n        }\n        return (react__WEBPACK_IMPORTED_MODULE_1___default().createElement(PopperComponent, _assign({}, this.props, { className: this.props.popperClassName, hidePopper: !this.isCalendarOpen(), targetComponent: this.renderInputContainer(), popperComponent: calendar, popperOnKeyDown: this.onPopperKeyDown, showArrow: this.props.showPopperArrow })));\n    };\n    return DatePicker;\n}(react__WEBPACK_IMPORTED_MODULE_1__.Component));\nvar PRESELECT_CHANGE_VIA_INPUT = \"input\";\nvar PRESELECT_CHANGE_VIA_NAVIGATE = \"navigate\";\n\n\n//# sourceMappingURL=index.es.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvcmVhY3QtZGF0ZXBpY2tlci9kaXN0L2luZGV4LmVzLmpzIiwibWFwcGluZ3MiOiI7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQzRCO0FBQ3FGO0FBQ3dzQjtBQUN4dEI7QUFDaEU7O0FBRWpDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDZDQUE2QyxPQUFPO0FBQ3BEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwyRUFBMkUsT0FBTztBQUNsRjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxZQUFZLDBEQUFtQixVQUFVLCtIQUErSDtBQUN4Szs7QUFFQTtBQUNBLGNBQWMsNkNBQU07QUFDcEIsNEJBQTRCLDZDQUFNO0FBQ2xDLElBQUksZ0RBQVM7QUFDYjtBQUNBLEtBQUs7QUFDTCw2QkFBNkIsa0RBQVc7QUFDeEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLCtDQUErQyxxQ0FBcUM7QUFDcEY7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTCxJQUFJLGdEQUFTO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFlBQVksMERBQW1CLFVBQVU7QUFDekM7QUFDQTtBQUNBO0FB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QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGVBQWUsc0RBQWE7QUFDNUI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGVBQWUsd0RBQWU7QUFDOUI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGVBQWUsb0RBQVc7QUFDMUI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGVBQWUsa0RBQVM7QUFDeEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZ0JBQWdCLHFEQUFVO0FBQzFCLGNBQWMsbURBQVE7QUFDdEI7QUFDQSxnQkFBZ0IsMkRBQWdCLFFBQVEsd0JBQXdCO0FBQ2hFO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNB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Q1g7QUFDQTs7QUFFb0g7QUFDcEgiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9pbnZvaWNlLWFwcC8uL25vZGVfbW9kdWxlcy9yZWFjdC1kYXRlcGlja2VyL2Rpc3QvaW5kZXguZXMuanM/OTQwMCJdLCJzb3VyY2VzQ29udGVudCI6WyIvKiFcbiAgcmVhY3QtZGF0ZXBpY2tlciB2OC4xMC4wXG4gIGh0dHBzOi8vZ2l0aHViLmNvbS9IYWNrZXIweDAxL3JlYWN0LWRhdGVwaWNrZXJcbiAgUmVsZWFzZWQgdW5kZXIgdGhlIE1JVCBMaWNlbnNlLlxuKi9cbmltcG9ydCB7IGNsc3ggfSBmcm9tICdjbHN4JztcbmltcG9ydCBSZWFjdCwgeyB1c2VSZWYsIHVzZUVmZmVjdCwgdXNlQ2FsbGJhY2ssIGNsb25lRWxlbWVudCwgQ29tcG9uZW50LCBjcmVhdGVSZWYsIGNyZWF0ZUVsZW1lbnQgfSBmcm9tICdyZWFjdCc7XG5pbXBvcnQgeyBpc1NhbWVEYXkgYXMgaXNTYW1lRGF5JDEsIGlzV2l0aGluSW50ZXJ2YWwsIHN0YXJ0T2ZXZWVrLCBmb3JtYXQsIHN0YXJ0T2ZEYXksIGVuZE9mRGF5LCBpc0VxdWFsIGFzIGlzRXF1YWwkMSwgcGFyc2VJU08sIHRvRGF0ZSwgZGlmZmVyZW5jZUluQ2FsZW5kYXJEYXlzLCBpc1ZhbGlkIGFzIGlzVmFsaWQkMSwgaXNCZWZvcmUsIGdldElTT1dlZWssIGlzU2FtZU1vbnRoIGFzIGlzU2FtZU1vbnRoJDEsIGlzU2FtZVF1YXJ0ZXIgYXMgaXNTYW1lUXVhcnRlciQxLCBnZXRZZWFyLCBnZXRNb250aCwgZ2V0UXVhcnRlciwgc3RhcnRPZk1vbnRoLCBzdGFydE9mUXVhcnRlciwgZW5kT2ZNb250aCwgc2V0TW9udGgsIHNldFF1YXJ0ZXIsIGlzU2FtZVllYXIgYXMgaXNTYW1lWWVhciQxLCBzZXRIb3VycywgZ2V0SG91cnMsIHNldE1pbnV0ZXMsIGdldE1pbnV0ZXMsIHNldFNlY29uZHMsIGdldFNlY29uZHMsIGFkZEhvdXJzLCBhZGRNaW51dGVzLCBhZGRTZWNvbmRzLCBpc0FmdGVyLCBzdGFydE9mWWVhciwgZW5kT2ZZZWFyLCBtaW4sIG1heCwgc3ViTW9udGhzLCBkaWZmZXJlbmNlSW5DYWxlbmRhck1vbnRocywgc3ViUXVhcnRlcnMsIGRpZmZlcmVuY2VJbkNhbGVuZGFyUXVhcnRlcnMsIHN1YlllYXJzLCBkaWZmZXJlbmNlSW5DYWxlbmRhclllYXJzLCBhZGRNb250aHMsIGFkZFF1YXJ0ZXJzLCBhZGRZZWFycywgaXNEYXRlLCBwYXJzZSwgZW5kT2ZXZWVrLCBnZXREYXksIGdldERhdGUsIGFkZERheXMsIGFkZFdlZWtzLCBnZXRUaW1lLCBzZXRZZWFyLCBkaWZmZXJlbmNlSW5EYXlzLCBzdWJXZWVrcywgc3ViRGF5cyB9IGZyb20gJ2RhdGUtZm5zJztcbmltcG9ydCB7IHVzZUZsb2F0aW5nLCBhdXRvVXBkYXRlLCBmbGlwLCBvZmZzZXQsIGFycm93LCBGbG9hdGluZ0Fycm93IH0gZnJvbSAnQGZsb2F0aW5nLXVpL3JlYWN0JztcbmltcG9ydCBSZWFjdERPTSBmcm9tICdyZWFjdC1kb20nO1xuXG4vKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqXHJcbkNvcHlyaWdodCAoYykgTWljcm9zb2Z0IENvcnBvcmF0aW9uLlxyXG5cclxuUGVybWlzc2lvbiB0byB1c2UsIGNvcHksIG1vZGlmeSwgYW5kL29yIGRpc3RyaWJ1dGUgdGhpcyBzb2Z0d2FyZSBmb3IgYW55XHJcbnB1cnBvc2Ugd2l0aCBvciB3aXRob3V0IGZlZSBpcyBoZXJlYnkgZ3JhbnRlZC5cclxuXHJcblRIRSBTT0ZUV0FSRSBJUyBQUk9WSURFRCBcIkFTIElTXCIgQU5EIFRIRSBBVVRIT1IgRElTQ0xBSU1TIEFMTCBXQVJSQU5USUVTIFdJVEhcclxuUkVHQVJEIFRPIFRISVMgU09GVFdBUkUgSU5DTFVESU5HIEFMTCBJTVBMSUVEIFdBUlJBTlRJRVMgT0YgTUVSQ0hBTlRBQklMSVRZXHJcbkFORCBGSVRORVNTLiBJTiBOTyBFVkVOVCBTSEFMTCBUSEUgQVVUSE9SIEJFIExJQUJMRSBGT1IgQU5ZIFNQRUNJQUwsIERJUkVDVCxcclxuSU5ESVJFQ1QsIE9SIENPTlNFUVVFTlRJQUwgREFNQUdFUyBPUiBBTlkgREFNQUdFUyBXSEFUU09FVkVSIFJFU1VMVElORyBGUk9NXHJcbkxPU1MgT0YgVVNFLCBEQVRBIE9SIFBST0ZJVFMsIFdIRVRIRVIgSU4gQU4gQUNUSU9OIE9GIENPTlRSQUNULCBORUdMSUdFTkNFIE9SXHJcbk9USEVSIFRPUlRJT1VTIEFDVElPTiwgQVJJU0lORyBPVVQgT0YgT1IgSU4gQ09OTkVDVElPTiBXSVRIIFRIRSBVU0UgT1JcclxuUEVSRk9STUFOQ0UgT0YgVEhJUyBTT0ZUV0FSRS5cclxuKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiogKi9cbi8qIGdsb2JhbCBSZWZsZWN0LCBQcm9taXNlLCBTdXBwcmVzc2VkRXJyb3IsIFN5bWJvbCwgSXRlcmF0b3IgKi9cblxudmFyIF9leHRlbmRTdGF0aWNzID0gZnVuY3Rpb24gZXh0ZW5kU3RhdGljcyhkLCBiKSB7XG4gIF9leHRlbmRTdGF0aWNzID0gT2JqZWN0LnNldFByb3RvdHlwZU9mIHx8IHtcbiAgICBfX3Byb3RvX186IFtdXG4gIH0gaW5zdGFuY2VvZiBBcnJheSAmJiBmdW5jdGlvbiAoZCwgYikge1xuICAgIGQuX19wcm90b19fID0gYjtcbiAgfSB8fCBmdW5jdGlvbiAoZCwgYikge1xuICAgIGZvciAodmFyIHAgaW4gYikgaWYgKE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbChiLCBwKSkgZFtwXSA9IGJbcF07XG4gIH07XG4gIHJldHVybiBfZXh0ZW5kU3RhdGljcyhkLCBiKTtcbn07XG5mdW5jdGlvbiBfX2V4dGVuZHMoZCwgYikge1xuICBpZiAodHlwZW9mIGIgIT09IFwiZnVuY3Rpb25cIiAmJiBiICE9PSBudWxsKSB0aHJvdyBuZXcgVHlwZUVycm9yKFwiQ2xhc3MgZXh0ZW5kcyB2YWx1ZSBcIiArIFN0cmluZyhiKSArIFwiIGlzIG5vdCBhIGNvbnN0cnVjdG9yIG9yIG51bGxcIik7XG4gIF9leHRlbmRTdGF0aWNzKGQsIGIpO1xuICBmdW5jdGlvbiBfXygpIHtcbiAgICB0aGlzLmNvbnN0cnVjdG9yID0gZDtcbiAgfVxuICBkLnByb3RvdHlwZSA9IGIgPT09IG51bGwgPyBPYmplY3QuY3JlYXRlKGIpIDogKF9fLnByb3RvdHlwZSA9IGIucHJvdG90eXBlLCBuZXcgX18oKSk7XG59XG52YXIgX2Fzc2lnbiA9IGZ1bmN0aW9uIF9fYXNzaWduKCkge1xuICBfYXNzaWduID0gT2JqZWN0LmFzc2lnbiB8fCBmdW5jdGlvbiBfX2Fzc2lnbih0KSB7XG4gICAgZm9yICh2YXIgcywgaSA9IDEsIG4gPSBhcmd1bWVudHMubGVuZ3RoOyBpIDwgbjsgaSsrKSB7XG4gICAgICBzID0gYXJndW1lbnRzW2ldO1xuICAgICAgZm9yICh2YXIgcCBpbiBzKSBpZiAoT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKHMsIHApKSB0W3BdID0gc1twXTtcbiAgICB9XG4gICAgcmV0dXJuIHQ7XG4gIH07XG4gIHJldHVybiBfYXNzaWduLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XG59O1xuZnVuY3Rpb24gX19zcHJlYWRBcnJheSh0bywgZnJvbSwgcGFjaykge1xuICBpZiAocGFjayB8fCBhcmd1bWVudHMubGVuZ3RoID09PSAyKSBmb3IgKHZhciBpID0gMCwgbCA9IGZyb20ubGVuZ3RoLCBhcjsgaSA8IGw7IGkrKykge1xuICAgIGlmIChhciB8fCAhKGkgaW4gZnJvbSkpIHtcbiAgICAgIGlmICghYXIpIGFyID0gQXJyYXkucHJvdG90eXBlLnNsaWNlLmNhbGwoZnJvbSwgMCwgaSk7XG4gICAgICBhcltpXSA9IGZyb21baV07XG4gICAgfVxuICB9XG4gIHJldHVybiB0by5jb25jYXQoYXIgfHwgQXJyYXkucHJvdG90eXBlLnNsaWNlLmNhbGwoZnJvbSkpO1xufVxudHlwZW9mIFN1cHByZXNzZWRFcnJvciA9PT0gXCJmdW5jdGlvblwiID8gU3VwcHJlc3NlZEVycm9yIDogZnVuY3Rpb24gKGVycm9yLCBzdXBwcmVzc2VkLCBtZXNzYWdlKSB7XG4gIHZhciBlID0gbmV3IEVycm9yKG1lc3NhZ2UpO1xuICByZXR1cm4gZS5uYW1lID0gXCJTdXBwcmVzc2VkRXJyb3JcIiwgZS5lcnJvciA9IGVycm9yLCBlLnN1cHByZXNzZWQgPSBzdXBwcmVzc2VkLCBlO1xufTtcblxudmFyIENhbGVuZGFyQ29udGFpbmVyID0gZnVuY3Rpb24gKF9hKSB7XG4gICAgdmFyIF9iID0gX2Euc2hvd1RpbWVTZWxlY3RPbmx5LCBzaG93VGltZVNlbGVjdE9ubHkgPSBfYiA9PT0gdm9pZCAwID8gZmFsc2UgOiBfYiwgX2MgPSBfYS5zaG93VGltZSwgc2hvd1RpbWUgPSBfYyA9PT0gdm9pZCAwID8gZmFsc2UgOiBfYywgY2xhc3NOYW1lID0gX2EuY2xhc3NOYW1lLCBjaGlsZHJlbiA9IF9hLmNoaWxkcmVuLCBpbmxpbmUgPSBfYS5pbmxpbmU7XG4gICAgdmFyIGFyaWFMYWJlbCA9IHNob3dUaW1lU2VsZWN0T25seVxuICAgICAgICA/IFwiQ2hvb3NlIFRpbWVcIlxuICAgICAgICA6IFwiQ2hvb3NlIERhdGVcIi5jb25jYXQoc2hvd1RpbWUgPyBcIiBhbmQgVGltZVwiIDogXCJcIik7XG4gICAgcmV0dXJuIChSZWFjdC5jcmVhdGVFbGVtZW50KFwiZGl2XCIsIHsgY2xhc3NOYW1lOiBjbGFzc05hbWUsIFwiYXJpYS1sYWJlbFwiOiBhcmlhTGFiZWwsIHJvbGU6IGlubGluZSA/IHVuZGVmaW5lZCA6IFwiZGlhbG9nXCIsIFwiYXJpYS1tb2RhbFwiOiBpbmxpbmUgPyB1bmRlZmluZWQgOiBcInRydWVcIiB9LCBjaGlsZHJlbikpO1xufTtcblxudmFyIHVzZURldGVjdENsaWNrT3V0c2lkZSA9IGZ1bmN0aW9uIChvbkNsaWNrT3V0c2lkZSwgaWdub3JlQ2xhc3MpIHtcbiAgICB2YXIgcmVmID0gdXNlUmVmKG51bGwpO1xuICAgIHZhciBvbkNsaWNrT3V0c2lkZVJlZiA9IHVzZVJlZihvbkNsaWNrT3V0c2lkZSk7XG4gICAgdXNlRWZmZWN0KGZ1bmN0aW9uICgpIHtcbiAgICAgICAgb25DbGlja091dHNpZGVSZWYuY3VycmVudCA9IG9uQ2xpY2tPdXRzaWRlO1xuICAgIH0sIFtvbkNsaWNrT3V0c2lkZV0pO1xuICAgIHZhciBoYW5kbGVDbGlja091dHNpZGUgPSB1c2VDYWxsYmFjayhmdW5jdGlvbiAoZXZlbnQpIHtcbiAgICAgICAgdmFyIF9hO1xuICAgICAgICB2YXIgdGFyZ2V0ID0gKGV2ZW50LmNvbXBvc2VkICYmXG4gICAgICAgICAgICBldmVudC5jb21wb3NlZFBhdGggJiZcbiAgICAgICAgICAgIGV2ZW50XG4gICAgICAgICAgICAgICAgLmNvbXBvc2VkUGF0aCgpXG4gICAgICAgICAgICAgICAgLmZpbmQoZnVuY3Rpb24gKGV2ZW50VGFyZ2V0KSB7IHJldHVybiBldmVudFRhcmdldCBpbnN0YW5jZW9mIE5vZGU7IH0pKSB8fFxuICAgICAgICAgICAgZXZlbnQudGFyZ2V0O1xuICAgICAgICBpZiAocmVmLmN1cnJlbnQgJiYgIXJlZi5jdXJyZW50LmNvbnRhaW5zKHRhcmdldCkpIHtcbiAgICAgICAgICAgIGlmICghKGlnbm9yZUNsYXNzICYmXG4gICAgICAgICAgICAgICAgdGFyZ2V0IGluc3RhbmNlb2YgSFRNTEVsZW1lbnQgJiZcbiAgICAgICAgICAgICAgICB0YXJnZXQuY2xhc3NMaXN0LmNvbnRhaW5zKGlnbm9yZUNsYXNzKSkpIHtcbiAgICAgICAgICAgICAgICAoX2EgPSBvbkNsaWNrT3V0c2lkZVJlZi5jdXJyZW50KSA9PT0gbnVsbCB8fCBfYSA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2EuY2FsbChvbkNsaWNrT3V0c2lkZVJlZiwgZXZlbnQpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfSwgW2lnbm9yZUNsYXNzXSk7XG4gICAgdXNlRWZmZWN0KGZ1bmN0aW9uICgpIHtcbiAgICAgICAgZG9jdW1lbnQuYWRkRXZlbnRMaXN0ZW5lcihcIm1vdXNlZG93blwiLCBoYW5kbGVDbGlja091dHNpZGUpO1xuICAgICAgICByZXR1cm4gZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgZG9jdW1lbnQucmVtb3ZlRXZlbnRMaXN0ZW5lcihcIm1vdXNlZG93blwiLCBoYW5kbGVDbGlja091dHNpZGUpO1xuICAgICAgICB9O1xuICAgIH0sIFtoYW5kbGVDbGlja091dHNpZGVdKTtcbiAgICByZXR1cm4gcmVmO1xufTtcbnZhciBDbGlja091dHNpZGVXcmFwcGVyID0gZnVuY3Rpb24gKF9hKSB7XG4gICAgdmFyIGNoaWxkcmVuID0gX2EuY2hpbGRyZW4sIG9uQ2xpY2tPdXRzaWRlID0gX2Eub25DbGlja091dHNpZGUsIGNsYXNzTmFtZSA9IF9hLmNsYXNzTmFtZSwgY29udGFpbmVyUmVmID0gX2EuY29udGFpbmVyUmVmLCBzdHlsZSA9IF9hLnN0eWxlLCBpZ25vcmVDbGFzcyA9IF9hLmlnbm9yZUNsYXNzO1xuICAgIHZhciBkZXRlY3RSZWYgPSB1c2VEZXRlY3RDbGlja091dHNpZGUob25DbGlja091dHNpZGUsIGlnbm9yZUNsYXNzKTtcbiAgICByZXR1cm4gKFJlYWN0LmNyZWF0ZUVsZW1lbnQoXCJkaXZcIiwgeyBjbGFzc05hbWU6IGNsYXNzTmFtZSwgc3R5bGU6IHN0eWxlLCByZWY6IGZ1bmN0aW9uIChub2RlKSB7XG4gICAgICAgICAgICBkZXRlY3RSZWYuY3VycmVudCA9IG5vZGU7XG4gICAgICAgICAgICBpZiAoY29udGFpbmVyUmVmKSB7XG4gICAgICAgICAgICAgICAgY29udGFpbmVyUmVmLmN1cnJlbnQgPSBub2RlO1xuICAgICAgICAgICAgfVxuICAgICAgICB9IH0sIGNoaWxkcmVuKSk7XG59O1xuXG52YXIgS2V5VHlwZTtcbihmdW5jdGlvbiAoS2V5VHlwZSkge1xuICAgIEtleVR5cGVbXCJBcnJvd1VwXCJdID0gXCJBcnJvd1VwXCI7XG4gICAgS2V5VHlwZVtcIkFycm93RG93blwiXSA9IFwiQXJyb3dEb3duXCI7XG4gICAgS2V5VHlwZVtcIkFycm93TGVmdFwiXSA9IFwiQXJyb3dMZWZ0XCI7XG4gICAgS2V5VHlwZVtcIkFycm93UmlnaHRcIl0gPSBcIkFycm93UmlnaHRcIjtcbiAgICBLZXlUeXBlW1wiUGFnZVVwXCJdID0gXCJQYWdlVXBcIjtcbiAgICBLZXlUeXBlW1wiUGFnZURvd25cIl0gPSBcIlBhZ2VEb3duXCI7XG4gICAgS2V5VHlwZVtcIkhvbWVcIl0gPSBcIkhvbWVcIjtcbiAgICBLZXlUeXBlW1wiRW5kXCJdID0gXCJFbmRcIjtcbiAgICBLZXlUeXBlW1wiRW50ZXJcIl0gPSBcIkVudGVyXCI7XG4gICAgS2V5VHlwZVtcIlNwYWNlXCJdID0gXCIgXCI7XG4gICAgS2V5VHlwZVtcIlRhYlwiXSA9IFwiVGFiXCI7XG4gICAgS2V5VHlwZVtcIkVzY2FwZVwiXSA9IFwiRXNjYXBlXCI7XG4gICAgS2V5VHlwZVtcIkJhY2tzcGFjZVwiXSA9IFwiQmFja3NwYWNlXCI7XG4gICAgS2V5VHlwZVtcIlhcIl0gPSBcInhcIjtcbn0pKEtleVR5cGUgfHwgKEtleVR5cGUgPSB7fSkpO1xuZnVuY3Rpb24gZ2V0TG9jYWxlU2NvcGUoKSB7XG4gICAgLy8gVXNlIHRoaXMgY2FzdCB0byBhdm9pZCBtZXNzaW5nIHdpdGggdXNlcnMgZ2xvYmFsVGhpcyAobGlrZSB3aW5kb3cpIGFuZCB0aGUgcmVzdCBvZiBrZXlzIGluIHRoZSBnbG9iYWxUaGlzIG9iamVjdCB3ZSBkb24ndCBjYXJlIGFib3V0XG4gICAgdmFyIHNjb3BlID0gKHR5cGVvZiB3aW5kb3cgIT09IFwidW5kZWZpbmVkXCJcbiAgICAgICAgPyB3aW5kb3dcbiAgICAgICAgOiBnbG9iYWxUaGlzKTtcbiAgICByZXR1cm4gc2NvcGU7XG59XG52YXIgREVGQVVMVF9ZRUFSX0lURU1fTlVNQkVSID0gMTI7XG4vLyAqKiBEYXRlIENvbnN0cnVjdG9ycyAqKlxuZnVuY3Rpb24gbmV3RGF0ZSh2YWx1ZSkge1xuICAgIGlmICh2YWx1ZSA9PSBudWxsKSB7XG4gICAgICAgIHJldHVybiBuZXcgRGF0ZSgpO1xuICAgIH1cbiAgICB2YXIgZCA9IHR5cGVvZiB2YWx1ZSA9PT0gXCJzdHJpbmdcIiA/IHBhcnNlSVNPKHZhbHVlKSA6IHRvRGF0ZSh2YWx1ZSk7XG4gICAgcmV0dXJuIGlzVmFsaWQoZCkgPyBkIDogbmV3IERhdGUoKTtcbn1cbi8qKlxuICogUGFyc2VzIGEgZGF0ZS5cbiAqXG4gKiBAcGFyYW0gdmFsdWUgLSBUaGUgc3RyaW5nIHJlcHJlc2VudGluZyB0aGUgRGF0ZSBpbiBhIHBhcnNhYmxlIGZvcm0sIGUuZy4sIElTTyAxODYxXG4gKiBAcGFyYW0gZGF0ZUZvcm1hdCAtIFRoZSBkYXRlIGZvcm1hdC5cbiAqIEBwYXJhbSBsb2NhbGUgLSBUaGUgbG9jYWxlLlxuICogQHBhcmFtIHN0cmljdFBhcnNpbmcgLSBUaGUgc3RyaWN0IHBhcnNpbmcgZmxhZy5cbiAqIEBwYXJhbSByZWZEYXRlIC0gVGhlIGJhc2UgZGF0ZSB0byBiZSBwYXNzZWQgdG8gZGF0ZS1mbnMgcGFyc2UoKSBmdW5jdGlvbi5cbiAqIEByZXR1cm5zIC0gVGhlIHBhcnNlZCBkYXRlIG9yIG51bGwuXG4gKi9cbmZ1bmN0aW9uIHBhcnNlRGF0ZSh2YWx1ZSwgZGF0ZUZvcm1hdCwgbG9jYWxlLCBzdHJpY3RQYXJzaW5nLCByZWZEYXRlKSB7XG4gICAgaWYgKHJlZkRhdGUgPT09IHZvaWQgMCkgeyByZWZEYXRlID0gbmV3RGF0ZSgpOyB9XG4gICAgdmFyIGxvY2FsZU9iamVjdCA9IGdldExvY2FsZU9iamVjdChsb2NhbGUpIHx8IGdldExvY2FsZU9iamVjdChnZXREZWZhdWx0TG9jYWxlKCkpO1xuICAgIHZhciBmb3JtYXRzID0gQXJyYXkuaXNBcnJheShkYXRlRm9ybWF0KSA/IGRhdGVGb3JtYXQgOiBbZGF0ZUZvcm1hdF07XG4gICAgZm9yICh2YXIgX2kgPSAwLCBmb3JtYXRzXzEgPSBmb3JtYXRzOyBfaSA8IGZvcm1hdHNfMS5sZW5ndGg7IF9pKyspIHtcbiAgICAgICAgdmFyIGZvcm1hdF8xID0gZm9ybWF0c18xW19pXTtcbiAgICAgICAgdmFyIHBhcnNlZERhdGUgPSBwYXJzZSh2YWx1ZSwgZm9ybWF0XzEsIHJlZkRhdGUsIHtcbiAgICAgICAgICAgIGxvY2FsZTogbG9jYWxlT2JqZWN0LFxuICAgICAgICAgICAgdXNlQWRkaXRpb25hbFdlZWtZZWFyVG9rZW5zOiB0cnVlLFxuICAgICAgICAgICAgdXNlQWRkaXRpb25hbERheU9mWWVhclRva2VuczogdHJ1ZSxcbiAgICAgICAgfSk7XG4gICAgICAgIGlmIChpc1ZhbGlkKHBhcnNlZERhdGUpICYmXG4gICAgICAgICAgICAoIXN0cmljdFBhcnNpbmcgfHwgdmFsdWUgPT09IGZvcm1hdERhdGUocGFyc2VkRGF0ZSwgZm9ybWF0XzEsIGxvY2FsZSkpKSB7XG4gICAgICAgICAgICByZXR1cm4gcGFyc2VkRGF0ZTtcbiAgICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gbnVsbDtcbn1cbi8qKlxuICogQ2hlY2tzIGlmIGEgZ2l2ZW4gZGF0ZSBpcyB2YWxpZCBhbmQgbm90IGJlZm9yZSB0aGUgbWluaW11bSBkYXRlLlxuICogQHBhcmFtIGRhdGUgLSBUaGUgZGF0ZSB0byBiZSBjaGVja2VkLlxuICogQHBhcmFtIG1pbkRhdGUgLSBUaGUgbWluaW11bSBkYXRlIGFsbG93ZWQuIElmIG5vdCBwcm92aWRlZCwgZGVmYXVsdHMgdG8gXCIxLzEvMTgwMFwiLlxuICogQHJldHVybnMgQSBib29sZWFuIHZhbHVlIGluZGljYXRpbmcgd2hldGhlciB0aGUgZGF0ZSBpcyB2YWxpZCBhbmQgbm90IGJlZm9yZSB0aGUgbWluaW11bSBkYXRlLlxuICovXG5mdW5jdGlvbiBpc1ZhbGlkKGRhdGUsIG1pbkRhdGUpIHtcbiAgICAvKiB0aGUgZmFsbGJhY2sgZGF0ZSBpcyBlc3NlbnRpYWwgdG8gbm90IGJyZWFrIHRlc3QgY2FzZVxuICAgICAqIGBzaG91bGQgYXV0byB1cGRhdGUgY2FsZW5kYXIgd2hlbiB0aGUgdXBkYXRlZCBkYXRlIHRleHQgaXMgYWZ0ZXIgcHJvcHMubWluRGF0ZWBcbiAgICAgKiBhbmQgYmFja3dhcmQgY29tcGF0aWJpbGl0eSByZXNwZWN0ZnVsbHlcbiAgICAgKi9cbiAgICByZXR1cm4gaXNWYWxpZCQxKGRhdGUpICYmICFpc0JlZm9yZShkYXRlLCBuZXcgRGF0ZShcIjEvMS8xODAwXCIpKTtcbn1cbi8vICoqIERhdGUgRm9ybWF0dGluZyAqKlxuLyoqXG4gKiBGb3JtYXRzIGEgZGF0ZS5cbiAqXG4gKiBAcGFyYW0gZGF0ZSAtIFRoZSBkYXRlLlxuICogQHBhcmFtIGZvcm1hdFN0ciAtIFRoZSBmb3JtYXQgc3RyaW5nLlxuICogQHBhcmFtIGxvY2FsZSAtIFRoZSBsb2NhbGUuXG4gKiBAcmV0dXJucyAtIFRoZSBmb3JtYXR0ZWQgZGF0ZS5cbiAqL1xuZnVuY3Rpb24gZm9ybWF0RGF0ZShkYXRlLCBmb3JtYXRTdHIsIGxvY2FsZSkge1xuICAgIGlmIChsb2NhbGUgPT09IFwiZW5cIikge1xuICAgICAgICByZXR1cm4gZm9ybWF0KGRhdGUsIGZvcm1hdFN0ciwge1xuICAgICAgICAgICAgdXNlQWRkaXRpb25hbFdlZWtZZWFyVG9rZW5zOiB0cnVlLFxuICAgICAgICAgICAgdXNlQWRkaXRpb25hbERheU9mWWVhclRva2VuczogdHJ1ZSxcbiAgICAgICAgfSk7XG4gICAgfVxuICAgIHZhciBsb2NhbGVPYmogPSBsb2NhbGUgPyBnZXRMb2NhbGVPYmplY3QobG9jYWxlKSA6IHVuZGVmaW5lZDtcbiAgICBpZiAobG9jYWxlICYmICFsb2NhbGVPYmopIHtcbiAgICAgICAgY29uc29sZS53YXJuKFwiQSBsb2NhbGUgb2JqZWN0IHdhcyBub3QgZm91bmQgZm9yIHRoZSBwcm92aWRlZCBzdHJpbmcgW1xcXCJcIi5jb25jYXQobG9jYWxlLCBcIlxcXCJdLlwiKSk7XG4gICAgfVxuICAgIGxvY2FsZU9iaiA9IGxvY2FsZU9iaiB8fCBnZXRMb2NhbGVPYmplY3QoZ2V0RGVmYXVsdExvY2FsZSgpKTtcbiAgICByZXR1cm4gZm9ybWF0KGRhdGUsIGZvcm1hdFN0ciwge1xuICAgICAgICBsb2NhbGU6IGxvY2FsZU9iaixcbiAgICAgICAgdXNlQWRkaXRpb25hbFdlZWtZZWFyVG9rZW5zOiB0cnVlLFxuICAgICAgICB1c2VBZGRpdGlvbmFsRGF5T2ZZZWFyVG9rZW5zOiB0cnVlLFxuICAgIH0pO1xufVxuLyoqXG4gKiBTYWZlbHkgZm9ybWF0cyBhIGRhdGUuXG4gKlxuICogQHBhcmFtIGRhdGUgLSBUaGUgZGF0ZS5cbiAqIEBwYXJhbSBvcHRpb25zIC0gQW4gb2JqZWN0IGNvbnRhaW5pbmcgdGhlIGRhdGVGb3JtYXQgYW5kIGxvY2FsZS5cbiAqIEByZXR1cm5zIC0gVGhlIGZvcm1hdHRlZCBkYXRlIG9yIGFuIGVtcHR5IHN0cmluZy5cbiAqL1xuZnVuY3Rpb24gc2FmZURhdGVGb3JtYXQoZGF0ZSwgX2EpIHtcbiAgICB2YXIgZGF0ZUZvcm1hdCA9IF9hLmRhdGVGb3JtYXQsIGxvY2FsZSA9IF9hLmxvY2FsZTtcbiAgICB2YXIgZm9ybWF0U3RyID0gKEFycmF5LmlzQXJyYXkoZGF0ZUZvcm1hdCkgJiYgZGF0ZUZvcm1hdC5sZW5ndGggPiAwXG4gICAgICAgID8gZGF0ZUZvcm1hdFswXVxuICAgICAgICA6IGRhdGVGb3JtYXQpOyAvLyBDYXN0IHRvIHN0cmluZyBiZWNhdXNlIGl0J3MgaW1wb3NzaWJsZSB0byBnZXQgYHN0cmluZyB8IHN0cmluZ1tdIHwgdW5kZWZpbmVkYCBoZXJlIGFuZCB0eXBlc2NyaXB0IGRvZXNuJ3Qga25vdyB0aGF0XG4gICAgcmV0dXJuIChkYXRlICYmIGZvcm1hdERhdGUoZGF0ZSwgZm9ybWF0U3RyLCBsb2NhbGUpKSB8fCBcIlwiO1xufVxuLyoqXG4gKiBVc2VkIGFzIGEgZGVsaW1pdGVyIHRvIHNlcGFyYXRlIHR3byBkYXRlcyB3aGVuIGZvcm1hdHRpbmcgYSBkYXRlIHJhbmdlXG4gKi9cbnZhciBEQVRFX1JBTkdFX1NFUEFSQVRPUiA9IFwiIC0gXCI7XG4vKipcbiAqIFNhZmVseSBmb3JtYXRzIGEgZGF0ZSByYW5nZS5cbiAqXG4gKiBAcGFyYW0gc3RhcnREYXRlIC0gVGhlIHN0YXJ0IGRhdGUuXG4gKiBAcGFyYW0gZW5kRGF0ZSAtIFRoZSBlbmQgZGF0ZS5cbiAqIEBwYXJhbSBwcm9wcyAtIFRoZSBwcm9wcy5cbiAqIEByZXR1cm5zIC0gVGhlIGZvcm1hdHRlZCBkYXRlIHJhbmdlIG9yIGFuIGVtcHR5IHN0cmluZy5cbiAqL1xuZnVuY3Rpb24gc2FmZURhdGVSYW5nZUZvcm1hdChzdGFydERhdGUsIGVuZERhdGUsIHByb3BzKSB7XG4gICAgaWYgKCFzdGFydERhdGUgJiYgIWVuZERhdGUpIHtcbiAgICAgICAgcmV0dXJuIFwiXCI7XG4gICAgfVxuICAgIHZhciBmb3JtYXR0ZWRTdGFydERhdGUgPSBzdGFydERhdGUgPyBzYWZlRGF0ZUZvcm1hdChzdGFydERhdGUsIHByb3BzKSA6IFwiXCI7XG4gICAgdmFyIGZvcm1hdHRlZEVuZERhdGUgPSBlbmREYXRlID8gc2FmZURhdGVGb3JtYXQoZW5kRGF0ZSwgcHJvcHMpIDogXCJcIjtcbiAgICB2YXIgZGF0ZVJhbmdlU2VwYXJhdG9yID0gcHJvcHMucmFuZ2VTZXBhcmF0b3IgfHwgREFURV9SQU5HRV9TRVBBUkFUT1I7XG4gICAgcmV0dXJuIFwiXCIuY29uY2F0KGZvcm1hdHRlZFN0YXJ0RGF0ZSkuY29uY2F0KGRhdGVSYW5nZVNlcGFyYXRvcikuY29uY2F0KGZvcm1hdHRlZEVuZERhdGUpO1xufVxuLyoqXG4gKiBTYWZlbHkgZm9ybWF0cyBtdWx0aXBsZSBkYXRlcy5cbiAqXG4gKiBAcGFyYW0gZGF0ZXMgLSBUaGUgZGF0ZXMuXG4gKiBAcGFyYW0gcHJvcHMgLSBUaGUgcHJvcHMuXG4gKiBAcmV0dXJucyAtIFRoZSBmb3JtYXR0ZWQgZGF0ZXMgb3IgYW4gZW1wdHkgc3RyaW5nLlxuICovXG5mdW5jdGlvbiBzYWZlTXVsdGlwbGVEYXRlc0Zvcm1hdChkYXRlcywgcHJvcHMpIHtcbiAgICBpZiAoIShkYXRlcyA9PT0gbnVsbCB8fCBkYXRlcyA9PT0gdm9pZCAwID8gdm9pZCAwIDogZGF0ZXMubGVuZ3RoKSkge1xuICAgICAgICByZXR1cm4gXCJcIjtcbiAgICB9XG4gICAgdmFyIGZvcm1hdHRlZEZpcnN0RGF0ZSA9IGRhdGVzWzBdID8gc2FmZURhdGVGb3JtYXQoZGF0ZXNbMF0sIHByb3BzKSA6IFwiXCI7XG4gICAgaWYgKGRhdGVzLmxlbmd0aCA9PT0gMSkge1xuICAgICAgICByZXR1cm4gZm9ybWF0dGVkRmlyc3REYXRlO1xuICAgIH1cbiAgICBpZiAoZGF0ZXMubGVuZ3RoID09PSAyICYmIGRhdGVzWzFdKSB7XG4gICAgICAgIHZhciBmb3JtYXR0ZWRTZWNvbmREYXRlID0gc2FmZURhdGVGb3JtYXQoZGF0ZXNbMV0sIHByb3BzKTtcbiAgICAgICAgcmV0dXJuIFwiXCIuY29uY2F0KGZvcm1hdHRlZEZpcnN0RGF0ZSwgXCIsIFwiKS5jb25jYXQoZm9ybWF0dGVkU2Vjb25kRGF0ZSk7XG4gICAgfVxuICAgIHZhciBleHRyYURhdGVzQ291bnQgPSBkYXRlcy5sZW5ndGggLSAxO1xuICAgIHJldHVybiBcIlwiLmNvbmNhdChmb3JtYXR0ZWRGaXJzdERhdGUsIFwiICgrXCIpLmNvbmNhdChleHRyYURhdGVzQ291bnQsIFwiKVwiKTtcbn1cbi8vICoqIERhdGUgU2V0dGVycyAqKlxuLyoqXG4gKiBTZXRzIHRoZSB0aW1lIGZvciBhIGdpdmVuIGRhdGUuXG4gKlxuICogQHBhcmFtIGRhdGUgLSBUaGUgZGF0ZS5cbiAqIEBwYXJhbSB0aW1lIC0gQW4gb2JqZWN0IGNvbnRhaW5pbmcgdGhlIGhvdXIsIG1pbnV0ZSwgYW5kIHNlY29uZC5cbiAqIEByZXR1cm5zIC0gVGhlIGRhdGUgd2l0aCB0aGUgdGltZSBzZXQuXG4gKi9cbmZ1bmN0aW9uIHNldFRpbWUoZGF0ZSwgX2EpIHtcbiAgICB2YXIgX2IgPSBfYS5ob3VyLCBob3VyID0gX2IgPT09IHZvaWQgMCA/IDAgOiBfYiwgX2MgPSBfYS5taW51dGUsIG1pbnV0ZSA9IF9jID09PSB2b2lkIDAgPyAwIDogX2MsIF9kID0gX2Euc2Vjb25kLCBzZWNvbmQgPSBfZCA9PT0gdm9pZCAwID8gMCA6IF9kO1xuICAgIHJldHVybiBzZXRIb3VycyhzZXRNaW51dGVzKHNldFNlY29uZHMoZGF0ZSwgc2Vjb25kKSwgbWludXRlKSwgaG91cik7XG59XG4vKipcbiAqIEdldHMgdGhlIHdlZWsgb2YgdGhlIHllYXIgZm9yIGEgZ2l2ZW4gZGF0ZS5cbiAqXG4gKiBAcGFyYW0gZGF0ZSAtIFRoZSBkYXRlLlxuICogQHJldHVybnMgLSBUaGUgd2VlayBvZiB0aGUgeWVhci5cbiAqL1xuZnVuY3Rpb24gZ2V0V2VlayhkYXRlKSB7XG4gICAgcmV0dXJuIGdldElTT1dlZWsoZGF0ZSk7XG59XG4vKipcbiAqIEdldHMgdGhlIGRheSBvZiB0aGUgd2VlayBjb2RlIGZvciBhIGdpdmVuIGRheS5cbiAqXG4gKiBAcGFyYW0gZGF5IC0gVGhlIGRheS5cbiAqIEBwYXJhbSBsb2NhbGUgLSBUaGUgbG9jYWxlLlxuICogQHJldHVybnMgLSBUaGUgZGF5IG9mIHRoZSB3ZWVrIGNvZGUuXG4gKi9cbmZ1bmN0aW9uIGdldERheU9mV2Vla0NvZGUoZGF5LCBsb2NhbGUpIHtcbiAgICByZXR1cm4gZm9ybWF0RGF0ZShkYXksIFwiZGRkXCIsIGxvY2FsZSk7XG59XG4vLyAqKiogU3RhcnQgb2YgKioqXG4vKipcbiAqIEdldHMgdGhlIHN0YXJ0IG9mIHRoZSBkYXkgZm9yIGEgZ2l2ZW4gZGF0ZS5cbiAqXG4gKiBAcGFyYW0gZGF0ZSAtIFRoZSBkYXRlLlxuICogQHJldHVybnMgLSBUaGUgc3RhcnQgb2YgdGhlIGRheS5cbiAqL1xuZnVuY3Rpb24gZ2V0U3RhcnRPZkRheShkYXRlKSB7XG4gICAgcmV0dXJuIHN0YXJ0T2ZEYXkoZGF0ZSk7XG59XG4vKipcbiAqIEdldHMgdGhlIHN0YXJ0IG9mIHRoZSB3ZWVrIGZvciBhIGdpdmVuIGRhdGUuXG4gKlxuICogQHBhcmFtIGRhdGUgLSBUaGUgZGF0ZS5cbiAqIEBwYXJhbSBsb2NhbGUgLSBUaGUgbG9jYWxlLlxuICogQHBhcmFtIGNhbGVuZGFyU3RhcnREYXkgLSBUaGUgZGF5IHRoZSBjYWxlbmRhciBzdGFydHMgb24uXG4gKiBAcmV0dXJucyAtIFRoZSBzdGFydCBvZiB0aGUgd2Vlay5cbiAqL1xuZnVuY3Rpb24gZ2V0U3RhcnRPZldlZWsoZGF0ZSwgbG9jYWxlLCBjYWxlbmRhclN0YXJ0RGF5KSB7XG4gICAgdmFyIGxvY2FsZU9iaiA9IGxvY2FsZVxuICAgICAgICA/IGdldExvY2FsZU9iamVjdChsb2NhbGUpXG4gICAgICAgIDogZ2V0TG9jYWxlT2JqZWN0KGdldERlZmF1bHRMb2NhbGUoKSk7XG4gICAgcmV0dXJuIHN0YXJ0T2ZXZWVrKGRhdGUsIHtcbiAgICAgICAgbG9jYWxlOiBsb2NhbGVPYmosXG4gICAgICAgIHdlZWtTdGFydHNPbjogY2FsZW5kYXJTdGFydERheSxcbiAgICB9KTtcbn1cbi8qKlxuICogR2V0cyB0aGUgc3RhcnQgb2YgdGhlIG1vbnRoIGZvciBhIGdpdmVuIGRhdGUuXG4gKlxuICogQHBhcmFtIGRhdGUgLSBUaGUgZGF0ZS5cbiAqIEByZXR1cm5zIC0gVGhlIHN0YXJ0IG9mIHRoZSBtb250aC5cbiAqL1xuZnVuY3Rpb24gZ2V0U3RhcnRPZk1vbnRoKGRhdGUpIHtcbiAgICByZXR1cm4gc3RhcnRPZk1vbnRoKGRhdGUpO1xufVxuLyoqXG4gKiBHZXRzIHRoZSBzdGFydCBvZiB0aGUgeWVhciBmb3IgYSBnaXZlbiBkYXRlLlxuICpcbiAqIEBwYXJhbSBkYXRlIC0gVGhlIGRhdGUuXG4gKiBAcmV0dXJucyAtIFRoZSBzdGFydCBvZiB0aGUgeWVhci5cbiAqL1xuZnVuY3Rpb24gZ2V0U3RhcnRPZlllYXIoZGF0ZSkge1xuICAgIHJldHVybiBzdGFydE9mWWVhcihkYXRlKTtcbn1cbi8qKlxuICogR2V0cyB0aGUgc3RhcnQgb2YgdGhlIHF1YXJ0ZXIgZm9yIGEgZ2l2ZW4gZGF0ZS5cbiAqXG4gKiBAcGFyYW0gZGF0ZSAtIFRoZSBkYXRlLlxuICogQHJldHVybnMgLSBUaGUgc3RhcnQgb2YgdGhlIHF1YXJ0ZXIuXG4gKi9cbmZ1bmN0aW9uIGdldFN0YXJ0T2ZRdWFydGVyKGRhdGUpIHtcbiAgICByZXR1cm4gc3RhcnRPZlF1YXJ0ZXIoZGF0ZSk7XG59XG4vKipcbiAqIEdldHMgdGhlIHN0YXJ0IG9mIHRvZGF5LlxuICpcbiAqIEByZXR1cm5zIC0gVGhlIHN0YXJ0IG9mIHRvZGF5LlxuICovXG5mdW5jdGlvbiBnZXRTdGFydE9mVG9kYXkoKSB7XG4gICAgcmV0dXJuIHN0YXJ0T2ZEYXkobmV3RGF0ZSgpKTtcbn1cbi8vICoqKiBFbmQgb2YgKioqXG4vKipcbiAqIEdldHMgdGhlIGVuZCBvZiB0aGUgZGF5IGZvciBhIGdpdmVuIGRhdGUuXG4gKlxuICogQHBhcmFtIGRhdGUgLSBUaGUgZGF0ZS5cbiAqIEByZXR1cm5zIC0gVGhlIGVuZCBvZiB0aGUgZGF5LlxuICovXG5mdW5jdGlvbiBnZXRFbmRPZkRheShkYXRlKSB7XG4gICAgcmV0dXJuIGVuZE9mRGF5KGRhdGUpO1xufVxuLyoqXG4gKiBHZXRzIHRoZSBlbmQgb2YgdGhlIHdlZWsgZm9yIGEgZ2l2ZW4gZGF0ZS5cbiAqXG4gKiBAcGFyYW0gZGF0ZSAtIFRoZSBkYXRlLlxuICogQHJldHVybnMgLSBUaGUgZW5kIG9mIHRoZSB3ZWVrLlxuICovXG5mdW5jdGlvbiBnZXRFbmRPZldlZWsoZGF0ZSkge1xuICAgIHJldHVybiBlbmRPZldlZWsoZGF0ZSk7XG59XG4vKipcbiAqIEdldHMgdGhlIGVuZCBvZiB0aGUgbW9udGggZm9yIGEgZ2l2ZW4gZGF0ZS5cbiAqXG4gKiBAcGFyYW0gZGF0ZSAtIFRoZSBkYXRlLlxuICogQHJldHVybnMgLSBUaGUgZW5kIG9mIHRoZSBtb250aC5cbiAqL1xuZnVuY3Rpb24gZ2V0RW5kT2ZNb250aChkYXRlKSB7XG4gICAgcmV0dXJuIGVuZE9mTW9udGgoZGF0ZSk7XG59XG4vKipcbiAqIENoZWNrcyBpZiB0d28gZGF0ZXMgYXJlIGluIHRoZSBzYW1lIHllYXIuXG4gKlxuICogQHBhcmFtIGRhdGUxIC0gVGhlIGZpcnN0IGRhdGUuXG4gKiBAcGFyYW0gZGF0ZTIgLSBUaGUgc2Vjb25kIGRhdGUuXG4gKiBAcmV0dXJucyAtIFRydWUgaWYgdGhlIGRhdGVzIGFyZSBpbiB0aGUgc2FtZSB5ZWFyLCBmYWxzZSBvdGhlcndpc2UuXG4gKi9cbmZ1bmN0aW9uIGlzU2FtZVllYXIoZGF0ZTEsIGRhdGUyKSB7XG4gICAgaWYgKGRhdGUxICYmIGRhdGUyKSB7XG4gICAgICAgIHJldHVybiBpc1NhbWVZZWFyJDEoZGF0ZTEsIGRhdGUyKTtcbiAgICB9XG4gICAgZWxzZSB7XG4gICAgICAgIHJldHVybiAhZGF0ZTEgJiYgIWRhdGUyO1xuICAgIH1cbn1cbi8qKlxuICogQ2hlY2tzIGlmIHR3byBkYXRlcyBhcmUgaW4gdGhlIHNhbWUgbW9udGguXG4gKlxuICogQHBhcmFtIGRhdGUxIC0gVGhlIGZpcnN0IGRhdGUuXG4gKiBAcGFyYW0gZGF0ZTIgLSBUaGUgc2Vjb25kIGRhdGUuXG4gKiBAcmV0dXJucyAtIFRydWUgaWYgdGhlIGRhdGVzIGFyZSBpbiB0aGUgc2FtZSBtb250aCwgZmFsc2Ugb3RoZXJ3aXNlLlxuICovXG5mdW5jdGlvbiBpc1NhbWVNb250aChkYXRlMSwgZGF0ZTIpIHtcbiAgICBpZiAoZGF0ZTEgJiYgZGF0ZTIpIHtcbiAgICAgICAgcmV0dXJuIGlzU2FtZU1vbnRoJDEoZGF0ZTEsIGRhdGUyKTtcbiAgICB9XG4gICAgZWxzZSB7XG4gICAgICAgIHJldHVybiAhZGF0ZTEgJiYgIWRhdGUyO1xuICAgIH1cbn1cbi8qKlxuICogQ2hlY2tzIGlmIHR3byBkYXRlcyBhcmUgaW4gdGhlIHNhbWUgcXVhcnRlci5cbiAqXG4gKiBAcGFyYW0gZGF0ZTEgLSBUaGUgZmlyc3QgZGF0ZS5cbiAqIEBwYXJhbSBkYXRlMiAtIFRoZSBzZWNvbmQgZGF0ZS5cbiAqIEByZXR1cm5zIC0gVHJ1ZSBpZiB0aGUgZGF0ZXMgYXJlIGluIHRoZSBzYW1lIHF1YXJ0ZXIsIGZhbHNlIG90aGVyd2lzZS5cbiAqL1xuZnVuY3Rpb24gaXNTYW1lUXVhcnRlcihkYXRlMSwgZGF0ZTIpIHtcbiAgICBpZiAoZGF0ZTEgJiYgZGF0ZTIpIHtcbiAgICAgICAgcmV0dXJuIGlzU2FtZVF1YXJ0ZXIkMShkYXRlMSwgZGF0ZTIpO1xuICAgIH1cbiAgICBlbHNlIHtcbiAgICAgICAgcmV0dXJuICFkYXRlMSAmJiAhZGF0ZTI7XG4gICAgfVxufVxuLyoqXG4gKiBDaGVja3MgaWYgdHdvIGRhdGVzIGFyZSBvbiB0aGUgc2FtZSBkYXkuXG4gKlxuICogQHBhcmFtIGRhdGUxIC0gVGhlIGZpcnN0IGRhdGUuXG4gKiBAcGFyYW0gZGF0ZTIgLSBUaGUgc2Vjb25kIGRhdGUuXG4gKiBAcmV0dXJucyAtIFRydWUgaWYgdGhlIGRhdGVzIGFyZSBvbiB0aGUgc2FtZSBkYXksIGZhbHNlIG90aGVyd2lzZS5cbiAqL1xuZnVuY3Rpb24gaXNTYW1lRGF5KGRhdGUxLCBkYXRlMikge1xuICAgIGlmIChkYXRlMSAmJiBkYXRlMikge1xuICAgICAgICByZXR1cm4gaXNTYW1lRGF5JDEoZGF0ZTEsIGRhdGUyKTtcbiAgICB9XG4gICAgZWxzZSB7XG4gICAgICAgIHJldHVybiAhZGF0ZTEgJiYgIWRhdGUyO1xuICAgIH1cbn1cbi8qKlxuICogQ2hlY2tzIGlmIHR3byBkYXRlcyBhcmUgZXF1YWwuXG4gKlxuICogQHBhcmFtIGRhdGUxIC0gVGhlIGZpcnN0IGRhdGUuXG4gKiBAcGFyYW0gZGF0ZTIgLSBUaGUgc2Vjb25kIGRhdGUuXG4gKiBAcmV0dXJucyAtIFRydWUgaWYgdGhlIGRhdGVzIGFyZSBlcXVhbCwgZmFsc2Ugb3RoZXJ3aXNlLlxuICovXG5mdW5jdGlvbiBpc0VxdWFsKGRhdGUxLCBkYXRlMikge1xuICAgIGlmIChkYXRlMSAmJiBkYXRlMikge1xuICAgICAgICByZXR1cm4gaXNFcXVhbCQxKGRhdGUxLCBkYXRlMik7XG4gICAgfVxuICAgIGVsc2Uge1xuICAgICAgICByZXR1cm4gIWRhdGUxICYmICFkYXRlMjtcbiAgICB9XG59XG4vKipcbiAqIENoZWNrcyBpZiBhIGRheSBpcyB3aXRoaW4gYSBkYXRlIHJhbmdlLlxuICpcbiAqIEBwYXJhbSBkYXkgLSBUaGUgZGF5IHRvIGNoZWNrLlxuICogQHBhcmFtIHN0YXJ0RGF0ZSAtIFRoZSBzdGFydCBkYXRlIG9mIHRoZSByYW5nZS5cbiAqIEBwYXJhbSBlbmREYXRlIC0gVGhlIGVuZCBkYXRlIG9mIHRoZSByYW5nZS5cbiAqIEByZXR1cm5zIC0gVHJ1ZSBpZiB0aGUgZGF5IGlzIHdpdGhpbiB0aGUgcmFuZ2UsIGZhbHNlIG90aGVyd2lzZS5cbiAqL1xuZnVuY3Rpb24gaXNEYXlJblJhbmdlKGRheSwgc3RhcnREYXRlLCBlbmREYXRlKSB7XG4gICAgdmFyIHZhbGlkO1xuICAgIHZhciBzdGFydCA9IHN0YXJ0T2ZEYXkoc3RhcnREYXRlKTtcbiAgICB2YXIgZW5kID0gZW5kT2ZEYXkoZW5kRGF0ZSk7XG4gICAgdHJ5IHtcbiAgICAgICAgdmFsaWQgPSBpc1dpdGhpbkludGVydmFsKGRheSwgeyBzdGFydDogc3RhcnQsIGVuZDogZW5kIH0pO1xuICAgIH1cbiAgICBjYXRjaCAoZXJyKSB7XG4gICAgICAgIHZhbGlkID0gZmFsc2U7XG4gICAgfVxuICAgIHJldHVybiB2YWxpZDtcbn1cbi8vICoqIERhdGUgTG9jYWxpemF0aW9uICoqXG4vKipcbiAqIFJlZ2lzdGVycyBhIGxvY2FsZS5cbiAqXG4gKiBAcGFyYW0gbG9jYWxlTmFtZSAtIFRoZSBuYW1lIG9mIHRoZSBsb2NhbGUuXG4gKiBAcGFyYW0gbG9jYWxlRGF0YSAtIFRoZSBkYXRhIG9mIHRoZSBsb2NhbGUuXG4gKi9cbmZ1bmN0aW9uIHJlZ2lzdGVyTG9jYWxlKGxvY2FsZU5hbWUsIGxvY2FsZURhdGEpIHtcbiAgICB2YXIgc2NvcGUgPSBnZXRMb2NhbGVTY29wZSgpO1xuICAgIGlmICghc2NvcGUuX19sb2NhbGVEYXRhX18pIHtcbiAgICAgICAgc2NvcGUuX19sb2NhbGVEYXRhX18gPSB7fTtcbiAgICB9XG4gICAgc2NvcGUuX19sb2NhbGVEYXRhX19bbG9jYWxlTmFtZV0gPSBsb2NhbGVEYXRhO1xufVxuLyoqXG4gKiBTZXRzIHRoZSBkZWZhdWx0IGxvY2FsZS5cbiAqXG4gKiBAcGFyYW0gbG9jYWxlTmFtZSAtIFRoZSBuYW1lIG9mIHRoZSBsb2NhbGUuXG4gKi9cbmZ1bmN0aW9uIHNldERlZmF1bHRMb2NhbGUobG9jYWxlTmFtZSkge1xuICAgIHZhciBzY29wZSA9IGdldExvY2FsZVNjb3BlKCk7XG4gICAgc2NvcGUuX19sb2NhbGVJZF9fID0gbG9jYWxlTmFtZTtcbn1cbi8qKlxuICogR2V0cyB0aGUgZGVmYXVsdCBsb2NhbGUuXG4gKlxuICogQHJldHVybnMgLSBUaGUgZGVmYXVsdCBsb2NhbGUuXG4gKi9cbmZ1bmN0aW9uIGdldERlZmF1bHRMb2NhbGUoKSB7XG4gICAgdmFyIHNjb3BlID0gZ2V0TG9jYWxlU2NvcGUoKTtcbiAgICByZXR1cm4gc2NvcGUuX19sb2NhbGVJZF9fO1xufVxuLyoqXG4gKiBHZXRzIHRoZSBsb2NhbGUgb2JqZWN0LlxuICpcbiAqIEBwYXJhbSBsb2NhbGVTcGVjIC0gVGhlIGxvY2FsZSBzcGVjaWZpY2F0aW9uLlxuICogQHJldHVybnMgLSBUaGUgbG9jYWxlIG9iamVjdC5cbiAqL1xuZnVuY3Rpb24gZ2V0TG9jYWxlT2JqZWN0KGxvY2FsZVNwZWMpIHtcbiAgICBpZiAodHlwZW9mIGxvY2FsZVNwZWMgPT09IFwic3RyaW5nXCIpIHtcbiAgICAgICAgLy8gVHJlYXQgaXQgYXMgYSBsb2NhbGUgbmFtZSByZWdpc3RlcmVkIGJ5IHJlZ2lzdGVyTG9jYWxlXG4gICAgICAgIHZhciBzY29wZSA9IGdldExvY2FsZVNjb3BlKCk7XG4gICAgICAgIC8vIE51bGwgd2FzIHJlcGxhY2VkIHdpdGggdW5kZWZpbmVkIHRvIGF2b2lkIHR5cGUgY29lcmNpb25cbiAgICAgICAgcmV0dXJuIHNjb3BlLl9fbG9jYWxlRGF0YV9fID8gc2NvcGUuX19sb2NhbGVEYXRhX19bbG9jYWxlU3BlY10gOiB1bmRlZmluZWQ7XG4gICAgfVxuICAgIGVsc2Uge1xuICAgICAgICAvLyBUcmVhdCBpdCBhcyBhIHJhdyBkYXRlLWZucyBsb2NhbGUgb2JqZWN0XG4gICAgICAgIHJldHVybiBsb2NhbGVTcGVjO1xuICAgIH1cbn1cbi8qKlxuICogRm9ybWF0cyB0aGUgd2Vla2RheSBpbiBhIGdpdmVuIGxvY2FsZS5cbiAqXG4gKiBAcGFyYW0gZGF0ZSAtIFRoZSBkYXRlIHRvIGZvcm1hdC5cbiAqIEBwYXJhbSBmb3JtYXRGdW5jIC0gVGhlIGZvcm1hdHRpbmcgZnVuY3Rpb24uXG4gKiBAcGFyYW0gbG9jYWxlIC0gVGhlIGxvY2FsZSB0byB1c2UgZm9yIGZvcm1hdHRpbmcuXG4gKiBAcmV0dXJucyAtIFRoZSBmb3JtYXR0ZWQgd2Vla2RheS5cbiAqL1xuZnVuY3Rpb24gZ2V0Rm9ybWF0dGVkV2Vla2RheUluTG9jYWxlKGRhdGUsIGZvcm1hdEZ1bmMsIGxvY2FsZSkge1xuICAgIHJldHVybiBmb3JtYXRGdW5jKGZvcm1hdERhdGUoZGF0ZSwgXCJFRUVFXCIsIGxvY2FsZSkpO1xufVxuLyoqXG4gKiBHZXRzIHRoZSBtaW5pbXVtIHdlZWtkYXkgaW4gYSBnaXZlbiBsb2NhbGUuXG4gKlxuICogQHBhcmFtIGRhdGUgLSBUaGUgZGF0ZSB0byBmb3JtYXQuXG4gKiBAcGFyYW0gbG9jYWxlIC0gVGhlIGxvY2FsZSB0byB1c2UgZm9yIGZvcm1hdHRpbmcuXG4gKiBAcmV0dXJucyAtIFRoZSBtaW5pbXVtIHdlZWtkYXkuXG4gKi9cbmZ1bmN0aW9uIGdldFdlZWtkYXlNaW5JbkxvY2FsZShkYXRlLCBsb2NhbGUpIHtcbiAgICByZXR1cm4gZm9ybWF0RGF0ZShkYXRlLCBcIkVFRUVFRVwiLCBsb2NhbGUpO1xufVxuLyoqXG4gKiBHZXRzIHRoZSBzaG9ydCB3ZWVrZGF5IGluIGEgZ2l2ZW4gbG9jYWxlLlxuICpcbiAqIEBwYXJhbSBkYXRlIC0gVGhlIGRhdGUgdG8gZm9ybWF0LlxuICogQHBhcmFtIGxvY2FsZSAtIFRoZSBsb2NhbGUgdG8gdXNlIGZvciBmb3JtYXR0aW5nLlxuICogQHJldHVybnMgLSBUaGUgc2hvcnQgd2Vla2RheS5cbiAqL1xuZnVuY3Rpb24gZ2V0V2Vla2RheVNob3J0SW5Mb2NhbGUoZGF0ZSwgbG9jYWxlKSB7XG4gICAgcmV0dXJuIGZvcm1hdERhdGUoZGF0ZSwgXCJFRUVcIiwgbG9jYWxlKTtcbn1cbi8qKlxuICogR2V0cyB0aGUgbW9udGggaW4gYSBnaXZlbiBsb2NhbGUuXG4gKlxuICogQHBhcmFtIG1vbnRoIC0gVGhlIG1vbnRoIHRvIGZvcm1hdC5cbiAqIEBwYXJhbSBsb2NhbGUgLSBUaGUgbG9jYWxlIHRvIHVzZSBmb3IgZm9ybWF0dGluZy5cbiAqIEByZXR1cm5zIC0gVGhlIG1vbnRoLlxuICovXG5mdW5jdGlvbiBnZXRNb250aEluTG9jYWxlKG1vbnRoLCBsb2NhbGUpIHtcbiAgICByZXR1cm4gZm9ybWF0RGF0ZShzZXRNb250aChuZXdEYXRlKCksIG1vbnRoKSwgXCJMTExMXCIsIGxvY2FsZSk7XG59XG4vKipcbiAqIEdldHMgdGhlIHNob3J0IG1vbnRoIGluIGEgZ2l2ZW4gbG9jYWxlLlxuICpcbiAqIEBwYXJhbSBtb250aCAtIFRoZSBtb250aCB0byBmb3JtYXQuXG4gKiBAcGFyYW0gbG9jYWxlIC0gVGhlIGxvY2FsZSB0byB1c2UgZm9yIGZvcm1hdHRpbmcuXG4gKiBAcmV0dXJucyAtIFRoZSBzaG9ydCBtb250aC5cbiAqL1xuZnVuY3Rpb24gZ2V0TW9udGhTaG9ydEluTG9jYWxlKG1vbnRoLCBsb2NhbGUpIHtcbiAgICByZXR1cm4gZm9ybWF0RGF0ZShzZXRNb250aChuZXdEYXRlKCksIG1vbnRoKSwgXCJMTExcIiwgbG9jYWxlKTtcbn1cbi8qKlxuICogR2V0cyB0aGUgc2hvcnQgcXVhcnRlciBpbiBhIGdpdmVuIGxvY2FsZS5cbiAqXG4gKiBAcGFyYW0gcXVhcnRlciAtIFRoZSBxdWFydGVyIHRvIGZvcm1hdC5cbiAqIEBwYXJhbSBsb2NhbGUgLSBUaGUgbG9jYWxlIHRvIHVzZSBmb3IgZm9ybWF0dGluZy5cbiAqIEByZXR1cm5zIC0gVGhlIHNob3J0IHF1YXJ0ZXIuXG4gKi9cbmZ1bmN0aW9uIGdldFF1YXJ0ZXJTaG9ydEluTG9jYWxlKHF1YXJ0ZXIsIGxvY2FsZSkge1xuICAgIHJldHVybiBmb3JtYXREYXRlKHNldFF1YXJ0ZXIobmV3RGF0ZSgpLCBxdWFydGVyKSwgXCJRUVFcIiwgbG9jYWxlKTtcbn1cbi8qKlxuICogQ2hlY2tzIGlmIGEgZGF5IGlzIGRpc2FibGVkLlxuICpcbiAqIEBwYXJhbSBkYXkgLSBUaGUgZGF5IHRvIGNoZWNrLlxuICogQHBhcmFtIG9wdGlvbnMgLSBUaGUgb3B0aW9ucyB0byBjb25zaWRlciB3aGVuIGNoZWNraW5nLlxuICogQHJldHVybnMgLSBSZXR1cm5zIHRydWUgaWYgdGhlIGRheSBpcyBkaXNhYmxlZCwgZmFsc2Ugb3RoZXJ3aXNlLlxuICovXG5mdW5jdGlvbiBpc0RheURpc2FibGVkKGRheSwgX2EpIHtcbiAgICB2YXIgX2IgPSBfYSA9PT0gdm9pZCAwID8ge30gOiBfYSwgbWluRGF0ZSA9IF9iLm1pbkRhdGUsIG1heERhdGUgPSBfYi5tYXhEYXRlLCBleGNsdWRlRGF0ZXMgPSBfYi5leGNsdWRlRGF0ZXMsIGV4Y2x1ZGVEYXRlSW50ZXJ2YWxzID0gX2IuZXhjbHVkZURhdGVJbnRlcnZhbHMsIGluY2x1ZGVEYXRlcyA9IF9iLmluY2x1ZGVEYXRlcywgaW5jbHVkZURhdGVJbnRlcnZhbHMgPSBfYi5pbmNsdWRlRGF0ZUludGVydmFscywgZmlsdGVyRGF0ZSA9IF9iLmZpbHRlckRhdGUsIGRpc2FibGVkID0gX2IuZGlzYWJsZWQ7XG4gICAgaWYgKGRpc2FibGVkKSB7XG4gICAgICAgIHJldHVybiB0cnVlO1xuICAgIH1cbiAgICByZXR1cm4gKGlzT3V0T2ZCb3VuZHMoZGF5LCB7IG1pbkRhdGU6IG1pbkRhdGUsIG1heERhdGU6IG1heERhdGUgfSkgfHxcbiAgICAgICAgKGV4Y2x1ZGVEYXRlcyAmJlxuICAgICAgICAgICAgZXhjbHVkZURhdGVzLnNvbWUoZnVuY3Rpb24gKGV4Y2x1ZGVEYXRlKSB7XG4gICAgICAgICAgICAgICAgaWYgKGV4Y2x1ZGVEYXRlIGluc3RhbmNlb2YgRGF0ZSkge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gaXNTYW1lRGF5KGRheSwgZXhjbHVkZURhdGUpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGlzU2FtZURheShkYXksIGV4Y2x1ZGVEYXRlLmRhdGUpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0pKSB8fFxuICAgICAgICAoZXhjbHVkZURhdGVJbnRlcnZhbHMgJiZcbiAgICAgICAgICAgIGV4Y2x1ZGVEYXRlSW50ZXJ2YWxzLnNvbWUoZnVuY3Rpb24gKF9hKSB7XG4gICAgICAgICAgICAgICAgdmFyIHN0YXJ0ID0gX2Euc3RhcnQsIGVuZCA9IF9hLmVuZDtcbiAgICAgICAgICAgICAgICByZXR1cm4gaXNXaXRoaW5JbnRlcnZhbChkYXksIHsgc3RhcnQ6IHN0YXJ0LCBlbmQ6IGVuZCB9KTtcbiAgICAgICAgICAgIH0pKSB8fFxuICAgICAgICAoaW5jbHVkZURhdGVzICYmXG4gICAgICAgICAgICAhaW5jbHVkZURhdGVzLnNvbWUoZnVuY3Rpb24gKGluY2x1ZGVEYXRlKSB7IHJldHVybiBpc1NhbWVEYXkoZGF5LCBpbmNsdWRlRGF0ZSk7IH0pKSB8fFxuICAgICAgICAoaW5jbHVkZURhdGVJbnRlcnZhbHMgJiZcbiAgICAgICAgICAgICFpbmNsdWRlRGF0ZUludGVydmFscy5zb21lKGZ1bmN0aW9uIChfYSkge1xuICAgICAgICAgICAgICAgIHZhciBzdGFydCA9IF9hLnN0YXJ0LCBlbmQgPSBfYS5lbmQ7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGlzV2l0aGluSW50ZXJ2YWwoZGF5LCB7IHN0YXJ0OiBzdGFydCwgZW5kOiBlbmQgfSk7XG4gICAgICAgICAgICB9KSkgfHxcbiAgICAgICAgKGZpbHRlckRhdGUgJiYgIWZpbHRlckRhdGUobmV3RGF0ZShkYXkpKSkgfHxcbiAgICAgICAgZmFsc2UpO1xufVxuLyoqXG4gKiBDaGVja3MgaWYgYSBkYXkgaXMgZXhjbHVkZWQuXG4gKlxuICogQHBhcmFtIGRheSAtIFRoZSBkYXkgdG8gY2hlY2suXG4gKiBAcGFyYW0gb3B0aW9ucyAtIFRoZSBvcHRpb25zIHRvIGNvbnNpZGVyIHdoZW4gY2hlY2tpbmcuXG4gKiBAcmV0dXJucyAtIFJldHVybnMgdHJ1ZSBpZiB0aGUgZGF5IGlzIGV4Y2x1ZGVkLCBmYWxzZSBvdGhlcndpc2UuXG4gKi9cbmZ1bmN0aW9uIGlzRGF5RXhjbHVkZWQoZGF5LCBfYSkge1xuICAgIHZhciBfYiA9IF9hID09PSB2b2lkIDAgPyB7fSA6IF9hLCBleGNsdWRlRGF0ZXMgPSBfYi5leGNsdWRlRGF0ZXMsIGV4Y2x1ZGVEYXRlSW50ZXJ2YWxzID0gX2IuZXhjbHVkZURhdGVJbnRlcnZhbHM7XG4gICAgaWYgKGV4Y2x1ZGVEYXRlSW50ZXJ2YWxzICYmIGV4Y2x1ZGVEYXRlSW50ZXJ2YWxzLmxlbmd0aCA+IDApIHtcbiAgICAgICAgcmV0dXJuIGV4Y2x1ZGVEYXRlSW50ZXJ2YWxzLnNvbWUoZnVuY3Rpb24gKF9hKSB7XG4gICAgICAgICAgICB2YXIgc3RhcnQgPSBfYS5zdGFydCwgZW5kID0gX2EuZW5kO1xuICAgICAgICAgICAgcmV0dXJuIGlzV2l0aGluSW50ZXJ2YWwoZGF5LCB7IHN0YXJ0OiBzdGFydCwgZW5kOiBlbmQgfSk7XG4gICAgICAgIH0pO1xuICAgIH1cbiAgICByZXR1cm4gKChleGNsdWRlRGF0ZXMgJiZcbiAgICAgICAgZXhjbHVkZURhdGVzLnNvbWUoZnVuY3Rpb24gKGV4Y2x1ZGVEYXRlKSB7XG4gICAgICAgICAgICB2YXIgX2E7XG4gICAgICAgICAgICBpZiAoZXhjbHVkZURhdGUgaW5zdGFuY2VvZiBEYXRlKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGlzU2FtZURheShkYXksIGV4Y2x1ZGVEYXRlKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIHJldHVybiBpc1NhbWVEYXkoZGF5LCAoX2EgPSBleGNsdWRlRGF0ZS5kYXRlKSAhPT0gbnVsbCAmJiBfYSAhPT0gdm9pZCAwID8gX2EgOiBuZXcgRGF0ZSgpKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSkpIHx8XG4gICAgICAgIGZhbHNlKTtcbn1cbmZ1bmN0aW9uIGlzTW9udGhEaXNhYmxlZChtb250aCwgX2EpIHtcbiAgICB2YXIgX2IgPSBfYSA9PT0gdm9pZCAwID8ge30gOiBfYSwgbWluRGF0ZSA9IF9iLm1pbkRhdGUsIG1heERhdGUgPSBfYi5tYXhEYXRlLCBleGNsdWRlRGF0ZXMgPSBfYi5leGNsdWRlRGF0ZXMsIGluY2x1ZGVEYXRlcyA9IF9iLmluY2x1ZGVEYXRlcywgZmlsdGVyRGF0ZSA9IF9iLmZpbHRlckRhdGU7XG4gICAgcmV0dXJuIChpc091dE9mQm91bmRzKG1vbnRoLCB7XG4gICAgICAgIG1pbkRhdGU6IG1pbkRhdGUgPyBzdGFydE9mTW9udGgobWluRGF0ZSkgOiB1bmRlZmluZWQsXG4gICAgICAgIG1heERhdGU6IG1heERhdGUgPyBlbmRPZk1vbnRoKG1heERhdGUpIDogdW5kZWZpbmVkLFxuICAgIH0pIHx8XG4gICAgICAgIChleGNsdWRlRGF0ZXMgPT09IG51bGwgfHwgZXhjbHVkZURhdGVzID09PSB2b2lkIDAgPyB2b2lkIDAgOiBleGNsdWRlRGF0ZXMuc29tZShmdW5jdGlvbiAoZXhjbHVkZURhdGUpIHtcbiAgICAgICAgICAgIHJldHVybiBpc1NhbWVNb250aChtb250aCwgZXhjbHVkZURhdGUgaW5zdGFuY2VvZiBEYXRlID8gZXhjbHVkZURhdGUgOiBleGNsdWRlRGF0ZS5kYXRlKTtcbiAgICAgICAgfSkpIHx8XG4gICAgICAgIChpbmNsdWRlRGF0ZXMgJiZcbiAgICAgICAgICAgICFpbmNsdWRlRGF0ZXMuc29tZShmdW5jdGlvbiAoaW5jbHVkZURhdGUpIHsgcmV0dXJuIGlzU2FtZU1vbnRoKG1vbnRoLCBpbmNsdWRlRGF0ZSk7IH0pKSB8fFxuICAgICAgICAoZmlsdGVyRGF0ZSAmJiAhZmlsdGVyRGF0ZShuZXdEYXRlKG1vbnRoKSkpIHx8XG4gICAgICAgIGZhbHNlKTtcbn1cbmZ1bmN0aW9uIGlzTW9udGhJblJhbmdlKHN0YXJ0RGF0ZSwgZW5kRGF0ZSwgbSwgZGF5KSB7XG4gICAgdmFyIHN0YXJ0RGF0ZVllYXIgPSBnZXRZZWFyKHN0YXJ0RGF0ZSk7XG4gICAgdmFyIHN0YXJ0RGF0ZU1vbnRoID0gZ2V0TW9udGgoc3RhcnREYXRlKTtcbiAgICB2YXIgZW5kRGF0ZVllYXIgPSBnZXRZZWFyKGVuZERhdGUpO1xuICAgIHZhciBlbmREYXRlTW9udGggPSBnZXRNb250aChlbmREYXRlKTtcbiAgICB2YXIgZGF5WWVhciA9IGdldFllYXIoZGF5KTtcbiAgICBpZiAoc3RhcnREYXRlWWVhciA9PT0gZW5kRGF0ZVllYXIgJiYgc3RhcnREYXRlWWVhciA9PT0gZGF5WWVhcikge1xuICAgICAgICByZXR1cm4gc3RhcnREYXRlTW9udGggPD0gbSAmJiBtIDw9IGVuZERhdGVNb250aDtcbiAgICB9XG4gICAgZWxzZSBpZiAoc3RhcnREYXRlWWVhciA8IGVuZERhdGVZZWFyKSB7XG4gICAgICAgIHJldHVybiAoKGRheVllYXIgPT09IHN0YXJ0RGF0ZVllYXIgJiYgc3RhcnREYXRlTW9udGggPD0gbSkgfHxcbiAgICAgICAgICAgIChkYXlZZWFyID09PSBlbmREYXRlWWVhciAmJiBlbmREYXRlTW9udGggPj0gbSkgfHxcbiAgICAgICAgICAgIChkYXlZZWFyIDwgZW5kRGF0ZVllYXIgJiYgZGF5WWVhciA+IHN0YXJ0RGF0ZVllYXIpKTtcbiAgICB9XG4gICAgcmV0dXJuIGZhbHNlO1xufVxuLyoqXG4gKiBUbyBjaGVjayBpZiBhIGRhdGUncyBtb250aCBhbmQgeWVhciBhcmUgZGlzYWJsZWQvZXhjbHVkZWRcbiAqIEBwYXJhbSBkYXRlIERhdGUgdG8gY2hlY2tcbiAqIEByZXR1cm5zIHtib29sZWFufSB0cnVlIGlmIG1vbnRoIGFuZCB5ZWFyIGFyZSBkaXNhYmxlZC9leGNsdWRlZCwgZmFsc2Ugb3RoZXJ3aXNlXG4gKi9cbmZ1bmN0aW9uIGlzTW9udGhZZWFyRGlzYWJsZWQoZGF0ZSwgX2EpIHtcbiAgICB2YXIgX2IgPSBfYSA9PT0gdm9pZCAwID8ge30gOiBfYSwgbWluRGF0ZSA9IF9iLm1pbkRhdGUsIG1heERhdGUgPSBfYi5tYXhEYXRlLCBleGNsdWRlRGF0ZXMgPSBfYi5leGNsdWRlRGF0ZXMsIGluY2x1ZGVEYXRlcyA9IF9iLmluY2x1ZGVEYXRlcztcbiAgICByZXR1cm4gKGlzT3V0T2ZCb3VuZHMoZGF0ZSwgeyBtaW5EYXRlOiBtaW5EYXRlLCBtYXhEYXRlOiBtYXhEYXRlIH0pIHx8XG4gICAgICAgIChleGNsdWRlRGF0ZXMgJiZcbiAgICAgICAgICAgIGV4Y2x1ZGVEYXRlcy5zb21lKGZ1bmN0aW9uIChleGNsdWRlZERhdGUpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gaXNTYW1lTW9udGgoZXhjbHVkZWREYXRlIGluc3RhbmNlb2YgRGF0ZSA/IGV4Y2x1ZGVkRGF0ZSA6IGV4Y2x1ZGVkRGF0ZS5kYXRlLCBkYXRlKTtcbiAgICAgICAgICAgIH0pKSB8fFxuICAgICAgICAoaW5jbHVkZURhdGVzICYmXG4gICAgICAgICAgICAhaW5jbHVkZURhdGVzLnNvbWUoZnVuY3Rpb24gKGluY2x1ZGVkRGF0ZSkgeyByZXR1cm4gaXNTYW1lTW9udGgoaW5jbHVkZWREYXRlLCBkYXRlKTsgfSkpIHx8XG4gICAgICAgIGZhbHNlKTtcbn1cbmZ1bmN0aW9uIGlzUXVhcnRlckRpc2FibGVkKHF1YXJ0ZXIsIF9hKSB7XG4gICAgdmFyIF9iID0gX2EgPT09IHZvaWQgMCA/IHt9IDogX2EsIG1pbkRhdGUgPSBfYi5taW5EYXRlLCBtYXhEYXRlID0gX2IubWF4RGF0ZSwgZXhjbHVkZURhdGVzID0gX2IuZXhjbHVkZURhdGVzLCBpbmNsdWRlRGF0ZXMgPSBfYi5pbmNsdWRlRGF0ZXMsIGZpbHRlckRhdGUgPSBfYi5maWx0ZXJEYXRlLCBkaXNhYmxlZCA9IF9iLmRpc2FibGVkO1xuICAgIGlmIChkaXNhYmxlZCkge1xuICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9XG4gICAgcmV0dXJuIChpc091dE9mQm91bmRzKHF1YXJ0ZXIsIHsgbWluRGF0ZTogbWluRGF0ZSwgbWF4RGF0ZTogbWF4RGF0ZSB9KSB8fFxuICAgICAgICAoZXhjbHVkZURhdGVzID09PSBudWxsIHx8IGV4Y2x1ZGVEYXRlcyA9PT0gdm9pZCAwID8gdm9pZCAwIDogZXhjbHVkZURhdGVzLnNvbWUoZnVuY3Rpb24gKGV4Y2x1ZGVEYXRlKSB7XG4gICAgICAgICAgICByZXR1cm4gaXNTYW1lUXVhcnRlcihxdWFydGVyLCBleGNsdWRlRGF0ZSBpbnN0YW5jZW9mIERhdGUgPyBleGNsdWRlRGF0ZSA6IGV4Y2x1ZGVEYXRlLmRhdGUpO1xuICAgICAgICB9KSkgfHxcbiAgICAgICAgKGluY2x1ZGVEYXRlcyAmJlxuICAgICAgICAgICAgIWluY2x1ZGVEYXRlcy5zb21lKGZ1bmN0aW9uIChpbmNsdWRlRGF0ZSkge1xuICAgICAgICAgICAgICAgIHJldHVybiBpc1NhbWVRdWFydGVyKHF1YXJ0ZXIsIGluY2x1ZGVEYXRlKTtcbiAgICAgICAgICAgIH0pKSB8fFxuICAgICAgICAoZmlsdGVyRGF0ZSAmJiAhZmlsdGVyRGF0ZShuZXdEYXRlKHF1YXJ0ZXIpKSkgfHxcbiAgICAgICAgZmFsc2UpO1xufVxuZnVuY3Rpb24gaXNZZWFySW5SYW5nZSh5ZWFyLCBzdGFydCwgZW5kKSB7XG4gICAgaWYgKCFzdGFydCB8fCAhZW5kKVxuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgaWYgKCFpc1ZhbGlkJDEoc3RhcnQpIHx8ICFpc1ZhbGlkJDEoZW5kKSlcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIHZhciBzdGFydFllYXIgPSBnZXRZZWFyKHN0YXJ0KTtcbiAgICB2YXIgZW5kWWVhciA9IGdldFllYXIoZW5kKTtcbiAgICByZXR1cm4gc3RhcnRZZWFyIDw9IHllYXIgJiYgZW5kWWVhciA+PSB5ZWFyO1xufVxuZnVuY3Rpb24gaXNZZWFyRGlzYWJsZWQoeWVhciwgX2EpIHtcbiAgICB2YXIgX2IgPSBfYSA9PT0gdm9pZCAwID8ge30gOiBfYSwgbWluRGF0ZSA9IF9iLm1pbkRhdGUsIG1heERhdGUgPSBfYi5tYXhEYXRlLCBleGNsdWRlRGF0ZXMgPSBfYi5leGNsdWRlRGF0ZXMsIGluY2x1ZGVEYXRlcyA9IF9iLmluY2x1ZGVEYXRlcywgZmlsdGVyRGF0ZSA9IF9iLmZpbHRlckRhdGUsIGRpc2FibGVkID0gX2IuZGlzYWJsZWQ7XG4gICAgaWYgKGRpc2FibGVkKSB7XG4gICAgICAgIHJldHVybiB0cnVlO1xuICAgIH1cbiAgICB2YXIgZGF0ZSA9IG5ldyBEYXRlKHllYXIsIDAsIDEpO1xuICAgIHJldHVybiAoaXNPdXRPZkJvdW5kcyhkYXRlLCB7XG4gICAgICAgIG1pbkRhdGU6IG1pbkRhdGUgPyBzdGFydE9mWWVhcihtaW5EYXRlKSA6IHVuZGVmaW5lZCxcbiAgICAgICAgbWF4RGF0ZTogbWF4RGF0ZSA/IGVuZE9mWWVhcihtYXhEYXRlKSA6IHVuZGVmaW5lZCxcbiAgICB9KSB8fFxuICAgICAgICAoZXhjbHVkZURhdGVzID09PSBudWxsIHx8IGV4Y2x1ZGVEYXRlcyA9PT0gdm9pZCAwID8gdm9pZCAwIDogZXhjbHVkZURhdGVzLnNvbWUoZnVuY3Rpb24gKGV4Y2x1ZGVEYXRlKSB7XG4gICAgICAgICAgICByZXR1cm4gaXNTYW1lWWVhcihkYXRlLCBleGNsdWRlRGF0ZSBpbnN0YW5jZW9mIERhdGUgPyBleGNsdWRlRGF0ZSA6IGV4Y2x1ZGVEYXRlLmRhdGUpO1xuICAgICAgICB9KSkgfHxcbiAgICAgICAgKGluY2x1ZGVEYXRlcyAmJlxuICAgICAgICAgICAgIWluY2x1ZGVEYXRlcy5zb21lKGZ1bmN0aW9uIChpbmNsdWRlRGF0ZSkgeyByZXR1cm4gaXNTYW1lWWVhcihkYXRlLCBpbmNsdWRlRGF0ZSk7IH0pKSB8fFxuICAgICAgICAoZmlsdGVyRGF0ZSAmJiAhZmlsdGVyRGF0ZShuZXdEYXRlKGRhdGUpKSkgfHxcbiAgICAgICAgZmFsc2UpO1xufVxuZnVuY3Rpb24gaXNRdWFydGVySW5SYW5nZShzdGFydERhdGUsIGVuZERhdGUsIHEsIGRheSkge1xuICAgIHZhciBzdGFydERhdGVZZWFyID0gZ2V0WWVhcihzdGFydERhdGUpO1xuICAgIHZhciBzdGFydERhdGVRdWFydGVyID0gZ2V0UXVhcnRlcihzdGFydERhdGUpO1xuICAgIHZhciBlbmREYXRlWWVhciA9IGdldFllYXIoZW5kRGF0ZSk7XG4gICAgdmFyIGVuZERhdGVRdWFydGVyID0gZ2V0UXVhcnRlcihlbmREYXRlKTtcbiAgICB2YXIgZGF5WWVhciA9IGdldFllYXIoZGF5KTtcbiAgICBpZiAoc3RhcnREYXRlWWVhciA9PT0gZW5kRGF0ZVllYXIgJiYgc3RhcnREYXRlWWVhciA9PT0gZGF5WWVhcikge1xuICAgICAgICByZXR1cm4gc3RhcnREYXRlUXVhcnRlciA8PSBxICYmIHEgPD0gZW5kRGF0ZVF1YXJ0ZXI7XG4gICAgfVxuICAgIGVsc2UgaWYgKHN0YXJ0RGF0ZVllYXIgPCBlbmREYXRlWWVhcikge1xuICAgICAgICByZXR1cm4gKChkYXlZZWFyID09PSBzdGFydERhdGVZZWFyICYmIHN0YXJ0RGF0ZVF1YXJ0ZXIgPD0gcSkgfHxcbiAgICAgICAgICAgIChkYXlZZWFyID09PSBlbmREYXRlWWVhciAmJiBlbmREYXRlUXVhcnRlciA+PSBxKSB8fFxuICAgICAgICAgICAgKGRheVllYXIgPCBlbmREYXRlWWVhciAmJiBkYXlZZWFyID4gc3RhcnREYXRlWWVhcikpO1xuICAgIH1cbiAgICByZXR1cm4gZmFsc2U7XG59XG5mdW5jdGlvbiBpc091dE9mQm91bmRzKGRheSwgX2EpIHtcbiAgICB2YXIgX2I7XG4gICAgdmFyIF9jID0gX2EgPT09IHZvaWQgMCA/IHt9IDogX2EsIG1pbkRhdGUgPSBfYy5taW5EYXRlLCBtYXhEYXRlID0gX2MubWF4RGF0ZTtcbiAgICByZXR1cm4gKChfYiA9ICgobWluRGF0ZSAmJiBkaWZmZXJlbmNlSW5DYWxlbmRhckRheXMoZGF5LCBtaW5EYXRlKSA8IDApIHx8XG4gICAgICAgIChtYXhEYXRlICYmIGRpZmZlcmVuY2VJbkNhbGVuZGFyRGF5cyhkYXksIG1heERhdGUpID4gMCkpKSAhPT0gbnVsbCAmJiBfYiAhPT0gdm9pZCAwID8gX2IgOiBmYWxzZSk7XG59XG5mdW5jdGlvbiBpc1RpbWVJbkxpc3QodGltZSwgdGltZXMpIHtcbiAgICByZXR1cm4gdGltZXMuc29tZShmdW5jdGlvbiAobGlzdFRpbWUpIHtcbiAgICAgICAgcmV0dXJuIGdldEhvdXJzKGxpc3RUaW1lKSA9PT0gZ2V0SG91cnModGltZSkgJiZcbiAgICAgICAgICAgIGdldE1pbnV0ZXMobGlzdFRpbWUpID09PSBnZXRNaW51dGVzKHRpbWUpICYmXG4gICAgICAgICAgICBnZXRTZWNvbmRzKGxpc3RUaW1lKSA9PT0gZ2V0U2Vjb25kcyh0aW1lKTtcbiAgICB9KTtcbn1cbmZ1bmN0aW9uIGlzVGltZURpc2FibGVkKHRpbWUsIF9hKSB7XG4gICAgdmFyIF9iID0gX2EgPT09IHZvaWQgMCA/IHt9IDogX2EsIGV4Y2x1ZGVUaW1lcyA9IF9iLmV4Y2x1ZGVUaW1lcywgaW5jbHVkZVRpbWVzID0gX2IuaW5jbHVkZVRpbWVzLCBmaWx0ZXJUaW1lID0gX2IuZmlsdGVyVGltZTtcbiAgICByZXR1cm4gKChleGNsdWRlVGltZXMgJiYgaXNUaW1lSW5MaXN0KHRpbWUsIGV4Y2x1ZGVUaW1lcykpIHx8XG4gICAgICAgIChpbmNsdWRlVGltZXMgJiYgIWlzVGltZUluTGlzdCh0aW1lLCBpbmNsdWRlVGltZXMpKSB8fFxuICAgICAgICAoZmlsdGVyVGltZSAmJiAhZmlsdGVyVGltZSh0aW1lKSkgfHxcbiAgICAgICAgZmFsc2UpO1xufVxuZnVuY3Rpb24gaXNUaW1lSW5EaXNhYmxlZFJhbmdlKHRpbWUsIF9hKSB7XG4gICAgdmFyIG1pblRpbWUgPSBfYS5taW5UaW1lLCBtYXhUaW1lID0gX2EubWF4VGltZTtcbiAgICBpZiAoIW1pblRpbWUgfHwgIW1heFRpbWUpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiQm90aCBtaW5UaW1lIGFuZCBtYXhUaW1lIHByb3BzIHJlcXVpcmVkXCIpO1xuICAgIH1cbiAgICB2YXIgYmFzZVRpbWUgPSBuZXdEYXRlKCk7XG4gICAgYmFzZVRpbWUgPSBzZXRIb3VycyhiYXNlVGltZSwgZ2V0SG91cnModGltZSkpO1xuICAgIGJhc2VUaW1lID0gc2V0TWludXRlcyhiYXNlVGltZSwgZ2V0TWludXRlcyh0aW1lKSk7XG4gICAgYmFzZVRpbWUgPSBzZXRTZWNvbmRzKGJhc2VUaW1lLCBnZXRTZWNvbmRzKHRpbWUpKTtcbiAgICB2YXIgbWluID0gbmV3RGF0ZSgpO1xuICAgIG1pbiA9IHNldEhvdXJzKG1pbiwgZ2V0SG91cnMobWluVGltZSkpO1xuICAgIG1pbiA9IHNldE1pbnV0ZXMobWluLCBnZXRNaW51dGVzKG1pblRpbWUpKTtcbiAgICBtaW4gPSBzZXRTZWNvbmRzKG1pbiwgZ2V0U2Vjb25kcyhtaW5UaW1lKSk7XG4gICAgdmFyIG1heCA9IG5ld0RhdGUoKTtcbiAgICBtYXggPSBzZXRIb3VycyhtYXgsIGdldEhvdXJzKG1heFRpbWUpKTtcbiAgICBtYXggPSBzZXRNaW51dGVzKG1heCwgZ2V0TWludXRlcyhtYXhUaW1lKSk7XG4gICAgbWF4ID0gc2V0U2Vjb25kcyhtYXgsIGdldFNlY29uZHMobWF4VGltZSkpO1xuICAgIHZhciB2YWxpZDtcbiAgICB0cnkge1xuICAgICAgICB2YWxpZCA9ICFpc1dpdGhpbkludGVydmFsKGJhc2VUaW1lLCB7IHN0YXJ0OiBtaW4sIGVuZDogbWF4IH0pO1xuICAgIH1cbiAgICBjYXRjaCAoZXJyKSB7XG4gICAgICAgIC8qIGlzdGFuYnVsIGlnbm9yZSBuZXh0IC0gZGF0ZS1mbnMgaGlzdG9yaWNhbGx5IHRocmV3IG9uIGludmFsaWQgaW50ZXJ2YWxzICovXG4gICAgICAgIHZhbGlkID0gZmFsc2U7XG4gICAgfVxuICAgIHJldHVybiB2YWxpZDtcbn1cbmZ1bmN0aW9uIG1vbnRoRGlzYWJsZWRCZWZvcmUoZGF5LCBfYSkge1xuICAgIHZhciBfYiA9IF9hID09PSB2b2lkIDAgPyB7fSA6IF9hLCBtaW5EYXRlID0gX2IubWluRGF0ZSwgaW5jbHVkZURhdGVzID0gX2IuaW5jbHVkZURhdGVzO1xuICAgIHZhciBwcmV2aW91c01vbnRoID0gc3ViTW9udGhzKGRheSwgMSk7XG4gICAgcmV0dXJuICgobWluRGF0ZSAmJiBkaWZmZXJlbmNlSW5DYWxlbmRhck1vbnRocyhtaW5EYXRlLCBwcmV2aW91c01vbnRoKSA+IDApIHx8XG4gICAgICAgIChpbmNsdWRlRGF0ZXMgJiZcbiAgICAgICAgICAgIGluY2x1ZGVEYXRlcy5ldmVyeShmdW5jdGlvbiAoaW5jbHVkZURhdGUpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gZGlmZmVyZW5jZUluQ2FsZW5kYXJNb250aHMoaW5jbHVkZURhdGUsIHByZXZpb3VzTW9udGgpID4gMDtcbiAgICAgICAgICAgIH0pKSB8fFxuICAgICAgICBmYWxzZSk7XG59XG5mdW5jdGlvbiBtb250aERpc2FibGVkQWZ0ZXIoZGF5LCBfYSkge1xuICAgIHZhciBfYiA9IF9hID09PSB2b2lkIDAgPyB7fSA6IF9hLCBtYXhEYXRlID0gX2IubWF4RGF0ZSwgaW5jbHVkZURhdGVzID0gX2IuaW5jbHVkZURhdGVzO1xuICAgIHZhciBuZXh0TW9udGggPSBhZGRNb250aHMoZGF5LCAxKTtcbiAgICByZXR1cm4gKChtYXhEYXRlICYmIGRpZmZlcmVuY2VJbkNhbGVuZGFyTW9udGhzKG5leHRNb250aCwgbWF4RGF0ZSkgPiAwKSB8fFxuICAgICAgICAoaW5jbHVkZURhdGVzICYmXG4gICAgICAgICAgICBpbmNsdWRlRGF0ZXMuZXZlcnkoZnVuY3Rpb24gKGluY2x1ZGVEYXRlKSB7IHJldHVybiBkaWZmZXJlbmNlSW5DYWxlbmRhck1vbnRocyhuZXh0TW9udGgsIGluY2x1ZGVEYXRlKSA+IDA7IH0pKSB8fFxuICAgICAgICBmYWxzZSk7XG59XG5mdW5jdGlvbiBxdWFydGVyRGlzYWJsZWRCZWZvcmUoZGF0ZSwgX2EpIHtcbiAgICB2YXIgX2IgPSBfYSA9PT0gdm9pZCAwID8ge30gOiBfYSwgbWluRGF0ZSA9IF9iLm1pbkRhdGUsIGluY2x1ZGVEYXRlcyA9IF9iLmluY2x1ZGVEYXRlcztcbiAgICB2YXIgZmlyc3REYXRlT2ZZZWFyID0gc3RhcnRPZlllYXIoZGF0ZSk7XG4gICAgdmFyIHByZXZpb3VzUXVhcnRlciA9IHN1YlF1YXJ0ZXJzKGZpcnN0RGF0ZU9mWWVhciwgMSk7XG4gICAgcmV0dXJuICgobWluRGF0ZSAmJiBkaWZmZXJlbmNlSW5DYWxlbmRhclF1YXJ0ZXJzKG1pbkRhdGUsIHByZXZpb3VzUXVhcnRlcikgPiAwKSB8fFxuICAgICAgICAoaW5jbHVkZURhdGVzICYmXG4gICAgICAgICAgICBpbmNsdWRlRGF0ZXMuZXZlcnkoZnVuY3Rpb24gKGluY2x1ZGVEYXRlKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGRpZmZlcmVuY2VJbkNhbGVuZGFyUXVhcnRlcnMoaW5jbHVkZURhdGUsIHByZXZpb3VzUXVhcnRlcikgPiAwO1xuICAgICAgICAgICAgfSkpIHx8XG4gICAgICAgIGZhbHNlKTtcbn1cbmZ1bmN0aW9uIHF1YXJ0ZXJEaXNhYmxlZEFmdGVyKGRhdGUsIF9hKSB7XG4gICAgdmFyIF9iID0gX2EgPT09IHZvaWQgMCA/IHt9IDogX2EsIG1heERhdGUgPSBfYi5tYXhEYXRlLCBpbmNsdWRlRGF0ZXMgPSBfYi5pbmNsdWRlRGF0ZXM7XG4gICAgdmFyIGxhc3REYXRlT2ZZZWFyID0gZW5kT2ZZZWFyKGRhdGUpO1xuICAgIHZhciBuZXh0UXVhcnRlciA9IGFkZFF1YXJ0ZXJzKGxhc3REYXRlT2ZZZWFyLCAxKTtcbiAgICByZXR1cm4gKChtYXhEYXRlICYmIGRpZmZlcmVuY2VJbkNhbGVuZGFyUXVhcnRlcnMobmV4dFF1YXJ0ZXIsIG1heERhdGUpID4gMCkgfHxcbiAgICAgICAgKGluY2x1ZGVEYXRlcyAmJlxuICAgICAgICAgICAgaW5jbHVkZURhdGVzLmV2ZXJ5KGZ1bmN0aW9uIChpbmNsdWRlRGF0ZSkge1xuICAgICAgICAgICAgICAgIHJldHVybiBkaWZmZXJlbmNlSW5DYWxlbmRhclF1YXJ0ZXJzKG5leHRRdWFydGVyLCBpbmNsdWRlRGF0ZSkgPiAwO1xuICAgICAgICAgICAgfSkpIHx8XG4gICAgICAgIGZhbHNlKTtcbn1cbmZ1bmN0aW9uIHllYXJEaXNhYmxlZEJlZm9yZShkYXksIF9hKSB7XG4gICAgdmFyIF9iID0gX2EgPT09IHZvaWQgMCA/IHt9IDogX2EsIG1pbkRhdGUgPSBfYi5taW5EYXRlLCBpbmNsdWRlRGF0ZXMgPSBfYi5pbmNsdWRlRGF0ZXM7XG4gICAgdmFyIHByZXZpb3VzWWVhciA9IHN1YlllYXJzKGRheSwgMSk7XG4gICAgcmV0dXJuICgobWluRGF0ZSAmJiBkaWZmZXJlbmNlSW5DYWxlbmRhclllYXJzKG1pbkRhdGUsIHByZXZpb3VzWWVhcikgPiAwKSB8fFxuICAgICAgICAoaW5jbHVkZURhdGVzICYmXG4gICAgICAgICAgICBpbmNsdWRlRGF0ZXMuZXZlcnkoZnVuY3Rpb24gKGluY2x1ZGVEYXRlKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGRpZmZlcmVuY2VJbkNhbGVuZGFyWWVhcnMoaW5jbHVkZURhdGUsIHByZXZpb3VzWWVhcikgPiAwO1xuICAgICAgICAgICAgfSkpIHx8XG4gICAgICAgIGZhbHNlKTtcbn1cbmZ1bmN0aW9uIHllYXJzRGlzYWJsZWRCZWZvcmUoZGF5LCBfYSkge1xuICAgIHZhciBfYiA9IF9hID09PSB2b2lkIDAgPyB7fSA6IF9hLCBtaW5EYXRlID0gX2IubWluRGF0ZSwgX2MgPSBfYi55ZWFySXRlbU51bWJlciwgeWVhckl0ZW1OdW1iZXIgPSBfYyA9PT0gdm9pZCAwID8gREVGQVVMVF9ZRUFSX0lURU1fTlVNQkVSIDogX2M7XG4gICAgdmFyIHByZXZpb3VzWWVhciA9IGdldFN0YXJ0T2ZZZWFyKHN1YlllYXJzKGRheSwgeWVhckl0ZW1OdW1iZXIpKTtcbiAgICB2YXIgZW5kUGVyaW9kID0gZ2V0WWVhcnNQZXJpb2QocHJldmlvdXNZZWFyLCB5ZWFySXRlbU51bWJlcikuZW5kUGVyaW9kO1xuICAgIHZhciBtaW5EYXRlWWVhciA9IG1pbkRhdGUgJiYgZ2V0WWVhcihtaW5EYXRlKTtcbiAgICByZXR1cm4gKG1pbkRhdGVZZWFyICYmIG1pbkRhdGVZZWFyID4gZW5kUGVyaW9kKSB8fCBmYWxzZTtcbn1cbmZ1bmN0aW9uIHllYXJEaXNhYmxlZEFmdGVyKGRheSwgX2EpIHtcbiAgICB2YXIgX2IgPSBfYSA9PT0gdm9pZCAwID8ge30gOiBfYSwgbWF4RGF0ZSA9IF9iLm1heERhdGUsIGluY2x1ZGVEYXRlcyA9IF9iLmluY2x1ZGVEYXRlcztcbiAgICB2YXIgbmV4dFllYXIgPSBhZGRZZWFycyhkYXksIDEpO1xuICAgIHJldHVybiAoKG1heERhdGUgJiYgZGlmZmVyZW5jZUluQ2FsZW5kYXJZZWFycyhuZXh0WWVhciwgbWF4RGF0ZSkgPiAwKSB8fFxuICAgICAgICAoaW5jbHVkZURhdGVzICYmXG4gICAgICAgICAgICBpbmNsdWRlRGF0ZXMuZXZlcnkoZnVuY3Rpb24gKGluY2x1ZGVEYXRlKSB7IHJldHVybiBkaWZmZXJlbmNlSW5DYWxlbmRhclllYXJzKG5leHRZZWFyLCBpbmNsdWRlRGF0ZSkgPiAwOyB9KSkgfHxcbiAgICAgICAgZmFsc2UpO1xufVxuZnVuY3Rpb24geWVhcnNEaXNhYmxlZEFmdGVyKGRheSwgX2EpIHtcbiAgICB2YXIgX2IgPSBfYSA9PT0gdm9pZCAwID8ge30gOiBfYSwgbWF4RGF0ZSA9IF9iLm1heERhdGUsIF9jID0gX2IueWVhckl0ZW1OdW1iZXIsIHllYXJJdGVtTnVtYmVyID0gX2MgPT09IHZvaWQgMCA/IERFRkFVTFRfWUVBUl9JVEVNX05VTUJFUiA6IF9jO1xuICAgIHZhciBuZXh0WWVhciA9IGFkZFllYXJzKGRheSwgeWVhckl0ZW1OdW1iZXIpO1xuICAgIHZhciBzdGFydFBlcmlvZCA9IGdldFllYXJzUGVyaW9kKG5leHRZZWFyLCB5ZWFySXRlbU51bWJlcikuc3RhcnRQZXJpb2Q7XG4gICAgdmFyIG1heERhdGVZZWFyID0gbWF4RGF0ZSAmJiBnZXRZZWFyKG1heERhdGUpO1xuICAgIHJldHVybiAobWF4RGF0ZVllYXIgJiYgbWF4RGF0ZVllYXIgPCBzdGFydFBlcmlvZCkgfHwgZmFsc2U7XG59XG5mdW5jdGlvbiBnZXRFZmZlY3RpdmVNaW5EYXRlKF9hKSB7XG4gICAgdmFyIG1pbkRhdGUgPSBfYS5taW5EYXRlLCBpbmNsdWRlRGF0ZXMgPSBfYS5pbmNsdWRlRGF0ZXM7XG4gICAgaWYgKGluY2x1ZGVEYXRlcyAmJiBtaW5EYXRlKSB7XG4gICAgICAgIHZhciBtaW5EYXRlcyA9IGluY2x1ZGVEYXRlcy5maWx0ZXIoZnVuY3Rpb24gKGluY2x1ZGVEYXRlKSB7IHJldHVybiBkaWZmZXJlbmNlSW5DYWxlbmRhckRheXMoaW5jbHVkZURhdGUsIG1pbkRhdGUpID49IDA7IH0pO1xuICAgICAgICByZXR1cm4gbWluKG1pbkRhdGVzKTtcbiAgICB9XG4gICAgZWxzZSBpZiAoaW5jbHVkZURhdGVzKSB7XG4gICAgICAgIHJldHVybiBtaW4oaW5jbHVkZURhdGVzKTtcbiAgICB9XG4gICAgZWxzZSB7XG4gICAgICAgIHJldHVybiBtaW5EYXRlO1xuICAgIH1cbn1cbmZ1bmN0aW9uIGdldEVmZmVjdGl2ZU1heERhdGUoX2EpIHtcbiAgICB2YXIgbWF4RGF0ZSA9IF9hLm1heERhdGUsIGluY2x1ZGVEYXRlcyA9IF9hLmluY2x1ZGVEYXRlcztcbiAgICBpZiAoaW5jbHVkZURhdGVzICYmIG1heERhdGUpIHtcbiAgICAgICAgdmFyIG1heERhdGVzID0gaW5jbHVkZURhdGVzLmZpbHRlcihmdW5jdGlvbiAoaW5jbHVkZURhdGUpIHsgcmV0dXJuIGRpZmZlcmVuY2VJbkNhbGVuZGFyRGF5cyhpbmNsdWRlRGF0ZSwgbWF4RGF0ZSkgPD0gMDsgfSk7XG4gICAgICAgIHJldHVybiBtYXgobWF4RGF0ZXMpO1xuICAgIH1cbiAgICBlbHNlIGlmIChpbmNsdWRlRGF0ZXMpIHtcbiAgICAgICAgcmV0dXJuIG1heChpbmNsdWRlRGF0ZXMpO1xuICAgIH1cbiAgICBlbHNlIHtcbiAgICAgICAgcmV0dXJuIG1heERhdGU7XG4gICAgfVxufVxuLyoqXG4gKiBHZXQgYSBtYXAgb2YgaGlnaGxpZ2h0ZWQgZGF0ZXMgd2l0aCB0aGVpciBjb3JyZXNwb25kaW5nIGNsYXNzZXMuXG4gKiBAcGFyYW0gaGlnaGxpZ2h0RGF0ZXMgVGhlIGRhdGVzIHRvIGhpZ2hsaWdodC5cbiAqIEBwYXJhbSBkZWZhdWx0Q2xhc3NOYW1lIFRoZSBkZWZhdWx0IGNsYXNzIHRvIHVzZSBmb3IgaGlnaGxpZ2h0aW5nLlxuICogQHJldHVybnMgQSBtYXAgd2l0aCBkYXRlcyBhcyBrZXlzIGFuZCBhcnJheXMgb2YgY2xhc3MgbmFtZXMgYXMgdmFsdWVzLlxuICovXG5mdW5jdGlvbiBnZXRIaWdoTGlnaHREYXlzTWFwKGhpZ2hsaWdodERhdGVzLCBkZWZhdWx0Q2xhc3NOYW1lKSB7XG4gICAgdmFyIF9hO1xuICAgIGlmIChoaWdobGlnaHREYXRlcyA9PT0gdm9pZCAwKSB7IGhpZ2hsaWdodERhdGVzID0gW107IH1cbiAgICBpZiAoZGVmYXVsdENsYXNzTmFtZSA9PT0gdm9pZCAwKSB7IGRlZmF1bHRDbGFzc05hbWUgPSBcInJlYWN0LWRhdGVwaWNrZXJfX2RheS0taGlnaGxpZ2h0ZWRcIjsgfVxuICAgIHZhciBkYXRlQ2xhc3NlcyA9IG5ldyBNYXAoKTtcbiAgICBmb3IgKHZhciBpID0gMCwgbGVuID0gaGlnaGxpZ2h0RGF0ZXMubGVuZ3RoOyBpIDwgbGVuOyBpKyspIHtcbiAgICAgICAgdmFyIG9iaiA9IGhpZ2hsaWdodERhdGVzW2ldO1xuICAgICAgICBpZiAoaXNEYXRlKG9iaikpIHtcbiAgICAgICAgICAgIHZhciBrZXkgPSBmb3JtYXREYXRlKG9iaiwgXCJNTS5kZC55eXl5XCIpO1xuICAgICAgICAgICAgdmFyIGNsYXNzTmFtZXNBcnIgPSBkYXRlQ2xhc3Nlcy5nZXQoa2V5KSB8fCBbXTtcbiAgICAgICAgICAgIGlmICghY2xhc3NOYW1lc0Fyci5pbmNsdWRlcyhkZWZhdWx0Q2xhc3NOYW1lKSkge1xuICAgICAgICAgICAgICAgIGNsYXNzTmFtZXNBcnIucHVzaChkZWZhdWx0Q2xhc3NOYW1lKTtcbiAgICAgICAgICAgICAgICBkYXRlQ2xhc3Nlcy5zZXQoa2V5LCBjbGFzc05hbWVzQXJyKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmICh0eXBlb2Ygb2JqID09PSBcIm9iamVjdFwiKSB7XG4gICAgICAgICAgICB2YXIga2V5cyA9IE9iamVjdC5rZXlzKG9iaik7XG4gICAgICAgICAgICB2YXIgY2xhc3NOYW1lID0gKF9hID0ga2V5c1swXSkgIT09IG51bGwgJiYgX2EgIT09IHZvaWQgMCA/IF9hIDogXCJcIjtcbiAgICAgICAgICAgIHZhciBhcnJPZkRhdGVzID0gb2JqW2NsYXNzTmFtZV07XG4gICAgICAgICAgICBpZiAodHlwZW9mIGNsYXNzTmFtZSA9PT0gXCJzdHJpbmdcIiAmJiBBcnJheS5pc0FycmF5KGFyck9mRGF0ZXMpKSB7XG4gICAgICAgICAgICAgICAgZm9yICh2YXIgayA9IDAsIGxlbl8xID0gYXJyT2ZEYXRlcy5sZW5ndGg7IGsgPCBsZW5fMTsgaysrKSB7XG4gICAgICAgICAgICAgICAgICAgIHZhciBkYXRlSyA9IGFyck9mRGF0ZXNba107XG4gICAgICAgICAgICAgICAgICAgIGlmIChkYXRlSykge1xuICAgICAgICAgICAgICAgICAgICAgICAgdmFyIGtleSA9IGZvcm1hdERhdGUoZGF0ZUssIFwiTU0uZGQueXl5eVwiKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhciBjbGFzc05hbWVzQXJyID0gZGF0ZUNsYXNzZXMuZ2V0KGtleSkgfHwgW107XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoIWNsYXNzTmFtZXNBcnIuaW5jbHVkZXMoY2xhc3NOYW1lKSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNsYXNzTmFtZXNBcnIucHVzaChjbGFzc05hbWUpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGRhdGVDbGFzc2VzLnNldChrZXksIGNsYXNzTmFtZXNBcnIpO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfVxuICAgIHJldHVybiBkYXRlQ2xhc3Nlcztcbn1cbi8qKlxuICogQ29tcGFyZSB0aGUgdHdvIGFycmF5c1xuICogQHBhcmFtIGFycmF5MSBUaGUgZmlyc3QgYXJyYXkgdG8gY29tcGFyZS5cbiAqIEBwYXJhbSBhcnJheTIgVGhlIHNlY29uZCBhcnJheSB0byBjb21wYXJlLlxuICogQHJldHVybnMgdHJ1ZSwgaWYgdGhlIHBhc3NlZCBhcnJheXMgYXJlIGVxdWFsLCBmYWxzZSBvdGhlcndpc2UuXG4gKi9cbmZ1bmN0aW9uIGFycmF5c0FyZUVxdWFsKGFycmF5MSwgYXJyYXkyKSB7XG4gICAgaWYgKGFycmF5MS5sZW5ndGggIT09IGFycmF5Mi5sZW5ndGgpIHtcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbiAgICByZXR1cm4gYXJyYXkxLmV2ZXJ5KGZ1bmN0aW9uICh2YWx1ZSwgaW5kZXgpIHsgcmV0dXJuIHZhbHVlID09PSBhcnJheTJbaW5kZXhdOyB9KTtcbn1cbi8qKlxuICogQXNzaWduIHRoZSBjdXN0b20gY2xhc3MgdG8gZWFjaCBkYXRlXG4gKiBAcGFyYW0gaG9saWRheURhdGVzIGFycmF5IG9mIG9iamVjdCBjb250YWluaW5nIGRhdGUgYW5kIG5hbWUgb2YgdGhlIGhvbGlkYXlcbiAqIEBwYXJhbSBkZWZhdWx0Q2xhc3NOYW1lIGNsYXNzTmFtZSB0byBiZSBhZGRlZC5cbiAqIEByZXR1cm5zIE1hcCBjb250YWluaW5nIGRhdGUgYXMga2V5IGFuZCBhcnJheSBvZiBjbGFzc05hbWUgYW5kIGhvbGlkYXkgbmFtZSBhcyB2YWx1ZVxuICovXG5mdW5jdGlvbiBnZXRIb2xpZGF5c01hcChob2xpZGF5RGF0ZXMsIGRlZmF1bHRDbGFzc05hbWUpIHtcbiAgICBpZiAoaG9saWRheURhdGVzID09PSB2b2lkIDApIHsgaG9saWRheURhdGVzID0gW107IH1cbiAgICBpZiAoZGVmYXVsdENsYXNzTmFtZSA9PT0gdm9pZCAwKSB7IGRlZmF1bHRDbGFzc05hbWUgPSBcInJlYWN0LWRhdGVwaWNrZXJfX2RheS0taG9saWRheXNcIjsgfVxuICAgIHZhciBkYXRlQ2xhc3NlcyA9IG5ldyBNYXAoKTtcbiAgICBob2xpZGF5RGF0ZXMuZm9yRWFjaChmdW5jdGlvbiAoaG9saWRheSkge1xuICAgICAgICB2YXIgZGF0ZU9iaiA9IGhvbGlkYXkuZGF0ZSwgaG9saWRheU5hbWUgPSBob2xpZGF5LmhvbGlkYXlOYW1lO1xuICAgICAgICBpZiAoIWlzRGF0ZShkYXRlT2JqKSkge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIHZhciBrZXkgPSBmb3JtYXREYXRlKGRhdGVPYmosIFwiTU0uZGQueXl5eVwiKTtcbiAgICAgICAgdmFyIGNsYXNzTmFtZXNPYmogPSBkYXRlQ2xhc3Nlcy5nZXQoa2V5KSB8fCB7XG4gICAgICAgICAgICBjbGFzc05hbWU6IFwiXCIsXG4gICAgICAgICAgICBob2xpZGF5TmFtZXM6IFtdLFxuICAgICAgICB9O1xuICAgICAgICBpZiAoXCJjbGFzc05hbWVcIiBpbiBjbGFzc05hbWVzT2JqICYmXG4gICAgICAgICAgICBjbGFzc05hbWVzT2JqW1wiY2xhc3NOYW1lXCJdID09PSBkZWZhdWx0Q2xhc3NOYW1lICYmXG4gICAgICAgICAgICBhcnJheXNBcmVFcXVhbChjbGFzc05hbWVzT2JqW1wiaG9saWRheU5hbWVzXCJdLCBbaG9saWRheU5hbWVdKSkge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIGNsYXNzTmFtZXNPYmpbXCJjbGFzc05hbWVcIl0gPSBkZWZhdWx0Q2xhc3NOYW1lO1xuICAgICAgICB2YXIgaG9saWRheU5hbWVBcnIgPSBjbGFzc05hbWVzT2JqW1wiaG9saWRheU5hbWVzXCJdO1xuICAgICAgICBjbGFzc05hbWVzT2JqW1wiaG9saWRheU5hbWVzXCJdID0gaG9saWRheU5hbWVBcnJcbiAgICAgICAgICAgID8gX19zcHJlYWRBcnJheShfX3NwcmVhZEFycmF5KFtdLCBob2xpZGF5TmFtZUFyciwgdHJ1ZSksIFtob2xpZGF5TmFtZV0sIGZhbHNlKSA6IFtob2xpZGF5TmFtZV07XG4gICAgICAgIGRhdGVDbGFzc2VzLnNldChrZXksIGNsYXNzTmFtZXNPYmopO1xuICAgIH0pO1xuICAgIHJldHVybiBkYXRlQ2xhc3Nlcztcbn1cbi8qKlxuICogRGV0ZXJtaW5lcyB0aGUgdGltZXMgdG8gaW5qZWN0IGFmdGVyIGEgZ2l2ZW4gc3RhcnQgb2YgZGF5LCBjdXJyZW50IHRpbWUsIGFuZCBtdWx0aXBsaWVyLlxuICogQHBhcmFtIHN0YXJ0T2ZEYXkgVGhlIHN0YXJ0IG9mIHRoZSBkYXkuXG4gKiBAcGFyYW0gY3VycmVudFRpbWUgVGhlIGN1cnJlbnQgdGltZS5cbiAqIEBwYXJhbSBjdXJyZW50TXVsdGlwbGllciBUaGUgY3VycmVudCBtdWx0aXBsaWVyLlxuICogQHBhcmFtIGludGVydmFscyBUaGUgaW50ZXJ2YWxzLlxuICogQHBhcmFtIGluamVjdGVkVGltZXMgVGhlIHRpbWVzIHRvIHBvdGVudGlhbGx5IGluamVjdC5cbiAqIEByZXR1cm5zIEFuIGFycmF5IG9mIHRpbWVzIHRvIGluamVjdC5cbiAqL1xuZnVuY3Rpb24gdGltZXNUb0luamVjdEFmdGVyKHN0YXJ0T2ZEYXksIGN1cnJlbnRUaW1lLCBjdXJyZW50TXVsdGlwbGllciwgaW50ZXJ2YWxzLCBpbmplY3RlZFRpbWVzKSB7XG4gICAgdmFyIGwgPSBpbmplY3RlZFRpbWVzLmxlbmd0aDtcbiAgICB2YXIgdGltZXMgPSBbXTtcbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IGw7IGkrKykge1xuICAgICAgICB2YXIgaW5qZWN0ZWRUaW1lID0gc3RhcnRPZkRheTtcbiAgICAgICAgdmFyIGluamVjdGVkVGltZVZhbHVlID0gaW5qZWN0ZWRUaW1lc1tpXTtcbiAgICAgICAgaWYgKGluamVjdGVkVGltZVZhbHVlKSB7XG4gICAgICAgICAgICBpbmplY3RlZFRpbWUgPSBhZGRIb3VycyhpbmplY3RlZFRpbWUsIGdldEhvdXJzKGluamVjdGVkVGltZVZhbHVlKSk7XG4gICAgICAgICAgICBpbmplY3RlZFRpbWUgPSBhZGRNaW51dGVzKGluamVjdGVkVGltZSwgZ2V0TWludXRlcyhpbmplY3RlZFRpbWVWYWx1ZSkpO1xuICAgICAgICAgICAgaW5qZWN0ZWRUaW1lID0gYWRkU2Vjb25kcyhpbmplY3RlZFRpbWUsIGdldFNlY29uZHMoaW5qZWN0ZWRUaW1lVmFsdWUpKTtcbiAgICAgICAgfVxuICAgICAgICB2YXIgbmV4dFRpbWUgPSBhZGRNaW51dGVzKHN0YXJ0T2ZEYXksIChjdXJyZW50TXVsdGlwbGllciArIDEpICogaW50ZXJ2YWxzKTtcbiAgICAgICAgaWYgKGlzQWZ0ZXIoaW5qZWN0ZWRUaW1lLCBjdXJyZW50VGltZSkgJiZcbiAgICAgICAgICAgIGlzQmVmb3JlKGluamVjdGVkVGltZSwgbmV4dFRpbWUpICYmXG4gICAgICAgICAgICBpbmplY3RlZFRpbWVWYWx1ZSAhPSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgIHRpbWVzLnB1c2goaW5qZWN0ZWRUaW1lVmFsdWUpO1xuICAgICAgICB9XG4gICAgfVxuICAgIHJldHVybiB0aW1lcztcbn1cbi8qKlxuICogQWRkcyBhIGxlYWRpbmcgemVybyB0byBhIG51bWJlciBpZiBpdCdzIGxlc3MgdGhhbiAxMC5cbiAqIEBwYXJhbSBpIFRoZSBudW1iZXIgdG8gYWRkIGEgbGVhZGluZyB6ZXJvIHRvLlxuICogQHJldHVybnMgVGhlIG51bWJlciBhcyBhIHN0cmluZywgd2l0aCBhIGxlYWRpbmcgemVybyBpZiBpdCB3YXMgbGVzcyB0aGFuIDEwLlxuICovXG5mdW5jdGlvbiBhZGRaZXJvKGkpIHtcbiAgICByZXR1cm4gaSA8IDEwID8gXCIwXCIuY29uY2F0KGkpIDogXCJcIi5jb25jYXQoaSk7XG59XG4vKipcbiAqIEdldHMgdGhlIHN0YXJ0IGFuZCBlbmQgeWVhcnMgZm9yIGEgcGVyaW9kLlxuICogQHBhcmFtIGRhdGUgVGhlIGRhdGUgdG8gZ2V0IHRoZSBwZXJpb2QgZm9yLlxuICogQHBhcmFtIHllYXJJdGVtTnVtYmVyIFRoZSBudW1iZXIgb2YgeWVhcnMgaW4gdGhlIHBlcmlvZC4gRGVmYXVsdHMgdG8gREVGQVVMVF9ZRUFSX0lURU1fTlVNQkVSLlxuICogQHJldHVybnMgQW4gb2JqZWN0IHdpdGggdGhlIHN0YXJ0IGFuZCBlbmQgeWVhcnMgZm9yIHRoZSBwZXJpb2QuXG4gKi9cbmZ1bmN0aW9uIGdldFllYXJzUGVyaW9kKGRhdGUsIHllYXJJdGVtTnVtYmVyKSB7XG4gICAgaWYgKHllYXJJdGVtTnVtYmVyID09PSB2b2lkIDApIHsgeWVhckl0ZW1OdW1iZXIgPSBERUZBVUxUX1lFQVJfSVRFTV9OVU1CRVI7IH1cbiAgICB2YXIgZW5kUGVyaW9kID0gTWF0aC5jZWlsKGdldFllYXIoZGF0ZSkgLyB5ZWFySXRlbU51bWJlcikgKiB5ZWFySXRlbU51bWJlcjtcbiAgICB2YXIgc3RhcnRQZXJpb2QgPSBlbmRQZXJpb2QgLSAoeWVhckl0ZW1OdW1iZXIgLSAxKTtcbiAgICByZXR1cm4geyBzdGFydFBlcmlvZDogc3RhcnRQZXJpb2QsIGVuZFBlcmlvZDogZW5kUGVyaW9kIH07XG59XG4vKipcbiAqIEdldHMgdGhlIG51bWJlciBvZiBob3VycyBpbiBhIGRheS5cbiAqIEBwYXJhbSBkIFRoZSBkYXRlIHRvIGdldCB0aGUgbnVtYmVyIG9mIGhvdXJzIGZvci5cbiAqIEByZXR1cm5zIFRoZSBudW1iZXIgb2YgaG91cnMgaW4gdGhlIGRheS5cbiAqL1xuZnVuY3Rpb24gZ2V0SG91cnNJbkRheShkKSB7XG4gICAgdmFyIHN0YXJ0T2ZEYXkgPSBuZXcgRGF0ZShkLmdldEZ1bGxZZWFyKCksIGQuZ2V0TW9udGgoKSwgZC5nZXREYXRlKCkpO1xuICAgIHZhciBzdGFydE9mVGhlTmV4dERheSA9IG5ldyBEYXRlKGQuZ2V0RnVsbFllYXIoKSwgZC5nZXRNb250aCgpLCBkLmdldERhdGUoKSwgMjQpO1xuICAgIHJldHVybiBNYXRoLnJvdW5kKCgrc3RhcnRPZlRoZU5leHREYXkgLSArc3RhcnRPZkRheSkgLyAzNjAwMDAwKTtcbn1cbi8qKlxuICogUmV0dXJucyB0aGUgc3RhcnQgb2YgdGhlIG1pbnV0ZSBmb3IgdGhlIGdpdmVuIGRhdGVcbiAqXG4gKiBOT1RFOiB0aGlzIGZ1bmN0aW9uIGlzIGEgRFNUIGFuZCB0aW1lem9uZS1zYWZlIGFuYWxvZyBvZiBgZGF0ZS1mbnMvc3RhcnRPZk1pbnV0ZWBcbiAqIGRvIG5vdCBtYWtlIGNoYW5nZXMgdW5sZXNzIHlvdSBrbm93IHdoYXQgeW91J3JlIGRvaW5nXG4gKlxuICogU2VlIGNvbW1lbnRzIG9uIGh0dHBzOi8vZ2l0aHViLmNvbS9IYWNrZXIweDAxL3JlYWN0LWRhdGVwaWNrZXIvcHVsbC80MjQ0XG4gKiBmb3IgbW9yZSBkZXRhaWxzXG4gKlxuICogQHBhcmFtIGQgZGF0ZVxuICogQHJldHVybnMgc3RhcnQgb2YgdGhlIG1pbnV0ZVxuICovXG5mdW5jdGlvbiBzdGFydE9mTWludXRlKGQpIHtcbiAgICB2YXIgc2Vjb25kcyA9IGQuZ2V0U2Vjb25kcygpO1xuICAgIHZhciBtaWxsaXNlY29uZHMgPSBkLmdldE1pbGxpc2Vjb25kcygpO1xuICAgIHJldHVybiB0b0RhdGUoZC5nZXRUaW1lKCkgLSBzZWNvbmRzICogMTAwMCAtIG1pbGxpc2Vjb25kcyk7XG59XG4vKipcbiAqIFJldHVybnMgd2hldGhlciB0aGUgZ2l2ZW4gZGF0ZXMgYXJlIGluIHRoZSBzYW1lIG1pbnV0ZVxuICpcbiAqIFRoaXMgZnVuY3Rpb24gaXMgYSBEU1QgYW5kIHRpbWV6b25lLXNhZmUgYW5hbG9nIG9mIGBkYXRlLWZucy9pc1NhbWVNaW51dGVgXG4gKlxuICogQHBhcmFtIGQxXG4gKiBAcGFyYW0gZDJcbiAqIEByZXR1cm5zXG4gKi9cbmZ1bmN0aW9uIGlzU2FtZU1pbnV0ZShkMSwgZDIpIHtcbiAgICByZXR1cm4gc3RhcnRPZk1pbnV0ZShkMSkuZ2V0VGltZSgpID09PSBzdGFydE9mTWludXRlKGQyKS5nZXRUaW1lKCk7XG59XG4vKipcbiAqIFJldHVybnMgYSBuZXcgZGF0ZXRpbWUgb2JqZWN0IHJlcHJlc2VudGluZyB0aGUgaW5wdXQgZGF0ZSB3aXRoIG1pZG5pZ2h0IHRpbWVcbiAqIEBwYXJhbSBkYXRlIFRoZSBkYXRlIHRvIGdldCB0aGUgbWlkbmlnaHQgdGltZSBmb3JcbiAqIEByZXR1cm5zIEEgbmV3IGRhdGV0aW1lIG9iamVjdCByZXByZXNlbnRpbmcgdGhlIGlucHV0IGRhdGUgd2l0aCBtaWRuaWdodCB0aW1lXG4gKi9cbmZ1bmN0aW9uIGdldE1pZG5pZ2h0RGF0ZShkYXRlKSB7XG4gICAgaWYgKCFpc0RhdGUoZGF0ZSkpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiSW52YWxpZCBkYXRlXCIpO1xuICAgIH1cbiAgICB2YXIgZGF0ZVdpdGhvdXRUaW1lID0gbmV3IERhdGUoZGF0ZSk7XG4gICAgZGF0ZVdpdGhvdXRUaW1lLnNldEhvdXJzKDAsIDAsIDAsIDApO1xuICAgIHJldHVybiBkYXRlV2l0aG91dFRpbWU7XG59XG4vKipcbiAqIElzIHRoZSBmaXJzdCBkYXRlIGJlZm9yZSB0aGUgc2Vjb25kIG9uZT9cbiAqIEBwYXJhbSBkYXRlIFRoZSBkYXRlIHRoYXQgc2hvdWxkIGJlIGJlZm9yZSB0aGUgb3RoZXIgb25lIHRvIHJldHVybiB0cnVlXG4gKiBAcGFyYW0gZGF0ZVRvQ29tcGFyZSBUaGUgZGF0ZSB0byBjb21wYXJlIHdpdGhcbiAqIEByZXR1cm5zIFRoZSBmaXJzdCBkYXRlIGlzIGJlZm9yZSB0aGUgc2Vjb25kIGRhdGVcbiAqXG4gKiBOb3RlOlxuICogIFRoaXMgZnVuY3Rpb24gY29uc2lkZXJzIHRoZSBtaWQtbmlnaHQgb2YgdGhlIGdpdmVuIGRhdGVzIGZvciBjb21wYXJpc29uLlxuICogIEl0IGV2YWx1YXRlcyB3aGV0aGVyIGRhdGUgaXMgYmVmb3JlIGRhdGVUb0NvbXBhcmUgYmFzZWQgb24gdGhlaXIgbWlkLW5pZ2h0IHRpbWVzdGFtcHMuXG4gKi9cbmZ1bmN0aW9uIGlzRGF0ZUJlZm9yZShkYXRlLCBkYXRlVG9Db21wYXJlKSB7XG4gICAgaWYgKCFpc0RhdGUoZGF0ZSkgfHwgIWlzRGF0ZShkYXRlVG9Db21wYXJlKSkge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJJbnZhbGlkIGRhdGUgcmVjZWl2ZWRcIik7XG4gICAgfVxuICAgIHZhciBtaWRuaWdodERhdGUgPSBnZXRNaWRuaWdodERhdGUoZGF0ZSk7XG4gICAgdmFyIG1pZG5pZ2h0RGF0ZVRvQ29tcGFyZSA9IGdldE1pZG5pZ2h0RGF0ZShkYXRlVG9Db21wYXJlKTtcbiAgICByZXR1cm4gaXNCZWZvcmUobWlkbmlnaHREYXRlLCBtaWRuaWdodERhdGVUb0NvbXBhcmUpO1xufVxuLyoqXG4gKiBDaGVja3MgaWYgdGhlIHNwYWNlIGtleSB3YXMgcHJlc3NlZCBkb3duLlxuICpcbiAqIEBwYXJhbSBldmVudCAtIFRoZSBrZXlib2FyZCBldmVudC5cbiAqIEByZXR1cm5zIC0gUmV0dXJucyB0cnVlIGlmIHRoZSBzcGFjZSBrZXkgd2FzIHByZXNzZWQgZG93biwgZmFsc2Ugb3RoZXJ3aXNlLlxuICovXG5mdW5jdGlvbiBpc1NwYWNlS2V5RG93bihldmVudCkge1xuICAgIHJldHVybiBldmVudC5rZXkgPT09IEtleVR5cGUuU3BhY2U7XG59XG5cbi8qKlxuICogYElucHV0VGltZWAgaXMgYSBSZWFjdCBjb21wb25lbnQgdGhhdCBtYW5hZ2VzIHRpbWUgaW5wdXQuXG4gKlxuICogQGNvbXBvbmVudFxuICogQGV4YW1wbGVcbiAqIDxJbnB1dFRpbWUgdGltZVN0cmluZz1cIjEyOjAwXCIgLz5cbiAqXG4gKiBAcGFyYW0gcHJvcHMgLSBUaGUgcHJvcGVydGllcyB0aGF0IGRlZmluZSB0aGUgYElucHV0VGltZWAgY29tcG9uZW50LlxuICogQHBhcmFtIHByb3BzLm9uQ2hhbmdlIC0gRnVuY3Rpb24gdGhhdCBpcyBjYWxsZWQgd2hlbiB0aGUgZGF0ZSBjaGFuZ2VzLlxuICogQHBhcmFtIHByb3BzLmRhdGUgLSBUaGUgaW5pdGlhbCBkYXRlIHZhbHVlLlxuICogQHBhcmFtIHByb3BzLnRpbWVTdHJpbmcgLSBUaGUgaW5pdGlhbCB0aW1lIHN0cmluZyB2YWx1ZS5cbiAqIEBwYXJhbSBwcm9wcy50aW1lSW5wdXRMYWJlbCAtIFRoZSBsYWJlbCBmb3IgdGhlIHRpbWUgaW5wdXQuXG4gKiBAcGFyYW0gcHJvcHMuY3VzdG9tVGltZUlucHV0IC0gQW4gb3B0aW9uYWwgY3VzdG9tIHRpbWUgaW5wdXQgZWxlbWVudC5cbiAqXG4gKiBAcmV0dXJucyBUaGUgYElucHV0VGltZWAgY29tcG9uZW50LlxuICovXG52YXIgSW5wdXRUaW1lID0gLyoqIEBjbGFzcyAqLyAoZnVuY3Rpb24gKF9zdXBlcikge1xuICAgIF9fZXh0ZW5kcyhJbnB1dFRpbWUsIF9zdXBlcik7XG4gICAgZnVuY3Rpb24gSW5wdXRUaW1lKHByb3BzKSB7XG4gICAgICAgIHZhciBfdGhpcyA9IF9zdXBlci5jYWxsKHRoaXMsIHByb3BzKSB8fCB0aGlzO1xuICAgICAgICBfdGhpcy5pbnB1dFJlZiA9IFJlYWN0LmNyZWF0ZVJlZigpO1xuICAgICAgICBfdGhpcy5vblRpbWVDaGFuZ2UgPSBmdW5jdGlvbiAodGltZSkge1xuICAgICAgICAgICAgdmFyIF9hLCBfYjtcbiAgICAgICAgICAgIF90aGlzLnNldFN0YXRlKHsgdGltZTogdGltZSB9KTtcbiAgICAgICAgICAgIHZhciBwcm9wRGF0ZSA9IF90aGlzLnByb3BzLmRhdGU7XG4gICAgICAgICAgICB2YXIgaXNQcm9wRGF0ZVZhbGlkID0gcHJvcERhdGUgaW5zdGFuY2VvZiBEYXRlICYmICFpc05hTigrcHJvcERhdGUpO1xuICAgICAgICAgICAgdmFyIGRhdGUgPSBpc1Byb3BEYXRlVmFsaWQgPyBwcm9wRGF0ZSA6IG5ldyBEYXRlKCk7XG4gICAgICAgICAgICBpZiAodGltZSA9PT0gbnVsbCB8fCB0aW1lID09PSB2b2lkIDAgPyB2b2lkIDAgOiB0aW1lLmluY2x1ZGVzKFwiOlwiKSkge1xuICAgICAgICAgICAgICAgIHZhciBfYyA9IHRpbWUuc3BsaXQoXCI6XCIpLCBob3VycyA9IF9jWzBdLCBtaW51dGVzID0gX2NbMV07XG4gICAgICAgICAgICAgICAgZGF0ZS5zZXRIb3VycyhOdW1iZXIoaG91cnMpKTtcbiAgICAgICAgICAgICAgICBkYXRlLnNldE1pbnV0ZXMoTnVtYmVyKG1pbnV0ZXMpKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIChfYiA9IChfYSA9IF90aGlzLnByb3BzKS5vbkNoYW5nZSkgPT09IG51bGwgfHwgX2IgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9iLmNhbGwoX2EsIGRhdGUpO1xuICAgICAgICB9O1xuICAgICAgICBfdGhpcy5yZW5kZXJUaW1lSW5wdXQgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICB2YXIgdGltZSA9IF90aGlzLnN0YXRlLnRpbWU7XG4gICAgICAgICAgICB2YXIgX2EgPSBfdGhpcy5wcm9wcywgZGF0ZSA9IF9hLmRhdGUsIHRpbWVTdHJpbmcgPSBfYS50aW1lU3RyaW5nLCBjdXN0b21UaW1lSW5wdXQgPSBfYS5jdXN0b21UaW1lSW5wdXQ7XG4gICAgICAgICAgICBpZiAoY3VzdG9tVGltZUlucHV0KSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGNsb25lRWxlbWVudChjdXN0b21UaW1lSW5wdXQsIHtcbiAgICAgICAgICAgICAgICAgICAgZGF0ZTogZGF0ZSxcbiAgICAgICAgICAgICAgICAgICAgdmFsdWU6IHRpbWUsXG4gICAgICAgICAgICAgICAgICAgIG9uQ2hhbmdlOiBfdGhpcy5vblRpbWVDaGFuZ2UsXG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gKFJlYWN0LmNyZWF0ZUVsZW1lbnQoXCJpbnB1dFwiLCB7IHR5cGU6IFwidGltZVwiLCBjbGFzc05hbWU6IFwicmVhY3QtZGF0ZXBpY2tlci10aW1lX19pbnB1dFwiLCBwbGFjZWhvbGRlcjogXCJUaW1lXCIsIG5hbWU6IFwidGltZS1pbnB1dFwiLCByZWY6IF90aGlzLmlucHV0UmVmLCBvbkNsaWNrOiBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICAgICAgICAgIHZhciBfYTtcbiAgICAgICAgICAgICAgICAgICAgKF9hID0gX3RoaXMuaW5wdXRSZWYuY3VycmVudCkgPT09IG51bGwgfHwgX2EgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9hLmZvY3VzKCk7XG4gICAgICAgICAgICAgICAgfSwgcmVxdWlyZWQ6IHRydWUsIHZhbHVlOiB0aW1lLCBvbkNoYW5nZTogZnVuY3Rpb24gKGV2ZW50KSB7XG4gICAgICAgICAgICAgICAgICAgIF90aGlzLm9uVGltZUNoYW5nZShldmVudC50YXJnZXQudmFsdWUgfHwgdGltZVN0cmluZyk7XG4gICAgICAgICAgICAgICAgfSB9KSk7XG4gICAgICAgIH07XG4gICAgICAgIF90aGlzLnN0YXRlID0ge1xuICAgICAgICAgICAgdGltZTogX3RoaXMucHJvcHMudGltZVN0cmluZyxcbiAgICAgICAgfTtcbiAgICAgICAgcmV0dXJuIF90aGlzO1xuICAgIH1cbiAgICBJbnB1dFRpbWUuZ2V0RGVyaXZlZFN0YXRlRnJvbVByb3BzID0gZnVuY3Rpb24gKHByb3BzLCBzdGF0ZSkge1xuICAgICAgICBpZiAocHJvcHMudGltZVN0cmluZyAhPT0gc3RhdGUudGltZSkge1xuICAgICAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgICAgICB0aW1lOiBwcm9wcy50aW1lU3RyaW5nLFxuICAgICAgICAgICAgfTtcbiAgICAgICAgfVxuICAgICAgICAvLyBSZXR1cm4gbnVsbCB0byBpbmRpY2F0ZSBubyBjaGFuZ2UgdG8gc3RhdGUuXG4gICAgICAgIHJldHVybiBudWxsO1xuICAgIH07XG4gICAgSW5wdXRUaW1lLnByb3RvdHlwZS5yZW5kZXIgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHJldHVybiAoUmVhY3QuY3JlYXRlRWxlbWVudChcImRpdlwiLCB7IGNsYXNzTmFtZTogXCJyZWFjdC1kYXRlcGlja2VyX19pbnB1dC10aW1lLWNvbnRhaW5lclwiIH0sXG4gICAgICAgICAgICBSZWFjdC5jcmVhdGVFbGVtZW50KFwiZGl2XCIsIHsgY2xhc3NOYW1lOiBcInJlYWN0LWRhdGVwaWNrZXItdGltZV9fY2FwdGlvblwiIH0sIHRoaXMucHJvcHMudGltZUlucHV0TGFiZWwpLFxuICAgICAgICAgICAgUmVhY3QuY3JlYXRlRWxlbWVudChcImRpdlwiLCB7IGNsYXNzTmFtZTogXCJyZWFjdC1kYXRlcGlja2VyLXRpbWVfX2lucHV0LWNvbnRhaW5lclwiIH0sXG4gICAgICAgICAgICAgICAgUmVhY3QuY3JlYXRlRWxlbWVudChcImRpdlwiLCB7IGNsYXNzTmFtZTogXCJyZWFjdC1kYXRlcGlja2VyLXRpbWVfX2lucHV0XCIgfSwgdGhpcy5yZW5kZXJUaW1lSW5wdXQoKSkpKSk7XG4gICAgfTtcbiAgICByZXR1cm4gSW5wdXRUaW1lO1xufShDb21wb25lbnQpKTtcblxuLyoqXG4gKiBgRGF5YCBpcyBhIFJlYWN0IGNvbXBvbmVudCB0aGF0IHJlcHJlc2VudHMgYSBzaW5nbGUgZGF5IGluIGEgZGF0ZSBwaWNrZXIuXG4gKiBJdCBoYW5kbGVzIHRoZSByZW5kZXJpbmcgYW5kIGludGVyYWN0aW9uIG9mIGEgZGF5LlxuICpcbiAqIEBwcm9wIGFyaWFMYWJlbFByZWZpeFdoZW5FbmFibGVkIC0gQXJpYSBsYWJlbCBwcmVmaXggd2hlbiB0aGUgZGF5IGlzIGVuYWJsZWQuXG4gKiBAcHJvcCBhcmlhTGFiZWxQcmVmaXhXaGVuRGlzYWJsZWQgLSBBcmlhIGxhYmVsIHByZWZpeCB3aGVuIHRoZSBkYXkgaXMgZGlzYWJsZWQuXG4gKiBAcHJvcCBkaXNhYmxlZEtleWJvYXJkTmF2aWdhdGlvbiAtIFdoZXRoZXIga2V5Ym9hcmQgbmF2aWdhdGlvbiBpcyBkaXNhYmxlZC5cbiAqIEBwcm9wIGRheSAtIFRoZSBkYXkgdG8gYmUgZGlzcGxheWVkLlxuICogQHByb3AgZGF5Q2xhc3NOYW1lIC0gRnVuY3Rpb24gdG8gY3VzdG9taXplIHRoZSBDU1MgY2xhc3Mgb2YgdGhlIGRheS5cbiAqIEBwcm9wIGVuZERhdGUgLSBUaGUgZW5kIGRhdGUgaW4gYSByYW5nZS5cbiAqIEBwcm9wIGhpZ2hsaWdodERhdGVzIC0gTWFwIG9mIGRhdGVzIHRvIGJlIGhpZ2hsaWdodGVkLlxuICogQHByb3AgaG9saWRheXMgLSBNYXAgb2YgaG9saWRheSBkYXRlcy5cbiAqIEBwcm9wIGlubGluZSAtIFdoZXRoZXIgdGhlIGRhdGUgcGlja2VyIGlzIGlubGluZS5cbiAqIEBwcm9wIHNob3VsZEZvY3VzRGF5SW5saW5lIC0gV2hldGhlciB0aGUgZGF5IHNob3VsZCBiZSBmb2N1c2VkIHdoZW4gZGF0ZSBwaWNrZXIgaXMgaW5saW5lLlxuICogQHByb3AgbW9udGggLSBUaGUgbW9udGggdGhlIGRheSBiZWxvbmdzIHRvLlxuICogQHByb3Agb25DbGljayAtIENsaWNrIGV2ZW50IGhhbmRsZXIuXG4gKiBAcHJvcCBvbk1vdXNlRW50ZXIgLSBNb3VzZSBlbnRlciBldmVudCBoYW5kbGVyLlxuICogQHByb3AgaGFuZGxlT25LZXlEb3duIC0gS2V5IGRvd24gZXZlbnQgaGFuZGxlci5cbiAqIEBwcm9wIHVzZVBvaW50ZXJFdmVudCAtIFdoZXRoZXIgdG8gdXNlIHBvaW50ZXIgZXZlbnRzLlxuICogQHByb3AgcHJlU2VsZWN0aW9uIC0gVGhlIGRhdGUgdGhhdCBpcyBjdXJyZW50bHkgc2VsZWN0ZWQuXG4gKiBAcHJvcCBzZWxlY3RlZCAtIFRoZSBzZWxlY3RlZCBkYXRlLlxuICogQHByb3Agc2VsZWN0aW5nRGF0ZSAtIFRoZSBkYXRlIGN1cnJlbnRseSBiZWluZyBzZWxlY3RlZC5cbiAqIEBwcm9wIHNlbGVjdHNFbmQgLSBXaGV0aGVyIHRoZSBkYXkgY2FuIGJlIHRoZSBlbmQgZGF0ZSBpbiBhIHJhbmdlLlxuICogQHByb3Agc2VsZWN0c1N0YXJ0IC0gV2hldGhlciB0aGUgZGF5IGNhbiBiZSB0aGUgc3RhcnQgZGF0ZSBpbiBhIHJhbmdlLlxuICogQHByb3Agc2VsZWN0c1JhbmdlIC0gV2hldGhlciB0aGUgZGF5IGNhbiBiZSBpbiBhIHJhbmdlLlxuICogQHByb3Agc2hvd1dlZWtQaWNrZXIgLSBXaGV0aGVyIHRvIHNob3cgd2VlayBwaWNrZXIuXG4gKiBAcHJvcCBzaG93V2Vla051bWJlciAtIFdoZXRoZXIgdG8gc2hvdyB3ZWVrIG51bWJlcnMuXG4gKiBAcHJvcCBzZWxlY3RzRGlzYWJsZWREYXlzSW5SYW5nZSAtIFdoZXRoZXIgdG8gc2VsZWN0IGRpc2FibGVkIGRheXMgaW4gYSByYW5nZS5cbiAqIEBwcm9wIHNlbGVjdHNNdWx0aXBsZSAtIFdoZXRoZXIgdG8gYWxsb3cgbXVsdGlwbGUgZGF0ZSBzZWxlY3Rpb24uXG4gKiBAcHJvcCBzZWxlY3RlZERhdGVzIC0gQXJyYXkgb2Ygc2VsZWN0ZWQgZGF0ZXMuXG4gKiBAcHJvcCBzdGFydERhdGUgLSBUaGUgc3RhcnQgZGF0ZSBpbiBhIHJhbmdlLlxuICogQHByb3AgcmVuZGVyRGF5Q29udGVudHMgLSBGdW5jdGlvbiB0byBjdXN0b21pemUgdGhlIHJlbmRlcmluZyBvZiB0aGUgZGF5J3MgY29udGVudHMuXG4gKiBAcHJvcCBjb250YWluZXJSZWYgLSBSZWYgZm9yIHRoZSBjb250YWluZXIuXG4gKiBAcHJvcCBleGNsdWRlRGF0ZXMgLSBBcnJheSBvZiBkYXRlcyB0byBiZSBleGNsdWRlZC5cbiAqIEBwcm9wIGNhbGVuZGFyU3RhcnREYXkgLSBUaGUgc3RhcnQgZGF5IG9mIHRoZSB3ZWVrLlxuICogQHByb3AgbG9jYWxlIC0gVGhlIGxvY2FsZSBvYmplY3QuXG4gKiBAcHJvcCBtb250aFNob3dzRHVwbGljYXRlRGF5c0VuZCAtIFdoZXRoZXIgdG8gc2hvdyBkdXBsaWNhdGUgZGF5cyBhdCB0aGUgZW5kIG9mIHRoZSBtb250aC5cbiAqIEBwcm9wIG1vbnRoU2hvd3NEdXBsaWNhdGVEYXlzU3RhcnQgLSBXaGV0aGVyIHRvIHNob3cgZHVwbGljYXRlIGRheXMgYXQgdGhlIHN0YXJ0IG9mIHRoZSBtb250aC5cbiAqIEBwcm9wIGluY2x1ZGVEYXRlcyAtIEFycmF5IG9mIGRhdGVzIHRvIGJlIGluY2x1ZGVkLlxuICogQHByb3AgaW5jbHVkZURhdGVJbnRlcnZhbHMgLSBBcnJheSBvZiBkYXRlIGludGVydmFscyB0byBiZSBpbmNsdWRlZC5cbiAqIEBwcm9wIG1pbkRhdGUgLSBUaGUgbWluaW11bSBkYXRlIHRoYXQgY2FuIGJlIHNlbGVjdGVkLlxuICogQHByb3AgbWF4RGF0ZSAtIFRoZSBtYXhpbXVtIGRhdGUgdGhhdCBjYW4gYmUgc2VsZWN0ZWQuXG4gKlxuICogQGV4YW1wbGVcbiAqIGBgYHRzeFxuICogaW1wb3J0IFJlYWN0IGZyb20gJ3JlYWN0JztcbiAqIGltcG9ydCBEYXkgZnJvbSAnLi9kYXknO1xuICpcbiAqIGZ1bmN0aW9uIE15Q29tcG9uZW50KCkge1xuICogICBjb25zdCBoYW5kbGVEYXlDbGljayA9IChldmVudCkgPT4ge1xuICogICAgIGNvbnNvbGUubG9nKCdEYXkgY2xpY2tlZCcsIGV2ZW50KTtcbiAqICAgfTtcbiAqXG4gKiAgIGNvbnN0IGhhbmRsZURheU1vdXNlRW50ZXIgPSAoZXZlbnQpID0+IHtcbiAqICAgICBjb25zb2xlLmxvZygnTW91c2UgZW50ZXJlZCBkYXknLCBldmVudCk7XG4gKiAgIH07XG4gKlxuICogICBjb25zdCByZW5kZXJEYXlDb250ZW50cyA9IChkYXRlKSA9PiB7XG4gKiAgICAgcmV0dXJuIDxkaXY+e2RhdGUuZ2V0RGF0ZSgpfTwvZGl2PjtcbiAqICAgfTtcbiAqXG4gKiAgIHJldHVybiAoXG4gKiAgICAgPERheVxuICogICAgICAgZGF5PXtuZXcgRGF0ZSgpfVxuICogICAgICAgb25DbGljaz17aGFuZGxlRGF5Q2xpY2t9XG4gKiAgICAgICBvbk1vdXNlRW50ZXI9e2hhbmRsZURheU1vdXNlRW50ZXJ9XG4gKiAgICAgICByZW5kZXJEYXlDb250ZW50cz17cmVuZGVyRGF5Q29udGVudHN9XG4gKiAgICAgLz5cbiAqICAgKTtcbiAqIH1cbiAqXG4gKiBleHBvcnQgZGVmYXVsdCBNeUNvbXBvbmVudDtcbiAqIGBgYFxuICovXG52YXIgRGF5ID0gLyoqIEBjbGFzcyAqLyAoZnVuY3Rpb24gKF9zdXBlcikge1xuICAgIF9fZXh0ZW5kcyhEYXksIF9zdXBlcik7XG4gICAgZnVuY3Rpb24gRGF5KCkge1xuICAgICAgICB2YXIgX3RoaXMgPSBfc3VwZXIgIT09IG51bGwgJiYgX3N1cGVyLmFwcGx5KHRoaXMsIGFyZ3VtZW50cykgfHwgdGhpcztcbiAgICAgICAgX3RoaXMuZGF5RWwgPSBjcmVhdGVSZWYoKTtcbiAgICAgICAgX3RoaXMuaGFuZGxlQ2xpY2sgPSBmdW5jdGlvbiAoZXZlbnQpIHtcbiAgICAgICAgICAgIGlmICghX3RoaXMuaXNEaXNhYmxlZCgpICYmIF90aGlzLnByb3BzLm9uQ2xpY2spIHtcbiAgICAgICAgICAgICAgICBfdGhpcy5wcm9wcy5vbkNsaWNrKGV2ZW50KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfTtcbiAgICAgICAgX3RoaXMuaGFuZGxlTW91c2VFbnRlciA9IGZ1bmN0aW9uIChldmVudCkge1xuICAgICAgICAgICAgaWYgKCFfdGhpcy5pc0Rpc2FibGVkKCkgJiYgX3RoaXMucHJvcHMub25Nb3VzZUVudGVyKSB7XG4gICAgICAgICAgICAgICAgX3RoaXMucHJvcHMub25Nb3VzZUVudGVyKGV2ZW50KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfTtcbiAgICAgICAgX3RoaXMuaGFuZGxlT25LZXlEb3duID0gZnVuY3Rpb24gKGV2ZW50KSB7XG4gICAgICAgICAgICB2YXIgX2EsIF9iO1xuICAgICAgICAgICAgdmFyIGV2ZW50S2V5ID0gZXZlbnQua2V5O1xuICAgICAgICAgICAgaWYgKGV2ZW50S2V5ID09PSBLZXlUeXBlLlNwYWNlKSB7XG4gICAgICAgICAgICAgICAgZXZlbnQucHJldmVudERlZmF1bHQoKTtcbiAgICAgICAgICAgICAgICBldmVudC5rZXkgPSBLZXlUeXBlLkVudGVyO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgKF9iID0gKF9hID0gX3RoaXMucHJvcHMpLmhhbmRsZU9uS2V5RG93bikgPT09IG51bGwgfHwgX2IgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9iLmNhbGwoX2EsIGV2ZW50KTtcbiAgICAgICAgfTtcbiAgICAgICAgX3RoaXMuaXNTYW1lRGF5ID0gZnVuY3Rpb24gKG90aGVyKSB7XG4gICAgICAgICAgICByZXR1cm4gaXNTYW1lRGF5KF90aGlzLnByb3BzLmRheSwgb3RoZXIpO1xuICAgICAgICB9O1xuICAgICAgICBfdGhpcy5pc0tleWJvYXJkU2VsZWN0ZWQgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICB2YXIgX2E7XG4gICAgICAgICAgICBpZiAoX3RoaXMucHJvcHMuZGlzYWJsZWRLZXlib2FyZE5hdmlnYXRpb24pIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB2YXIgaXNTZWxlY3RlZERhdGUgPSBfdGhpcy5wcm9wcy5zZWxlY3RzTXVsdGlwbGVcbiAgICAgICAgICAgICAgICA/IChfYSA9IF90aGlzLnByb3BzLnNlbGVjdGVkRGF0ZXMpID09PSBudWxsIHx8IF9hID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYS5zb21lKGZ1bmN0aW9uIChkYXRlKSB7IHJldHVybiBfdGhpcy5pc1NhbWVEYXlPcldlZWsoZGF0ZSk7IH0pXG4gICAgICAgICAgICAgICAgOiBfdGhpcy5pc1NhbWVEYXlPcldlZWsoX3RoaXMucHJvcHMuc2VsZWN0ZWQpO1xuICAgICAgICAgICAgdmFyIGlzRGlzYWJsZWQgPSBfdGhpcy5wcm9wcy5wcmVTZWxlY3Rpb24gJiYgX3RoaXMuaXNEaXNhYmxlZChfdGhpcy5wcm9wcy5wcmVTZWxlY3Rpb24pO1xuICAgICAgICAgICAgcmV0dXJuICghaXNTZWxlY3RlZERhdGUgJiZcbiAgICAgICAgICAgICAgICBfdGhpcy5pc1NhbWVEYXlPcldlZWsoX3RoaXMucHJvcHMucHJlU2VsZWN0aW9uKSAmJlxuICAgICAgICAgICAgICAgICFpc0Rpc2FibGVkKTtcbiAgICAgICAgfTtcbiAgICAgICAgX3RoaXMuaXNEaXNhYmxlZCA9IGZ1bmN0aW9uIChkYXkpIHtcbiAgICAgICAgICAgIGlmIChkYXkgPT09IHZvaWQgMCkgeyBkYXkgPSBfdGhpcy5wcm9wcy5kYXk7IH1cbiAgICAgICAgICAgIC8vIEFsbW9zdCBhbGwgcHJvcHMgcHJldmlvdXNseSB3ZXJlIHBhc3NlZCBhcyB0aGlzLnByb3BzIHcvbyBwcm9wZXIgdHlwaW5nIHdpdGggcHJvcC10eXBlc1xuICAgICAgICAgICAgLy8gYWZ0ZXIgdGhlIG1pZ3JhdGlvbiB0byBUUyBpIG1hZGUgaXQgZXhwbGljaXRcbiAgICAgICAgICAgIHJldHVybiBpc0RheURpc2FibGVkKGRheSwge1xuICAgICAgICAgICAgICAgIG1pbkRhdGU6IF90aGlzLnByb3BzLm1pbkRhdGUsXG4gICAgICAgICAgICAgICAgbWF4RGF0ZTogX3RoaXMucHJvcHMubWF4RGF0ZSxcbiAgICAgICAgICAgICAgICBleGNsdWRlRGF0ZXM6IF90aGlzLnByb3BzLmV4Y2x1ZGVEYXRlcyxcbiAgICAgICAgICAgICAgICBleGNsdWRlRGF0ZUludGVydmFsczogX3RoaXMucHJvcHMuZXhjbHVkZURhdGVJbnRlcnZhbHMsXG4gICAgICAgICAgICAgICAgaW5jbHVkZURhdGVJbnRlcnZhbHM6IF90aGlzLnByb3BzLmluY2x1ZGVEYXRlSW50ZXJ2YWxzLFxuICAgICAgICAgICAgICAgIGluY2x1ZGVEYXRlczogX3RoaXMucHJvcHMuaW5jbHVkZURhdGVzLFxuICAgICAgICAgICAgICAgIGZpbHRlckRhdGU6IF90aGlzLnByb3BzLmZpbHRlckRhdGUsXG4gICAgICAgICAgICAgICAgZGlzYWJsZWQ6IF90aGlzLnByb3BzLmRpc2FibGVkLFxuICAgICAgICAgICAgfSk7XG4gICAgICAgIH07XG4gICAgICAgIF90aGlzLmlzRXhjbHVkZWQgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICAvLyBBbG1vc3QgYWxsIHByb3BzIHByZXZpb3VzbHkgd2VyZSBwYXNzZWQgYXMgdGhpcy5wcm9wcyB3L28gcHJvcGVyIHR5cGluZyB3aXRoIHByb3AtdHlwZXNcbiAgICAgICAgICAgIC8vIGFmdGVyIHRoZSBtaWdyYXRpb24gdG8gVFMgaSBtYWRlIGl0IGV4cGxpY2l0XG4gICAgICAgICAgICByZXR1cm4gaXNEYXlFeGNsdWRlZChfdGhpcy5wcm9wcy5kYXksIHtcbiAgICAgICAgICAgICAgICBleGNsdWRlRGF0ZXM6IF90aGlzLnByb3BzLmV4Y2x1ZGVEYXRlcyxcbiAgICAgICAgICAgICAgICBleGNsdWRlRGF0ZUludGVydmFsczogX3RoaXMucHJvcHMuZXhjbHVkZURhdGVJbnRlcnZhbHMsXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfTtcbiAgICAgICAgX3RoaXMuaXNTdGFydE9mV2VlayA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIHJldHVybiBpc1NhbWVEYXkoX3RoaXMucHJvcHMuZGF5LCBnZXRTdGFydE9mV2VlayhfdGhpcy5wcm9wcy5kYXksIF90aGlzLnByb3BzLmxvY2FsZSwgX3RoaXMucHJvcHMuY2FsZW5kYXJTdGFydERheSkpO1xuICAgICAgICB9O1xuICAgICAgICBfdGhpcy5pc1NhbWVXZWVrID0gZnVuY3Rpb24gKG90aGVyKSB7XG4gICAgICAgICAgICByZXR1cm4gX3RoaXMucHJvcHMuc2hvd1dlZWtQaWNrZXIgJiZcbiAgICAgICAgICAgICAgICBpc1NhbWVEYXkob3RoZXIsIGdldFN0YXJ0T2ZXZWVrKF90aGlzLnByb3BzLmRheSwgX3RoaXMucHJvcHMubG9jYWxlLCBfdGhpcy5wcm9wcy5jYWxlbmRhclN0YXJ0RGF5KSk7XG4gICAgICAgIH07XG4gICAgICAgIF90aGlzLmlzU2FtZURheU9yV2VlayA9IGZ1bmN0aW9uIChvdGhlcikge1xuICAgICAgICAgICAgcmV0dXJuIF90aGlzLmlzU2FtZURheShvdGhlcikgfHwgX3RoaXMuaXNTYW1lV2VlayhvdGhlcik7XG4gICAgICAgIH07XG4gICAgICAgIF90aGlzLmdldEhpZ2hMaWdodGVkQ2xhc3MgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICB2YXIgX2EgPSBfdGhpcy5wcm9wcywgZGF5ID0gX2EuZGF5LCBoaWdobGlnaHREYXRlcyA9IF9hLmhpZ2hsaWdodERhdGVzO1xuICAgICAgICAgICAgaWYgKCFoaWdobGlnaHREYXRlcykge1xuICAgICAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIC8vIExvb2tpbmcgZm9yIGNsYXNzTmFtZSBpbiB0aGUgTWFwIG9mIHsnZGF5IHN0cmluZywgJ2NsYXNzTmFtZSd9XG4gICAgICAgICAgICB2YXIgZGF5U3RyID0gZm9ybWF0RGF0ZShkYXksIFwiTU0uZGQueXl5eVwiKTtcbiAgICAgICAgICAgIHJldHVybiBoaWdobGlnaHREYXRlcy5nZXQoZGF5U3RyKTtcbiAgICAgICAgfTtcbiAgICAgICAgLy8gRnVuY3Rpb24gdG8gcmV0dXJuIHRoZSBhcnJheSBjb250YWluaW5nIGNsYXNzTmFtZSBhc3NvY2lhdGVkIHRvIHRoZSBkYXRlXG4gICAgICAgIF90aGlzLmdldEhvbGlkYXlzQ2xhc3MgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICB2YXIgX2E7XG4gICAgICAgICAgICB2YXIgX2IgPSBfdGhpcy5wcm9wcywgZGF5ID0gX2IuZGF5LCBob2xpZGF5cyA9IF9iLmhvbGlkYXlzO1xuICAgICAgICAgICAgaWYgKCFob2xpZGF5cykge1xuICAgICAgICAgICAgICAgIC8vIEZvciB0eXBlIGNvbnNpc3RlbmN5IG5vIG90aGVyIHJlYXNvbnNcbiAgICAgICAgICAgICAgICByZXR1cm4gW3VuZGVmaW5lZF07XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB2YXIgZGF5U3RyID0gZm9ybWF0RGF0ZShkYXksIFwiTU0uZGQueXl5eVwiKTtcbiAgICAgICAgICAgIC8vIExvb2tpbmcgZm9yIGNsYXNzTmFtZSBpbiB0aGUgTWFwIG9mIHtkYXkgc3RyaW5nOiB7Y2xhc3NOYW1lLCBob2xpZGF5TmFtZX19XG4gICAgICAgICAgICBpZiAoaG9saWRheXMuaGFzKGRheVN0cikpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gWyhfYSA9IGhvbGlkYXlzLmdldChkYXlTdHIpKSA9PT0gbnVsbCB8fCBfYSA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2EuY2xhc3NOYW1lXTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIC8vIEZvciB0eXBlIGNvbnNpc3RlbmN5IG5vIG90aGVyIHJlYXNvbnNcbiAgICAgICAgICAgIHJldHVybiBbdW5kZWZpbmVkXTtcbiAgICAgICAgfTtcbiAgICAgICAgX3RoaXMuaXNJblJhbmdlID0gZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgdmFyIF9hID0gX3RoaXMucHJvcHMsIGRheSA9IF9hLmRheSwgc3RhcnREYXRlID0gX2Euc3RhcnREYXRlLCBlbmREYXRlID0gX2EuZW5kRGF0ZTtcbiAgICAgICAgICAgIGlmICghc3RhcnREYXRlIHx8ICFlbmREYXRlKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIGlzRGF5SW5SYW5nZShkYXksIHN0YXJ0RGF0ZSwgZW5kRGF0ZSk7XG4gICAgICAgIH07XG4gICAgICAgIF90aGlzLmlzSW5TZWxlY3RpbmdSYW5nZSA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIHZhciBfYTtcbiAgICAgICAgICAgIHZhciBfYiA9IF90aGlzLnByb3BzLCBkYXkgPSBfYi5kYXksIHNlbGVjdHNTdGFydCA9IF9iLnNlbGVjdHNTdGFydCwgc2VsZWN0c0VuZCA9IF9iLnNlbGVjdHNFbmQsIHNlbGVjdHNSYW5nZSA9IF9iLnNlbGVjdHNSYW5nZSwgc2VsZWN0c0Rpc2FibGVkRGF5c0luUmFuZ2UgPSBfYi5zZWxlY3RzRGlzYWJsZWREYXlzSW5SYW5nZSwgc3RhcnREYXRlID0gX2Iuc3RhcnREYXRlLCBzd2FwUmFuZ2UgPSBfYi5zd2FwUmFuZ2UsIGVuZERhdGUgPSBfYi5lbmREYXRlO1xuICAgICAgICAgICAgdmFyIHNlbGVjdGluZ0RhdGUgPSAoX2EgPSBfdGhpcy5wcm9wcy5zZWxlY3RpbmdEYXRlKSAhPT0gbnVsbCAmJiBfYSAhPT0gdm9pZCAwID8gX2EgOiBfdGhpcy5wcm9wcy5wcmVTZWxlY3Rpb247XG4gICAgICAgICAgICBpZiAoIShzZWxlY3RzU3RhcnQgfHwgc2VsZWN0c0VuZCB8fCBzZWxlY3RzUmFuZ2UpIHx8XG4gICAgICAgICAgICAgICAgIXNlbGVjdGluZ0RhdGUgfHxcbiAgICAgICAgICAgICAgICAoIXNlbGVjdHNEaXNhYmxlZERheXNJblJhbmdlICYmIF90aGlzLmlzRGlzYWJsZWQoKSkpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoc2VsZWN0c1N0YXJ0ICYmXG4gICAgICAgICAgICAgICAgZW5kRGF0ZSAmJlxuICAgICAgICAgICAgICAgIChpc0JlZm9yZShzZWxlY3RpbmdEYXRlLCBlbmREYXRlKSB8fCBpc0VxdWFsKHNlbGVjdGluZ0RhdGUsIGVuZERhdGUpKSkge1xuICAgICAgICAgICAgICAgIHJldHVybiBpc0RheUluUmFuZ2UoZGF5LCBzZWxlY3RpbmdEYXRlLCBlbmREYXRlKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChzZWxlY3RzRW5kICYmXG4gICAgICAgICAgICAgICAgc3RhcnREYXRlICYmXG4gICAgICAgICAgICAgICAgKGlzQWZ0ZXIoc2VsZWN0aW5nRGF0ZSwgc3RhcnREYXRlKSB8fCBpc0VxdWFsKHNlbGVjdGluZ0RhdGUsIHN0YXJ0RGF0ZSkpKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGlzRGF5SW5SYW5nZShkYXksIHN0YXJ0RGF0ZSwgc2VsZWN0aW5nRGF0ZSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoc2VsZWN0c1JhbmdlICYmIHN0YXJ0RGF0ZSAmJiAhZW5kRGF0ZSkge1xuICAgICAgICAgICAgICAgIGlmIChpc0VxdWFsKHNlbGVjdGluZ0RhdGUsIHN0YXJ0RGF0ZSkpIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGlzRGF5SW5SYW5nZShkYXksIHN0YXJ0RGF0ZSwgc2VsZWN0aW5nRGF0ZSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGlmIChpc0FmdGVyKHNlbGVjdGluZ0RhdGUsIHN0YXJ0RGF0ZSkpIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGlzRGF5SW5SYW5nZShkYXksIHN0YXJ0RGF0ZSwgc2VsZWN0aW5nRGF0ZSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGlmIChzd2FwUmFuZ2UgJiYgaXNCZWZvcmUoc2VsZWN0aW5nRGF0ZSwgc3RhcnREYXRlKSkge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gaXNEYXlJblJhbmdlKGRheSwgc2VsZWN0aW5nRGF0ZSwgc3RhcnREYXRlKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgIH07XG4gICAgICAgIF90aGlzLmlzU2VsZWN0aW5nUmFuZ2VTdGFydCA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIHZhciBfYTtcbiAgICAgICAgICAgIGlmICghX3RoaXMuaXNJblNlbGVjdGluZ1JhbmdlKCkpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB2YXIgX2IgPSBfdGhpcy5wcm9wcywgZGF5ID0gX2IuZGF5LCBzdGFydERhdGUgPSBfYi5zdGFydERhdGUsIHNlbGVjdHNTdGFydCA9IF9iLnNlbGVjdHNTdGFydCwgc3dhcFJhbmdlID0gX2Iuc3dhcFJhbmdlLCBzZWxlY3RzUmFuZ2UgPSBfYi5zZWxlY3RzUmFuZ2U7XG4gICAgICAgICAgICB2YXIgc2VsZWN0aW5nRGF0ZSA9IChfYSA9IF90aGlzLnByb3BzLnNlbGVjdGluZ0RhdGUpICE9PSBudWxsICYmIF9hICE9PSB2b2lkIDAgPyBfYSA6IF90aGlzLnByb3BzLnByZVNlbGVjdGlvbjtcbiAgICAgICAgICAgIGlmIChzZWxlY3RzU3RhcnQpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gaXNTYW1lRGF5KGRheSwgc2VsZWN0aW5nRGF0ZSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoc2VsZWN0c1JhbmdlICYmIHN3YXBSYW5nZSAmJiBzdGFydERhdGUgJiYgc2VsZWN0aW5nRGF0ZSkge1xuICAgICAgICAgICAgICAgIHJldHVybiBpc1NhbWVEYXkoZGF5LCBpc0JlZm9yZShzZWxlY3RpbmdEYXRlLCBzdGFydERhdGUpID8gc2VsZWN0aW5nRGF0ZSA6IHN0YXJ0RGF0ZSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gaXNTYW1lRGF5KGRheSwgc3RhcnREYXRlKTtcbiAgICAgICAgfTtcbiAgICAgICAgX3RoaXMuaXNTZWxlY3RpbmdSYW5nZUVuZCA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIHZhciBfYTtcbiAgICAgICAgICAgIGlmICghX3RoaXMuaXNJblNlbGVjdGluZ1JhbmdlKCkpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB2YXIgX2IgPSBfdGhpcy5wcm9wcywgZGF5ID0gX2IuZGF5LCBlbmREYXRlID0gX2IuZW5kRGF0ZSwgc2VsZWN0c0VuZCA9IF9iLnNlbGVjdHNFbmQsIHNlbGVjdHNSYW5nZSA9IF9iLnNlbGVjdHNSYW5nZSwgc3dhcFJhbmdlID0gX2Iuc3dhcFJhbmdlLCBzdGFydERhdGUgPSBfYi5zdGFydERhdGU7XG4gICAgICAgICAgICB2YXIgc2VsZWN0aW5nRGF0ZSA9IChfYSA9IF90aGlzLnByb3BzLnNlbGVjdGluZ0RhdGUpICE9PSBudWxsICYmIF9hICE9PSB2b2lkIDAgPyBfYSA6IF90aGlzLnByb3BzLnByZVNlbGVjdGlvbjtcbiAgICAgICAgICAgIGlmIChzZWxlY3RzRW5kKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGlzU2FtZURheShkYXksIHNlbGVjdGluZ0RhdGUpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKHNlbGVjdHNSYW5nZSAmJiBzd2FwUmFuZ2UgJiYgc3RhcnREYXRlICYmIHNlbGVjdGluZ0RhdGUpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gaXNTYW1lRGF5KGRheSwgaXNCZWZvcmUoc2VsZWN0aW5nRGF0ZSwgc3RhcnREYXRlKSA/IHN0YXJ0RGF0ZSA6IHNlbGVjdGluZ0RhdGUpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKHNlbGVjdHNSYW5nZSkge1xuICAgICAgICAgICAgICAgIHJldHVybiBpc1NhbWVEYXkoZGF5LCBzZWxlY3RpbmdEYXRlKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiBpc1NhbWVEYXkoZGF5LCBlbmREYXRlKTtcbiAgICAgICAgfTtcbiAgICAgICAgX3RoaXMuaXNSYW5nZVN0YXJ0ID0gZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgdmFyIF9hID0gX3RoaXMucHJvcHMsIGRheSA9IF9hLmRheSwgc3RhcnREYXRlID0gX2Euc3RhcnREYXRlLCBlbmREYXRlID0gX2EuZW5kRGF0ZTtcbiAgICAgICAgICAgIGlmICghc3RhcnREYXRlIHx8ICFlbmREYXRlKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIGlzU2FtZURheShzdGFydERhdGUsIGRheSk7XG4gICAgICAgIH07XG4gICAgICAgIF90aGlzLmlzUmFuZ2VFbmQgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICB2YXIgX2EgPSBfdGhpcy5wcm9wcywgZGF5ID0gX2EuZGF5LCBzdGFydERhdGUgPSBfYS5zdGFydERhdGUsIGVuZERhdGUgPSBfYS5lbmREYXRlO1xuICAgICAgICAgICAgaWYgKCFzdGFydERhdGUgfHwgIWVuZERhdGUpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gaXNTYW1lRGF5KGVuZERhdGUsIGRheSk7XG4gICAgICAgIH07XG4gICAgICAgIF90aGlzLmlzV2Vla2VuZCA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIHZhciB3ZWVrZGF5ID0gZ2V0RGF5KF90aGlzLnByb3BzLmRheSk7XG4gICAgICAgICAgICByZXR1cm4gd2Vla2RheSA9PT0gMCB8fCB3ZWVrZGF5ID09PSA2O1xuICAgICAgICB9O1xuICAgICAgICBfdGhpcy5pc0FmdGVyTW9udGggPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICByZXR1cm4gKF90aGlzLnByb3BzLm1vbnRoICE9PSB1bmRlZmluZWQgJiZcbiAgICAgICAgICAgICAgICAoX3RoaXMucHJvcHMubW9udGggKyAxKSAlIDEyID09PSBnZXRNb250aChfdGhpcy5wcm9wcy5kYXkpKTtcbiAgICAgICAgfTtcbiAgICAgICAgX3RoaXMuaXNCZWZvcmVNb250aCA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIHJldHVybiAoX3RoaXMucHJvcHMubW9udGggIT09IHVuZGVmaW5lZCAmJlxuICAgICAgICAgICAgICAgIChnZXRNb250aChfdGhpcy5wcm9wcy5kYXkpICsgMSkgJSAxMiA9PT0gX3RoaXMucHJvcHMubW9udGgpO1xuICAgICAgICB9O1xuICAgICAgICBfdGhpcy5pc0N1cnJlbnREYXkgPSBmdW5jdGlvbiAoKSB7IHJldHVybiBfdGhpcy5pc1NhbWVEYXkobmV3RGF0ZSgpKTsgfTtcbiAgICAgICAgX3RoaXMuaXNTZWxlY3RlZCA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIHZhciBfYTtcbiAgICAgICAgICAgIGlmIChfdGhpcy5wcm9wcy5zZWxlY3RzTXVsdGlwbGUpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gKF9hID0gX3RoaXMucHJvcHMuc2VsZWN0ZWREYXRlcykgPT09IG51bGwgfHwgX2EgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9hLnNvbWUoZnVuY3Rpb24gKGRhdGUpIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIF90aGlzLmlzU2FtZURheU9yV2VlayhkYXRlKTtcbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiBfdGhpcy5pc1NhbWVEYXlPcldlZWsoX3RoaXMucHJvcHMuc2VsZWN0ZWQpO1xuICAgICAgICB9O1xuICAgICAgICBfdGhpcy5nZXRDbGFzc05hbWVzID0gZnVuY3Rpb24gKGRhdGUpIHtcbiAgICAgICAgICAgIHZhciBkYXlDbGFzc05hbWUgPSBfdGhpcy5wcm9wcy5kYXlDbGFzc05hbWVcbiAgICAgICAgICAgICAgICA/IF90aGlzLnByb3BzLmRheUNsYXNzTmFtZShkYXRlKVxuICAgICAgICAgICAgICAgIDogdW5kZWZpbmVkO1xuICAgICAgICAgICAgcmV0dXJuIGNsc3goXCJyZWFjdC1kYXRlcGlja2VyX19kYXlcIiwgZGF5Q2xhc3NOYW1lLCBcInJlYWN0LWRhdGVwaWNrZXJfX2RheS0tXCIgKyBnZXREYXlPZldlZWtDb2RlKF90aGlzLnByb3BzLmRheSksIHtcbiAgICAgICAgICAgICAgICBcInJlYWN0LWRhdGVwaWNrZXJfX2RheS0tZGlzYWJsZWRcIjogX3RoaXMuaXNEaXNhYmxlZCgpLFxuICAgICAgICAgICAgICAgIFwicmVhY3QtZGF0ZXBpY2tlcl9fZGF5LS1leGNsdWRlZFwiOiBfdGhpcy5pc0V4Y2x1ZGVkKCksXG4gICAgICAgICAgICAgICAgXCJyZWFjdC1kYXRlcGlja2VyX19kYXktLXNlbGVjdGVkXCI6IF90aGlzLmlzU2VsZWN0ZWQoKSxcbiAgICAgICAgICAgICAgICBcInJlYWN0LWRhdGVwaWNrZXJfX2RheS0ta2V5Ym9hcmQtc2VsZWN0ZWRcIjogX3RoaXMuaXNLZXlib2FyZFNlbGVjdGVkKCksXG4gICAgICAgICAgICAgICAgXCJyZWFjdC1kYXRlcGlja2VyX19kYXktLXJhbmdlLXN0YXJ0XCI6IF90aGlzLmlzUmFuZ2VTdGFydCgpLFxuICAgICAgICAgICAgICAgIFwicmVhY3QtZGF0ZXBpY2tlcl9fZGF5LS1yYW5nZS1lbmRcIjogX3RoaXMuaXNSYW5nZUVuZCgpLFxuICAgICAgICAgICAgICAgIFwicmVhY3QtZGF0ZXBpY2tlcl9fZGF5LS1pbi1yYW5nZVwiOiBfdGhpcy5pc0luUmFuZ2UoKSxcbiAgICAgICAgICAgICAgICBcInJlYWN0LWRhdGVwaWNrZXJfX2RheS0taW4tc2VsZWN0aW5nLXJhbmdlXCI6IF90aGlzLmlzSW5TZWxlY3RpbmdSYW5nZSgpLFxuICAgICAgICAgICAgICAgIFwicmVhY3QtZGF0ZXBpY2tlcl9fZGF5LS1zZWxlY3RpbmctcmFuZ2Utc3RhcnRcIjogX3RoaXMuaXNTZWxlY3RpbmdSYW5nZVN0YXJ0KCksXG4gICAgICAgICAgICAgICAgXCJyZWFjdC1kYXRlcGlja2VyX19kYXktLXNlbGVjdGluZy1yYW5nZS1lbmRcIjogX3RoaXMuaXNTZWxlY3RpbmdSYW5nZUVuZCgpLFxuICAgICAgICAgICAgICAgIFwicmVhY3QtZGF0ZXBpY2tlcl9fZGF5LS10b2RheVwiOiBfdGhpcy5pc0N1cnJlbnREYXkoKSxcbiAgICAgICAgICAgICAgICBcInJlYWN0LWRhdGVwaWNrZXJfX2RheS0td2Vla2VuZFwiOiBfdGhpcy5pc1dlZWtlbmQoKSxcbiAgICAgICAgICAgICAgICBcInJlYWN0LWRhdGVwaWNrZXJfX2RheS0tb3V0c2lkZS1tb250aFwiOiBfdGhpcy5pc0FmdGVyTW9udGgoKSB8fCBfdGhpcy5pc0JlZm9yZU1vbnRoKCksXG4gICAgICAgICAgICB9LCBfdGhpcy5nZXRIaWdoTGlnaHRlZENsYXNzKCksIF90aGlzLmdldEhvbGlkYXlzQ2xhc3MoKSk7XG4gICAgICAgIH07XG4gICAgICAgIF90aGlzLmdldEFyaWFMYWJlbCA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIHZhciBfYSA9IF90aGlzLnByb3BzLCBkYXkgPSBfYS5kYXksIF9iID0gX2EuYXJpYUxhYmVsUHJlZml4V2hlbkVuYWJsZWQsIGFyaWFMYWJlbFByZWZpeFdoZW5FbmFibGVkID0gX2IgPT09IHZvaWQgMCA/IFwiQ2hvb3NlXCIgOiBfYiwgX2MgPSBfYS5hcmlhTGFiZWxQcmVmaXhXaGVuRGlzYWJsZWQsIGFyaWFMYWJlbFByZWZpeFdoZW5EaXNhYmxlZCA9IF9jID09PSB2b2lkIDAgPyBcIk5vdCBhdmFpbGFibGVcIiA6IF9jO1xuICAgICAgICAgICAgdmFyIHByZWZpeCA9IF90aGlzLmlzRGlzYWJsZWQoKSB8fCBfdGhpcy5pc0V4Y2x1ZGVkKClcbiAgICAgICAgICAgICAgICA/IGFyaWFMYWJlbFByZWZpeFdoZW5EaXNhYmxlZFxuICAgICAgICAgICAgICAgIDogYXJpYUxhYmVsUHJlZml4V2hlbkVuYWJsZWQ7XG4gICAgICAgICAgICByZXR1cm4gXCJcIi5jb25jYXQocHJlZml4LCBcIiBcIikuY29uY2F0KGZvcm1hdERhdGUoZGF5LCBcIlBQUFBcIiwgX3RoaXMucHJvcHMubG9jYWxlKSk7XG4gICAgICAgIH07XG4gICAgICAgIC8vIEEgZnVuY3Rpb24gdG8gcmV0dXJuIHRoZSBob2xpZGF5J3MgbmFtZSBhcyB0aXRsZSdzIGNvbnRlbnRcbiAgICAgICAgX3RoaXMuZ2V0VGl0bGUgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICB2YXIgX2EgPSBfdGhpcy5wcm9wcywgZGF5ID0gX2EuZGF5LCBfYiA9IF9hLmhvbGlkYXlzLCBob2xpZGF5cyA9IF9iID09PSB2b2lkIDAgPyBuZXcgTWFwKCkgOiBfYiwgZXhjbHVkZURhdGVzID0gX2EuZXhjbHVkZURhdGVzO1xuICAgICAgICAgICAgdmFyIGNvbXBhcmVEdCA9IGZvcm1hdERhdGUoZGF5LCBcIk1NLmRkLnl5eXlcIik7XG4gICAgICAgICAgICB2YXIgdGl0bGVzID0gW107XG4gICAgICAgICAgICBpZiAoaG9saWRheXMuaGFzKGNvbXBhcmVEdCkpIHtcbiAgICAgICAgICAgICAgICB0aXRsZXMucHVzaC5hcHBseSh0aXRsZXMsIGhvbGlkYXlzLmdldChjb21wYXJlRHQpLmhvbGlkYXlOYW1lcyk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoX3RoaXMuaXNFeGNsdWRlZCgpKSB7XG4gICAgICAgICAgICAgICAgdGl0bGVzLnB1c2goZXhjbHVkZURhdGVzID09PSBudWxsIHx8IGV4Y2x1ZGVEYXRlcyA9PT0gdm9pZCAwID8gdm9pZCAwIDogZXhjbHVkZURhdGVzLmZpbHRlcihmdW5jdGlvbiAoZXhjbHVkZURhdGUpIHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKGV4Y2x1ZGVEYXRlIGluc3RhbmNlb2YgRGF0ZSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGlzU2FtZURheShleGNsdWRlRGF0ZSwgZGF5KTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gaXNTYW1lRGF5KGV4Y2x1ZGVEYXRlID09PSBudWxsIHx8IGV4Y2x1ZGVEYXRlID09PSB2b2lkIDAgPyB2b2lkIDAgOiBleGNsdWRlRGF0ZS5kYXRlLCBkYXkpO1xuICAgICAgICAgICAgICAgIH0pLm1hcChmdW5jdGlvbiAoZXhjbHVkZURhdGUpIHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKGV4Y2x1ZGVEYXRlIGluc3RhbmNlb2YgRGF0ZSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHVuZGVmaW5lZDtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gZXhjbHVkZURhdGUgPT09IG51bGwgfHwgZXhjbHVkZURhdGUgPT09IHZvaWQgMCA/IHZvaWQgMCA6IGV4Y2x1ZGVEYXRlLm1lc3NhZ2U7XG4gICAgICAgICAgICAgICAgfSkpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgLy8gSSdtIG5vdCBzdXJlIHRoYXQgdGhpcyBpcyBhIHJpZ2h0IG91dHB1dCwgYnV0IGFsbCB0ZXN0cyBhcmUgZ3JlZW5cbiAgICAgICAgICAgIHJldHVybiB0aXRsZXMuam9pbihcIiwgXCIpO1xuICAgICAgICB9O1xuICAgICAgICBfdGhpcy5nZXRUYWJJbmRleCA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIHZhciBzZWxlY3RlZERheSA9IF90aGlzLnByb3BzLnNlbGVjdGVkO1xuICAgICAgICAgICAgdmFyIHByZVNlbGVjdGlvbkRheSA9IF90aGlzLnByb3BzLnByZVNlbGVjdGlvbjtcbiAgICAgICAgICAgIHZhciB0YWJJbmRleCA9ICEoX3RoaXMucHJvcHMuc2hvd1dlZWtQaWNrZXIgJiZcbiAgICAgICAgICAgICAgICAoX3RoaXMucHJvcHMuc2hvd1dlZWtOdW1iZXIgfHwgIV90aGlzLmlzU3RhcnRPZldlZWsoKSkpICYmXG4gICAgICAgICAgICAgICAgKF90aGlzLmlzS2V5Ym9hcmRTZWxlY3RlZCgpIHx8XG4gICAgICAgICAgICAgICAgICAgIChfdGhpcy5pc1NhbWVEYXkoc2VsZWN0ZWREYXkpICYmXG4gICAgICAgICAgICAgICAgICAgICAgICBpc1NhbWVEYXkocHJlU2VsZWN0aW9uRGF5LCBzZWxlY3RlZERheSkpKVxuICAgICAgICAgICAgICAgID8gMFxuICAgICAgICAgICAgICAgIDogLTE7XG4gICAgICAgICAgICByZXR1cm4gdGFiSW5kZXg7XG4gICAgICAgIH07XG4gICAgICAgIC8vIHZhcmlvdXMgY2FzZXMgd2hlbiB3ZSBuZWVkIHRvIGFwcGx5IGZvY3VzIHRvIHRoZSBwcmVzZWxlY3RlZCBkYXlcbiAgICAgICAgLy8gZm9jdXMgdGhlIGRheSBvbiBtb3VudC91cGRhdGUgc28gdGhhdCBrZXlib2FyZCBuYXZpZ2F0aW9uIHdvcmtzIHdoaWxlIGN5Y2xpbmcgdGhyb3VnaCBtb250aHMgd2l0aCB1cCBvciBkb3duIGtleXMgKG5vdCBmb3IgcHJldiBhbmQgbmV4dCBtb250aCBidXR0b25zKVxuICAgICAgICAvLyBwcmV2ZW50IGZvY3VzIGZvciB0aGVzZSBhY3RpdmVFbGVtZW50IGNhc2VzIHNvIHdlIGRvbid0IHB1bGwgZm9jdXMgZnJvbSB0aGUgaW5wdXQgYXMgdGhlIGNhbGVuZGFyIG9wZW5zXG4gICAgICAgIF90aGlzLmhhbmRsZUZvY3VzRGF5ID0gZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgdmFyIF9hO1xuICAgICAgICAgICAgLy8gb25seSBkbyB0aGlzIHdoaWxlIHRoZSBpbnB1dCBpc24ndCBmb2N1c2VkXG4gICAgICAgICAgICAvLyBvdGhlcndpc2UsIHR5cGluZy9iYWNrc3BhY2luZyB0aGUgZGF0ZSBtYW51YWxseSBtYXkgc3RlYWwgZm9jdXMgYXdheSBmcm9tIHRoZSBpbnB1dFxuICAgICAgICAgICAgX3RoaXMuc2hvdWxkRm9jdXNEYXkoKSAmJiAoKF9hID0gX3RoaXMuZGF5RWwuY3VycmVudCkgPT09IG51bGwgfHwgX2EgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9hLmZvY3VzKHsgcHJldmVudFNjcm9sbDogdHJ1ZSB9KSk7XG4gICAgICAgIH07XG4gICAgICAgIF90aGlzLnJlbmRlckRheUNvbnRlbnRzID0gZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgaWYgKF90aGlzLnByb3BzLm1vbnRoU2hvd3NEdXBsaWNhdGVEYXlzRW5kICYmIF90aGlzLmlzQWZ0ZXJNb250aCgpKVxuICAgICAgICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICAgICAgaWYgKF90aGlzLnByb3BzLm1vbnRoU2hvd3NEdXBsaWNhdGVEYXlzU3RhcnQgJiYgX3RoaXMuaXNCZWZvcmVNb250aCgpKVxuICAgICAgICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICAgICAgcmV0dXJuIF90aGlzLnByb3BzLnJlbmRlckRheUNvbnRlbnRzXG4gICAgICAgICAgICAgICAgPyBfdGhpcy5wcm9wcy5yZW5kZXJEYXlDb250ZW50cyhnZXREYXRlKF90aGlzLnByb3BzLmRheSksIF90aGlzLnByb3BzLmRheSlcbiAgICAgICAgICAgICAgICA6IGdldERhdGUoX3RoaXMucHJvcHMuZGF5KTtcbiAgICAgICAgfTtcbiAgICAgICAgX3RoaXMucmVuZGVyID0gZnVuY3Rpb24gKCkgeyByZXR1cm4gKFxuICAgICAgICAvLyBUT0RPOiBVc2UgPG9wdGlvbj4gaW5zdGVhZCBvZiB0aGUgXCJvcHRpb25cIiByb2xlIHRvIGVuc3VyZSBhY2Nlc3NpYmlsaXR5IGFjcm9zcyBhbGwgZGV2aWNlcy5cbiAgICAgICAgUmVhY3QuY3JlYXRlRWxlbWVudChcImRpdlwiLCB7IHJlZjogX3RoaXMuZGF5RWwsIGNsYXNzTmFtZTogX3RoaXMuZ2V0Q2xhc3NOYW1lcyhfdGhpcy5wcm9wcy5kYXkpLCBvbktleURvd246IF90aGlzLmhhbmRsZU9uS2V5RG93biwgb25DbGljazogX3RoaXMuaGFuZGxlQ2xpY2ssIG9uTW91c2VFbnRlcjogIV90aGlzLnByb3BzLnVzZVBvaW50ZXJFdmVudCA/IF90aGlzLmhhbmRsZU1vdXNlRW50ZXIgOiB1bmRlZmluZWQsIG9uUG9pbnRlckVudGVyOiBfdGhpcy5wcm9wcy51c2VQb2ludGVyRXZlbnQgPyBfdGhpcy5oYW5kbGVNb3VzZUVudGVyIDogdW5kZWZpbmVkLCB0YWJJbmRleDogX3RoaXMuZ2V0VGFiSW5kZXgoKSwgXCJhcmlhLWxhYmVsXCI6IF90aGlzLmdldEFyaWFMYWJlbCgpLCByb2xlOiBcImdyaWRjZWxsXCIsIHRpdGxlOiBfdGhpcy5nZXRUaXRsZSgpLCBcImFyaWEtZGlzYWJsZWRcIjogX3RoaXMuaXNEaXNhYmxlZCgpLCBcImFyaWEtY3VycmVudFwiOiBfdGhpcy5pc0N1cnJlbnREYXkoKSA/IFwiZGF0ZVwiIDogdW5kZWZpbmVkLCBcImFyaWEtc2VsZWN0ZWRcIjogX3RoaXMuaXNTZWxlY3RlZCgpIHx8IF90aGlzLmlzSW5SYW5nZSgpIH0sXG4gICAgICAgICAgICBfdGhpcy5yZW5kZXJEYXlDb250ZW50cygpLFxuICAgICAgICAgICAgX3RoaXMuZ2V0VGl0bGUoKSAhPT0gXCJcIiAmJiAoUmVhY3QuY3JlYXRlRWxlbWVudChcInNwYW5cIiwgeyBjbGFzc05hbWU6IFwib3ZlcmxheVwiIH0sIF90aGlzLmdldFRpdGxlKCkpKSkpOyB9O1xuICAgICAgICByZXR1cm4gX3RoaXM7XG4gICAgfVxuICAgIERheS5wcm90b3R5cGUuY29tcG9uZW50RGlkTW91bnQgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHRoaXMuaGFuZGxlRm9jdXNEYXkoKTtcbiAgICB9O1xuICAgIERheS5wcm90b3R5cGUuY29tcG9uZW50RGlkVXBkYXRlID0gZnVuY3Rpb24gKCkge1xuICAgICAgICB0aGlzLmhhbmRsZUZvY3VzRGF5KCk7XG4gICAgfTtcbiAgICBEYXkucHJvdG90eXBlLnNob3VsZEZvY3VzRGF5ID0gZnVuY3Rpb24gKCkge1xuICAgICAgICB2YXIgc2hvdWxkRm9jdXNEYXkgPSBmYWxzZTtcbiAgICAgICAgaWYgKHRoaXMuZ2V0VGFiSW5kZXgoKSA9PT0gMCAmJiB0aGlzLmlzU2FtZURheSh0aGlzLnByb3BzLnByZVNlbGVjdGlvbikpIHtcbiAgICAgICAgICAgIC8vIHRoZXJlIGlzIGN1cnJlbnRseSBubyBhY3RpdmVFbGVtZW50IGFuZCBub3QgaW5saW5lXG4gICAgICAgICAgICBpZiAoIWRvY3VtZW50LmFjdGl2ZUVsZW1lbnQgfHwgZG9jdW1lbnQuYWN0aXZlRWxlbWVudCA9PT0gZG9jdW1lbnQuYm9keSkge1xuICAgICAgICAgICAgICAgIHNob3VsZEZvY3VzRGF5ID0gdHJ1ZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIC8vIGlubGluZSB2ZXJzaW9uOlxuICAgICAgICAgICAgLy8gZG8gbm90IGZvY3VzIG9uIGluaXRpYWwgcmVuZGVyIHRvIHByZXZlbnQgYXV0b0ZvY3VzIGlzc3VlXG4gICAgICAgICAgICAvLyBmb2N1cyBhZnRlciBtb250aCBoYXMgY2hhbmdlZCB2aWEga2V5Ym9hcmRcbiAgICAgICAgICAgIGlmICh0aGlzLnByb3BzLmlubGluZSAmJiAhdGhpcy5wcm9wcy5zaG91bGRGb2N1c0RheUlubGluZSkge1xuICAgICAgICAgICAgICAgIHNob3VsZEZvY3VzRGF5ID0gZmFsc2U7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAodGhpcy5pc0RheUFjdGl2ZUVsZW1lbnQoKSkge1xuICAgICAgICAgICAgICAgIHNob3VsZEZvY3VzRGF5ID0gdHJ1ZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmICh0aGlzLmlzRHVwbGljYXRlRGF5KCkpIHtcbiAgICAgICAgICAgICAgICBzaG91bGRGb2N1c0RheSA9IGZhbHNlO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiBzaG91bGRGb2N1c0RheTtcbiAgICB9O1xuICAgIC8vIHRoZSBhY3RpdmVFbGVtZW50IGlzIGluIHRoZSBjb250YWluZXIsIGFuZCBpdCBpcyBhbm90aGVyIGluc3RhbmNlIG9mIERheVxuICAgIERheS5wcm90b3R5cGUuaXNEYXlBY3RpdmVFbGVtZW50ID0gZnVuY3Rpb24gKCkge1xuICAgICAgICB2YXIgX2EsIF9iLCBfYztcbiAgICAgICAgcmV0dXJuICgoKF9iID0gKF9hID0gdGhpcy5wcm9wcy5jb250YWluZXJSZWYpID09PSBudWxsIHx8IF9hID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYS5jdXJyZW50KSA9PT0gbnVsbCB8fCBfYiA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2IuY29udGFpbnMoZG9jdW1lbnQuYWN0aXZlRWxlbWVudCkpICYmXG4gICAgICAgICAgICAoKF9jID0gZG9jdW1lbnQuYWN0aXZlRWxlbWVudCkgPT09IG51bGwgfHwgX2MgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9jLmNsYXNzTGlzdC5jb250YWlucyhcInJlYWN0LWRhdGVwaWNrZXJfX2RheVwiKSkpO1xuICAgIH07XG4gICAgRGF5LnByb3RvdHlwZS5pc0R1cGxpY2F0ZURheSA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgcmV0dXJuIChcbiAgICAgICAgLy9kYXkgaXMgb25lIG9mIHRoZSBub24gcmVuZGVyZWQgZHVwbGljYXRlIGRheXNcbiAgICAgICAgKHRoaXMucHJvcHMubW9udGhTaG93c0R1cGxpY2F0ZURheXNFbmQgJiYgdGhpcy5pc0FmdGVyTW9udGgoKSkgfHxcbiAgICAgICAgICAgICh0aGlzLnByb3BzLm1vbnRoU2hvd3NEdXBsaWNhdGVEYXlzU3RhcnQgJiYgdGhpcy5pc0JlZm9yZU1vbnRoKCkpKTtcbiAgICB9O1xuICAgIHJldHVybiBEYXk7XG59KENvbXBvbmVudCkpO1xuXG52YXIgV2Vla051bWJlciA9IC8qKiBAY2xhc3MgKi8gKGZ1bmN0aW9uIChfc3VwZXIpIHtcbiAgICBfX2V4dGVuZHMoV2Vla051bWJlciwgX3N1cGVyKTtcbiAgICBmdW5jdGlvbiBXZWVrTnVtYmVyKCkge1xuICAgICAgICB2YXIgX3RoaXMgPSBfc3VwZXIgIT09IG51bGwgJiYgX3N1cGVyLmFwcGx5KHRoaXMsIGFyZ3VtZW50cykgfHwgdGhpcztcbiAgICAgICAgX3RoaXMud2Vla051bWJlckVsID0gY3JlYXRlUmVmKCk7XG4gICAgICAgIF90aGlzLmhhbmRsZUNsaWNrID0gZnVuY3Rpb24gKGV2ZW50KSB7XG4gICAgICAgICAgICBpZiAoX3RoaXMucHJvcHMub25DbGljaykge1xuICAgICAgICAgICAgICAgIF90aGlzLnByb3BzLm9uQ2xpY2soZXZlbnQpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9O1xuICAgICAgICBfdGhpcy5oYW5kbGVPbktleURvd24gPSBmdW5jdGlvbiAoZXZlbnQpIHtcbiAgICAgICAgICAgIHZhciBfYSwgX2I7XG4gICAgICAgICAgICB2YXIgZXZlbnRLZXkgPSBldmVudC5rZXk7XG4gICAgICAgICAgICBpZiAoZXZlbnRLZXkgPT09IEtleVR5cGUuU3BhY2UpIHtcbiAgICAgICAgICAgICAgICBldmVudC5wcmV2ZW50RGVmYXVsdCgpO1xuICAgICAgICAgICAgICAgIGV2ZW50LmtleSA9IEtleVR5cGUuRW50ZXI7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICAoX2IgPSAoX2EgPSBfdGhpcy5wcm9wcykuaGFuZGxlT25LZXlEb3duKSA9PT0gbnVsbCB8fCBfYiA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2IuY2FsbChfYSwgZXZlbnQpO1xuICAgICAgICB9O1xuICAgICAgICBfdGhpcy5pc0tleWJvYXJkU2VsZWN0ZWQgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICByZXR1cm4gIV90aGlzLnByb3BzLmRpc2FibGVkS2V5Ym9hcmROYXZpZ2F0aW9uICYmXG4gICAgICAgICAgICAgICAgIWlzU2FtZURheShfdGhpcy5wcm9wcy5kYXRlLCBfdGhpcy5wcm9wcy5zZWxlY3RlZCkgJiZcbiAgICAgICAgICAgICAgICBpc1NhbWVEYXkoX3RoaXMucHJvcHMuZGF0ZSwgX3RoaXMucHJvcHMucHJlU2VsZWN0aW9uKTtcbiAgICAgICAgfTtcbiAgICAgICAgX3RoaXMuZ2V0VGFiSW5kZXggPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICByZXR1cm4gX3RoaXMucHJvcHMuc2hvd1dlZWtQaWNrZXIgJiZcbiAgICAgICAgICAgICAgICBfdGhpcy5wcm9wcy5zaG93V2Vla051bWJlciAmJlxuICAgICAgICAgICAgICAgIChfdGhpcy5pc0tleWJvYXJkU2VsZWN0ZWQoKSB8fFxuICAgICAgICAgICAgICAgICAgICAoaXNTYW1lRGF5KF90aGlzLnByb3BzLmRhdGUsIF90aGlzLnByb3BzLnNlbGVjdGVkKSAmJlxuICAgICAgICAgICAgICAgICAgICAgICAgaXNTYW1lRGF5KF90aGlzLnByb3BzLnByZVNlbGVjdGlvbiwgX3RoaXMucHJvcHMuc2VsZWN0ZWQpKSlcbiAgICAgICAgICAgICAgICA/IDBcbiAgICAgICAgICAgICAgICA6IC0xO1xuICAgICAgICB9O1xuICAgICAgICAvLyB2YXJpb3VzIGNhc2VzIHdoZW4gd2UgbmVlZCB0byBhcHBseSBmb2N1cyB0byB0aGUgcHJlc2VsZWN0ZWQgd2Vlay1udW1iZXJcbiAgICAgICAgLy8gZm9jdXMgdGhlIHdlZWstbnVtYmVyIG9uIG1vdW50L3VwZGF0ZSBzbyB0aGF0IGtleWJvYXJkIG5hdmlnYXRpb24gd29ya3Mgd2hpbGUgY3ljbGluZyB0aHJvdWdoIG1vbnRocyB3aXRoIHVwIG9yIGRvd24ga2V5cyAobm90IGZvciBwcmV2IGFuZCBuZXh0IG1vbnRoIGJ1dHRvbnMpXG4gICAgICAgIC8vIHByZXZlbnQgZm9jdXMgZm9yIHRoZXNlIGFjdGl2ZUVsZW1lbnQgY2FzZXMgc28gd2UgZG9uJ3QgcHVsbCBmb2N1cyBmcm9tIHRoZSBpbnB1dCBhcyB0aGUgY2FsZW5kYXIgb3BlbnNcbiAgICAgICAgX3RoaXMuaGFuZGxlRm9jdXNXZWVrTnVtYmVyID0gZnVuY3Rpb24gKHByZXZQcm9wcykge1xuICAgICAgICAgICAgdmFyIHNob3VsZEZvY3VzV2Vla051bWJlciA9IGZhbHNlO1xuICAgICAgICAgICAgLy8gb25seSBkbyB0aGlzIHdoaWxlIHRoZSBpbnB1dCBpc24ndCBmb2N1c2VkXG4gICAgICAgICAgICAvLyBvdGhlcndpc2UsIHR5cGluZy9iYWNrc3BhY2luZyB0aGUgZGF0ZSBtYW51YWxseSBtYXkgc3RlYWwgZm9jdXMgYXdheSBmcm9tIHRoZSBpbnB1dFxuICAgICAgICAgICAgaWYgKF90aGlzLmdldFRhYkluZGV4KCkgPT09IDAgJiZcbiAgICAgICAgICAgICAgICAhKHByZXZQcm9wcyA9PT0gbnVsbCB8fCBwcmV2UHJvcHMgPT09IHZvaWQgMCA/IHZvaWQgMCA6IHByZXZQcm9wcy5pc0lucHV0Rm9jdXNlZCkgJiZcbiAgICAgICAgICAgICAgICBpc1NhbWVEYXkoX3RoaXMucHJvcHMuZGF0ZSwgX3RoaXMucHJvcHMucHJlU2VsZWN0aW9uKSkge1xuICAgICAgICAgICAgICAgIC8vIHRoZXJlIGlzIGN1cnJlbnRseSBubyBhY3RpdmVFbGVtZW50IGFuZCBub3QgaW5saW5lXG4gICAgICAgICAgICAgICAgaWYgKCFkb2N1bWVudC5hY3RpdmVFbGVtZW50IHx8IGRvY3VtZW50LmFjdGl2ZUVsZW1lbnQgPT09IGRvY3VtZW50LmJvZHkpIHtcbiAgICAgICAgICAgICAgICAgICAgc2hvdWxkRm9jdXNXZWVrTnVtYmVyID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgLy8gaW5saW5lIHZlcnNpb246XG4gICAgICAgICAgICAgICAgLy8gZG8gbm90IGZvY3VzIG9uIGluaXRpYWwgcmVuZGVyIHRvIHByZXZlbnQgYXV0b0ZvY3VzIGlzc3VlXG4gICAgICAgICAgICAgICAgLy8gZm9jdXMgYWZ0ZXIgbW9udGggaGFzIGNoYW5nZWQgdmlhIGtleWJvYXJkXG4gICAgICAgICAgICAgICAgaWYgKF90aGlzLnByb3BzLmlubGluZSAmJiAhX3RoaXMucHJvcHMuc2hvdWxkRm9jdXNEYXlJbmxpbmUpIHtcbiAgICAgICAgICAgICAgICAgICAgc2hvdWxkRm9jdXNXZWVrTnVtYmVyID0gZmFsc2U7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIC8vIHRoZSBhY3RpdmVFbGVtZW50IGlzIGluIHRoZSBjb250YWluZXIsIGFuZCBpdCBpcyBhbm90aGVyIGluc3RhbmNlIG9mIFdlZWtOdW1iZXJcbiAgICAgICAgICAgICAgICBpZiAoX3RoaXMucHJvcHMuY29udGFpbmVyUmVmICYmXG4gICAgICAgICAgICAgICAgICAgIF90aGlzLnByb3BzLmNvbnRhaW5lclJlZi5jdXJyZW50ICYmXG4gICAgICAgICAgICAgICAgICAgIF90aGlzLnByb3BzLmNvbnRhaW5lclJlZi5jdXJyZW50LmNvbnRhaW5zKGRvY3VtZW50LmFjdGl2ZUVsZW1lbnQpICYmXG4gICAgICAgICAgICAgICAgICAgIGRvY3VtZW50LmFjdGl2ZUVsZW1lbnQgJiZcbiAgICAgICAgICAgICAgICAgICAgZG9jdW1lbnQuYWN0aXZlRWxlbWVudC5jbGFzc0xpc3QuY29udGFpbnMoXCJyZWFjdC1kYXRlcGlja2VyX193ZWVrLW51bWJlclwiKSkge1xuICAgICAgICAgICAgICAgICAgICBzaG91bGRGb2N1c1dlZWtOdW1iZXIgPSB0cnVlO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHNob3VsZEZvY3VzV2Vla051bWJlciAmJlxuICAgICAgICAgICAgICAgIF90aGlzLndlZWtOdW1iZXJFbC5jdXJyZW50ICYmXG4gICAgICAgICAgICAgICAgX3RoaXMud2Vla051bWJlckVsLmN1cnJlbnQuZm9jdXMoeyBwcmV2ZW50U2Nyb2xsOiB0cnVlIH0pO1xuICAgICAgICB9O1xuICAgICAgICByZXR1cm4gX3RoaXM7XG4gICAgfVxuICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShXZWVrTnVtYmVyLCBcImRlZmF1bHRQcm9wc1wiLCB7XG4gICAgICAgIGdldDogZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgICAgICBhcmlhTGFiZWxQcmVmaXg6IFwid2VlayBcIixcbiAgICAgICAgICAgIH07XG4gICAgICAgIH0sXG4gICAgICAgIGVudW1lcmFibGU6IGZhbHNlLFxuICAgICAgICBjb25maWd1cmFibGU6IHRydWVcbiAgICB9KTtcbiAgICBXZWVrTnVtYmVyLnByb3RvdHlwZS5jb21wb25lbnREaWRNb3VudCA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdGhpcy5oYW5kbGVGb2N1c1dlZWtOdW1iZXIoKTtcbiAgICB9O1xuICAgIFdlZWtOdW1iZXIucHJvdG90eXBlLmNvbXBvbmVudERpZFVwZGF0ZSA9IGZ1bmN0aW9uIChwcmV2UHJvcHMpIHtcbiAgICAgICAgdGhpcy5oYW5kbGVGb2N1c1dlZWtOdW1iZXIocHJldlByb3BzKTtcbiAgICB9O1xuICAgIFdlZWtOdW1iZXIucHJvdG90eXBlLnJlbmRlciA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdmFyIF9hID0gdGhpcy5wcm9wcywgd2Vla051bWJlciA9IF9hLndlZWtOdW1iZXIsIGlzV2Vla0Rpc2FibGVkID0gX2EuaXNXZWVrRGlzYWJsZWQsIF9iID0gX2EuYXJpYUxhYmVsUHJlZml4LCBhcmlhTGFiZWxQcmVmaXggPSBfYiA9PT0gdm9pZCAwID8gV2Vla051bWJlci5kZWZhdWx0UHJvcHMuYXJpYUxhYmVsUHJlZml4IDogX2IsIG9uQ2xpY2sgPSBfYS5vbkNsaWNrO1xuICAgICAgICB2YXIgd2Vla051bWJlckNsYXNzZXMgPSB7XG4gICAgICAgICAgICBcInJlYWN0LWRhdGVwaWNrZXJfX3dlZWstbnVtYmVyXCI6IHRydWUsXG4gICAgICAgICAgICBcInJlYWN0LWRhdGVwaWNrZXJfX3dlZWstbnVtYmVyLS1jbGlja2FibGVcIjogISFvbkNsaWNrICYmICFpc1dlZWtEaXNhYmxlZCxcbiAgICAgICAgICAgIFwicmVhY3QtZGF0ZXBpY2tlcl9fd2Vlay1udW1iZXItLXNlbGVjdGVkXCI6ICEhb25DbGljayAmJiBpc1NhbWVEYXkodGhpcy5wcm9wcy5kYXRlLCB0aGlzLnByb3BzLnNlbGVjdGVkKSxcbiAgICAgICAgfTtcbiAgICAgICAgcmV0dXJuIChSZWFjdC5jcmVhdGVFbGVtZW50KFwiZGl2XCIsIHsgcmVmOiB0aGlzLndlZWtOdW1iZXJFbCwgY2xhc3NOYW1lOiBjbHN4KHdlZWtOdW1iZXJDbGFzc2VzKSwgXCJhcmlhLWxhYmVsXCI6IFwiXCIuY29uY2F0KGFyaWFMYWJlbFByZWZpeCwgXCIgXCIpLmNvbmNhdCh0aGlzLnByb3BzLndlZWtOdW1iZXIpLCBvbkNsaWNrOiB0aGlzLmhhbmRsZUNsaWNrLCBvbktleURvd246IHRoaXMuaGFuZGxlT25LZXlEb3duLCB0YWJJbmRleDogdGhpcy5nZXRUYWJJbmRleCgpLCByb2xlOiBcImdyaWRjZWxsXCIgfSwgd2Vla051bWJlcikpO1xuICAgIH07XG4gICAgcmV0dXJuIFdlZWtOdW1iZXI7XG59KENvbXBvbmVudCkpO1xuXG52YXIgV2VlayA9IC8qKiBAY2xhc3MgKi8gKGZ1bmN0aW9uIChfc3VwZXIpIHtcbiAgICBfX2V4dGVuZHMoV2VlaywgX3N1cGVyKTtcbiAgICBmdW5jdGlvbiBXZWVrKCkge1xuICAgICAgICB2YXIgX3RoaXMgPSBfc3VwZXIgIT09IG51bGwgJiYgX3N1cGVyLmFwcGx5KHRoaXMsIGFyZ3VtZW50cykgfHwgdGhpcztcbiAgICAgICAgX3RoaXMuaXNEaXNhYmxlZCA9IGZ1bmN0aW9uIChkYXkpIHtcbiAgICAgICAgICAgIHJldHVybiBpc0RheURpc2FibGVkKGRheSwge1xuICAgICAgICAgICAgICAgIG1pbkRhdGU6IF90aGlzLnByb3BzLm1pbkRhdGUsXG4gICAgICAgICAgICAgICAgbWF4RGF0ZTogX3RoaXMucHJvcHMubWF4RGF0ZSxcbiAgICAgICAgICAgICAgICBleGNsdWRlRGF0ZXM6IF90aGlzLnByb3BzLmV4Y2x1ZGVEYXRlcyxcbiAgICAgICAgICAgICAgICBleGNsdWRlRGF0ZUludGVydmFsczogX3RoaXMucHJvcHMuZXhjbHVkZURhdGVJbnRlcnZhbHMsXG4gICAgICAgICAgICAgICAgaW5jbHVkZURhdGVJbnRlcnZhbHM6IF90aGlzLnByb3BzLmluY2x1ZGVEYXRlSW50ZXJ2YWxzLFxuICAgICAgICAgICAgICAgIGluY2x1ZGVEYXRlczogX3RoaXMucHJvcHMuaW5jbHVkZURhdGVzLFxuICAgICAgICAgICAgICAgIGZpbHRlckRhdGU6IF90aGlzLnByb3BzLmZpbHRlckRhdGUsXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfTtcbiAgICAgICAgX3RoaXMuaGFuZGxlRGF5Q2xpY2sgPSBmdW5jdGlvbiAoZGF5LCBldmVudCkge1xuICAgICAgICAgICAgaWYgKF90aGlzLnByb3BzLm9uRGF5Q2xpY2spIHtcbiAgICAgICAgICAgICAgICBfdGhpcy5wcm9wcy5vbkRheUNsaWNrKGRheSwgZXZlbnQpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9O1xuICAgICAgICBfdGhpcy5oYW5kbGVEYXlNb3VzZUVudGVyID0gZnVuY3Rpb24gKGRheSkge1xuICAgICAgICAgICAgaWYgKF90aGlzLnByb3BzLm9uRGF5TW91c2VFbnRlcikge1xuICAgICAgICAgICAgICAgIF90aGlzLnByb3BzLm9uRGF5TW91c2VFbnRlcihkYXkpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9O1xuICAgICAgICBfdGhpcy5oYW5kbGVXZWVrQ2xpY2sgPSBmdW5jdGlvbiAoZGF5LCB3ZWVrTnVtYmVyLCBldmVudCkge1xuICAgICAgICAgICAgdmFyIF9hLCBfYiwgX2M7XG4gICAgICAgICAgICB2YXIgZW5hYmxlZFdlZWtEYXkgPSBuZXcgRGF0ZShkYXkpO1xuICAgICAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCA3OyBpKyspIHtcbiAgICAgICAgICAgICAgICB2YXIgcHJvY2Vzc2luZ0RheSA9IG5ldyBEYXRlKGRheSk7XG4gICAgICAgICAgICAgICAgcHJvY2Vzc2luZ0RheS5zZXREYXRlKHByb2Nlc3NpbmdEYXkuZ2V0RGF0ZSgpICsgaSk7XG4gICAgICAgICAgICAgICAgdmFyIGlzRW5hYmxlZCA9ICFfdGhpcy5pc0Rpc2FibGVkKHByb2Nlc3NpbmdEYXkpO1xuICAgICAgICAgICAgICAgIGlmIChpc0VuYWJsZWQpIHtcbiAgICAgICAgICAgICAgICAgICAgZW5hYmxlZFdlZWtEYXkgPSBwcm9jZXNzaW5nRGF5O1xuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAodHlwZW9mIF90aGlzLnByb3BzLm9uV2Vla1NlbGVjdCA9PT0gXCJmdW5jdGlvblwiKSB7XG4gICAgICAgICAgICAgICAgX3RoaXMucHJvcHMub25XZWVrU2VsZWN0KGVuYWJsZWRXZWVrRGF5LCB3ZWVrTnVtYmVyLCBldmVudCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoX3RoaXMucHJvcHMuc2hvd1dlZWtQaWNrZXIpIHtcbiAgICAgICAgICAgICAgICBfdGhpcy5oYW5kbGVEYXlDbGljayhlbmFibGVkV2Vla0RheSwgZXZlbnQpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKChfYSA9IF90aGlzLnByb3BzLnNob3VsZENsb3NlT25TZWxlY3QpICE9PSBudWxsICYmIF9hICE9PSB2b2lkIDAgPyBfYSA6IFdlZWsuZGVmYXVsdFByb3BzLnNob3VsZENsb3NlT25TZWxlY3QpIHtcbiAgICAgICAgICAgICAgICAoX2MgPSAoX2IgPSBfdGhpcy5wcm9wcykuc2V0T3BlbikgPT09IG51bGwgfHwgX2MgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9jLmNhbGwoX2IsIGZhbHNlKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfTtcbiAgICAgICAgX3RoaXMuZm9ybWF0V2Vla051bWJlciA9IGZ1bmN0aW9uIChkYXRlKSB7XG4gICAgICAgICAgICBpZiAoX3RoaXMucHJvcHMuZm9ybWF0V2Vla051bWJlcikge1xuICAgICAgICAgICAgICAgIHJldHVybiBfdGhpcy5wcm9wcy5mb3JtYXRXZWVrTnVtYmVyKGRhdGUpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIGdldFdlZWsoZGF0ZSk7XG4gICAgICAgIH07XG4gICAgICAgIF90aGlzLmlzV2Vla0Rpc2FibGVkID0gZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgdmFyIHN0YXJ0T2ZXZWVrID0gX3RoaXMuc3RhcnRPZldlZWsoKTtcbiAgICAgICAgICAgIHZhciBlbmRPZldlZWsgPSBhZGREYXlzKHN0YXJ0T2ZXZWVrLCA2KTtcbiAgICAgICAgICAgIHZhciBwcm9jZXNzaW5nRGF0ZSA9IG5ldyBEYXRlKHN0YXJ0T2ZXZWVrKTtcbiAgICAgICAgICAgIHdoaWxlIChwcm9jZXNzaW5nRGF0ZSA8PSBlbmRPZldlZWspIHtcbiAgICAgICAgICAgICAgICBpZiAoIV90aGlzLmlzRGlzYWJsZWQocHJvY2Vzc2luZ0RhdGUpKVxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgICAgICAgICAgcHJvY2Vzc2luZ0RhdGUgPSBhZGREYXlzKHByb2Nlc3NpbmdEYXRlLCAxKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICB9O1xuICAgICAgICBfdGhpcy5yZW5kZXJEYXlzID0gZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgdmFyIHN0YXJ0T2ZXZWVrID0gX3RoaXMuc3RhcnRPZldlZWsoKTtcbiAgICAgICAgICAgIHZhciBkYXlzID0gW107XG4gICAgICAgICAgICB2YXIgd2Vla051bWJlciA9IF90aGlzLmZvcm1hdFdlZWtOdW1iZXIoc3RhcnRPZldlZWspO1xuICAgICAgICAgICAgaWYgKF90aGlzLnByb3BzLnNob3dXZWVrTnVtYmVyKSB7XG4gICAgICAgICAgICAgICAgdmFyIG9uQ2xpY2tBY3Rpb24gPSBfdGhpcy5wcm9wcy5vbldlZWtTZWxlY3QgfHwgX3RoaXMucHJvcHMuc2hvd1dlZWtQaWNrZXJcbiAgICAgICAgICAgICAgICAgICAgPyBfdGhpcy5oYW5kbGVXZWVrQ2xpY2suYmluZChfdGhpcywgc3RhcnRPZldlZWssIHdlZWtOdW1iZXIpXG4gICAgICAgICAgICAgICAgICAgIDogdW5kZWZpbmVkO1xuICAgICAgICAgICAgICAgIGRheXMucHVzaChSZWFjdC5jcmVhdGVFbGVtZW50KFdlZWtOdW1iZXIsIF9hc3NpZ24oeyBrZXk6IFwiV1wiIH0sIFdlZWsuZGVmYXVsdFByb3BzLCBfdGhpcy5wcm9wcywgeyB3ZWVrTnVtYmVyOiB3ZWVrTnVtYmVyLCBpc1dlZWtEaXNhYmxlZDogX3RoaXMuaXNXZWVrRGlzYWJsZWQoKSwgZGF0ZTogc3RhcnRPZldlZWssIG9uQ2xpY2s6IG9uQ2xpY2tBY3Rpb24gfSkpKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiBkYXlzLmNvbmNhdChbMCwgMSwgMiwgMywgNCwgNSwgNl0ubWFwKGZ1bmN0aW9uIChvZmZzZXQpIHtcbiAgICAgICAgICAgICAgICB2YXIgZGF5ID0gYWRkRGF5cyhzdGFydE9mV2Vlaywgb2Zmc2V0KTtcbiAgICAgICAgICAgICAgICByZXR1cm4gKFJlYWN0LmNyZWF0ZUVsZW1lbnQoRGF5LCBfYXNzaWduKHt9LCBXZWVrLmRlZmF1bHRQcm9wcywgX3RoaXMucHJvcHMsIHsgYXJpYUxhYmVsUHJlZml4V2hlbkVuYWJsZWQ6IF90aGlzLnByb3BzLmNob29zZURheUFyaWFMYWJlbFByZWZpeCwgYXJpYUxhYmVsUHJlZml4V2hlbkRpc2FibGVkOiBfdGhpcy5wcm9wcy5kaXNhYmxlZERheUFyaWFMYWJlbFByZWZpeCwga2V5OiBkYXkudmFsdWVPZigpLCBkYXk6IGRheSwgb25DbGljazogX3RoaXMuaGFuZGxlRGF5Q2xpY2suYmluZChfdGhpcywgZGF5KSwgb25Nb3VzZUVudGVyOiBfdGhpcy5oYW5kbGVEYXlNb3VzZUVudGVyLmJpbmQoX3RoaXMsIGRheSkgfSkpKTtcbiAgICAgICAgICAgIH0pKTtcbiAgICAgICAgfTtcbiAgICAgICAgX3RoaXMuc3RhcnRPZldlZWsgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICByZXR1cm4gZ2V0U3RhcnRPZldlZWsoX3RoaXMucHJvcHMuZGF5LCBfdGhpcy5wcm9wcy5sb2NhbGUsIF90aGlzLnByb3BzLmNhbGVuZGFyU3RhcnREYXkpO1xuICAgICAgICB9O1xuICAgICAgICBfdGhpcy5pc0tleWJvYXJkU2VsZWN0ZWQgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICByZXR1cm4gIV90aGlzLnByb3BzLmRpc2FibGVkS2V5Ym9hcmROYXZpZ2F0aW9uICYmXG4gICAgICAgICAgICAgICAgIWlzU2FtZURheShfdGhpcy5zdGFydE9mV2VlaygpLCBfdGhpcy5wcm9wcy5zZWxlY3RlZCkgJiZcbiAgICAgICAgICAgICAgICBpc1NhbWVEYXkoX3RoaXMuc3RhcnRPZldlZWsoKSwgX3RoaXMucHJvcHMucHJlU2VsZWN0aW9uKTtcbiAgICAgICAgfTtcbiAgICAgICAgcmV0dXJuIF90aGlzO1xuICAgIH1cbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoV2VlaywgXCJkZWZhdWx0UHJvcHNcIiwge1xuICAgICAgICBnZXQ6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICAgICAgc2hvdWxkQ2xvc2VPblNlbGVjdDogdHJ1ZSxcbiAgICAgICAgICAgIH07XG4gICAgICAgIH0sXG4gICAgICAgIGVudW1lcmFibGU6IGZhbHNlLFxuICAgICAgICBjb25maWd1cmFibGU6IHRydWVcbiAgICB9KTtcbiAgICBXZWVrLnByb3RvdHlwZS5yZW5kZXIgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHZhciB3ZWVrTnVtYmVyQ2xhc3NlcyA9IHtcbiAgICAgICAgICAgIFwicmVhY3QtZGF0ZXBpY2tlcl9fd2Vla1wiOiB0cnVlLFxuICAgICAgICAgICAgXCJyZWFjdC1kYXRlcGlja2VyX193ZWVrLS1zZWxlY3RlZFwiOiBpc1NhbWVEYXkodGhpcy5zdGFydE9mV2VlaygpLCB0aGlzLnByb3BzLnNlbGVjdGVkKSxcbiAgICAgICAgICAgIFwicmVhY3QtZGF0ZXBpY2tlcl9fd2Vlay0ta2V5Ym9hcmQtc2VsZWN0ZWRcIjogdGhpcy5pc0tleWJvYXJkU2VsZWN0ZWQoKSxcbiAgICAgICAgfTtcbiAgICAgICAgdmFyIGN1c3RvbVdlZWtDbGFzc05hbWUgPSB0aGlzLnByb3BzLndlZWtDbGFzc05hbWVcbiAgICAgICAgICAgID8gdGhpcy5wcm9wcy53ZWVrQ2xhc3NOYW1lKHRoaXMuc3RhcnRPZldlZWsoKSlcbiAgICAgICAgICAgIDogdW5kZWZpbmVkO1xuICAgICAgICByZXR1cm4gKFJlYWN0LmNyZWF0ZUVsZW1lbnQoXCJkaXZcIiwgeyBjbGFzc05hbWU6IGNsc3god2Vla051bWJlckNsYXNzZXMsIGN1c3RvbVdlZWtDbGFzc05hbWUpLCByb2xlOiBcInJvd1wiIH0sIHRoaXMucmVuZGVyRGF5cygpKSk7XG4gICAgfTtcbiAgICByZXR1cm4gV2Vlaztcbn0oQ29tcG9uZW50KSk7XG5cbnZhciBfYTtcbnZhciBGSVhFRF9IRUlHSFRfU1RBTkRBUkRfV0VFS19DT1VOVCA9IDY7XG52YXIgTU9OVEhfQ09MVU1OU19MQVlPVVQgPSB7XG4gICAgVFdPX0NPTFVNTlM6IFwidHdvX2NvbHVtbnNcIixcbiAgICBUSFJFRV9DT0xVTU5TOiBcInRocmVlX2NvbHVtbnNcIixcbiAgICBGT1VSX0NPTFVNTlM6IFwiZm91cl9jb2x1bW5zXCIsXG59O1xudmFyIE1PTlRIX0NPTFVNTlMgPSAoX2EgPSB7fSxcbiAgICBfYVtNT05USF9DT0xVTU5TX0xBWU9VVC5UV09fQ09MVU1OU10gPSB7XG4gICAgICAgIGdyaWQ6IFtcbiAgICAgICAgICAgIFswLCAxXSxcbiAgICAgICAgICAgIFsyLCAzXSxcbiAgICAgICAgICAgIFs0LCA1XSxcbiAgICAgICAgICAgIFs2LCA3XSxcbiAgICAgICAgICAgIFs4LCA5XSxcbiAgICAgICAgICAgIFsxMCwgMTFdLFxuICAgICAgICBdLFxuICAgICAgICB2ZXJ0aWNhbE5hdmlnYXRpb25PZmZzZXQ6IDIsXG4gICAgfSxcbiAgICBfYVtNT05USF9DT0xVTU5TX0xBWU9VVC5USFJFRV9DT0xVTU5TXSA9IHtcbiAgICAgICAgZ3JpZDogW1xuICAgICAgICAgICAgWzAsIDEsIDJdLFxuICAgICAgICAgICAgWzMsIDQsIDVdLFxuICAgICAgICAgICAgWzYsIDcsIDhdLFxuICAgICAgICAgICAgWzksIDEwLCAxMV0sXG4gICAgICAgIF0sXG4gICAgICAgIHZlcnRpY2FsTmF2aWdhdGlvbk9mZnNldDogMyxcbiAgICB9LFxuICAgIF9hW01PTlRIX0NPTFVNTlNfTEFZT1VULkZPVVJfQ09MVU1OU10gPSB7XG4gICAgICAgIGdyaWQ6IFtcbiAgICAgICAgICAgIFswLCAxLCAyLCAzXSxcbiAgICAgICAgICAgIFs0LCA1LCA2LCA3XSxcbiAgICAgICAgICAgIFs4LCA5LCAxMCwgMTFdLFxuICAgICAgICBdLFxuICAgICAgICB2ZXJ0aWNhbE5hdmlnYXRpb25PZmZzZXQ6IDQsXG4gICAgfSxcbiAgICBfYSk7XG52YXIgTU9OVEhfTkFWSUdBVElPTl9IT1JJWk9OVEFMX09GRlNFVCA9IDE7XG5mdW5jdGlvbiBnZXRNb250aENvbHVtbnNMYXlvdXQoc2hvd0ZvdXJDb2x1bW5Nb250aFllYXJQaWNrZXIsIHNob3dUd29Db2x1bW5Nb250aFllYXJQaWNrZXIpIHtcbiAgICBpZiAoc2hvd0ZvdXJDb2x1bW5Nb250aFllYXJQaWNrZXIpIHtcbiAgICAgICAgcmV0dXJuIE1PTlRIX0NPTFVNTlNfTEFZT1VULkZPVVJfQ09MVU1OUztcbiAgICB9XG4gICAgaWYgKHNob3dUd29Db2x1bW5Nb250aFllYXJQaWNrZXIpIHtcbiAgICAgICAgcmV0dXJuIE1PTlRIX0NPTFVNTlNfTEFZT1VULlRXT19DT0xVTU5TO1xuICAgIH1cbiAgICByZXR1cm4gTU9OVEhfQ09MVU1OU19MQVlPVVQuVEhSRUVfQ09MVU1OUztcbn1cbi8qKlxuICogYE1vbnRoYCBpcyBhIFJlYWN0IGNvbXBvbmVudCB0aGF0IHJlcHJlc2VudHMgYSBtb250aCBpbiBhIGNhbGVuZGFyLlxuICogSXQgYWNjZXB0cyBhIGBNb250aFByb3BzYCBvYmplY3QgYXMgcHJvcHMgd2hpY2ggcHJvdmlkZXMgdmFyaW91cyBjb25maWd1cmF0aW9ucyBhbmQgZXZlbnQgaGFuZGxlcnMuXG4gKlxuICogQHByb3AgZGF5Q2xhc3NOYW1lIC0gRnVuY3Rpb24gdG8gZGV0ZXJtaW5lIHRoZSBjbGFzcyBuYW1lIGZvciBhIGRheS5cbiAqIEBwcm9wIG1vbnRoQ2xhc3NOYW1lIC0gRnVuY3Rpb24gdG8gZGV0ZXJtaW5lIHRoZSBjbGFzcyBuYW1lIGZvciBhIG1vbnRoLlxuICogQHByb3AgZmlsdGVyRGF0ZSAtIEZ1bmN0aW9uIHRvIGZpbHRlciBkYXRlcy5cbiAqIEBwcm9wIGZvcm1hdFdlZWtOdW1iZXIgLSBGdW5jdGlvbiB0byBmb3JtYXQgdGhlIHdlZWsgbnVtYmVyLlxuICogQHByb3Agb25EYXlDbGljayAtIEZ1bmN0aW9uIHRvIGhhbmRsZSBkYXkgY2xpY2sgZXZlbnRzLlxuICogQHByb3Agb25EYXlNb3VzZUVudGVyIC0gRnVuY3Rpb24gdG8gaGFuZGxlIG1vdXNlIGVudGVyIGV2ZW50cyBvbiBhIGRheS5cbiAqIEBwcm9wIG9uTW91c2VMZWF2ZSAtIEZ1bmN0aW9uIHRvIGhhbmRsZSBtb3VzZSBsZWF2ZSBldmVudHMuXG4gKiBAcHJvcCBvbldlZWtTZWxlY3QgLSBGdW5jdGlvbiB0byBoYW5kbGUgd2VlayBzZWxlY3Rpb24uXG4gKiBAcHJvcCBzZXRQcmVTZWxlY3Rpb24gLSBGdW5jdGlvbiB0byBzZXQgcHJlLXNlbGVjdGlvbi5cbiAqIEBwcm9wIHNldE9wZW4gLSBGdW5jdGlvbiB0byBzZXQgb3BlbiBzdGF0ZS5cbiAqIEBwcm9wIHJlbmRlckRheUNvbnRlbnRzIC0gRnVuY3Rpb24gdG8gcmVuZGVyIGRheSBjb250ZW50cy5cbiAqIEBwcm9wIHJlbmRlck1vbnRoQ29udGVudCAtIEZ1bmN0aW9uIHRvIHJlbmRlciBtb250aCBjb250ZW50LlxuICogQHByb3AgcmVuZGVyUXVhcnRlckNvbnRlbnQgLSBGdW5jdGlvbiB0byByZW5kZXIgcXVhcnRlciBjb250ZW50LlxuICogQHByb3AgaGFuZGxlT25LZXlEb3duIC0gRnVuY3Rpb24gdG8gaGFuZGxlIGtleSBkb3duIGV2ZW50cy5cbiAqIEBwcm9wIGhhbmRsZU9uTW9udGhLZXlEb3duIC0gRnVuY3Rpb24gdG8gaGFuZGxlIGtleSBkb3duIGV2ZW50cyBvbiBhIG1vbnRoLlxuICogQHByb3AgYXJpYUxhYmVsUHJlZml4IC0gQXJpYSBsYWJlbCBwcmVmaXguXG4gKiBAcHJvcCBjaG9vc2VEYXlBcmlhTGFiZWxQcmVmaXggLSBBcmlhIGxhYmVsIHByZWZpeCBmb3IgY2hvb3NpbmcgYSBkYXkuXG4gKiBAcHJvcCBkaXNhYmxlZERheUFyaWFMYWJlbFByZWZpeCAtIEFyaWEgbGFiZWwgcHJlZml4IGZvciBkaXNhYmxlZCBkYXkuXG4gKiBAcHJvcCBkaXNhYmxlZEtleWJvYXJkTmF2aWdhdGlvbiAtIEZsYWcgdG8gZGlzYWJsZSBrZXlib2FyZCBuYXZpZ2F0aW9uLlxuICogQHByb3AgZGF5IC0gVGhlIGRheS5cbiAqIEBwcm9wIGVuZERhdGUgLSBUaGUgZW5kIGRhdGUuXG4gKiBAcHJvcCBvcmRlckluRGlzcGxheSAtIFRoZSBvcmRlciBpbiBkaXNwbGF5LlxuICogQHByb3AgZXhjbHVkZURhdGVzIC0gRGF0ZXMgdG8gZXhjbHVkZS5cbiAqIEBwcm9wIGV4Y2x1ZGVEYXRlSW50ZXJ2YWxzIC0gRGF0ZSBpbnRlcnZhbHMgdG8gZXhjbHVkZS5cbiAqIEBwcm9wIGZpeGVkSGVpZ2h0IC0gRmxhZyB0byBzZXQgZml4ZWQgaGVpZ2h0LlxuICogQHByb3AgaGlnaGxpZ2h0RGF0ZXMgLSBEYXRlcyB0byBoaWdobGlnaHQuXG4gKiBAcHJvcCBob2xpZGF5cyAtIEhvbGlkYXlzLlxuICogQHByb3AgaW5jbHVkZURhdGVzIC0gRGF0ZXMgdG8gaW5jbHVkZS5cbiAqIEBwcm9wIGluY2x1ZGVEYXRlSW50ZXJ2YWxzIC0gRGF0ZSBpbnRlcnZhbHMgdG8gaW5jbHVkZS5cbiAqIEBwcm9wIGlubGluZSAtIEZsYWcgdG8gc2V0IGlubGluZS5cbiAqIEBwcm9wIHNob3VsZEZvY3VzRGF5SW5saW5lIC0gRmxhZyB0byBzZXQgZm9jdXMgb24gZGF5IGlubGluZS5cbiAqIEBwcm9wIGxvY2FsZSAtIFRoZSBsb2NhbGUuXG4gKiBAcHJvcCBtYXhEYXRlIC0gVGhlIG1heGltdW0gZGF0ZS5cbiAqIEBwcm9wIG1pbkRhdGUgLSBUaGUgbWluaW11bSBkYXRlLlxuICogQHByb3AgdXNlUG9pbnRlckV2ZW50IC0gRmxhZyB0byB1c2UgcG9pbnRlciBldmVudC5cbiAqIEBwcm9wIHBlZWtOZXh0TW9udGggLSBGbGFnIHRvIHBlZWsgbmV4dCBtb250aC5cbiAqIEBwcm9wIHByZVNlbGVjdGlvbiAtIFRoZSBwcmUtc2VsZWN0aW9uLlxuICogQHByb3Agc2VsZWN0ZWQgLSBUaGUgc2VsZWN0ZWQgZGF0ZS5cbiAqIEBwcm9wIHNlbGVjdGluZ0RhdGUgLSBUaGUgc2VsZWN0aW5nIGRhdGUuXG4gKiBAcHJvcCBjYWxlbmRhclN0YXJ0RGF5IC0gVGhlIGNhbGVuZGFyIHN0YXJ0IGRheS5cbiAqIEBwcm9wIHNlbGVjdHNFbmQgLSBGbGFnIHRvIHNlbGVjdCBlbmQuXG4gKiBAcHJvcCBzZWxlY3RzU3RhcnQgLSBGbGFnIHRvIHNlbGVjdCBzdGFydC5cbiAqIEBwcm9wIHNlbGVjdHNSYW5nZSAtIEZsYWcgdG8gc2VsZWN0IHJhbmdlLlxuICogQHByb3Agc2VsZWN0c0Rpc2FibGVkRGF5c0luUmFuZ2UgLSBGbGFnIHRvIHNlbGVjdCBkaXNhYmxlZCBkYXlzIGluIHJhbmdlLlxuICogQHByb3Agc2VsZWN0c011bHRpcGxlIC0gRmxhZyB0byBzZWxlY3QgbXVsdGlwbGUuXG4gKiBAcHJvcCBzZWxlY3RlZERhdGVzIC0gVGhlIHNlbGVjdGVkIGRhdGVzLlxuICogQHByb3Agc2hvd1dlZWtOdW1iZXJzIC0gRmxhZyB0byBzaG93IHdlZWsgbnVtYmVycy5cbiAqIEBwcm9wIHN0YXJ0RGF0ZSAtIFRoZSBzdGFydCBkYXRlLlxuICogQHByb3Agc2hvdWxkQ2xvc2VPblNlbGVjdCAtIEZsYWcgdG8gY2xvc2Ugb24gc2VsZWN0LlxuICogQHByb3Agc2hvd01vbnRoWWVhclBpY2tlciAtIEZsYWcgdG8gc2hvdyBtb250aCB5ZWFyIHBpY2tlci5cbiAqIEBwcm9wIHNob3dGdWxsTW9udGhZZWFyUGlja2VyIC0gRmxhZyB0byBzaG93IGZ1bGwgbW9udGggeWVhciBwaWNrZXIuXG4gKiBAcHJvcCBzaG93VHdvQ29sdW1uTW9udGhZZWFyUGlja2VyIC0gRmxhZyB0byBzaG93IHR3byBjb2x1bW4gbW9udGggeWVhciBwaWNrZXIuXG4gKiBAcHJvcCBzaG93Rm91ckNvbHVtbk1vbnRoWWVhclBpY2tlciAtIEZsYWcgdG8gc2hvdyBmb3VyIGNvbHVtbiBtb250aCB5ZWFyIHBpY2tlci5cbiAqIEBwcm9wIHNob3dRdWFydGVyWWVhclBpY2tlciAtIEZsYWcgdG8gc2hvdyBxdWFydGVyIHllYXIgcGlja2VyLlxuICogQHByb3Agc2hvd1dlZWtQaWNrZXIgLSBGbGFnIHRvIHNob3cgd2VlayBwaWNrZXIuXG4gKiBAcHJvcCBpc0lucHV0Rm9jdXNlZCAtIEZsYWcgdG8gc2V0IGlucHV0IGZvY3VzLlxuICogQHByb3Agd2Vla0FyaWFMYWJlbFByZWZpeCAtIEFyaWEgbGFiZWwgcHJlZml4IGZvciB3ZWVrLlxuICogQHByb3AgY29udGFpbmVyUmVmIC0gVGhlIGNvbnRhaW5lciByZWZlcmVuY2UuXG4gKiBAcHJvcCBtb250aFNob3dzRHVwbGljYXRlRGF5c0VuZCAtIEZsYWcgdG8gc2hvdyBkdXBsaWNhdGUgZGF5cyBhdCB0aGUgZW5kIG9mIHRoZSBtb250aC5cbiAqIEBwcm9wIG1vbnRoU2hvd3NEdXBsaWNhdGVEYXlzU3RhcnQgLSBGbGFnIHRvIHNob3cgZHVwbGljYXRlIGRheXMgYXQgdGhlIHN0YXJ0IG9mIHRoZSBtb250aC5cbiAqXG4gKiBAZXhhbXBsZVxuICogYGBgdHN4XG4gKiBmdW5jdGlvbiBBcHAoKSB7XG4gKiAgY29uc3QgaGFuZGxlRGF5Q2xpY2sgPSAoZGF0ZSkgPT4ge1xuICogICAgIGNvbnNvbGUubG9nKCdEYXkgY2xpY2tlZDogJywgZGF0ZSk7XG4gKiAgIH07XG4gKlxuICogICBjb25zdCBoYW5kbGVEYXlNb3VzZUVudGVyID0gKGRhdGUpID0+IHtcbiAqICAgICBjb25zb2xlLmxvZygnTW91c2UgZW50ZXJlZCBvbiBkYXk6ICcsIGRhdGUpO1xuICogICB9O1xuICpcbiAqICAgcmV0dXJuIChcbiAqICAgICA8ZGl2PlxuICogICAgICAgPE1vbnRoXG4gKiAgICAgICAgIGRheT17bmV3IERhdGUoKX1cbiAqICAgICAgICAgZW5kRGF0ZT17bmV3IERhdGUoKX1cbiAqICAgICAgICAgb25EYXlDbGljaz17aGFuZGxlRGF5Q2xpY2t9XG4gKiAgICAgICAgIG9uRGF5TW91c2VFbnRlcj17aGFuZGxlRGF5TW91c2VFbnRlcn1cbiAqICAgICAgICAgZGlzYWJsZWRLZXlib2FyZE5hdmlnYXRpb249e2ZhbHNlfVxuICogICAgICAgICBzaG93V2Vla051bWJlcnM9e3RydWV9XG4gKiAgICAgICAgIHNob3dNb250aFllYXJQaWNrZXI9e2ZhbHNlfVxuICogICAgICAgLz5cbiAqICAgICA8L2Rpdj5cbiAqICAgKTtcbiAqIH1cbiAqIGBgYFxuICovXG52YXIgTW9udGggPSAvKiogQGNsYXNzICovIChmdW5jdGlvbiAoX3N1cGVyKSB7XG4gICAgX19leHRlbmRzKE1vbnRoLCBfc3VwZXIpO1xuICAgIGZ1bmN0aW9uIE1vbnRoKCkge1xuICAgICAgICB2YXIgX3RoaXMgPSBfc3VwZXIgIT09IG51bGwgJiYgX3N1cGVyLmFwcGx5KHRoaXMsIGFyZ3VtZW50cykgfHwgdGhpcztcbiAgICAgICAgX3RoaXMuTU9OVEhfUkVGUyA9IF9fc3ByZWFkQXJyYXkoW10sIEFycmF5KDEyKSwgdHJ1ZSkubWFwKGZ1bmN0aW9uICgpIHsgcmV0dXJuIGNyZWF0ZVJlZigpOyB9KTtcbiAgICAgICAgX3RoaXMuUVVBUlRFUl9SRUZTID0gX19zcHJlYWRBcnJheShbXSwgQXJyYXkoNCksIHRydWUpLm1hcChmdW5jdGlvbiAoKSB7IHJldHVybiBjcmVhdGVSZWYoKTsgfSk7XG4gICAgICAgIF90aGlzLmlzRGlzYWJsZWQgPSBmdW5jdGlvbiAoZGF5KSB7XG4gICAgICAgICAgICAvLyBBbG1vc3QgYWxsIHByb3BzIHByZXZpb3VzbHkgd2VyZSBwYXNzZWQgYXMgdGhpcy5wcm9wcyB3L28gcHJvcGVyIHR5cGluZyB3aXRoIHByb3AtdHlwZXNcbiAgICAgICAgICAgIC8vIGFmdGVyIHRoZSBtaWdyYXRpb24gdG8gVFMgaSBtYWRlIGl0IGV4cGxpY2l0XG4gICAgICAgICAgICByZXR1cm4gaXNEYXlEaXNhYmxlZChkYXksIHtcbiAgICAgICAgICAgICAgICBtaW5EYXRlOiBfdGhpcy5wcm9wcy5taW5EYXRlLFxuICAgICAgICAgICAgICAgIG1heERhdGU6IF90aGlzLnByb3BzLm1heERhdGUsXG4gICAgICAgICAgICAgICAgZXhjbHVkZURhdGVzOiBfdGhpcy5wcm9wcy5leGNsdWRlRGF0ZXMsXG4gICAgICAgICAgICAgICAgZXhjbHVkZURhdGVJbnRlcnZhbHM6IF90aGlzLnByb3BzLmV4Y2x1ZGVEYXRlSW50ZXJ2YWxzLFxuICAgICAgICAgICAgICAgIGluY2x1ZGVEYXRlSW50ZXJ2YWxzOiBfdGhpcy5wcm9wcy5pbmNsdWRlRGF0ZUludGVydmFscyxcbiAgICAgICAgICAgICAgICBpbmNsdWRlRGF0ZXM6IF90aGlzLnByb3BzLmluY2x1ZGVEYXRlcyxcbiAgICAgICAgICAgICAgICBmaWx0ZXJEYXRlOiBfdGhpcy5wcm9wcy5maWx0ZXJEYXRlLFxuICAgICAgICAgICAgICAgIGRpc2FibGVkOiBfdGhpcy5wcm9wcy5kaXNhYmxlZCxcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9O1xuICAgICAgICBfdGhpcy5pc0V4Y2x1ZGVkID0gZnVuY3Rpb24gKGRheSkge1xuICAgICAgICAgICAgLy8gQWxtb3N0IGFsbCBwcm9wcyBwcmV2aW91c2x5IHdlcmUgcGFzc2VkIGFzIHRoaXMucHJvcHMgdy9vIHByb3BlciB0eXBpbmcgd2l0aCBwcm9wLXR5cGVzXG4gICAgICAgICAgICAvLyBhZnRlciB0aGUgbWlncmF0aW9uIHRvIFRTIGkgbWFkZSBpdCBleHBsaWNpdFxuICAgICAgICAgICAgcmV0dXJuIGlzRGF5RXhjbHVkZWQoZGF5LCB7XG4gICAgICAgICAgICAgICAgZXhjbHVkZURhdGVzOiBfdGhpcy5wcm9wcy5leGNsdWRlRGF0ZXMsXG4gICAgICAgICAgICAgICAgZXhjbHVkZURhdGVJbnRlcnZhbHM6IF90aGlzLnByb3BzLmV4Y2x1ZGVEYXRlSW50ZXJ2YWxzLFxuICAgICAgICAgICAgfSk7XG4gICAgICAgIH07XG4gICAgICAgIF90aGlzLmhhbmRsZURheUNsaWNrID0gZnVuY3Rpb24gKGRheSwgZXZlbnQpIHtcbiAgICAgICAgICAgIHZhciBfYSwgX2I7XG4gICAgICAgICAgICAoX2IgPSAoX2EgPSBfdGhpcy5wcm9wcykub25EYXlDbGljaykgPT09IG51bGwgfHwgX2IgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9iLmNhbGwoX2EsIGRheSwgZXZlbnQsIF90aGlzLnByb3BzLm9yZGVySW5EaXNwbGF5KTtcbiAgICAgICAgfTtcbiAgICAgICAgX3RoaXMuaGFuZGxlRGF5TW91c2VFbnRlciA9IGZ1bmN0aW9uIChkYXkpIHtcbiAgICAgICAgICAgIHZhciBfYSwgX2I7XG4gICAgICAgICAgICAoX2IgPSAoX2EgPSBfdGhpcy5wcm9wcykub25EYXlNb3VzZUVudGVyKSA9PT0gbnVsbCB8fCBfYiA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2IuY2FsbChfYSwgZGF5KTtcbiAgICAgICAgfTtcbiAgICAgICAgX3RoaXMuaGFuZGxlTW91c2VMZWF2ZSA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIHZhciBfYSwgX2I7XG4gICAgICAgICAgICAoX2IgPSAoX2EgPSBfdGhpcy5wcm9wcykub25Nb3VzZUxlYXZlKSA9PT0gbnVsbCB8fCBfYiA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2IuY2FsbChfYSk7XG4gICAgICAgIH07XG4gICAgICAgIF90aGlzLmlzUmFuZ2VTdGFydE1vbnRoID0gZnVuY3Rpb24gKG0pIHtcbiAgICAgICAgICAgIHZhciBfYSA9IF90aGlzLnByb3BzLCBkYXkgPSBfYS5kYXksIHN0YXJ0RGF0ZSA9IF9hLnN0YXJ0RGF0ZSwgZW5kRGF0ZSA9IF9hLmVuZERhdGU7XG4gICAgICAgICAgICBpZiAoIXN0YXJ0RGF0ZSB8fCAhZW5kRGF0ZSkge1xuICAgICAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiBpc1NhbWVNb250aChzZXRNb250aChkYXksIG0pLCBzdGFydERhdGUpO1xuICAgICAgICB9O1xuICAgICAgICBfdGhpcy5pc1JhbmdlU3RhcnRRdWFydGVyID0gZnVuY3Rpb24gKHEpIHtcbiAgICAgICAgICAgIHZhciBfYSA9IF90aGlzLnByb3BzLCBkYXkgPSBfYS5kYXksIHN0YXJ0RGF0ZSA9IF9hLnN0YXJ0RGF0ZSwgZW5kRGF0ZSA9IF9hLmVuZERhdGU7XG4gICAgICAgICAgICBpZiAoIXN0YXJ0RGF0ZSB8fCAhZW5kRGF0ZSkge1xuICAgICAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiBpc1NhbWVRdWFydGVyKHNldFF1YXJ0ZXIoZGF5LCBxKSwgc3RhcnREYXRlKTtcbiAgICAgICAgfTtcbiAgICAgICAgX3RoaXMuaXNSYW5nZUVuZE1vbnRoID0gZnVuY3Rpb24gKG0pIHtcbiAgICAgICAgICAgIHZhciBfYSA9IF90aGlzLnByb3BzLCBkYXkgPSBfYS5kYXksIHN0YXJ0RGF0ZSA9IF9hLnN0YXJ0RGF0ZSwgZW5kRGF0ZSA9IF9hLmVuZERhdGU7XG4gICAgICAgICAgICBpZiAoIXN0YXJ0RGF0ZSB8fCAhZW5kRGF0ZSkge1xuICAgICAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiBpc1NhbWVNb250aChzZXRNb250aChkYXksIG0pLCBlbmREYXRlKTtcbiAgICAgICAgfTtcbiAgICAgICAgX3RoaXMuaXNSYW5nZUVuZFF1YXJ0ZXIgPSBmdW5jdGlvbiAocSkge1xuICAgICAgICAgICAgdmFyIF9hID0gX3RoaXMucHJvcHMsIGRheSA9IF9hLmRheSwgc3RhcnREYXRlID0gX2Euc3RhcnREYXRlLCBlbmREYXRlID0gX2EuZW5kRGF0ZTtcbiAgICAgICAgICAgIGlmICghc3RhcnREYXRlIHx8ICFlbmREYXRlKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIGlzU2FtZVF1YXJ0ZXIoc2V0UXVhcnRlcihkYXksIHEpLCBlbmREYXRlKTtcbiAgICAgICAgfTtcbiAgICAgICAgX3RoaXMuaXNJblNlbGVjdGluZ1JhbmdlTW9udGggPSBmdW5jdGlvbiAobSkge1xuICAgICAgICAgICAgdmFyIF9hO1xuICAgICAgICAgICAgdmFyIF9iID0gX3RoaXMucHJvcHMsIGRheSA9IF9iLmRheSwgc2VsZWN0c1N0YXJ0ID0gX2Iuc2VsZWN0c1N0YXJ0LCBzZWxlY3RzRW5kID0gX2Iuc2VsZWN0c0VuZCwgc2VsZWN0c1JhbmdlID0gX2Iuc2VsZWN0c1JhbmdlLCBzdGFydERhdGUgPSBfYi5zdGFydERhdGUsIGVuZERhdGUgPSBfYi5lbmREYXRlO1xuICAgICAgICAgICAgdmFyIHNlbGVjdGluZ0RhdGUgPSAoX2EgPSBfdGhpcy5wcm9wcy5zZWxlY3RpbmdEYXRlKSAhPT0gbnVsbCAmJiBfYSAhPT0gdm9pZCAwID8gX2EgOiBfdGhpcy5wcm9wcy5wcmVTZWxlY3Rpb247XG4gICAgICAgICAgICBpZiAoIShzZWxlY3RzU3RhcnQgfHwgc2VsZWN0c0VuZCB8fCBzZWxlY3RzUmFuZ2UpIHx8ICFzZWxlY3RpbmdEYXRlKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKHNlbGVjdHNTdGFydCAmJiBlbmREYXRlKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGlzTW9udGhJblJhbmdlKHNlbGVjdGluZ0RhdGUsIGVuZERhdGUsIG0sIGRheSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoc2VsZWN0c0VuZCAmJiBzdGFydERhdGUpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gaXNNb250aEluUmFuZ2Uoc3RhcnREYXRlLCBzZWxlY3RpbmdEYXRlLCBtLCBkYXkpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKHNlbGVjdHNSYW5nZSAmJiBzdGFydERhdGUgJiYgIWVuZERhdGUpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gaXNNb250aEluUmFuZ2Uoc3RhcnREYXRlLCBzZWxlY3RpbmdEYXRlLCBtLCBkYXkpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICB9O1xuICAgICAgICBfdGhpcy5pc1NlbGVjdGluZ01vbnRoUmFuZ2VTdGFydCA9IGZ1bmN0aW9uIChtKSB7XG4gICAgICAgICAgICB2YXIgX2E7XG4gICAgICAgICAgICBpZiAoIV90aGlzLmlzSW5TZWxlY3RpbmdSYW5nZU1vbnRoKG0pKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdmFyIF9iID0gX3RoaXMucHJvcHMsIGRheSA9IF9iLmRheSwgc3RhcnREYXRlID0gX2Iuc3RhcnREYXRlLCBzZWxlY3RzU3RhcnQgPSBfYi5zZWxlY3RzU3RhcnQ7XG4gICAgICAgICAgICB2YXIgX21vbnRoID0gc2V0TW9udGgoZGF5LCBtKTtcbiAgICAgICAgICAgIHZhciBzZWxlY3RpbmdEYXRlID0gKF9hID0gX3RoaXMucHJvcHMuc2VsZWN0aW5nRGF0ZSkgIT09IG51bGwgJiYgX2EgIT09IHZvaWQgMCA/IF9hIDogX3RoaXMucHJvcHMucHJlU2VsZWN0aW9uO1xuICAgICAgICAgICAgaWYgKHNlbGVjdHNTdGFydCkge1xuICAgICAgICAgICAgICAgIHJldHVybiBpc1NhbWVNb250aChfbW9udGgsIHNlbGVjdGluZ0RhdGUpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGlzU2FtZU1vbnRoKF9tb250aCwgc3RhcnREYXRlKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfTtcbiAgICAgICAgX3RoaXMuaXNTZWxlY3RpbmdNb250aFJhbmdlRW5kID0gZnVuY3Rpb24gKG0pIHtcbiAgICAgICAgICAgIHZhciBfYTtcbiAgICAgICAgICAgIGlmICghX3RoaXMuaXNJblNlbGVjdGluZ1JhbmdlTW9udGgobSkpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB2YXIgX2IgPSBfdGhpcy5wcm9wcywgZGF5ID0gX2IuZGF5LCBlbmREYXRlID0gX2IuZW5kRGF0ZSwgc2VsZWN0c0VuZCA9IF9iLnNlbGVjdHNFbmQsIHNlbGVjdHNSYW5nZSA9IF9iLnNlbGVjdHNSYW5nZTtcbiAgICAgICAgICAgIHZhciBfbW9udGggPSBzZXRNb250aChkYXksIG0pO1xuICAgICAgICAgICAgdmFyIHNlbGVjdGluZ0RhdGUgPSAoX2EgPSBfdGhpcy5wcm9wcy5zZWxlY3RpbmdEYXRlKSAhPT0gbnVsbCAmJiBfYSAhPT0gdm9pZCAwID8gX2EgOiBfdGhpcy5wcm9wcy5wcmVTZWxlY3Rpb247XG4gICAgICAgICAgICBpZiAoc2VsZWN0c0VuZCB8fCBzZWxlY3RzUmFuZ2UpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gaXNTYW1lTW9udGgoX21vbnRoLCBzZWxlY3RpbmdEYXRlKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIHJldHVybiBpc1NhbWVNb250aChfbW9udGgsIGVuZERhdGUpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9O1xuICAgICAgICBfdGhpcy5pc0luU2VsZWN0aW5nUmFuZ2VRdWFydGVyID0gZnVuY3Rpb24gKHEpIHtcbiAgICAgICAgICAgIHZhciBfYTtcbiAgICAgICAgICAgIHZhciBfYiA9IF90aGlzLnByb3BzLCBkYXkgPSBfYi5kYXksIHNlbGVjdHNTdGFydCA9IF9iLnNlbGVjdHNTdGFydCwgc2VsZWN0c0VuZCA9IF9iLnNlbGVjdHNFbmQsIHNlbGVjdHNSYW5nZSA9IF9iLnNlbGVjdHNSYW5nZSwgc3RhcnREYXRlID0gX2Iuc3RhcnREYXRlLCBlbmREYXRlID0gX2IuZW5kRGF0ZTtcbiAgICAgICAgICAgIHZhciBzZWxlY3RpbmdEYXRlID0gKF9hID0gX3RoaXMucHJvcHMuc2VsZWN0aW5nRGF0ZSkgIT09IG51bGwgJiYgX2EgIT09IHZvaWQgMCA/IF9hIDogX3RoaXMucHJvcHMucHJlU2VsZWN0aW9uO1xuICAgICAgICAgICAgaWYgKCEoc2VsZWN0c1N0YXJ0IHx8IHNlbGVjdHNFbmQgfHwgc2VsZWN0c1JhbmdlKSB8fCAhc2VsZWN0aW5nRGF0ZSkge1xuICAgICAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChzZWxlY3RzU3RhcnQgJiYgZW5kRGF0ZSkge1xuICAgICAgICAgICAgICAgIHJldHVybiBpc1F1YXJ0ZXJJblJhbmdlKHNlbGVjdGluZ0RhdGUsIGVuZERhdGUsIHEsIGRheSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoc2VsZWN0c0VuZCAmJiBzdGFydERhdGUpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gaXNRdWFydGVySW5SYW5nZShzdGFydERhdGUsIHNlbGVjdGluZ0RhdGUsIHEsIGRheSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoc2VsZWN0c1JhbmdlICYmIHN0YXJ0RGF0ZSAmJiAhZW5kRGF0ZSkge1xuICAgICAgICAgICAgICAgIHJldHVybiBpc1F1YXJ0ZXJJblJhbmdlKHN0YXJ0RGF0ZSwgc2VsZWN0aW5nRGF0ZSwgcSwgZGF5KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgfTtcbiAgICAgICAgX3RoaXMuaXNXZWVrSW5Nb250aCA9IGZ1bmN0aW9uIChzdGFydE9mV2Vlaykge1xuICAgICAgICAgICAgdmFyIGRheSA9IF90aGlzLnByb3BzLmRheTtcbiAgICAgICAgICAgIHZhciBlbmRPZldlZWsgPSBhZGREYXlzKHN0YXJ0T2ZXZWVrLCA2KTtcbiAgICAgICAgICAgIHJldHVybiBpc1NhbWVNb250aChzdGFydE9mV2VlaywgZGF5KSB8fCBpc1NhbWVNb250aChlbmRPZldlZWssIGRheSk7XG4gICAgICAgIH07XG4gICAgICAgIF90aGlzLmlzQ3VycmVudE1vbnRoID0gZnVuY3Rpb24gKGRheSwgbSkge1xuICAgICAgICAgICAgcmV0dXJuIGdldFllYXIoZGF5KSA9PT0gZ2V0WWVhcihuZXdEYXRlKCkpICYmIG0gPT09IGdldE1vbnRoKG5ld0RhdGUoKSk7XG4gICAgICAgIH07XG4gICAgICAgIF90aGlzLmlzQ3VycmVudFF1YXJ0ZXIgPSBmdW5jdGlvbiAoZGF5LCBxKSB7XG4gICAgICAgICAgICByZXR1cm4gZ2V0WWVhcihkYXkpID09PSBnZXRZZWFyKG5ld0RhdGUoKSkgJiYgcSA9PT0gZ2V0UXVhcnRlcihuZXdEYXRlKCkpO1xuICAgICAgICB9O1xuICAgICAgICBfdGhpcy5pc1NlbGVjdGVkTW9udGggPSBmdW5jdGlvbiAoZGF5LCBtLCBzZWxlY3RlZCkge1xuICAgICAgICAgICAgcmV0dXJuIGdldE1vbnRoKHNlbGVjdGVkKSA9PT0gbSAmJiBnZXRZZWFyKGRheSkgPT09IGdldFllYXIoc2VsZWN0ZWQpO1xuICAgICAgICB9O1xuICAgICAgICBfdGhpcy5pc1NlbGVjdE1vbnRoSW5MaXN0ID0gZnVuY3Rpb24gKGRheSwgbSwgc2VsZWN0ZWREYXRlcykge1xuICAgICAgICAgICAgcmV0dXJuIHNlbGVjdGVkRGF0ZXMuc29tZShmdW5jdGlvbiAoc2VsZWN0ZWREYXRlKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIF90aGlzLmlzU2VsZWN0ZWRNb250aChkYXksIG0sIHNlbGVjdGVkRGF0ZSk7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfTtcbiAgICAgICAgX3RoaXMuaXNTZWxlY3RlZFF1YXJ0ZXIgPSBmdW5jdGlvbiAoZGF5LCBxLCBzZWxlY3RlZCkge1xuICAgICAgICAgICAgcmV0dXJuIGdldFF1YXJ0ZXIoc2VsZWN0ZWQpID09PSBxICYmIGdldFllYXIoZGF5KSA9PT0gZ2V0WWVhcihzZWxlY3RlZCk7XG4gICAgICAgIH07XG4gICAgICAgIF90aGlzLmlzU2VsZWN0UXVhcnRlckluTGlzdCA9IGZ1bmN0aW9uIChkYXksIHEsIHNlbGVjdGVkRGF0ZXMpIHtcbiAgICAgICAgICAgIHJldHVybiBzZWxlY3RlZERhdGVzLnNvbWUoZnVuY3Rpb24gKHNlbGVjdGVkRGF0ZSkge1xuICAgICAgICAgICAgICAgIHJldHVybiBfdGhpcy5pc1NlbGVjdGVkUXVhcnRlcihkYXksIHEsIHNlbGVjdGVkRGF0ZSk7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfTtcbiAgICAgICAgX3RoaXMuaXNNb250aFNlbGVjdGVkID0gZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgdmFyIF9hID0gX3RoaXMucHJvcHMsIGRheSA9IF9hLmRheSwgc2VsZWN0ZWQgPSBfYS5zZWxlY3RlZCwgc2VsZWN0ZWREYXRlcyA9IF9hLnNlbGVjdGVkRGF0ZXMsIHNlbGVjdHNNdWx0aXBsZSA9IF9hLnNlbGVjdHNNdWx0aXBsZTtcbiAgICAgICAgICAgIHZhciBtb250aElkeCA9IGdldE1vbnRoKGRheSk7XG4gICAgICAgICAgICBpZiAoc2VsZWN0c011bHRpcGxlKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHNlbGVjdGVkRGF0ZXMgPT09IG51bGwgfHwgc2VsZWN0ZWREYXRlcyA9PT0gdm9pZCAwID8gdm9pZCAwIDogc2VsZWN0ZWREYXRlcy5zb21lKGZ1bmN0aW9uIChkYXRlKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBfdGhpcy5pc1NlbGVjdGVkTW9udGgoZGF5LCBtb250aElkeCwgZGF0ZSk7XG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gISFzZWxlY3RlZCAmJiBfdGhpcy5pc1NlbGVjdGVkTW9udGgoZGF5LCBtb250aElkeCwgc2VsZWN0ZWQpO1xuICAgICAgICB9O1xuICAgICAgICBfdGhpcy5pc1F1YXJ0ZXJTZWxlY3RlZCA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIHZhciBfYSA9IF90aGlzLnByb3BzLCBkYXkgPSBfYS5kYXksIHNlbGVjdGVkID0gX2Euc2VsZWN0ZWQsIHNlbGVjdGVkRGF0ZXMgPSBfYS5zZWxlY3RlZERhdGVzLCBzZWxlY3RzTXVsdGlwbGUgPSBfYS5zZWxlY3RzTXVsdGlwbGU7XG4gICAgICAgICAgICB2YXIgcXVhcnRlcklkeCA9IGdldFF1YXJ0ZXIoZGF5KTtcbiAgICAgICAgICAgIGlmIChzZWxlY3RzTXVsdGlwbGUpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gc2VsZWN0ZWREYXRlcyA9PT0gbnVsbCB8fCBzZWxlY3RlZERhdGVzID09PSB2b2lkIDAgPyB2b2lkIDAgOiBzZWxlY3RlZERhdGVzLnNvbWUoZnVuY3Rpb24gKHNlbGVjdGVkRGF0ZSkge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gX3RoaXMuaXNTZWxlY3RlZFF1YXJ0ZXIoZGF5LCBxdWFydGVySWR4LCBzZWxlY3RlZERhdGUpO1xuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuICEhc2VsZWN0ZWQgJiYgX3RoaXMuaXNTZWxlY3RlZFF1YXJ0ZXIoZGF5LCBxdWFydGVySWR4LCBzZWxlY3RlZCk7XG4gICAgICAgIH07XG4gICAgICAgIF90aGlzLnJlbmRlcldlZWtzID0gZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgLy8gUmV0dXJuIGVtcHR5IGFycmF5IGlmIGRheSBpcyBpbnZhbGlkXG4gICAgICAgICAgICBpZiAoIWlzVmFsaWQoX3RoaXMucHJvcHMuZGF5KSkge1xuICAgICAgICAgICAgICAgIHJldHVybiBbXTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHZhciB3ZWVrcyA9IFtdO1xuICAgICAgICAgICAgdmFyIGlzRml4ZWRIZWlnaHQgPSBfdGhpcy5wcm9wcy5maXhlZEhlaWdodDtcbiAgICAgICAgICAgIHZhciBpID0gMDtcbiAgICAgICAgICAgIHZhciBicmVha0FmdGVyTmV4dFB1c2ggPSBmYWxzZTtcbiAgICAgICAgICAgIHZhciBjdXJyZW50V2Vla1N0YXJ0ID0gZ2V0U3RhcnRPZldlZWsoZ2V0U3RhcnRPZk1vbnRoKF90aGlzLnByb3BzLmRheSksIF90aGlzLnByb3BzLmxvY2FsZSwgX3RoaXMucHJvcHMuY2FsZW5kYXJTdGFydERheSk7XG4gICAgICAgICAgICB2YXIgaXNQcmVTZWxlY3RlZCA9IGZ1bmN0aW9uIChwcmVTZWxlY3Rpb24pIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gX3RoaXMucHJvcHMuc2hvd1dlZWtQaWNrZXJcbiAgICAgICAgICAgICAgICAgICAgPyBnZXRTdGFydE9mV2VlayhwcmVTZWxlY3Rpb24sIF90aGlzLnByb3BzLmxvY2FsZSwgX3RoaXMucHJvcHMuY2FsZW5kYXJTdGFydERheSlcbiAgICAgICAgICAgICAgICAgICAgOiBfdGhpcy5wcm9wcy5wcmVTZWxlY3Rpb247XG4gICAgICAgICAgICB9O1xuICAgICAgICAgICAgdmFyIGlzU2VsZWN0ZWQgPSBmdW5jdGlvbiAoc2VsZWN0ZWQpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gX3RoaXMucHJvcHMuc2hvd1dlZWtQaWNrZXJcbiAgICAgICAgICAgICAgICAgICAgPyBnZXRTdGFydE9mV2VlayhzZWxlY3RlZCwgX3RoaXMucHJvcHMubG9jYWxlLCBfdGhpcy5wcm9wcy5jYWxlbmRhclN0YXJ0RGF5KVxuICAgICAgICAgICAgICAgICAgICA6IF90aGlzLnByb3BzLnNlbGVjdGVkO1xuICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIHZhciBzZWxlY3RlZCA9IF90aGlzLnByb3BzLnNlbGVjdGVkXG4gICAgICAgICAgICAgICAgPyBpc1NlbGVjdGVkKF90aGlzLnByb3BzLnNlbGVjdGVkKVxuICAgICAgICAgICAgICAgIDogdW5kZWZpbmVkO1xuICAgICAgICAgICAgdmFyIHByZVNlbGVjdGlvbiA9IF90aGlzLnByb3BzLnByZVNlbGVjdGlvblxuICAgICAgICAgICAgICAgID8gaXNQcmVTZWxlY3RlZChfdGhpcy5wcm9wcy5wcmVTZWxlY3Rpb24pXG4gICAgICAgICAgICAgICAgOiB1bmRlZmluZWQ7XG4gICAgICAgICAgICB3aGlsZSAodHJ1ZSkge1xuICAgICAgICAgICAgICAgIHdlZWtzLnB1c2goUmVhY3QuY3JlYXRlRWxlbWVudChXZWVrLCBfYXNzaWduKHt9LCBfdGhpcy5wcm9wcywgeyBhcmlhTGFiZWxQcmVmaXg6IF90aGlzLnByb3BzLndlZWtBcmlhTGFiZWxQcmVmaXgsIGtleTogaSwgZGF5OiBjdXJyZW50V2Vla1N0YXJ0LCBtb250aDogZ2V0TW9udGgoX3RoaXMucHJvcHMuZGF5KSwgb25EYXlDbGljazogX3RoaXMuaGFuZGxlRGF5Q2xpY2ssIG9uRGF5TW91c2VFbnRlcjogX3RoaXMuaGFuZGxlRGF5TW91c2VFbnRlciwgc2VsZWN0ZWQ6IHNlbGVjdGVkLCBwcmVTZWxlY3Rpb246IHByZVNlbGVjdGlvbiwgc2hvd1dlZWtOdW1iZXI6IF90aGlzLnByb3BzLnNob3dXZWVrTnVtYmVycyB9KSkpO1xuICAgICAgICAgICAgICAgIGlmIChicmVha0FmdGVyTmV4dFB1c2gpXG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIGkrKztcbiAgICAgICAgICAgICAgICBjdXJyZW50V2Vla1N0YXJ0ID0gYWRkV2Vla3MoY3VycmVudFdlZWtTdGFydCwgMSk7XG4gICAgICAgICAgICAgICAgLy8gSWYgb25lIG9mIHRoZXNlIGNvbmRpdGlvbnMgaXMgdHJ1ZSwgd2Ugd2lsbCBlaXRoZXIgYnJlYWsgb24gdGhpcyB3ZWVrXG4gICAgICAgICAgICAgICAgLy8gb3IgYnJlYWsgb24gdGhlIG5leHQgd2Vla1xuICAgICAgICAgICAgICAgIHZhciBpc0ZpeGVkQW5kRmluYWxXZWVrID0gaXNGaXhlZEhlaWdodCAmJiBpID49IEZJWEVEX0hFSUdIVF9TVEFOREFSRF9XRUVLX0NPVU5UO1xuICAgICAgICAgICAgICAgIHZhciBpc05vbkZpeGVkQW5kT3V0T2ZNb250aCA9ICFpc0ZpeGVkSGVpZ2h0ICYmICFfdGhpcy5pc1dlZWtJbk1vbnRoKGN1cnJlbnRXZWVrU3RhcnQpO1xuICAgICAgICAgICAgICAgIGlmIChpc0ZpeGVkQW5kRmluYWxXZWVrIHx8IGlzTm9uRml4ZWRBbmRPdXRPZk1vbnRoKSB7XG4gICAgICAgICAgICAgICAgICAgIGlmIChfdGhpcy5wcm9wcy5wZWVrTmV4dE1vbnRoKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBicmVha0FmdGVyTmV4dFB1c2ggPSB0cnVlO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gd2Vla3M7XG4gICAgICAgIH07XG4gICAgICAgIF90aGlzLm9uTW9udGhDbGljayA9IGZ1bmN0aW9uIChldmVudCwgbSkge1xuICAgICAgICAgICAgdmFyIF9hID0gX3RoaXMuaXNNb250aERpc2FibGVkRm9yTGFiZWxEYXRlKG0pLCBpc0Rpc2FibGVkID0gX2EuaXNEaXNhYmxlZCwgbGFiZWxEYXRlID0gX2EubGFiZWxEYXRlO1xuICAgICAgICAgICAgaWYgKGlzRGlzYWJsZWQpIHtcbiAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBfdGhpcy5oYW5kbGVEYXlDbGljayhnZXRTdGFydE9mTW9udGgobGFiZWxEYXRlKSwgZXZlbnQpO1xuICAgICAgICB9O1xuICAgICAgICBfdGhpcy5vbk1vbnRoTW91c2VFbnRlciA9IGZ1bmN0aW9uIChtKSB7XG4gICAgICAgICAgICB2YXIgX2EgPSBfdGhpcy5pc01vbnRoRGlzYWJsZWRGb3JMYWJlbERhdGUobSksIGlzRGlzYWJsZWQgPSBfYS5pc0Rpc2FibGVkLCBsYWJlbERhdGUgPSBfYS5sYWJlbERhdGU7XG4gICAgICAgICAgICBpZiAoaXNEaXNhYmxlZCkge1xuICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIF90aGlzLmhhbmRsZURheU1vdXNlRW50ZXIoZ2V0U3RhcnRPZk1vbnRoKGxhYmVsRGF0ZSkpO1xuICAgICAgICB9O1xuICAgICAgICBfdGhpcy5oYW5kbGVNb250aE5hdmlnYXRpb24gPSBmdW5jdGlvbiAobmV3TW9udGgsIG5ld0RhdGUpIHtcbiAgICAgICAgICAgIHZhciBfYSwgX2IsIF9jLCBfZDtcbiAgICAgICAgICAgIChfYiA9IChfYSA9IF90aGlzLnByb3BzKS5zZXRQcmVTZWxlY3Rpb24pID09PSBudWxsIHx8IF9iID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYi5jYWxsKF9hLCBuZXdEYXRlKTtcbiAgICAgICAgICAgIChfZCA9IChfYyA9IF90aGlzLk1PTlRIX1JFRlNbbmV3TW9udGhdKSA9PT0gbnVsbCB8fCBfYyA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2MuY3VycmVudCkgPT09IG51bGwgfHwgX2QgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9kLmZvY3VzKCk7XG4gICAgICAgIH07XG4gICAgICAgIF90aGlzLmhhbmRsZUtleWJvYXJkTmF2aWdhdGlvbiA9IGZ1bmN0aW9uIChldmVudCwgZXZlbnRLZXksIG1vbnRoKSB7XG4gICAgICAgICAgICB2YXIgX2E7XG4gICAgICAgICAgICB2YXIgX2IgPSBfdGhpcy5wcm9wcywgc2VsZWN0ZWQgPSBfYi5zZWxlY3RlZCwgcHJlU2VsZWN0aW9uID0gX2IucHJlU2VsZWN0aW9uLCBzZXRQcmVTZWxlY3Rpb24gPSBfYi5zZXRQcmVTZWxlY3Rpb24sIG1pbkRhdGUgPSBfYi5taW5EYXRlLCBtYXhEYXRlID0gX2IubWF4RGF0ZSwgc2hvd0ZvdXJDb2x1bW5Nb250aFllYXJQaWNrZXIgPSBfYi5zaG93Rm91ckNvbHVtbk1vbnRoWWVhclBpY2tlciwgc2hvd1R3b0NvbHVtbk1vbnRoWWVhclBpY2tlciA9IF9iLnNob3dUd29Db2x1bW5Nb250aFllYXJQaWNrZXI7XG4gICAgICAgICAgICBpZiAoIXByZVNlbGVjdGlvbilcbiAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICB2YXIgbW9udGhDb2x1bW5zTGF5b3V0ID0gZ2V0TW9udGhDb2x1bW5zTGF5b3V0KHNob3dGb3VyQ29sdW1uTW9udGhZZWFyUGlja2VyLCBzaG93VHdvQ29sdW1uTW9udGhZZWFyUGlja2VyKTtcbiAgICAgICAgICAgIHZhciB2ZXJ0aWNhbE9mZnNldCA9IF90aGlzLmdldFZlcnRpY2FsT2Zmc2V0KG1vbnRoQ29sdW1uc0xheW91dCk7XG4gICAgICAgICAgICB2YXIgbW9udGhzR3JpZCA9IChfYSA9IE1PTlRIX0NPTFVNTlNbbW9udGhDb2x1bW5zTGF5b3V0XSkgPT09IG51bGwgfHwgX2EgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9hLmdyaWQ7XG4gICAgICAgICAgICB2YXIgY2FsY3VsYXRlTmV3RGF0ZUFuZE1vbnRoID0gZnVuY3Rpb24gKGV2ZW50S2V5LCBkYXRlLCBtb250aCkge1xuICAgICAgICAgICAgICAgIHZhciBfYSwgX2I7XG4gICAgICAgICAgICAgICAgdmFyIG5ld0NhbGN1bGF0ZWREYXRlID0gZGF0ZTtcbiAgICAgICAgICAgICAgICB2YXIgbmV3Q2FsY3VsYXRlZE1vbnRoID0gbW9udGg7XG4gICAgICAgICAgICAgICAgc3dpdGNoIChldmVudEtleSkge1xuICAgICAgICAgICAgICAgICAgICBjYXNlIEtleVR5cGUuQXJyb3dSaWdodDpcbiAgICAgICAgICAgICAgICAgICAgICAgIG5ld0NhbGN1bGF0ZWREYXRlID0gYWRkTW9udGhzKGRhdGUsIE1PTlRIX05BVklHQVRJT05fSE9SSVpPTlRBTF9PRkZTRVQpO1xuICAgICAgICAgICAgICAgICAgICAgICAgbmV3Q2FsY3VsYXRlZE1vbnRoID1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBtb250aCA9PT0gMTEgPyAwIDogbW9udGggKyBNT05USF9OQVZJR0FUSU9OX0hPUklaT05UQUxfT0ZGU0VUO1xuICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgICAgIGNhc2UgS2V5VHlwZS5BcnJvd0xlZnQ6XG4gICAgICAgICAgICAgICAgICAgICAgICBuZXdDYWxjdWxhdGVkRGF0ZSA9IHN1Yk1vbnRocyhkYXRlLCBNT05USF9OQVZJR0FUSU9OX0hPUklaT05UQUxfT0ZGU0VUKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIG5ld0NhbGN1bGF0ZWRNb250aCA9XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgbW9udGggPT09IDAgPyAxMSA6IG1vbnRoIC0gTU9OVEhfTkFWSUdBVElPTl9IT1JJWk9OVEFMX09GRlNFVDtcbiAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgICAgICBjYXNlIEtleVR5cGUuQXJyb3dVcDpcbiAgICAgICAgICAgICAgICAgICAgICAgIG5ld0NhbGN1bGF0ZWREYXRlID0gc3ViTW9udGhzKGRhdGUsIHZlcnRpY2FsT2Zmc2V0KTtcbiAgICAgICAgICAgICAgICAgICAgICAgIG5ld0NhbGN1bGF0ZWRNb250aCA9ICgoX2EgPSBtb250aHNHcmlkID09PSBudWxsIHx8IG1vbnRoc0dyaWQgPT09IHZvaWQgMCA/IHZvaWQgMCA6IG1vbnRoc0dyaWRbMF0pID09PSBudWxsIHx8IF9hID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYS5pbmNsdWRlcyhtb250aCkpXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgPyBtb250aCArIDEyIC0gdmVydGljYWxPZmZzZXRcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICA6IG1vbnRoIC0gdmVydGljYWxPZmZzZXQ7XG4gICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICAgICAgY2FzZSBLZXlUeXBlLkFycm93RG93bjpcbiAgICAgICAgICAgICAgICAgICAgICAgIG5ld0NhbGN1bGF0ZWREYXRlID0gYWRkTW9udGhzKGRhdGUsIHZlcnRpY2FsT2Zmc2V0KTtcbiAgICAgICAgICAgICAgICAgICAgICAgIG5ld0NhbGN1bGF0ZWRNb250aCA9ICgoX2IgPSBtb250aHNHcmlkID09PSBudWxsIHx8IG1vbnRoc0dyaWQgPT09IHZvaWQgMCA/IHZvaWQgMCA6IG1vbnRoc0dyaWRbbW9udGhzR3JpZC5sZW5ndGggLSAxXSkgPT09IG51bGwgfHwgX2IgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9iLmluY2x1ZGVzKG1vbnRoKSlcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICA/IG1vbnRoIC0gMTIgKyB2ZXJ0aWNhbE9mZnNldFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIDogbW9udGggKyB2ZXJ0aWNhbE9mZnNldDtcbiAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICByZXR1cm4geyBuZXdDYWxjdWxhdGVkRGF0ZTogbmV3Q2FsY3VsYXRlZERhdGUsIG5ld0NhbGN1bGF0ZWRNb250aDogbmV3Q2FsY3VsYXRlZE1vbnRoIH07XG4gICAgICAgICAgICB9O1xuICAgICAgICAgICAgdmFyIGdldE5ld0RhdGVBbmRNb250aCA9IGZ1bmN0aW9uIChldmVudEtleSwgc2VsZWN0ZWREYXRlLCBtb250aCkge1xuICAgICAgICAgICAgICAgIHZhciBNQVhfSVRFUkFUSU9OUyA9IDQwO1xuICAgICAgICAgICAgICAgIHZhciBldmVudEtleUNvcHkgPSBldmVudEtleTtcbiAgICAgICAgICAgICAgICB2YXIgdmFsaWREYXRlRm91bmQgPSBmYWxzZTtcbiAgICAgICAgICAgICAgICB2YXIgaXRlcmF0aW9ucyA9IDA7XG4gICAgICAgICAgICAgICAgdmFyIF9hID0gY2FsY3VsYXRlTmV3RGF0ZUFuZE1vbnRoKGV2ZW50S2V5Q29weSwgc2VsZWN0ZWREYXRlLCBtb250aCksIG5ld0NhbGN1bGF0ZWREYXRlID0gX2EubmV3Q2FsY3VsYXRlZERhdGUsIG5ld0NhbGN1bGF0ZWRNb250aCA9IF9hLm5ld0NhbGN1bGF0ZWRNb250aDtcbiAgICAgICAgICAgICAgICB3aGlsZSAoIXZhbGlkRGF0ZUZvdW5kKSB7XG4gICAgICAgICAgICAgICAgICAgIGlmIChpdGVyYXRpb25zID49IE1BWF9JVEVSQVRJT05TKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBuZXdDYWxjdWxhdGVkRGF0ZSA9IHNlbGVjdGVkRGF0ZTtcbiAgICAgICAgICAgICAgICAgICAgICAgIG5ld0NhbGN1bGF0ZWRNb250aCA9IG1vbnRoO1xuICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgLy8gaWYgbWluRGF0ZSBleGlzdHMgYW5kIHRoZSBuZXcgbW9udGggaXMgYmVmb3JlIHRoZSBtaW5pbXVtIG1vbnRoLCBpdCB3aWxsIHRyeSB0byBmaW5kIHRoZSBuZXh0IGF2YWlsYWJsZSBtb250aCBhZnRlclxuICAgICAgICAgICAgICAgICAgICBpZiAobWluRGF0ZSAmJiBuZXdDYWxjdWxhdGVkRGF0ZSA8IG1pbkRhdGUpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGV2ZW50S2V5Q29weSA9IEtleVR5cGUuQXJyb3dSaWdodDtcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhciBvYmogPSBjYWxjdWxhdGVOZXdEYXRlQW5kTW9udGgoZXZlbnRLZXlDb3B5LCBuZXdDYWxjdWxhdGVkRGF0ZSwgbmV3Q2FsY3VsYXRlZE1vbnRoKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIG5ld0NhbGN1bGF0ZWREYXRlID0gb2JqLm5ld0NhbGN1bGF0ZWREYXRlO1xuICAgICAgICAgICAgICAgICAgICAgICAgbmV3Q2FsY3VsYXRlZE1vbnRoID0gb2JqLm5ld0NhbGN1bGF0ZWRNb250aDtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAvLyBpZiBtYXhEYXRlIGV4aXN0cyBhbmQgdGhlIG5ldyBtb250aCBpcyBhZnRlciB0aGUgbWF4aW11bSBtb250aCwgaXQgd2lsbCB0cnkgdG8gZmluZCB0aGUgbmV4dCBhdmFpbGFibGUgbW9udGggYmVmb3JlXG4gICAgICAgICAgICAgICAgICAgIGlmIChtYXhEYXRlICYmIG5ld0NhbGN1bGF0ZWREYXRlID4gbWF4RGF0ZSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgZXZlbnRLZXlDb3B5ID0gS2V5VHlwZS5BcnJvd0xlZnQ7XG4gICAgICAgICAgICAgICAgICAgICAgICB2YXIgb2JqID0gY2FsY3VsYXRlTmV3RGF0ZUFuZE1vbnRoKGV2ZW50S2V5Q29weSwgbmV3Q2FsY3VsYXRlZERhdGUsIG5ld0NhbGN1bGF0ZWRNb250aCk7XG4gICAgICAgICAgICAgICAgICAgICAgICBuZXdDYWxjdWxhdGVkRGF0ZSA9IG9iai5uZXdDYWxjdWxhdGVkRGF0ZTtcbiAgICAgICAgICAgICAgICAgICAgICAgIG5ld0NhbGN1bGF0ZWRNb250aCA9IG9iai5uZXdDYWxjdWxhdGVkTW9udGg7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgaWYgKGlzTW9udGhZZWFyRGlzYWJsZWQobmV3Q2FsY3VsYXRlZERhdGUsIF90aGlzLnByb3BzKSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgdmFyIG9iaiA9IGNhbGN1bGF0ZU5ld0RhdGVBbmRNb250aChldmVudEtleUNvcHksIG5ld0NhbGN1bGF0ZWREYXRlLCBuZXdDYWxjdWxhdGVkTW9udGgpO1xuICAgICAgICAgICAgICAgICAgICAgICAgbmV3Q2FsY3VsYXRlZERhdGUgPSBvYmoubmV3Q2FsY3VsYXRlZERhdGU7XG4gICAgICAgICAgICAgICAgICAgICAgICBuZXdDYWxjdWxhdGVkTW9udGggPSBvYmoubmV3Q2FsY3VsYXRlZE1vbnRoO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgdmFsaWREYXRlRm91bmQgPSB0cnVlO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGl0ZXJhdGlvbnMrKztcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgcmV0dXJuIHsgbmV3Q2FsY3VsYXRlZERhdGU6IG5ld0NhbGN1bGF0ZWREYXRlLCBuZXdDYWxjdWxhdGVkTW9udGg6IG5ld0NhbGN1bGF0ZWRNb250aCB9O1xuICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIGlmIChldmVudEtleSA9PT0gS2V5VHlwZS5FbnRlcikge1xuICAgICAgICAgICAgICAgIGlmICghX3RoaXMuaXNNb250aERpc2FibGVkKG1vbnRoKSkge1xuICAgICAgICAgICAgICAgICAgICBfdGhpcy5vbk1vbnRoQ2xpY2soZXZlbnQsIG1vbnRoKTtcbiAgICAgICAgICAgICAgICAgICAgc2V0UHJlU2VsZWN0aW9uID09PSBudWxsIHx8IHNldFByZVNlbGVjdGlvbiA9PT0gdm9pZCAwID8gdm9pZCAwIDogc2V0UHJlU2VsZWN0aW9uKHNlbGVjdGVkKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdmFyIF9jID0gZ2V0TmV3RGF0ZUFuZE1vbnRoKGV2ZW50S2V5LCBwcmVTZWxlY3Rpb24sIG1vbnRoKSwgbmV3Q2FsY3VsYXRlZERhdGUgPSBfYy5uZXdDYWxjdWxhdGVkRGF0ZSwgbmV3Q2FsY3VsYXRlZE1vbnRoID0gX2MubmV3Q2FsY3VsYXRlZE1vbnRoO1xuICAgICAgICAgICAgc3dpdGNoIChldmVudEtleSkge1xuICAgICAgICAgICAgICAgIGNhc2UgS2V5VHlwZS5BcnJvd1JpZ2h0OlxuICAgICAgICAgICAgICAgIGNhc2UgS2V5VHlwZS5BcnJvd0xlZnQ6XG4gICAgICAgICAgICAgICAgY2FzZSBLZXlUeXBlLkFycm93VXA6XG4gICAgICAgICAgICAgICAgY2FzZSBLZXlUeXBlLkFycm93RG93bjpcbiAgICAgICAgICAgICAgICAgICAgX3RoaXMuaGFuZGxlTW9udGhOYXZpZ2F0aW9uKG5ld0NhbGN1bGF0ZWRNb250aCwgbmV3Q2FsY3VsYXRlZERhdGUpO1xuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIH1cbiAgICAgICAgfTtcbiAgICAgICAgX3RoaXMuZ2V0VmVydGljYWxPZmZzZXQgPSBmdW5jdGlvbiAobW9udGhDb2x1bW5zTGF5b3V0KSB7XG4gICAgICAgICAgICB2YXIgX2EsIF9iO1xuICAgICAgICAgICAgcmV0dXJuIChfYiA9IChfYSA9IE1PTlRIX0NPTFVNTlNbbW9udGhDb2x1bW5zTGF5b3V0XSkgPT09IG51bGwgfHwgX2EgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9hLnZlcnRpY2FsTmF2aWdhdGlvbk9mZnNldCkgIT09IG51bGwgJiYgX2IgIT09IHZvaWQgMCA/IF9iIDogMDtcbiAgICAgICAgfTtcbiAgICAgICAgX3RoaXMub25Nb250aEtleURvd24gPSBmdW5jdGlvbiAoZXZlbnQsIG1vbnRoKSB7XG4gICAgICAgICAgICB2YXIgX2EgPSBfdGhpcy5wcm9wcywgZGlzYWJsZWRLZXlib2FyZE5hdmlnYXRpb24gPSBfYS5kaXNhYmxlZEtleWJvYXJkTmF2aWdhdGlvbiwgaGFuZGxlT25Nb250aEtleURvd24gPSBfYS5oYW5kbGVPbk1vbnRoS2V5RG93bjtcbiAgICAgICAgICAgIHZhciBldmVudEtleSA9IGV2ZW50LmtleTtcbiAgICAgICAgICAgIGlmIChldmVudEtleSAhPT0gS2V5VHlwZS5UYWIpIHtcbiAgICAgICAgICAgICAgICAvLyBwcmV2ZW50RGVmYXVsdCBvbiB0YWIgZXZlbnQgYmxvY2tzIGZvY3VzIGNoYW5nZVxuICAgICAgICAgICAgICAgIGV2ZW50LnByZXZlbnREZWZhdWx0KCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoIWRpc2FibGVkS2V5Ym9hcmROYXZpZ2F0aW9uKSB7XG4gICAgICAgICAgICAgICAgX3RoaXMuaGFuZGxlS2V5Ym9hcmROYXZpZ2F0aW9uKGV2ZW50LCBldmVudEtleSwgbW9udGgpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaGFuZGxlT25Nb250aEtleURvd24gJiYgaGFuZGxlT25Nb250aEtleURvd24oZXZlbnQpO1xuICAgICAgICB9O1xuICAgICAgICBfdGhpcy5vblF1YXJ0ZXJDbGljayA9IGZ1bmN0aW9uIChldmVudCwgcSkge1xuICAgICAgICAgICAgdmFyIGxhYmVsRGF0ZSA9IHNldFF1YXJ0ZXIoX3RoaXMucHJvcHMuZGF5LCBxKTtcbiAgICAgICAgICAgIGlmIChpc1F1YXJ0ZXJEaXNhYmxlZChsYWJlbERhdGUsIF90aGlzLnByb3BzKSkge1xuICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIF90aGlzLmhhbmRsZURheUNsaWNrKGdldFN0YXJ0T2ZRdWFydGVyKGxhYmVsRGF0ZSksIGV2ZW50KTtcbiAgICAgICAgfTtcbiAgICAgICAgX3RoaXMub25RdWFydGVyTW91c2VFbnRlciA9IGZ1bmN0aW9uIChxKSB7XG4gICAgICAgICAgICB2YXIgbGFiZWxEYXRlID0gc2V0UXVhcnRlcihfdGhpcy5wcm9wcy5kYXksIHEpO1xuICAgICAgICAgICAgaWYgKGlzUXVhcnRlckRpc2FibGVkKGxhYmVsRGF0ZSwgX3RoaXMucHJvcHMpKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgX3RoaXMuaGFuZGxlRGF5TW91c2VFbnRlcihnZXRTdGFydE9mUXVhcnRlcihsYWJlbERhdGUpKTtcbiAgICAgICAgfTtcbiAgICAgICAgX3RoaXMuaGFuZGxlUXVhcnRlck5hdmlnYXRpb24gPSBmdW5jdGlvbiAobmV3UXVhcnRlciwgbmV3RGF0ZSkge1xuICAgICAgICAgICAgdmFyIF9hLCBfYiwgX2MsIF9kO1xuICAgICAgICAgICAgaWYgKF90aGlzLmlzRGlzYWJsZWQobmV3RGF0ZSkgfHwgX3RoaXMuaXNFeGNsdWRlZChuZXdEYXRlKSkge1xuICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIChfYiA9IChfYSA9IF90aGlzLnByb3BzKS5zZXRQcmVTZWxlY3Rpb24pID09PSBudWxsIHx8IF9iID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYi5jYWxsKF9hLCBuZXdEYXRlKTtcbiAgICAgICAgICAgIChfZCA9IChfYyA9IF90aGlzLlFVQVJURVJfUkVGU1tuZXdRdWFydGVyIC0gMV0pID09PSBudWxsIHx8IF9jID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYy5jdXJyZW50KSA9PT0gbnVsbCB8fCBfZCA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2QuZm9jdXMoKTtcbiAgICAgICAgfTtcbiAgICAgICAgX3RoaXMub25RdWFydGVyS2V5RG93biA9IGZ1bmN0aW9uIChldmVudCwgcXVhcnRlcikge1xuICAgICAgICAgICAgdmFyIF9hLCBfYjtcbiAgICAgICAgICAgIHZhciBldmVudEtleSA9IGV2ZW50LmtleTtcbiAgICAgICAgICAgIGlmICghX3RoaXMucHJvcHMuZGlzYWJsZWRLZXlib2FyZE5hdmlnYXRpb24pIHtcbiAgICAgICAgICAgICAgICBzd2l0Y2ggKGV2ZW50S2V5KSB7XG4gICAgICAgICAgICAgICAgICAgIGNhc2UgS2V5VHlwZS5FbnRlcjpcbiAgICAgICAgICAgICAgICAgICAgICAgIF90aGlzLm9uUXVhcnRlckNsaWNrKGV2ZW50LCBxdWFydGVyKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIChfYiA9IChfYSA9IF90aGlzLnByb3BzKS5zZXRQcmVTZWxlY3Rpb24pID09PSBudWxsIHx8IF9iID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYi5jYWxsKF9hLCBfdGhpcy5wcm9wcy5zZWxlY3RlZCk7XG4gICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICAgICAgY2FzZSBLZXlUeXBlLkFycm93UmlnaHQ6XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoIV90aGlzLnByb3BzLnByZVNlbGVjdGlvbikge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgX3RoaXMuaGFuZGxlUXVhcnRlck5hdmlnYXRpb24ocXVhcnRlciA9PT0gNCA/IDEgOiBxdWFydGVyICsgMSwgYWRkUXVhcnRlcnMoX3RoaXMucHJvcHMucHJlU2VsZWN0aW9uLCAxKSk7XG4gICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICAgICAgY2FzZSBLZXlUeXBlLkFycm93TGVmdDpcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmICghX3RoaXMucHJvcHMucHJlU2VsZWN0aW9uKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICBfdGhpcy5oYW5kbGVRdWFydGVyTmF2aWdhdGlvbihxdWFydGVyID09PSAxID8gNCA6IHF1YXJ0ZXIgLSAxLCBzdWJRdWFydGVycyhfdGhpcy5wcm9wcy5wcmVTZWxlY3Rpb24sIDEpKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfTtcbiAgICAgICAgX3RoaXMuaXNNb250aERpc2FibGVkRm9yTGFiZWxEYXRlID0gZnVuY3Rpb24gKG1vbnRoKSB7XG4gICAgICAgICAgICB2YXIgX2E7XG4gICAgICAgICAgICB2YXIgX2IgPSBfdGhpcy5wcm9wcywgZGF5ID0gX2IuZGF5LCBkaXNhYmxlZCA9IF9iLmRpc2FibGVkLCBtaW5EYXRlID0gX2IubWluRGF0ZSwgbWF4RGF0ZSA9IF9iLm1heERhdGUsIGV4Y2x1ZGVEYXRlcyA9IF9iLmV4Y2x1ZGVEYXRlcywgaW5jbHVkZURhdGVzID0gX2IuaW5jbHVkZURhdGVzO1xuICAgICAgICAgICAgdmFyIGxhYmVsRGF0ZSA9IHNldE1vbnRoKGRheSwgbW9udGgpO1xuICAgICAgICAgICAgaWYgKGRpc2FibGVkKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgICAgICAgICAgaXNEaXNhYmxlZDogdHJ1ZSxcbiAgICAgICAgICAgICAgICAgICAgbGFiZWxEYXRlOiBzZXRNb250aChkYXksIG1vbnRoKSxcbiAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgICAgICBpc0Rpc2FibGVkOiAoX2EgPSAoKG1pbkRhdGUgfHwgbWF4RGF0ZSB8fCBleGNsdWRlRGF0ZXMgfHwgaW5jbHVkZURhdGVzKSAmJlxuICAgICAgICAgICAgICAgICAgICBpc01vbnRoRGlzYWJsZWQobGFiZWxEYXRlLCBfdGhpcy5wcm9wcykpKSAhPT0gbnVsbCAmJiBfYSAhPT0gdm9pZCAwID8gX2EgOiBmYWxzZSxcbiAgICAgICAgICAgICAgICBsYWJlbERhdGU6IGxhYmVsRGF0ZSxcbiAgICAgICAgICAgIH07XG4gICAgICAgIH07XG4gICAgICAgIF90aGlzLmlzTW9udGhEaXNhYmxlZCA9IGZ1bmN0aW9uIChtb250aCkge1xuICAgICAgICAgICAgdmFyIGlzRGlzYWJsZWQgPSBfdGhpcy5pc01vbnRoRGlzYWJsZWRGb3JMYWJlbERhdGUobW9udGgpLmlzRGlzYWJsZWQ7XG4gICAgICAgICAgICByZXR1cm4gaXNEaXNhYmxlZDtcbiAgICAgICAgfTtcbiAgICAgICAgX3RoaXMuZ2V0TW9udGhDbGFzc05hbWVzID0gZnVuY3Rpb24gKG0pIHtcbiAgICAgICAgICAgIHZhciBfYSA9IF90aGlzLnByb3BzLCBkYXkgPSBfYS5kYXksIHN0YXJ0RGF0ZSA9IF9hLnN0YXJ0RGF0ZSwgZW5kRGF0ZSA9IF9hLmVuZERhdGUsIHByZVNlbGVjdGlvbiA9IF9hLnByZVNlbGVjdGlvbiwgbW9udGhDbGFzc05hbWUgPSBfYS5tb250aENsYXNzTmFtZTtcbiAgICAgICAgICAgIHZhciBfbW9udGhDbGFzc05hbWUgPSBtb250aENsYXNzTmFtZVxuICAgICAgICAgICAgICAgID8gbW9udGhDbGFzc05hbWUoc2V0TW9udGgoZGF5LCBtKSlcbiAgICAgICAgICAgICAgICA6IHVuZGVmaW5lZDtcbiAgICAgICAgICAgIHZhciBzZWxlY3Rpb24gPSBfdGhpcy5nZXRTZWxlY3Rpb24oKTtcbiAgICAgICAgICAgIHJldHVybiBjbHN4KFwicmVhY3QtZGF0ZXBpY2tlcl9fbW9udGgtdGV4dFwiLCBcInJlYWN0LWRhdGVwaWNrZXJfX21vbnRoLVwiLmNvbmNhdChtKSwgX21vbnRoQ2xhc3NOYW1lLCB7XG4gICAgICAgICAgICAgICAgXCJyZWFjdC1kYXRlcGlja2VyX19tb250aC10ZXh0LS1kaXNhYmxlZFwiOiBfdGhpcy5pc01vbnRoRGlzYWJsZWQobSksXG4gICAgICAgICAgICAgICAgXCJyZWFjdC1kYXRlcGlja2VyX19tb250aC10ZXh0LS1zZWxlY3RlZFwiOiBzZWxlY3Rpb25cbiAgICAgICAgICAgICAgICAgICAgPyBfdGhpcy5pc1NlbGVjdE1vbnRoSW5MaXN0KGRheSwgbSwgc2VsZWN0aW9uKVxuICAgICAgICAgICAgICAgICAgICA6IHVuZGVmaW5lZCxcbiAgICAgICAgICAgICAgICBcInJlYWN0LWRhdGVwaWNrZXJfX21vbnRoLXRleHQtLWtleWJvYXJkLXNlbGVjdGVkXCI6ICFfdGhpcy5wcm9wcy5kaXNhYmxlZEtleWJvYXJkTmF2aWdhdGlvbiAmJlxuICAgICAgICAgICAgICAgICAgICBwcmVTZWxlY3Rpb24gJiZcbiAgICAgICAgICAgICAgICAgICAgX3RoaXMuaXNTZWxlY3RlZE1vbnRoKGRheSwgbSwgcHJlU2VsZWN0aW9uKSAmJlxuICAgICAgICAgICAgICAgICAgICAhX3RoaXMuaXNNb250aFNlbGVjdGVkKCkgJiZcbiAgICAgICAgICAgICAgICAgICAgIV90aGlzLmlzTW9udGhEaXNhYmxlZChtKSxcbiAgICAgICAgICAgICAgICBcInJlYWN0LWRhdGVwaWNrZXJfX21vbnRoLXRleHQtLWluLXNlbGVjdGluZy1yYW5nZVwiOiBfdGhpcy5pc0luU2VsZWN0aW5nUmFuZ2VNb250aChtKSxcbiAgICAgICAgICAgICAgICBcInJlYWN0LWRhdGVwaWNrZXJfX21vbnRoLXRleHQtLWluLXJhbmdlXCI6IHN0YXJ0RGF0ZSAmJiBlbmREYXRlXG4gICAgICAgICAgICAgICAgICAgID8gaXNNb250aEluUmFuZ2Uoc3RhcnREYXRlLCBlbmREYXRlLCBtLCBkYXkpXG4gICAgICAgICAgICAgICAgICAgIDogdW5kZWZpbmVkLFxuICAgICAgICAgICAgICAgIFwicmVhY3QtZGF0ZXBpY2tlcl9fbW9udGgtdGV4dC0tcmFuZ2Utc3RhcnRcIjogX3RoaXMuaXNSYW5nZVN0YXJ0TW9udGgobSksXG4gICAgICAgICAgICAgICAgXCJyZWFjdC1kYXRlcGlja2VyX19tb250aC10ZXh0LS1yYW5nZS1lbmRcIjogX3RoaXMuaXNSYW5nZUVuZE1vbnRoKG0pLFxuICAgICAgICAgICAgICAgIFwicmVhY3QtZGF0ZXBpY2tlcl9fbW9udGgtdGV4dC0tc2VsZWN0aW5nLXJhbmdlLXN0YXJ0XCI6IF90aGlzLmlzU2VsZWN0aW5nTW9udGhSYW5nZVN0YXJ0KG0pLFxuICAgICAgICAgICAgICAgIFwicmVhY3QtZGF0ZXBpY2tlcl9fbW9udGgtdGV4dC0tc2VsZWN0aW5nLXJhbmdlLWVuZFwiOiBfdGhpcy5pc1NlbGVjdGluZ01vbnRoUmFuZ2VFbmQobSksXG4gICAgICAgICAgICAgICAgXCJyZWFjdC1kYXRlcGlja2VyX19tb250aC10ZXh0LS10b2RheVwiOiBfdGhpcy5pc0N1cnJlbnRNb250aChkYXksIG0pLFxuICAgICAgICAgICAgfSk7XG4gICAgICAgIH07XG4gICAgICAgIF90aGlzLmdldFRhYkluZGV4ID0gZnVuY3Rpb24gKG0pIHtcbiAgICAgICAgICAgIGlmIChfdGhpcy5wcm9wcy5wcmVTZWxlY3Rpb24gPT0gbnVsbCkge1xuICAgICAgICAgICAgICAgIHJldHVybiBcIi0xXCI7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB2YXIgcHJlU2VsZWN0ZWRNb250aCA9IGdldE1vbnRoKF90aGlzLnByb3BzLnByZVNlbGVjdGlvbik7XG4gICAgICAgICAgICB2YXIgaXNQcmVTZWxlY3RlZE1vbnRoRGlzYWJsZWQgPSBfdGhpcy5pc01vbnRoRGlzYWJsZWRGb3JMYWJlbERhdGUocHJlU2VsZWN0ZWRNb250aCkuaXNEaXNhYmxlZDtcbiAgICAgICAgICAgIHZhciB0YWJJbmRleCA9IG0gPT09IHByZVNlbGVjdGVkTW9udGggJiZcbiAgICAgICAgICAgICAgICAhKGlzUHJlU2VsZWN0ZWRNb250aERpc2FibGVkIHx8IF90aGlzLnByb3BzLmRpc2FibGVkS2V5Ym9hcmROYXZpZ2F0aW9uKVxuICAgICAgICAgICAgICAgID8gXCIwXCJcbiAgICAgICAgICAgICAgICA6IFwiLTFcIjtcbiAgICAgICAgICAgIHJldHVybiB0YWJJbmRleDtcbiAgICAgICAgfTtcbiAgICAgICAgX3RoaXMuZ2V0UXVhcnRlclRhYkluZGV4ID0gZnVuY3Rpb24gKHEpIHtcbiAgICAgICAgICAgIGlmIChfdGhpcy5wcm9wcy5wcmVTZWxlY3Rpb24gPT0gbnVsbCkge1xuICAgICAgICAgICAgICAgIHJldHVybiBcIi0xXCI7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB2YXIgcHJlU2VsZWN0ZWRRdWFydGVyID0gZ2V0UXVhcnRlcihfdGhpcy5wcm9wcy5wcmVTZWxlY3Rpb24pO1xuICAgICAgICAgICAgdmFyIGlzQ3VycmVudFF1YXJ0ZXJEaXNhYmxlZCA9IGlzUXVhcnRlckRpc2FibGVkKF90aGlzLnByb3BzLmRheSwgX3RoaXMucHJvcHMpO1xuICAgICAgICAgICAgdmFyIHRhYkluZGV4ID0gcSA9PT0gcHJlU2VsZWN0ZWRRdWFydGVyICYmXG4gICAgICAgICAgICAgICAgIShpc0N1cnJlbnRRdWFydGVyRGlzYWJsZWQgfHwgX3RoaXMucHJvcHMuZGlzYWJsZWRLZXlib2FyZE5hdmlnYXRpb24pXG4gICAgICAgICAgICAgICAgPyBcIjBcIlxuICAgICAgICAgICAgICAgIDogXCItMVwiO1xuICAgICAgICAgICAgcmV0dXJuIHRhYkluZGV4O1xuICAgICAgICB9O1xuICAgICAgICBfdGhpcy5nZXRBcmlhTGFiZWwgPSBmdW5jdGlvbiAobW9udGgpIHtcbiAgICAgICAgICAgIHZhciBfYSA9IF90aGlzLnByb3BzLCBfYiA9IF9hLmNob29zZURheUFyaWFMYWJlbFByZWZpeCwgY2hvb3NlRGF5QXJpYUxhYmVsUHJlZml4ID0gX2IgPT09IHZvaWQgMCA/IFwiQ2hvb3NlXCIgOiBfYiwgX2MgPSBfYS5kaXNhYmxlZERheUFyaWFMYWJlbFByZWZpeCwgZGlzYWJsZWREYXlBcmlhTGFiZWxQcmVmaXggPSBfYyA9PT0gdm9pZCAwID8gXCJOb3QgYXZhaWxhYmxlXCIgOiBfYywgZGF5ID0gX2EuZGF5LCBsb2NhbGUgPSBfYS5sb2NhbGU7XG4gICAgICAgICAgICB2YXIgbGFiZWxEYXRlID0gc2V0TW9udGgoZGF5LCBtb250aCk7XG4gICAgICAgICAgICB2YXIgcHJlZml4ID0gX3RoaXMuaXNEaXNhYmxlZChsYWJlbERhdGUpIHx8IF90aGlzLmlzRXhjbHVkZWQobGFiZWxEYXRlKVxuICAgICAgICAgICAgICAgID8gZGlzYWJsZWREYXlBcmlhTGFiZWxQcmVmaXhcbiAgICAgICAgICAgICAgICA6IGNob29zZURheUFyaWFMYWJlbFByZWZpeDtcbiAgICAgICAgICAgIHJldHVybiBcIlwiLmNvbmNhdChwcmVmaXgsIFwiIFwiKS5jb25jYXQoZm9ybWF0RGF0ZShsYWJlbERhdGUsIFwiTU1NTSB5eXl5XCIsIGxvY2FsZSkpO1xuICAgICAgICB9O1xuICAgICAgICBfdGhpcy5nZXRRdWFydGVyQ2xhc3NOYW1lcyA9IGZ1bmN0aW9uIChxKSB7XG4gICAgICAgICAgICB2YXIgX2EgPSBfdGhpcy5wcm9wcywgZGF5ID0gX2EuZGF5LCBzdGFydERhdGUgPSBfYS5zdGFydERhdGUsIGVuZERhdGUgPSBfYS5lbmREYXRlLCBtaW5EYXRlID0gX2EubWluRGF0ZSwgbWF4RGF0ZSA9IF9hLm1heERhdGUsIGV4Y2x1ZGVEYXRlcyA9IF9hLmV4Y2x1ZGVEYXRlcywgaW5jbHVkZURhdGVzID0gX2EuaW5jbHVkZURhdGVzLCBmaWx0ZXJEYXRlID0gX2EuZmlsdGVyRGF0ZSwgcHJlU2VsZWN0aW9uID0gX2EucHJlU2VsZWN0aW9uLCBkaXNhYmxlZEtleWJvYXJkTmF2aWdhdGlvbiA9IF9hLmRpc2FibGVkS2V5Ym9hcmROYXZpZ2F0aW9uLCBkaXNhYmxlZCA9IF9hLmRpc2FibGVkO1xuICAgICAgICAgICAgdmFyIGlzRGlzYWJsZWQgPSAobWluRGF0ZSB8fFxuICAgICAgICAgICAgICAgIG1heERhdGUgfHxcbiAgICAgICAgICAgICAgICBleGNsdWRlRGF0ZXMgfHxcbiAgICAgICAgICAgICAgICBpbmNsdWRlRGF0ZXMgfHxcbiAgICAgICAgICAgICAgICBmaWx0ZXJEYXRlIHx8XG4gICAgICAgICAgICAgICAgZGlzYWJsZWQpICYmXG4gICAgICAgICAgICAgICAgaXNRdWFydGVyRGlzYWJsZWQoc2V0UXVhcnRlcihkYXksIHEpLCBfdGhpcy5wcm9wcyk7XG4gICAgICAgICAgICB2YXIgc2VsZWN0aW9uID0gX3RoaXMuZ2V0U2VsZWN0aW9uKCk7XG4gICAgICAgICAgICByZXR1cm4gY2xzeChcInJlYWN0LWRhdGVwaWNrZXJfX3F1YXJ0ZXItdGV4dFwiLCBcInJlYWN0LWRhdGVwaWNrZXJfX3F1YXJ0ZXItXCIuY29uY2F0KHEpLCB7XG4gICAgICAgICAgICAgICAgXCJyZWFjdC1kYXRlcGlja2VyX19xdWFydGVyLXRleHQtLWRpc2FibGVkXCI6IGlzRGlzYWJsZWQsXG4gICAgICAgICAgICAgICAgXCJyZWFjdC1kYXRlcGlja2VyX19xdWFydGVyLXRleHQtLXNlbGVjdGVkXCI6IHNlbGVjdGlvblxuICAgICAgICAgICAgICAgICAgICA/IF90aGlzLmlzU2VsZWN0UXVhcnRlckluTGlzdChkYXksIHEsIHNlbGVjdGlvbilcbiAgICAgICAgICAgICAgICAgICAgOiB1bmRlZmluZWQsXG4gICAgICAgICAgICAgICAgXCJyZWFjdC1kYXRlcGlja2VyX19xdWFydGVyLXRleHQtLWtleWJvYXJkLXNlbGVjdGVkXCI6ICFkaXNhYmxlZEtleWJvYXJkTmF2aWdhdGlvbiAmJlxuICAgICAgICAgICAgICAgICAgICBwcmVTZWxlY3Rpb24gJiZcbiAgICAgICAgICAgICAgICAgICAgX3RoaXMuaXNTZWxlY3RlZFF1YXJ0ZXIoZGF5LCBxLCBwcmVTZWxlY3Rpb24pICYmXG4gICAgICAgICAgICAgICAgICAgICFfdGhpcy5pc1F1YXJ0ZXJTZWxlY3RlZCgpICYmXG4gICAgICAgICAgICAgICAgICAgICFpc0Rpc2FibGVkLFxuICAgICAgICAgICAgICAgIFwicmVhY3QtZGF0ZXBpY2tlcl9fcXVhcnRlci10ZXh0LS1pbi1zZWxlY3RpbmctcmFuZ2VcIjogX3RoaXMuaXNJblNlbGVjdGluZ1JhbmdlUXVhcnRlcihxKSxcbiAgICAgICAgICAgICAgICBcInJlYWN0LWRhdGVwaWNrZXJfX3F1YXJ0ZXItdGV4dC0taW4tcmFuZ2VcIjogc3RhcnREYXRlICYmIGVuZERhdGVcbiAgICAgICAgICAgICAgICAgICAgPyBpc1F1YXJ0ZXJJblJhbmdlKHN0YXJ0RGF0ZSwgZW5kRGF0ZSwgcSwgZGF5KVxuICAgICAgICAgICAgICAgICAgICA6IHVuZGVmaW5lZCxcbiAgICAgICAgICAgICAgICBcInJlYWN0LWRhdGVwaWNrZXJfX3F1YXJ0ZXItdGV4dC0tcmFuZ2Utc3RhcnRcIjogX3RoaXMuaXNSYW5nZVN0YXJ0UXVhcnRlcihxKSxcbiAgICAgICAgICAgICAgICBcInJlYWN0LWRhdGVwaWNrZXJfX3F1YXJ0ZXItdGV4dC0tcmFuZ2UtZW5kXCI6IF90aGlzLmlzUmFuZ2VFbmRRdWFydGVyKHEpLFxuICAgICAgICAgICAgICAgIFwicmVhY3QtZGF0ZXBpY2tlcl9fcXVhcnRlci10ZXh0LS10b2RheVwiOiBfdGhpcy5pc0N1cnJlbnRRdWFydGVyKGRheSwgcSksXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfTtcbiAgICAgICAgX3RoaXMuZ2V0TW9udGhDb250ZW50ID0gZnVuY3Rpb24gKG0pIHtcbiAgICAgICAgICAgIHZhciBfYSA9IF90aGlzLnByb3BzLCBzaG93RnVsbE1vbnRoWWVhclBpY2tlciA9IF9hLnNob3dGdWxsTW9udGhZZWFyUGlja2VyLCByZW5kZXJNb250aENvbnRlbnQgPSBfYS5yZW5kZXJNb250aENvbnRlbnQsIGxvY2FsZSA9IF9hLmxvY2FsZSwgZGF5ID0gX2EuZGF5O1xuICAgICAgICAgICAgdmFyIHNob3J0TW9udGhUZXh0ID0gZ2V0TW9udGhTaG9ydEluTG9jYWxlKG0sIGxvY2FsZSk7XG4gICAgICAgICAgICB2YXIgZnVsbE1vbnRoVGV4dCA9IGdldE1vbnRoSW5Mb2NhbGUobSwgbG9jYWxlKTtcbiAgICAgICAgICAgIGlmIChyZW5kZXJNb250aENvbnRlbnQpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gcmVuZGVyTW9udGhDb250ZW50KG0sIHNob3J0TW9udGhUZXh0LCBmdWxsTW9udGhUZXh0LCBkYXkpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIHNob3dGdWxsTW9udGhZZWFyUGlja2VyID8gZnVsbE1vbnRoVGV4dCA6IHNob3J0TW9udGhUZXh0O1xuICAgICAgICB9O1xuICAgICAgICBfdGhpcy5nZXRRdWFydGVyQ29udGVudCA9IGZ1bmN0aW9uIChxKSB7XG4gICAgICAgICAgICB2YXIgX2E7XG4gICAgICAgICAgICB2YXIgX2IgPSBfdGhpcy5wcm9wcywgcmVuZGVyUXVhcnRlckNvbnRlbnQgPSBfYi5yZW5kZXJRdWFydGVyQ29udGVudCwgbG9jYWxlID0gX2IubG9jYWxlO1xuICAgICAgICAgICAgdmFyIHNob3J0UXVhcnRlciA9IGdldFF1YXJ0ZXJTaG9ydEluTG9jYWxlKHEsIGxvY2FsZSk7XG4gICAgICAgICAgICByZXR1cm4gKF9hID0gcmVuZGVyUXVhcnRlckNvbnRlbnQgPT09IG51bGwgfHwgcmVuZGVyUXVhcnRlckNvbnRlbnQgPT09IHZvaWQgMCA/IHZvaWQgMCA6IHJlbmRlclF1YXJ0ZXJDb250ZW50KHEsIHNob3J0UXVhcnRlcikpICE9PSBudWxsICYmIF9hICE9PSB2b2lkIDAgPyBfYSA6IHNob3J0UXVhcnRlcjtcbiAgICAgICAgfTtcbiAgICAgICAgX3RoaXMucmVuZGVyTW9udGhzID0gZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgdmFyIF9hO1xuICAgICAgICAgICAgdmFyIF9iID0gX3RoaXMucHJvcHMsIHNob3dUd29Db2x1bW5Nb250aFllYXJQaWNrZXIgPSBfYi5zaG93VHdvQ29sdW1uTW9udGhZZWFyUGlja2VyLCBzaG93Rm91ckNvbHVtbk1vbnRoWWVhclBpY2tlciA9IF9iLnNob3dGb3VyQ29sdW1uTW9udGhZZWFyUGlja2VyLCBkYXkgPSBfYi5kYXksIHNlbGVjdGVkID0gX2Iuc2VsZWN0ZWQ7XG4gICAgICAgICAgICB2YXIgbW9udGhDb2x1bW5zID0gKF9hID0gTU9OVEhfQ09MVU1OU1tnZXRNb250aENvbHVtbnNMYXlvdXQoc2hvd0ZvdXJDb2x1bW5Nb250aFllYXJQaWNrZXIsIHNob3dUd29Db2x1bW5Nb250aFllYXJQaWNrZXIpXSkgPT09IG51bGwgfHwgX2EgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9hLmdyaWQ7XG4gICAgICAgICAgICByZXR1cm4gbW9udGhDb2x1bW5zID09PSBudWxsIHx8IG1vbnRoQ29sdW1ucyA9PT0gdm9pZCAwID8gdm9pZCAwIDogbW9udGhDb2x1bW5zLm1hcChmdW5jdGlvbiAobW9udGgsIGkpIHsgcmV0dXJuIChSZWFjdC5jcmVhdGVFbGVtZW50KFwiZGl2XCIsIHsgY2xhc3NOYW1lOiBcInJlYWN0LWRhdGVwaWNrZXJfX21vbnRoLXdyYXBwZXJcIiwga2V5OiBpIH0sIG1vbnRoLm1hcChmdW5jdGlvbiAobSwgaikgeyByZXR1cm4gKFJlYWN0LmNyZWF0ZUVsZW1lbnQoXCJkaXZcIiwgeyByZWY6IF90aGlzLk1PTlRIX1JFRlNbbV0sIGtleTogaiwgb25DbGljazogZnVuY3Rpb24gKGV2ZW50KSB7XG4gICAgICAgICAgICAgICAgICAgIF90aGlzLm9uTW9udGhDbGljayhldmVudCwgbSk7XG4gICAgICAgICAgICAgICAgfSwgb25LZXlEb3duOiBmdW5jdGlvbiAoZXZlbnQpIHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKGlzU3BhY2VLZXlEb3duKGV2ZW50KSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgZXZlbnQucHJldmVudERlZmF1bHQoKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGV2ZW50LmtleSA9IEtleVR5cGUuRW50ZXI7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgX3RoaXMub25Nb250aEtleURvd24oZXZlbnQsIG0pO1xuICAgICAgICAgICAgICAgIH0sIG9uTW91c2VFbnRlcjogIV90aGlzLnByb3BzLnVzZVBvaW50ZXJFdmVudFxuICAgICAgICAgICAgICAgICAgICA/IGZ1bmN0aW9uICgpIHsgcmV0dXJuIF90aGlzLm9uTW9udGhNb3VzZUVudGVyKG0pOyB9XG4gICAgICAgICAgICAgICAgICAgIDogdW5kZWZpbmVkLCBvblBvaW50ZXJFbnRlcjogX3RoaXMucHJvcHMudXNlUG9pbnRlckV2ZW50XG4gICAgICAgICAgICAgICAgICAgID8gZnVuY3Rpb24gKCkgeyByZXR1cm4gX3RoaXMub25Nb250aE1vdXNlRW50ZXIobSk7IH1cbiAgICAgICAgICAgICAgICAgICAgOiB1bmRlZmluZWQsIHRhYkluZGV4OiBOdW1iZXIoX3RoaXMuZ2V0VGFiSW5kZXgobSkpLCBjbGFzc05hbWU6IF90aGlzLmdldE1vbnRoQ2xhc3NOYW1lcyhtKSwgXCJhcmlhLWRpc2FibGVkXCI6IF90aGlzLmlzTW9udGhEaXNhYmxlZChtKSwgcm9sZTogXCJvcHRpb25cIiwgXCJhcmlhLWxhYmVsXCI6IF90aGlzLmdldEFyaWFMYWJlbChtKSwgXCJhcmlhLWN1cnJlbnRcIjogX3RoaXMuaXNDdXJyZW50TW9udGgoZGF5LCBtKSA/IFwiZGF0ZVwiIDogdW5kZWZpbmVkLCBcImFyaWEtc2VsZWN0ZWRcIjogc2VsZWN0ZWQgPyBfdGhpcy5pc1NlbGVjdGVkTW9udGgoZGF5LCBtLCBzZWxlY3RlZCkgOiB1bmRlZmluZWQgfSwgX3RoaXMuZ2V0TW9udGhDb250ZW50KG0pKSk7IH0pKSk7IH0pO1xuICAgICAgICB9O1xuICAgICAgICBfdGhpcy5yZW5kZXJRdWFydGVycyA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIHZhciBfYSA9IF90aGlzLnByb3BzLCBkYXkgPSBfYS5kYXksIHNlbGVjdGVkID0gX2Euc2VsZWN0ZWQ7XG4gICAgICAgICAgICB2YXIgcXVhcnRlcnMgPSBbMSwgMiwgMywgNF07XG4gICAgICAgICAgICByZXR1cm4gKFJlYWN0LmNyZWF0ZUVsZW1lbnQoXCJkaXZcIiwgeyBjbGFzc05hbWU6IFwicmVhY3QtZGF0ZXBpY2tlcl9fcXVhcnRlci13cmFwcGVyXCIgfSwgcXVhcnRlcnMubWFwKGZ1bmN0aW9uIChxLCBqKSB7IHJldHVybiAoUmVhY3QuY3JlYXRlRWxlbWVudChcImRpdlwiLCB7IGtleTogaiwgcmVmOiBfdGhpcy5RVUFSVEVSX1JFRlNbal0sIHJvbGU6IFwib3B0aW9uXCIsIG9uQ2xpY2s6IGZ1bmN0aW9uIChldmVudCkge1xuICAgICAgICAgICAgICAgICAgICBfdGhpcy5vblF1YXJ0ZXJDbGljayhldmVudCwgcSk7XG4gICAgICAgICAgICAgICAgfSwgb25LZXlEb3duOiBmdW5jdGlvbiAoZXZlbnQpIHtcbiAgICAgICAgICAgICAgICAgICAgX3RoaXMub25RdWFydGVyS2V5RG93bihldmVudCwgcSk7XG4gICAgICAgICAgICAgICAgfSwgb25Nb3VzZUVudGVyOiAhX3RoaXMucHJvcHMudXNlUG9pbnRlckV2ZW50XG4gICAgICAgICAgICAgICAgICAgID8gZnVuY3Rpb24gKCkgeyByZXR1cm4gX3RoaXMub25RdWFydGVyTW91c2VFbnRlcihxKTsgfVxuICAgICAgICAgICAgICAgICAgICA6IHVuZGVmaW5lZCwgb25Qb2ludGVyRW50ZXI6IF90aGlzLnByb3BzLnVzZVBvaW50ZXJFdmVudFxuICAgICAgICAgICAgICAgICAgICA/IGZ1bmN0aW9uICgpIHsgcmV0dXJuIF90aGlzLm9uUXVhcnRlck1vdXNlRW50ZXIocSk7IH1cbiAgICAgICAgICAgICAgICAgICAgOiB1bmRlZmluZWQsIGNsYXNzTmFtZTogX3RoaXMuZ2V0UXVhcnRlckNsYXNzTmFtZXMocSksIFwiYXJpYS1zZWxlY3RlZFwiOiBzZWxlY3RlZCA/IF90aGlzLmlzU2VsZWN0ZWRRdWFydGVyKGRheSwgcSwgc2VsZWN0ZWQpIDogdW5kZWZpbmVkLCB0YWJJbmRleDogTnVtYmVyKF90aGlzLmdldFF1YXJ0ZXJUYWJJbmRleChxKSksIFwiYXJpYS1jdXJyZW50XCI6IF90aGlzLmlzQ3VycmVudFF1YXJ0ZXIoZGF5LCBxKSA/IFwiZGF0ZVwiIDogdW5kZWZpbmVkIH0sIF90aGlzLmdldFF1YXJ0ZXJDb250ZW50KHEpKSk7IH0pKSk7XG4gICAgICAgIH07XG4gICAgICAgIF90aGlzLmdldENsYXNzTmFtZXMgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICB2YXIgX2EgPSBfdGhpcy5wcm9wcywgc2VsZWN0aW5nRGF0ZSA9IF9hLnNlbGVjdGluZ0RhdGUsIHNlbGVjdHNTdGFydCA9IF9hLnNlbGVjdHNTdGFydCwgc2VsZWN0c0VuZCA9IF9hLnNlbGVjdHNFbmQsIHNob3dNb250aFllYXJQaWNrZXIgPSBfYS5zaG93TW9udGhZZWFyUGlja2VyLCBzaG93UXVhcnRlclllYXJQaWNrZXIgPSBfYS5zaG93UXVhcnRlclllYXJQaWNrZXIsIHNob3dXZWVrUGlja2VyID0gX2Euc2hvd1dlZWtQaWNrZXI7XG4gICAgICAgICAgICByZXR1cm4gY2xzeChcInJlYWN0LWRhdGVwaWNrZXJfX21vbnRoXCIsIHtcbiAgICAgICAgICAgICAgICBcInJlYWN0LWRhdGVwaWNrZXJfX21vbnRoLS1zZWxlY3RpbmctcmFuZ2VcIjogc2VsZWN0aW5nRGF0ZSAmJiAoc2VsZWN0c1N0YXJ0IHx8IHNlbGVjdHNFbmQpLFxuICAgICAgICAgICAgfSwgeyBcInJlYWN0LWRhdGVwaWNrZXJfX21vbnRoUGlja2VyXCI6IHNob3dNb250aFllYXJQaWNrZXIgfSwgeyBcInJlYWN0LWRhdGVwaWNrZXJfX3F1YXJ0ZXJQaWNrZXJcIjogc2hvd1F1YXJ0ZXJZZWFyUGlja2VyIH0sIHsgXCJyZWFjdC1kYXRlcGlja2VyX193ZWVrUGlja2VyXCI6IHNob3dXZWVrUGlja2VyIH0pO1xuICAgICAgICB9O1xuICAgICAgICByZXR1cm4gX3RoaXM7XG4gICAgfVxuICAgIE1vbnRoLnByb3RvdHlwZS5nZXRTZWxlY3Rpb24gPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHZhciBfYSA9IHRoaXMucHJvcHMsIHNlbGVjdGVkID0gX2Euc2VsZWN0ZWQsIHNlbGVjdGVkRGF0ZXMgPSBfYS5zZWxlY3RlZERhdGVzLCBzZWxlY3RzTXVsdGlwbGUgPSBfYS5zZWxlY3RzTXVsdGlwbGU7XG4gICAgICAgIGlmIChzZWxlY3RzTXVsdGlwbGUpIHtcbiAgICAgICAgICAgIHJldHVybiBzZWxlY3RlZERhdGVzO1xuICAgICAgICB9XG4gICAgICAgIGlmIChzZWxlY3RlZCkge1xuICAgICAgICAgICAgcmV0dXJuIFtzZWxlY3RlZF07XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHVuZGVmaW5lZDtcbiAgICB9O1xuICAgIE1vbnRoLnByb3RvdHlwZS5yZW5kZXIgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHZhciBfYSA9IHRoaXMucHJvcHMsIHNob3dNb250aFllYXJQaWNrZXIgPSBfYS5zaG93TW9udGhZZWFyUGlja2VyLCBzaG93UXVhcnRlclllYXJQaWNrZXIgPSBfYS5zaG93UXVhcnRlclllYXJQaWNrZXIsIGRheSA9IF9hLmRheSwgX2IgPSBfYS5hcmlhTGFiZWxQcmVmaXgsIGFyaWFMYWJlbFByZWZpeCA9IF9iID09PSB2b2lkIDAgPyBcIk1vbnRoIFwiIDogX2I7XG4gICAgICAgIHZhciBmb3JtYXR0ZWRBcmlhTGFiZWxQcmVmaXggPSBhcmlhTGFiZWxQcmVmaXhcbiAgICAgICAgICAgID8gYXJpYUxhYmVsUHJlZml4LnRyaW0oKSArIFwiIFwiXG4gICAgICAgICAgICA6IFwiXCI7XG4gICAgICAgIC8vIEZvcm1hdCBhcmlhLWxhYmVsLCByZXR1cm4gZW1wdHkgc3RyaW5nIGlmIGRhdGUgaXMgaW52YWxpZFxuICAgICAgICB2YXIgZm9ybWF0dGVkQXJpYUxhYmVsID0gaXNWYWxpZChkYXkpXG4gICAgICAgICAgICA/IFwiXCIuY29uY2F0KGZvcm1hdHRlZEFyaWFMYWJlbFByZWZpeCkuY29uY2F0KGZvcm1hdERhdGUoZGF5LCBcIk1NTU0sIHl5eXlcIiwgdGhpcy5wcm9wcy5sb2NhbGUpKVxuICAgICAgICAgICAgOiBcIlwiO1xuICAgICAgICB2YXIgc2hvdWxkVXNlTGlzdGJveFJvbGUgPSBzaG93TW9udGhZZWFyUGlja2VyIHx8IHNob3dRdWFydGVyWWVhclBpY2tlcjtcbiAgICAgICAgaWYgKHNob3VsZFVzZUxpc3Rib3hSb2xlKSB7XG4gICAgICAgICAgICByZXR1cm4gKFJlYWN0LmNyZWF0ZUVsZW1lbnQoXCJkaXZcIiwgeyBjbGFzc05hbWU6IHRoaXMuZ2V0Q2xhc3NOYW1lcygpLCBvbk1vdXNlTGVhdmU6ICF0aGlzLnByb3BzLnVzZVBvaW50ZXJFdmVudCA/IHRoaXMuaGFuZGxlTW91c2VMZWF2ZSA6IHVuZGVmaW5lZCwgb25Qb2ludGVyTGVhdmU6IHRoaXMucHJvcHMudXNlUG9pbnRlckV2ZW50ID8gdGhpcy5oYW5kbGVNb3VzZUxlYXZlIDogdW5kZWZpbmVkLCBcImFyaWEtbGFiZWxcIjogZm9ybWF0dGVkQXJpYUxhYmVsLCByb2xlOiBcImxpc3Rib3hcIiB9LCBzaG93TW9udGhZZWFyUGlja2VyID8gdGhpcy5yZW5kZXJNb250aHMoKSA6IHRoaXMucmVuZGVyUXVhcnRlcnMoKSkpO1xuICAgICAgICB9XG4gICAgICAgIC8vIEZvciByZWd1bGFyIGNhbGVuZGFyIHZpZXcsIHVzZSB0YWJsZSBzdHJ1Y3R1cmVcbiAgICAgICAgcmV0dXJuIChSZWFjdC5jcmVhdGVFbGVtZW50KFwiZGl2XCIsIHsgcm9sZTogXCJ0YWJsZVwiIH0sXG4gICAgICAgICAgICB0aGlzLnByb3BzLmRheU5hbWVzSGVhZGVyICYmIChSZWFjdC5jcmVhdGVFbGVtZW50KFwiZGl2XCIsIHsgcm9sZTogXCJyb3dncm91cFwiIH0sIHRoaXMucHJvcHMuZGF5TmFtZXNIZWFkZXIpKSxcbiAgICAgICAgICAgIFJlYWN0LmNyZWF0ZUVsZW1lbnQoXCJkaXZcIiwgeyBjbGFzc05hbWU6IHRoaXMuZ2V0Q2xhc3NOYW1lcygpLCBvbk1vdXNlTGVhdmU6ICF0aGlzLnByb3BzLnVzZVBvaW50ZXJFdmVudCA/IHRoaXMuaGFuZGxlTW91c2VMZWF2ZSA6IHVuZGVmaW5lZCwgb25Qb2ludGVyTGVhdmU6IHRoaXMucHJvcHMudXNlUG9pbnRlckV2ZW50ID8gdGhpcy5oYW5kbGVNb3VzZUxlYXZlIDogdW5kZWZpbmVkLCBcImFyaWEtbGFiZWxcIjogZm9ybWF0dGVkQXJpYUxhYmVsLCByb2xlOiBcInJvd2dyb3VwXCIgfSwgdGhpcy5yZW5kZXJXZWVrcygpKSkpO1xuICAgIH07XG4gICAgcmV0dXJuIE1vbnRoO1xufShDb21wb25lbnQpKTtcblxudmFyIE1vbnRoRHJvcGRvd25PcHRpb25zID0gLyoqIEBjbGFzcyAqLyAoZnVuY3Rpb24gKF9zdXBlcikge1xuICAgIF9fZXh0ZW5kcyhNb250aERyb3Bkb3duT3B0aW9ucywgX3N1cGVyKTtcbiAgICBmdW5jdGlvbiBNb250aERyb3Bkb3duT3B0aW9ucygpIHtcbiAgICAgICAgdmFyIF90aGlzID0gX3N1cGVyICE9PSBudWxsICYmIF9zdXBlci5hcHBseSh0aGlzLCBhcmd1bWVudHMpIHx8IHRoaXM7XG4gICAgICAgIF90aGlzLm1vbnRoT3B0aW9uQnV0dG9uc1JlZiA9IHt9O1xuICAgICAgICBfdGhpcy5pc1NlbGVjdGVkTW9udGggPSBmdW5jdGlvbiAoaSkgeyByZXR1cm4gX3RoaXMucHJvcHMubW9udGggPT09IGk7IH07XG4gICAgICAgIF90aGlzLmhhbmRsZU9wdGlvbktleURvd24gPSBmdW5jdGlvbiAoaSwgZSkge1xuICAgICAgICAgICAgdmFyIF9hO1xuICAgICAgICAgICAgc3dpdGNoIChlLmtleSkge1xuICAgICAgICAgICAgICAgIGNhc2UgXCJFbnRlclwiOlxuICAgICAgICAgICAgICAgICAgICBlLnByZXZlbnREZWZhdWx0KCk7XG4gICAgICAgICAgICAgICAgICAgIF90aGlzLm9uQ2hhbmdlKGkpO1xuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICBjYXNlIFwiRXNjYXBlXCI6XG4gICAgICAgICAgICAgICAgICAgIGUucHJldmVudERlZmF1bHQoKTtcbiAgICAgICAgICAgICAgICAgICAgX3RoaXMucHJvcHMub25DYW5jZWwoKTtcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgY2FzZSBcIkFycm93VXBcIjpcbiAgICAgICAgICAgICAgICBjYXNlIFwiQXJyb3dEb3duXCI6IHtcbiAgICAgICAgICAgICAgICAgICAgZS5wcmV2ZW50RGVmYXVsdCgpO1xuICAgICAgICAgICAgICAgICAgICB2YXIgbmV3TW9udGggPSAoaSArIChlLmtleSA9PT0gXCJBcnJvd1VwXCIgPyAtMSA6IDEpICsgX3RoaXMucHJvcHMubW9udGhOYW1lcy5sZW5ndGgpICVcbiAgICAgICAgICAgICAgICAgICAgICAgIF90aGlzLnByb3BzLm1vbnRoTmFtZXMubGVuZ3RoO1xuICAgICAgICAgICAgICAgICAgICAoX2EgPSBfdGhpcy5tb250aE9wdGlvbkJ1dHRvbnNSZWZbbmV3TW9udGhdKSA9PT0gbnVsbCB8fCBfYSA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2EuZm9jdXMoKTtcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9O1xuICAgICAgICBfdGhpcy5yZW5kZXJPcHRpb25zID0gZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgLy8gQ2xlYXIgcmVmcyB0byBwcmV2ZW50IG1lbW9yeSBsZWFrcyBvbiByZS1yZW5kZXJcbiAgICAgICAgICAgIF90aGlzLm1vbnRoT3B0aW9uQnV0dG9uc1JlZiA9IHt9O1xuICAgICAgICAgICAgcmV0dXJuIF90aGlzLnByb3BzLm1vbnRoTmFtZXMubWFwKGZ1bmN0aW9uIChtb250aCwgaSkgeyByZXR1cm4gKFJlYWN0LmNyZWF0ZUVsZW1lbnQoXCJkaXZcIiwgeyByZWY6IGZ1bmN0aW9uIChlbCkge1xuICAgICAgICAgICAgICAgICAgICBfdGhpcy5tb250aE9wdGlvbkJ1dHRvbnNSZWZbaV0gPSBlbDtcbiAgICAgICAgICAgICAgICAgICAgaWYgKF90aGlzLmlzU2VsZWN0ZWRNb250aChpKSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgZWwgPT09IG51bGwgfHwgZWwgPT09IHZvaWQgMCA/IHZvaWQgMCA6IGVsLmZvY3VzKCk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9LCByb2xlOiBcImJ1dHRvblwiLCB0YWJJbmRleDogMCwgY2xhc3NOYW1lOiBfdGhpcy5pc1NlbGVjdGVkTW9udGgoaSlcbiAgICAgICAgICAgICAgICAgICAgPyBcInJlYWN0LWRhdGVwaWNrZXJfX21vbnRoLW9wdGlvbiByZWFjdC1kYXRlcGlja2VyX19tb250aC1vcHRpb24tLXNlbGVjdGVkX21vbnRoXCJcbiAgICAgICAgICAgICAgICAgICAgOiBcInJlYWN0LWRhdGVwaWNrZXJfX21vbnRoLW9wdGlvblwiLCBrZXk6IG1vbnRoLCBvbkNsaWNrOiBfdGhpcy5vbkNoYW5nZS5iaW5kKF90aGlzLCBpKSwgb25LZXlEb3duOiBfdGhpcy5oYW5kbGVPcHRpb25LZXlEb3duLmJpbmQoX3RoaXMsIGkpLCBcImFyaWEtc2VsZWN0ZWRcIjogX3RoaXMuaXNTZWxlY3RlZE1vbnRoKGkpID8gXCJ0cnVlXCIgOiB1bmRlZmluZWQgfSxcbiAgICAgICAgICAgICAgICBfdGhpcy5pc1NlbGVjdGVkTW9udGgoaSkgPyAoUmVhY3QuY3JlYXRlRWxlbWVudChcInNwYW5cIiwgeyBjbGFzc05hbWU6IFwicmVhY3QtZGF0ZXBpY2tlcl9fbW9udGgtb3B0aW9uLS1zZWxlY3RlZFwiIH0sIFwiXFx1MjcxM1wiKSkgOiAoXCJcIiksXG4gICAgICAgICAgICAgICAgbW9udGgpKTsgfSk7XG4gICAgICAgIH07XG4gICAgICAgIF90aGlzLm9uQ2hhbmdlID0gZnVuY3Rpb24gKG1vbnRoKSB7IHJldHVybiBfdGhpcy5wcm9wcy5vbkNoYW5nZShtb250aCk7IH07XG4gICAgICAgIF90aGlzLmhhbmRsZUNsaWNrT3V0c2lkZSA9IGZ1bmN0aW9uICgpIHsgcmV0dXJuIF90aGlzLnByb3BzLm9uQ2FuY2VsKCk7IH07XG4gICAgICAgIHJldHVybiBfdGhpcztcbiAgICB9XG4gICAgTW9udGhEcm9wZG93bk9wdGlvbnMucHJvdG90eXBlLnJlbmRlciA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgcmV0dXJuIChSZWFjdC5jcmVhdGVFbGVtZW50KENsaWNrT3V0c2lkZVdyYXBwZXIsIHsgY2xhc3NOYW1lOiBcInJlYWN0LWRhdGVwaWNrZXJfX21vbnRoLWRyb3Bkb3duXCIsIG9uQ2xpY2tPdXRzaWRlOiB0aGlzLmhhbmRsZUNsaWNrT3V0c2lkZSB9LCB0aGlzLnJlbmRlck9wdGlvbnMoKSkpO1xuICAgIH07XG4gICAgcmV0dXJuIE1vbnRoRHJvcGRvd25PcHRpb25zO1xufShDb21wb25lbnQpKTtcblxudmFyIE1vbnRoRHJvcGRvd24gPSAvKiogQGNsYXNzICovIChmdW5jdGlvbiAoX3N1cGVyKSB7XG4gICAgX19leHRlbmRzKE1vbnRoRHJvcGRvd24sIF9zdXBlcik7XG4gICAgZnVuY3Rpb24gTW9udGhEcm9wZG93bigpIHtcbiAgICAgICAgdmFyIF90aGlzID0gX3N1cGVyICE9PSBudWxsICYmIF9zdXBlci5hcHBseSh0aGlzLCBhcmd1bWVudHMpIHx8IHRoaXM7XG4gICAgICAgIF90aGlzLnN0YXRlID0ge1xuICAgICAgICAgICAgZHJvcGRvd25WaXNpYmxlOiBmYWxzZSxcbiAgICAgICAgfTtcbiAgICAgICAgX3RoaXMucmVuZGVyU2VsZWN0T3B0aW9ucyA9IGZ1bmN0aW9uIChtb250aE5hbWVzKSB7XG4gICAgICAgICAgICByZXR1cm4gbW9udGhOYW1lcy5tYXAoZnVuY3Rpb24gKG0sIGkpIHsgcmV0dXJuIChSZWFjdC5jcmVhdGVFbGVtZW50KFwib3B0aW9uXCIsIHsga2V5OiBtLCB2YWx1ZTogaSB9LCBtKSk7IH0pO1xuICAgICAgICB9O1xuICAgICAgICBfdGhpcy5yZW5kZXJTZWxlY3RNb2RlID0gZnVuY3Rpb24gKG1vbnRoTmFtZXMpIHsgcmV0dXJuIChSZWFjdC5jcmVhdGVFbGVtZW50KFwic2VsZWN0XCIsIHsgdmFsdWU6IF90aGlzLnByb3BzLm1vbnRoLCBjbGFzc05hbWU6IFwicmVhY3QtZGF0ZXBpY2tlcl9fbW9udGgtc2VsZWN0XCIsIG9uQ2hhbmdlOiBmdW5jdGlvbiAoZSkgeyByZXR1cm4gX3RoaXMub25DaGFuZ2UocGFyc2VJbnQoZS50YXJnZXQudmFsdWUpKTsgfSB9LCBfdGhpcy5yZW5kZXJTZWxlY3RPcHRpb25zKG1vbnRoTmFtZXMpKSk7IH07XG4gICAgICAgIF90aGlzLnJlbmRlclJlYWRWaWV3ID0gZnVuY3Rpb24gKHZpc2libGUsIG1vbnRoTmFtZXMpIHsgcmV0dXJuIChSZWFjdC5jcmVhdGVFbGVtZW50KFwiYnV0dG9uXCIsIHsga2V5OiBcInJlYWRcIiwgdHlwZTogXCJidXR0b25cIiwgc3R5bGU6IHsgdmlzaWJpbGl0eTogdmlzaWJsZSA/IFwidmlzaWJsZVwiIDogXCJoaWRkZW5cIiB9LCBjbGFzc05hbWU6IFwicmVhY3QtZGF0ZXBpY2tlcl9fbW9udGgtcmVhZC12aWV3XCIsIG9uQ2xpY2s6IF90aGlzLnRvZ2dsZURyb3Bkb3duIH0sXG4gICAgICAgICAgICBSZWFjdC5jcmVhdGVFbGVtZW50KFwic3BhblwiLCB7IGNsYXNzTmFtZTogXCJyZWFjdC1kYXRlcGlja2VyX19tb250aC1yZWFkLXZpZXctLWRvd24tYXJyb3dcIiB9KSxcbiAgICAgICAgICAgIFJlYWN0LmNyZWF0ZUVsZW1lbnQoXCJzcGFuXCIsIHsgY2xhc3NOYW1lOiBcInJlYWN0LWRhdGVwaWNrZXJfX21vbnRoLXJlYWQtdmlldy0tc2VsZWN0ZWQtbW9udGhcIiB9LCBtb250aE5hbWVzW190aGlzLnByb3BzLm1vbnRoXSkpKTsgfTtcbiAgICAgICAgX3RoaXMucmVuZGVyRHJvcGRvd24gPSBmdW5jdGlvbiAobW9udGhOYW1lcykgeyByZXR1cm4gKFJlYWN0LmNyZWF0ZUVsZW1lbnQoTW9udGhEcm9wZG93bk9wdGlvbnMsIF9hc3NpZ24oeyBrZXk6IFwiZHJvcGRvd25cIiB9LCBfdGhpcy5wcm9wcywgeyBtb250aE5hbWVzOiBtb250aE5hbWVzLCBvbkNoYW5nZTogX3RoaXMub25DaGFuZ2UsIG9uQ2FuY2VsOiBfdGhpcy50b2dnbGVEcm9wZG93biB9KSkpOyB9O1xuICAgICAgICBfdGhpcy5yZW5kZXJTY3JvbGxNb2RlID0gZnVuY3Rpb24gKG1vbnRoTmFtZXMpIHtcbiAgICAgICAgICAgIHZhciBkcm9wZG93blZpc2libGUgPSBfdGhpcy5zdGF0ZS5kcm9wZG93blZpc2libGU7XG4gICAgICAgICAgICB2YXIgcmVzdWx0ID0gW190aGlzLnJlbmRlclJlYWRWaWV3KCFkcm9wZG93blZpc2libGUsIG1vbnRoTmFtZXMpXTtcbiAgICAgICAgICAgIGlmIChkcm9wZG93blZpc2libGUpIHtcbiAgICAgICAgICAgICAgICByZXN1bHQudW5zaGlmdChfdGhpcy5yZW5kZXJEcm9wZG93bihtb250aE5hbWVzKSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gcmVzdWx0O1xuICAgICAgICB9O1xuICAgICAgICBfdGhpcy5vbkNoYW5nZSA9IGZ1bmN0aW9uIChtb250aCkge1xuICAgICAgICAgICAgX3RoaXMudG9nZ2xlRHJvcGRvd24oKTtcbiAgICAgICAgICAgIGlmIChtb250aCAhPT0gX3RoaXMucHJvcHMubW9udGgpIHtcbiAgICAgICAgICAgICAgICBfdGhpcy5wcm9wcy5vbkNoYW5nZShtb250aCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH07XG4gICAgICAgIF90aGlzLnRvZ2dsZURyb3Bkb3duID0gZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgcmV0dXJuIF90aGlzLnNldFN0YXRlKHtcbiAgICAgICAgICAgICAgICBkcm9wZG93blZpc2libGU6ICFfdGhpcy5zdGF0ZS5kcm9wZG93blZpc2libGUsXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfTtcbiAgICAgICAgcmV0dXJuIF90aGlzO1xuICAgIH1cbiAgICBNb250aERyb3Bkb3duLnByb3RvdHlwZS5yZW5kZXIgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHZhciBfdGhpcyA9IHRoaXM7XG4gICAgICAgIHZhciBtb250aE5hbWVzID0gWzAsIDEsIDIsIDMsIDQsIDUsIDYsIDcsIDgsIDksIDEwLCAxMV0ubWFwKHRoaXMucHJvcHMudXNlU2hvcnRNb250aEluRHJvcGRvd25cbiAgICAgICAgICAgID8gZnVuY3Rpb24gKG0pIHsgcmV0dXJuIGdldE1vbnRoU2hvcnRJbkxvY2FsZShtLCBfdGhpcy5wcm9wcy5sb2NhbGUpOyB9XG4gICAgICAgICAgICA6IGZ1bmN0aW9uIChtKSB7IHJldHVybiBnZXRNb250aEluTG9jYWxlKG0sIF90aGlzLnByb3BzLmxvY2FsZSk7IH0pO1xuICAgICAgICB2YXIgcmVuZGVyZWREcm9wZG93bjtcbiAgICAgICAgc3dpdGNoICh0aGlzLnByb3BzLmRyb3Bkb3duTW9kZSkge1xuICAgICAgICAgICAgY2FzZSBcInNjcm9sbFwiOlxuICAgICAgICAgICAgICAgIHJlbmRlcmVkRHJvcGRvd24gPSB0aGlzLnJlbmRlclNjcm9sbE1vZGUobW9udGhOYW1lcyk7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICBjYXNlIFwic2VsZWN0XCI6XG4gICAgICAgICAgICAgICAgcmVuZGVyZWREcm9wZG93biA9IHRoaXMucmVuZGVyU2VsZWN0TW9kZShtb250aE5hbWVzKTtcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gKFJlYWN0LmNyZWF0ZUVsZW1lbnQoXCJkaXZcIiwgeyBjbGFzc05hbWU6IFwicmVhY3QtZGF0ZXBpY2tlcl9fbW9udGgtZHJvcGRvd24tY29udGFpbmVyIHJlYWN0LWRhdGVwaWNrZXJfX21vbnRoLWRyb3Bkb3duLWNvbnRhaW5lci0tXCIuY29uY2F0KHRoaXMucHJvcHMuZHJvcGRvd25Nb2RlKSB9LCByZW5kZXJlZERyb3Bkb3duKSk7XG4gICAgfTtcbiAgICByZXR1cm4gTW9udGhEcm9wZG93bjtcbn0oQ29tcG9uZW50KSk7XG5cbmZ1bmN0aW9uIGdlbmVyYXRlTW9udGhZZWFycyhtaW5EYXRlLCBtYXhEYXRlKSB7XG4gICAgdmFyIGxpc3QgPSBbXTtcbiAgICB2YXIgY3VyckRhdGUgPSBnZXRTdGFydE9mTW9udGgobWluRGF0ZSk7XG4gICAgdmFyIGxhc3REYXRlID0gZ2V0U3RhcnRPZk1vbnRoKG1heERhdGUpO1xuICAgIHdoaWxlICghaXNBZnRlcihjdXJyRGF0ZSwgbGFzdERhdGUpKSB7XG4gICAgICAgIGxpc3QucHVzaChuZXdEYXRlKGN1cnJEYXRlKSk7XG4gICAgICAgIGN1cnJEYXRlID0gYWRkTW9udGhzKGN1cnJEYXRlLCAxKTtcbiAgICB9XG4gICAgcmV0dXJuIGxpc3Q7XG59XG52YXIgTW9udGhZZWFyRHJvcGRvd25PcHRpb25zID0gLyoqIEBjbGFzcyAqLyAoZnVuY3Rpb24gKF9zdXBlcikge1xuICAgIF9fZXh0ZW5kcyhNb250aFllYXJEcm9wZG93bk9wdGlvbnMsIF9zdXBlcik7XG4gICAgZnVuY3Rpb24gTW9udGhZZWFyRHJvcGRvd25PcHRpb25zKHByb3BzKSB7XG4gICAgICAgIHZhciBfdGhpcyA9IF9zdXBlci5jYWxsKHRoaXMsIHByb3BzKSB8fCB0aGlzO1xuICAgICAgICBfdGhpcy5yZW5kZXJPcHRpb25zID0gZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgcmV0dXJuIF90aGlzLnN0YXRlLm1vbnRoWWVhcnNMaXN0Lm1hcChmdW5jdGlvbiAobW9udGhZZWFyKSB7XG4gICAgICAgICAgICAgICAgdmFyIG1vbnRoWWVhclBvaW50ID0gZ2V0VGltZShtb250aFllYXIpO1xuICAgICAgICAgICAgICAgIHZhciBpc1NhbWVNb250aFllYXIgPSBpc1NhbWVZZWFyKF90aGlzLnByb3BzLmRhdGUsIG1vbnRoWWVhcikgJiZcbiAgICAgICAgICAgICAgICAgICAgaXNTYW1lTW9udGgoX3RoaXMucHJvcHMuZGF0ZSwgbW9udGhZZWFyKTtcbiAgICAgICAgICAgICAgICByZXR1cm4gKFJlYWN0LmNyZWF0ZUVsZW1lbnQoXCJkaXZcIiwgeyBjbGFzc05hbWU6IGlzU2FtZU1vbnRoWWVhclxuICAgICAgICAgICAgICAgICAgICAgICAgPyBcInJlYWN0LWRhdGVwaWNrZXJfX21vbnRoLXllYXItb3B0aW9uLS1zZWxlY3RlZF9tb250aC15ZWFyXCJcbiAgICAgICAgICAgICAgICAgICAgICAgIDogXCJyZWFjdC1kYXRlcGlja2VyX19tb250aC15ZWFyLW9wdGlvblwiLCBrZXk6IG1vbnRoWWVhclBvaW50LCBvbkNsaWNrOiBfdGhpcy5vbkNoYW5nZS5iaW5kKF90aGlzLCBtb250aFllYXJQb2ludCksIFwiYXJpYS1zZWxlY3RlZFwiOiBpc1NhbWVNb250aFllYXIgPyBcInRydWVcIiA6IHVuZGVmaW5lZCB9LFxuICAgICAgICAgICAgICAgICAgICBpc1NhbWVNb250aFllYXIgPyAoUmVhY3QuY3JlYXRlRWxlbWVudChcInNwYW5cIiwgeyBjbGFzc05hbWU6IFwicmVhY3QtZGF0ZXBpY2tlcl9fbW9udGgteWVhci1vcHRpb24tLXNlbGVjdGVkXCIgfSwgXCJcXHUyNzEzXCIpKSA6IChcIlwiKSxcbiAgICAgICAgICAgICAgICAgICAgZm9ybWF0RGF0ZShtb250aFllYXIsIF90aGlzLnByb3BzLmRhdGVGb3JtYXQsIF90aGlzLnByb3BzLmxvY2FsZSkpKTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9O1xuICAgICAgICBfdGhpcy5vbkNoYW5nZSA9IGZ1bmN0aW9uIChtb250aFllYXIpIHsgcmV0dXJuIF90aGlzLnByb3BzLm9uQ2hhbmdlKG1vbnRoWWVhcik7IH07XG4gICAgICAgIF90aGlzLmhhbmRsZUNsaWNrT3V0c2lkZSA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIF90aGlzLnByb3BzLm9uQ2FuY2VsKCk7XG4gICAgICAgIH07XG4gICAgICAgIF90aGlzLnN0YXRlID0ge1xuICAgICAgICAgICAgbW9udGhZZWFyc0xpc3Q6IGdlbmVyYXRlTW9udGhZZWFycyhfdGhpcy5wcm9wcy5taW5EYXRlLCBfdGhpcy5wcm9wcy5tYXhEYXRlKSxcbiAgICAgICAgfTtcbiAgICAgICAgcmV0dXJuIF90aGlzO1xuICAgIH1cbiAgICBNb250aFllYXJEcm9wZG93bk9wdGlvbnMucHJvdG90eXBlLnJlbmRlciA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdmFyIGRyb3Bkb3duQ2xhc3MgPSBjbHN4KHtcbiAgICAgICAgICAgIFwicmVhY3QtZGF0ZXBpY2tlcl9fbW9udGgteWVhci1kcm9wZG93blwiOiB0cnVlLFxuICAgICAgICAgICAgXCJyZWFjdC1kYXRlcGlja2VyX19tb250aC15ZWFyLWRyb3Bkb3duLS1zY3JvbGxhYmxlXCI6IHRoaXMucHJvcHMuc2Nyb2xsYWJsZU1vbnRoWWVhckRyb3Bkb3duLFxuICAgICAgICB9KTtcbiAgICAgICAgcmV0dXJuIChSZWFjdC5jcmVhdGVFbGVtZW50KENsaWNrT3V0c2lkZVdyYXBwZXIsIHsgY2xhc3NOYW1lOiBkcm9wZG93bkNsYXNzLCBvbkNsaWNrT3V0c2lkZTogdGhpcy5oYW5kbGVDbGlja091dHNpZGUgfSwgdGhpcy5yZW5kZXJPcHRpb25zKCkpKTtcbiAgICB9O1xuICAgIHJldHVybiBNb250aFllYXJEcm9wZG93bk9wdGlvbnM7XG59KENvbXBvbmVudCkpO1xuXG52YXIgTW9udGhZZWFyRHJvcGRvd24gPSAvKiogQGNsYXNzICovIChmdW5jdGlvbiAoX3N1cGVyKSB7XG4gICAgX19leHRlbmRzKE1vbnRoWWVhckRyb3Bkb3duLCBfc3VwZXIpO1xuICAgIGZ1bmN0aW9uIE1vbnRoWWVhckRyb3Bkb3duKCkge1xuICAgICAgICB2YXIgX3RoaXMgPSBfc3VwZXIgIT09IG51bGwgJiYgX3N1cGVyLmFwcGx5KHRoaXMsIGFyZ3VtZW50cykgfHwgdGhpcztcbiAgICAgICAgX3RoaXMuc3RhdGUgPSB7XG4gICAgICAgICAgICBkcm9wZG93blZpc2libGU6IGZhbHNlLFxuICAgICAgICB9O1xuICAgICAgICBfdGhpcy5yZW5kZXJTZWxlY3RPcHRpb25zID0gZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgdmFyIGN1cnJEYXRlID0gZ2V0U3RhcnRPZk1vbnRoKF90aGlzLnByb3BzLm1pbkRhdGUpO1xuICAgICAgICAgICAgdmFyIGxhc3REYXRlID0gZ2V0U3RhcnRPZk1vbnRoKF90aGlzLnByb3BzLm1heERhdGUpO1xuICAgICAgICAgICAgdmFyIG9wdGlvbnMgPSBbXTtcbiAgICAgICAgICAgIHdoaWxlICghaXNBZnRlcihjdXJyRGF0ZSwgbGFzdERhdGUpKSB7XG4gICAgICAgICAgICAgICAgdmFyIHRpbWVQb2ludCA9IGdldFRpbWUoY3VyckRhdGUpO1xuICAgICAgICAgICAgICAgIG9wdGlvbnMucHVzaChSZWFjdC5jcmVhdGVFbGVtZW50KFwib3B0aW9uXCIsIHsga2V5OiB0aW1lUG9pbnQsIHZhbHVlOiB0aW1lUG9pbnQgfSwgZm9ybWF0RGF0ZShjdXJyRGF0ZSwgX3RoaXMucHJvcHMuZGF0ZUZvcm1hdCwgX3RoaXMucHJvcHMubG9jYWxlKSkpO1xuICAgICAgICAgICAgICAgIGN1cnJEYXRlID0gYWRkTW9udGhzKGN1cnJEYXRlLCAxKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiBvcHRpb25zO1xuICAgICAgICB9O1xuICAgICAgICBfdGhpcy5vblNlbGVjdENoYW5nZSA9IGZ1bmN0aW9uIChldmVudCkge1xuICAgICAgICAgICAgX3RoaXMub25DaGFuZ2UocGFyc2VJbnQoZXZlbnQudGFyZ2V0LnZhbHVlKSk7XG4gICAgICAgIH07XG4gICAgICAgIF90aGlzLnJlbmRlclNlbGVjdE1vZGUgPSBmdW5jdGlvbiAoKSB7IHJldHVybiAoUmVhY3QuY3JlYXRlRWxlbWVudChcInNlbGVjdFwiLCB7IHZhbHVlOiBnZXRUaW1lKGdldFN0YXJ0T2ZNb250aChfdGhpcy5wcm9wcy5kYXRlKSksIGNsYXNzTmFtZTogXCJyZWFjdC1kYXRlcGlja2VyX19tb250aC15ZWFyLXNlbGVjdFwiLCBvbkNoYW5nZTogX3RoaXMub25TZWxlY3RDaGFuZ2UgfSwgX3RoaXMucmVuZGVyU2VsZWN0T3B0aW9ucygpKSk7IH07XG4gICAgICAgIF90aGlzLnJlbmRlclJlYWRWaWV3ID0gZnVuY3Rpb24gKHZpc2libGUpIHtcbiAgICAgICAgICAgIHZhciB5ZWFyTW9udGggPSBmb3JtYXREYXRlKF90aGlzLnByb3BzLmRhdGUsIF90aGlzLnByb3BzLmRhdGVGb3JtYXQsIF90aGlzLnByb3BzLmxvY2FsZSk7XG4gICAgICAgICAgICByZXR1cm4gKFJlYWN0LmNyZWF0ZUVsZW1lbnQoXCJkaXZcIiwgeyBrZXk6IFwicmVhZFwiLCBzdHlsZTogeyB2aXNpYmlsaXR5OiB2aXNpYmxlID8gXCJ2aXNpYmxlXCIgOiBcImhpZGRlblwiIH0sIGNsYXNzTmFtZTogXCJyZWFjdC1kYXRlcGlja2VyX19tb250aC15ZWFyLXJlYWQtdmlld1wiLCBvbkNsaWNrOiBfdGhpcy50b2dnbGVEcm9wZG93biB9LFxuICAgICAgICAgICAgICAgIFJlYWN0LmNyZWF0ZUVsZW1lbnQoXCJzcGFuXCIsIHsgY2xhc3NOYW1lOiBcInJlYWN0LWRhdGVwaWNrZXJfX21vbnRoLXllYXItcmVhZC12aWV3LS1kb3duLWFycm93XCIgfSksXG4gICAgICAgICAgICAgICAgUmVhY3QuY3JlYXRlRWxlbWVudChcInNwYW5cIiwgeyBjbGFzc05hbWU6IFwicmVhY3QtZGF0ZXBpY2tlcl9fbW9udGgteWVhci1yZWFkLXZpZXctLXNlbGVjdGVkLW1vbnRoLXllYXJcIiB9LCB5ZWFyTW9udGgpKSk7XG4gICAgICAgIH07XG4gICAgICAgIF90aGlzLnJlbmRlckRyb3Bkb3duID0gZnVuY3Rpb24gKCkgeyByZXR1cm4gKFJlYWN0LmNyZWF0ZUVsZW1lbnQoTW9udGhZZWFyRHJvcGRvd25PcHRpb25zLCBfYXNzaWduKHsga2V5OiBcImRyb3Bkb3duXCIgfSwgX3RoaXMucHJvcHMsIHsgb25DaGFuZ2U6IF90aGlzLm9uQ2hhbmdlLCBvbkNhbmNlbDogX3RoaXMudG9nZ2xlRHJvcGRvd24gfSkpKTsgfTtcbiAgICAgICAgX3RoaXMucmVuZGVyU2Nyb2xsTW9kZSA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIHZhciBkcm9wZG93blZpc2libGUgPSBfdGhpcy5zdGF0ZS5kcm9wZG93blZpc2libGU7XG4gICAgICAgICAgICB2YXIgcmVzdWx0ID0gW190aGlzLnJlbmRlclJlYWRWaWV3KCFkcm9wZG93blZpc2libGUpXTtcbiAgICAgICAgICAgIGlmIChkcm9wZG93blZpc2libGUpIHtcbiAgICAgICAgICAgICAgICByZXN1bHQudW5zaGlmdChfdGhpcy5yZW5kZXJEcm9wZG93bigpKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgICAgIH07XG4gICAgICAgIF90aGlzLm9uQ2hhbmdlID0gZnVuY3Rpb24gKG1vbnRoWWVhclBvaW50KSB7XG4gICAgICAgICAgICBfdGhpcy50b2dnbGVEcm9wZG93bigpO1xuICAgICAgICAgICAgdmFyIGNoYW5nZWREYXRlID0gbmV3RGF0ZShtb250aFllYXJQb2ludCk7XG4gICAgICAgICAgICBpZiAoaXNTYW1lWWVhcihfdGhpcy5wcm9wcy5kYXRlLCBjaGFuZ2VkRGF0ZSkgJiZcbiAgICAgICAgICAgICAgICBpc1NhbWVNb250aChfdGhpcy5wcm9wcy5kYXRlLCBjaGFuZ2VkRGF0ZSkpIHtcbiAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBfdGhpcy5wcm9wcy5vbkNoYW5nZShjaGFuZ2VkRGF0ZSk7XG4gICAgICAgIH07XG4gICAgICAgIF90aGlzLnRvZ2dsZURyb3Bkb3duID0gZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgcmV0dXJuIF90aGlzLnNldFN0YXRlKHtcbiAgICAgICAgICAgICAgICBkcm9wZG93blZpc2libGU6ICFfdGhpcy5zdGF0ZS5kcm9wZG93blZpc2libGUsXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfTtcbiAgICAgICAgcmV0dXJuIF90aGlzO1xuICAgIH1cbiAgICBNb250aFllYXJEcm9wZG93bi5wcm90b3R5cGUucmVuZGVyID0gZnVuY3Rpb24gKCkge1xuICAgICAgICB2YXIgcmVuZGVyZWREcm9wZG93bjtcbiAgICAgICAgc3dpdGNoICh0aGlzLnByb3BzLmRyb3Bkb3duTW9kZSkge1xuICAgICAgICAgICAgY2FzZSBcInNjcm9sbFwiOlxuICAgICAgICAgICAgICAgIHJlbmRlcmVkRHJvcGRvd24gPSB0aGlzLnJlbmRlclNjcm9sbE1vZGUoKTtcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIGNhc2UgXCJzZWxlY3RcIjpcbiAgICAgICAgICAgICAgICByZW5kZXJlZERyb3Bkb3duID0gdGhpcy5yZW5kZXJTZWxlY3RNb2RlKCk7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIChSZWFjdC5jcmVhdGVFbGVtZW50KFwiZGl2XCIsIHsgY2xhc3NOYW1lOiBcInJlYWN0LWRhdGVwaWNrZXJfX21vbnRoLXllYXItZHJvcGRvd24tY29udGFpbmVyIHJlYWN0LWRhdGVwaWNrZXJfX21vbnRoLXllYXItZHJvcGRvd24tY29udGFpbmVyLS1cIi5jb25jYXQodGhpcy5wcm9wcy5kcm9wZG93bk1vZGUpIH0sIHJlbmRlcmVkRHJvcGRvd24pKTtcbiAgICB9O1xuICAgIHJldHVybiBNb250aFllYXJEcm9wZG93bjtcbn0oQ29tcG9uZW50KSk7XG5cbnZhciBUaW1lID0gLyoqIEBjbGFzcyAqLyAoZnVuY3Rpb24gKF9zdXBlcikge1xuICAgIF9fZXh0ZW5kcyhUaW1lLCBfc3VwZXIpO1xuICAgIGZ1bmN0aW9uIFRpbWUoKSB7XG4gICAgICAgIHZhciBfdGhpcyA9IF9zdXBlciAhPT0gbnVsbCAmJiBfc3VwZXIuYXBwbHkodGhpcywgYXJndW1lbnRzKSB8fCB0aGlzO1xuICAgICAgICBfdGhpcy5zdGF0ZSA9IHtcbiAgICAgICAgICAgIGhlaWdodDogbnVsbCxcbiAgICAgICAgfTtcbiAgICAgICAgX3RoaXMuc2Nyb2xsVG9UaGVTZWxlY3RlZFRpbWUgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICByZXF1ZXN0QW5pbWF0aW9uRnJhbWUoZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgICAgIHZhciBfYSwgX2IsIF9jO1xuICAgICAgICAgICAgICAgIGlmICghX3RoaXMubGlzdClcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgICAgIF90aGlzLmxpc3Quc2Nyb2xsVG9wID1cbiAgICAgICAgICAgICAgICAgICAgKF9jID0gKF90aGlzLmNlbnRlckxpICYmXG4gICAgICAgICAgICAgICAgICAgICAgICBUaW1lLmNhbGNDZW50ZXJQb3NpdGlvbihfdGhpcy5wcm9wcy5tb250aFJlZlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgID8gX3RoaXMucHJvcHMubW9udGhSZWYuY2xpZW50SGVpZ2h0IC1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKChfYiA9IChfYSA9IF90aGlzLmhlYWRlcikgPT09IG51bGwgfHwgX2EgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9hLmNsaWVudEhlaWdodCkgIT09IG51bGwgJiYgX2IgIT09IHZvaWQgMCA/IF9iIDogMClcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICA6IF90aGlzLmxpc3QuY2xpZW50SGVpZ2h0LCBfdGhpcy5jZW50ZXJMaSkpKSAhPT0gbnVsbCAmJiBfYyAhPT0gdm9pZCAwID8gX2MgOiAwO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgIH07XG4gICAgICAgIF90aGlzLmhhbmRsZUNsaWNrID0gZnVuY3Rpb24gKHRpbWUpIHtcbiAgICAgICAgICAgIHZhciBfYSwgX2I7XG4gICAgICAgICAgICBpZiAoKChfdGhpcy5wcm9wcy5taW5UaW1lIHx8IF90aGlzLnByb3BzLm1heFRpbWUpICYmXG4gICAgICAgICAgICAgICAgaXNUaW1lSW5EaXNhYmxlZFJhbmdlKHRpbWUsIF90aGlzLnByb3BzKSkgfHxcbiAgICAgICAgICAgICAgICAoKF90aGlzLnByb3BzLmV4Y2x1ZGVUaW1lcyB8fFxuICAgICAgICAgICAgICAgICAgICBfdGhpcy5wcm9wcy5pbmNsdWRlVGltZXMgfHxcbiAgICAgICAgICAgICAgICAgICAgX3RoaXMucHJvcHMuZmlsdGVyVGltZSkgJiZcbiAgICAgICAgICAgICAgICAgICAgaXNUaW1lRGlzYWJsZWQodGltZSwgX3RoaXMucHJvcHMpKSkge1xuICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIChfYiA9IChfYSA9IF90aGlzLnByb3BzKS5vbkNoYW5nZSkgPT09IG51bGwgfHwgX2IgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9iLmNhbGwoX2EsIHRpbWUpO1xuICAgICAgICB9O1xuICAgICAgICBfdGhpcy5pc1NlbGVjdGVkVGltZSA9IGZ1bmN0aW9uICh0aW1lKSB7XG4gICAgICAgICAgICByZXR1cm4gX3RoaXMucHJvcHMuc2VsZWN0ZWQgJiYgaXNTYW1lTWludXRlKF90aGlzLnByb3BzLnNlbGVjdGVkLCB0aW1lKTtcbiAgICAgICAgfTtcbiAgICAgICAgX3RoaXMuaXNEaXNhYmxlZFRpbWUgPSBmdW5jdGlvbiAodGltZSkge1xuICAgICAgICAgICAgcmV0dXJuICgoX3RoaXMucHJvcHMubWluVGltZSB8fCBfdGhpcy5wcm9wcy5tYXhUaW1lKSAmJlxuICAgICAgICAgICAgICAgIGlzVGltZUluRGlzYWJsZWRSYW5nZSh0aW1lLCBfdGhpcy5wcm9wcykpIHx8XG4gICAgICAgICAgICAgICAgKChfdGhpcy5wcm9wcy5leGNsdWRlVGltZXMgfHxcbiAgICAgICAgICAgICAgICAgICAgX3RoaXMucHJvcHMuaW5jbHVkZVRpbWVzIHx8XG4gICAgICAgICAgICAgICAgICAgIF90aGlzLnByb3BzLmZpbHRlclRpbWUpICYmXG4gICAgICAgICAgICAgICAgICAgIGlzVGltZURpc2FibGVkKHRpbWUsIF90aGlzLnByb3BzKSk7XG4gICAgICAgIH07XG4gICAgICAgIF90aGlzLmxpQ2xhc3NlcyA9IGZ1bmN0aW9uICh0aW1lKSB7XG4gICAgICAgICAgICB2YXIgX2E7XG4gICAgICAgICAgICB2YXIgY2xhc3NlcyA9IFtcbiAgICAgICAgICAgICAgICBcInJlYWN0LWRhdGVwaWNrZXJfX3RpbWUtbGlzdC1pdGVtXCIsXG4gICAgICAgICAgICAgICAgX3RoaXMucHJvcHMudGltZUNsYXNzTmFtZSA/IF90aGlzLnByb3BzLnRpbWVDbGFzc05hbWUodGltZSkgOiB1bmRlZmluZWQsXG4gICAgICAgICAgICBdO1xuICAgICAgICAgICAgaWYgKF90aGlzLmlzU2VsZWN0ZWRUaW1lKHRpbWUpKSB7XG4gICAgICAgICAgICAgICAgY2xhc3Nlcy5wdXNoKFwicmVhY3QtZGF0ZXBpY2tlcl9fdGltZS1saXN0LWl0ZW0tLXNlbGVjdGVkXCIpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKF90aGlzLmlzRGlzYWJsZWRUaW1lKHRpbWUpKSB7XG4gICAgICAgICAgICAgICAgY2xhc3Nlcy5wdXNoKFwicmVhY3QtZGF0ZXBpY2tlcl9fdGltZS1saXN0LWl0ZW0tLWRpc2FibGVkXCIpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgLy9jb252ZXJ0IHRoaXMucHJvcHMuaW50ZXJ2YWxzIGFuZCB0aGUgcmVsZXZhbnQgdGltZSB0byBzZWNvbmRzIGFuZCBjaGVjayBpZiBpdCBpdCdzIGEgY2xlYW4gbXVsdGlwbGUgb2YgdGhlIGludGVydmFsXG4gICAgICAgICAgICBpZiAoX3RoaXMucHJvcHMuaW5qZWN0VGltZXMgJiZcbiAgICAgICAgICAgICAgICAoZ2V0SG91cnModGltZSkgKiAzNjAwICsgZ2V0TWludXRlcyh0aW1lKSAqIDYwICsgZ2V0U2Vjb25kcyh0aW1lKSkgJVxuICAgICAgICAgICAgICAgICAgICAoKChfYSA9IF90aGlzLnByb3BzLmludGVydmFscykgIT09IG51bGwgJiYgX2EgIT09IHZvaWQgMCA/IF9hIDogVGltZS5kZWZhdWx0UHJvcHMuaW50ZXJ2YWxzKSAqIDYwKSAhPT1cbiAgICAgICAgICAgICAgICAgICAgMCkge1xuICAgICAgICAgICAgICAgIGNsYXNzZXMucHVzaChcInJlYWN0LWRhdGVwaWNrZXJfX3RpbWUtbGlzdC1pdGVtLS1pbmplY3RlZFwiKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiBjbGFzc2VzLmpvaW4oXCIgXCIpO1xuICAgICAgICB9O1xuICAgICAgICBfdGhpcy5oYW5kbGVPbktleURvd24gPSBmdW5jdGlvbiAoZXZlbnQsIHRpbWUpIHtcbiAgICAgICAgICAgIHZhciBfYSwgX2I7XG4gICAgICAgICAgICBpZiAoZXZlbnQua2V5ID09PSBLZXlUeXBlLlNwYWNlKSB7XG4gICAgICAgICAgICAgICAgZXZlbnQucHJldmVudERlZmF1bHQoKTtcbiAgICAgICAgICAgICAgICBldmVudC5rZXkgPSBLZXlUeXBlLkVudGVyO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKChldmVudC5rZXkgPT09IEtleVR5cGUuQXJyb3dVcCB8fCBldmVudC5rZXkgPT09IEtleVR5cGUuQXJyb3dMZWZ0KSAmJlxuICAgICAgICAgICAgICAgIGV2ZW50LnRhcmdldCBpbnN0YW5jZW9mIEhUTUxFbGVtZW50ICYmXG4gICAgICAgICAgICAgICAgZXZlbnQudGFyZ2V0LnByZXZpb3VzU2libGluZykge1xuICAgICAgICAgICAgICAgIGV2ZW50LnByZXZlbnREZWZhdWx0KCk7XG4gICAgICAgICAgICAgICAgZXZlbnQudGFyZ2V0LnByZXZpb3VzU2libGluZyBpbnN0YW5jZW9mIEhUTUxFbGVtZW50ICYmXG4gICAgICAgICAgICAgICAgICAgIGV2ZW50LnRhcmdldC5wcmV2aW91c1NpYmxpbmcuZm9jdXMoKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmICgoZXZlbnQua2V5ID09PSBLZXlUeXBlLkFycm93RG93biB8fCBldmVudC5rZXkgPT09IEtleVR5cGUuQXJyb3dSaWdodCkgJiZcbiAgICAgICAgICAgICAgICBldmVudC50YXJnZXQgaW5zdGFuY2VvZiBIVE1MRWxlbWVudCAmJlxuICAgICAgICAgICAgICAgIGV2ZW50LnRhcmdldC5uZXh0U2libGluZykge1xuICAgICAgICAgICAgICAgIGV2ZW50LnByZXZlbnREZWZhdWx0KCk7XG4gICAgICAgICAgICAgICAgZXZlbnQudGFyZ2V0Lm5leHRTaWJsaW5nIGluc3RhbmNlb2YgSFRNTEVsZW1lbnQgJiZcbiAgICAgICAgICAgICAgICAgICAgZXZlbnQudGFyZ2V0Lm5leHRTaWJsaW5nLmZvY3VzKCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoZXZlbnQua2V5ID09PSBLZXlUeXBlLkVudGVyKSB7XG4gICAgICAgICAgICAgICAgX3RoaXMuaGFuZGxlQ2xpY2sodGltZSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICAoX2IgPSAoX2EgPSBfdGhpcy5wcm9wcykuaGFuZGxlT25LZXlEb3duKSA9PT0gbnVsbCB8fCBfYiA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2IuY2FsbChfYSwgZXZlbnQpO1xuICAgICAgICB9O1xuICAgICAgICBfdGhpcy5yZW5kZXJUaW1lcyA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIHZhciBfYTtcbiAgICAgICAgICAgIHZhciB0aW1lcyA9IFtdO1xuICAgICAgICAgICAgdmFyIGZvcm1hdCA9IHR5cGVvZiBfdGhpcy5wcm9wcy5mb3JtYXQgPT09IFwic3RyaW5nXCIgPyBfdGhpcy5wcm9wcy5mb3JtYXQgOiBcInBcIjtcbiAgICAgICAgICAgIHZhciBpbnRlcnZhbHMgPSAoX2EgPSBfdGhpcy5wcm9wcy5pbnRlcnZhbHMpICE9PSBudWxsICYmIF9hICE9PSB2b2lkIDAgPyBfYSA6IFRpbWUuZGVmYXVsdFByb3BzLmludGVydmFscztcbiAgICAgICAgICAgIHZhciBhY3RpdmVEYXRlID0gX3RoaXMucHJvcHMuc2VsZWN0ZWQgfHwgX3RoaXMucHJvcHMub3BlblRvRGF0ZSB8fCBuZXdEYXRlKCk7XG4gICAgICAgICAgICB2YXIgYmFzZSA9IGdldFN0YXJ0T2ZEYXkoYWN0aXZlRGF0ZSk7XG4gICAgICAgICAgICB2YXIgc29ydGVkSW5qZWN0VGltZXMgPSBfdGhpcy5wcm9wcy5pbmplY3RUaW1lcyAmJlxuICAgICAgICAgICAgICAgIF90aGlzLnByb3BzLmluamVjdFRpbWVzLnNvcnQoZnVuY3Rpb24gKGEsIGIpIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGEuZ2V0VGltZSgpIC0gYi5nZXRUaW1lKCk7XG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB2YXIgbWludXRlc0luRGF5ID0gNjAgKiBnZXRIb3Vyc0luRGF5KGFjdGl2ZURhdGUpO1xuICAgICAgICAgICAgdmFyIG11bHRpcGxpZXIgPSBtaW51dGVzSW5EYXkgLyBpbnRlcnZhbHM7XG4gICAgICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IG11bHRpcGxpZXI7IGkrKykge1xuICAgICAgICAgICAgICAgIHZhciBjdXJyZW50VGltZSA9IGFkZE1pbnV0ZXMoYmFzZSwgaSAqIGludGVydmFscyk7XG4gICAgICAgICAgICAgICAgdGltZXMucHVzaChjdXJyZW50VGltZSk7XG4gICAgICAgICAgICAgICAgaWYgKHNvcnRlZEluamVjdFRpbWVzKSB7XG4gICAgICAgICAgICAgICAgICAgIHZhciB0aW1lc1RvSW5qZWN0ID0gdGltZXNUb0luamVjdEFmdGVyKGJhc2UsIGN1cnJlbnRUaW1lLCBpLCBpbnRlcnZhbHMsIHNvcnRlZEluamVjdFRpbWVzKTtcbiAgICAgICAgICAgICAgICAgICAgdGltZXMgPSB0aW1lcy5jb25jYXQodGltZXNUb0luamVjdCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgLy8gRGV0ZXJtaW5lIHdoaWNoIHRpbWUgdG8gZm9jdXMgYW5kIHNjcm9sbCBpbnRvIHZpZXcgd2hlbiBjb21wb25lbnQgbW91bnRzXG4gICAgICAgICAgICB2YXIgdGltZVRvRm9jdXMgPSB0aW1lcy5yZWR1Y2UoZnVuY3Rpb24gKHByZXYsIHRpbWUpIHtcbiAgICAgICAgICAgICAgICBpZiAodGltZS5nZXRUaW1lKCkgPD0gYWN0aXZlRGF0ZS5nZXRUaW1lKCkpIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHRpbWU7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHJldHVybiBwcmV2O1xuICAgICAgICAgICAgfSwgdGltZXNbMF0pO1xuICAgICAgICAgICAgcmV0dXJuIHRpbWVzLm1hcChmdW5jdGlvbiAodGltZSkge1xuICAgICAgICAgICAgICAgIHJldHVybiAoUmVhY3QuY3JlYXRlRWxlbWVudChcImxpXCIsIHsga2V5OiB0aW1lLnZhbHVlT2YoKSwgb25DbGljazogX3RoaXMuaGFuZGxlQ2xpY2suYmluZChfdGhpcywgdGltZSksIGNsYXNzTmFtZTogX3RoaXMubGlDbGFzc2VzKHRpbWUpLCByZWY6IGZ1bmN0aW9uIChsaSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKHRpbWUgPT09IHRpbWVUb0ZvY3VzKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgX3RoaXMuY2VudGVyTGkgPSBsaTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgfSwgb25LZXlEb3duOiBmdW5jdGlvbiAoZXZlbnQpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIF90aGlzLmhhbmRsZU9uS2V5RG93bihldmVudCwgdGltZSk7XG4gICAgICAgICAgICAgICAgICAgIH0sIHRhYkluZGV4OiB0aW1lID09PSB0aW1lVG9Gb2N1cyA/IDAgOiAtMSwgcm9sZTogXCJvcHRpb25cIiwgXCJhcmlhLXNlbGVjdGVkXCI6IF90aGlzLmlzU2VsZWN0ZWRUaW1lKHRpbWUpID8gXCJ0cnVlXCIgOiB1bmRlZmluZWQsIFwiYXJpYS1kaXNhYmxlZFwiOiBfdGhpcy5pc0Rpc2FibGVkVGltZSh0aW1lKSA/IFwidHJ1ZVwiIDogdW5kZWZpbmVkIH0sIGZvcm1hdERhdGUodGltZSwgZm9ybWF0LCBfdGhpcy5wcm9wcy5sb2NhbGUpKSk7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfTtcbiAgICAgICAgX3RoaXMucmVuZGVyVGltZUNhcHRpb24gPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICBpZiAoX3RoaXMucHJvcHMuc2hvd1RpbWVDYXB0aW9uID09PSBmYWxzZSkge1xuICAgICAgICAgICAgICAgIHJldHVybiBSZWFjdC5jcmVhdGVFbGVtZW50KFJlYWN0LkZyYWdtZW50LCBudWxsKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiAoUmVhY3QuY3JlYXRlRWxlbWVudChcImRpdlwiLCB7IGNsYXNzTmFtZTogXCJyZWFjdC1kYXRlcGlja2VyX19oZWFkZXIgcmVhY3QtZGF0ZXBpY2tlcl9faGVhZGVyLS10aW1lIFwiLmNvbmNhdChfdGhpcy5wcm9wcy5zaG93VGltZVNlbGVjdE9ubHlcbiAgICAgICAgICAgICAgICAgICAgPyBcInJlYWN0LWRhdGVwaWNrZXJfX2hlYWRlci0tdGltZS0tb25seVwiXG4gICAgICAgICAgICAgICAgICAgIDogXCJcIiksIHJlZjogZnVuY3Rpb24gKGhlYWRlcikge1xuICAgICAgICAgICAgICAgICAgICBfdGhpcy5oZWFkZXIgPSBoZWFkZXI7XG4gICAgICAgICAgICAgICAgfSB9LFxuICAgICAgICAgICAgICAgIFJlYWN0LmNyZWF0ZUVsZW1lbnQoXCJkaXZcIiwgeyBjbGFzc05hbWU6IFwicmVhY3QtZGF0ZXBpY2tlci10aW1lX19oZWFkZXJcIiB9LCBfdGhpcy5wcm9wcy50aW1lQ2FwdGlvbikpKTtcbiAgICAgICAgfTtcbiAgICAgICAgcmV0dXJuIF90aGlzO1xuICAgIH1cbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoVGltZSwgXCJkZWZhdWx0UHJvcHNcIiwge1xuICAgICAgICBnZXQ6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICAgICAgaW50ZXJ2YWxzOiAzMCxcbiAgICAgICAgICAgICAgICB0b2RheUJ1dHRvbjogbnVsbCxcbiAgICAgICAgICAgICAgICB0aW1lQ2FwdGlvbjogXCJUaW1lXCIsXG4gICAgICAgICAgICAgICAgc2hvd1RpbWVDYXB0aW9uOiB0cnVlLFxuICAgICAgICAgICAgfTtcbiAgICAgICAgfSxcbiAgICAgICAgZW51bWVyYWJsZTogZmFsc2UsXG4gICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZVxuICAgIH0pO1xuICAgIFRpbWUucHJvdG90eXBlLmNvbXBvbmVudERpZE1vdW50ID0gZnVuY3Rpb24gKCkge1xuICAgICAgICAvLyBjb2RlIHRvIGVuc3VyZSBzZWxlY3RlZCB0aW1lIHdpbGwgYWx3YXlzIGJlIGluIGZvY3VzIHdpdGhpbiB0aW1lIHdpbmRvdyB3aGVuIGl0IGZpcnN0IGFwcGVhcnNcbiAgICAgICAgdGhpcy5zY3JvbGxUb1RoZVNlbGVjdGVkVGltZSgpO1xuICAgICAgICB0aGlzLm9ic2VydmVEYXRlUGlja2VySGVpZ2h0Q2hhbmdlcygpO1xuICAgIH07XG4gICAgVGltZS5wcm90b3R5cGUuY29tcG9uZW50V2lsbFVubW91bnQgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHZhciBfYTtcbiAgICAgICAgKF9hID0gdGhpcy5yZXNpemVPYnNlcnZlcikgPT09IG51bGwgfHwgX2EgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9hLmRpc2Nvbm5lY3QoKTtcbiAgICB9O1xuICAgIFRpbWUucHJvdG90eXBlLm9ic2VydmVEYXRlUGlja2VySGVpZ2h0Q2hhbmdlcyA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdmFyIF90aGlzID0gdGhpcztcbiAgICAgICAgdmFyIG1vbnRoUmVmID0gdGhpcy5wcm9wcy5tb250aFJlZjtcbiAgICAgICAgdGhpcy51cGRhdGVDb250YWluZXJIZWlnaHQoKTtcbiAgICAgICAgaWYgKG1vbnRoUmVmKSB7XG4gICAgICAgICAgICB0aGlzLnJlc2l6ZU9ic2VydmVyID0gbmV3IFJlc2l6ZU9ic2VydmVyKGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgICAgICBfdGhpcy51cGRhdGVDb250YWluZXJIZWlnaHQoKTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgdGhpcy5yZXNpemVPYnNlcnZlci5vYnNlcnZlKG1vbnRoUmVmKTtcbiAgICAgICAgfVxuICAgIH07XG4gICAgVGltZS5wcm90b3R5cGUudXBkYXRlQ29udGFpbmVySGVpZ2h0ID0gZnVuY3Rpb24gKCkge1xuICAgICAgICBpZiAodGhpcy5wcm9wcy5tb250aFJlZiAmJiB0aGlzLmhlYWRlcikge1xuICAgICAgICAgICAgdGhpcy5zZXRTdGF0ZSh7XG4gICAgICAgICAgICAgICAgaGVpZ2h0OiB0aGlzLnByb3BzLm1vbnRoUmVmLmNsaWVudEhlaWdodCAtIHRoaXMuaGVhZGVyLmNsaWVudEhlaWdodCxcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgfTtcbiAgICBUaW1lLnByb3RvdHlwZS5yZW5kZXIgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHZhciBfdGhpcyA9IHRoaXM7XG4gICAgICAgIHZhciBfYTtcbiAgICAgICAgdmFyIGhlaWdodCA9IHRoaXMuc3RhdGUuaGVpZ2h0O1xuICAgICAgICByZXR1cm4gKFJlYWN0LmNyZWF0ZUVsZW1lbnQoXCJkaXZcIiwgeyBjbGFzc05hbWU6IFwicmVhY3QtZGF0ZXBpY2tlcl9fdGltZS1jb250YWluZXIgXCIuY29uY2F0KCgoX2EgPSB0aGlzLnByb3BzLnRvZGF5QnV0dG9uKSAhPT0gbnVsbCAmJiBfYSAhPT0gdm9pZCAwID8gX2EgOiBUaW1lLmRlZmF1bHRQcm9wcy50b2RheUJ1dHRvbilcbiAgICAgICAgICAgICAgICA/IFwicmVhY3QtZGF0ZXBpY2tlcl9fdGltZS1jb250YWluZXItLXdpdGgtdG9kYXktYnV0dG9uXCJcbiAgICAgICAgICAgICAgICA6IFwiXCIpIH0sXG4gICAgICAgICAgICB0aGlzLnJlbmRlclRpbWVDYXB0aW9uKCksXG4gICAgICAgICAgICBSZWFjdC5jcmVhdGVFbGVtZW50KFwiZGl2XCIsIHsgY2xhc3NOYW1lOiBcInJlYWN0LWRhdGVwaWNrZXJfX3RpbWVcIiB9LFxuICAgICAgICAgICAgICAgIFJlYWN0LmNyZWF0ZUVsZW1lbnQoXCJkaXZcIiwgeyBjbGFzc05hbWU6IFwicmVhY3QtZGF0ZXBpY2tlcl9fdGltZS1ib3hcIiB9LFxuICAgICAgICAgICAgICAgICAgICBSZWFjdC5jcmVhdGVFbGVtZW50KFwidWxcIiwgeyBjbGFzc05hbWU6IFwicmVhY3QtZGF0ZXBpY2tlcl9fdGltZS1saXN0XCIsIHJlZjogZnVuY3Rpb24gKGxpc3QpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBfdGhpcy5saXN0ID0gbGlzdDtcbiAgICAgICAgICAgICAgICAgICAgICAgIH0sIHN0eWxlOiBoZWlnaHQgPyB7IGhlaWdodDogaGVpZ2h0IH0gOiB7fSwgcm9sZTogXCJsaXN0Ym94XCIsIFwiYXJpYS1sYWJlbFwiOiB0aGlzLnByb3BzLnRpbWVDYXB0aW9uIH0sIHRoaXMucmVuZGVyVGltZXMoKSkpKSkpO1xuICAgIH07XG4gICAgVGltZS5jYWxjQ2VudGVyUG9zaXRpb24gPSBmdW5jdGlvbiAobGlzdEhlaWdodCwgY2VudGVyTGlSZWYpIHtcbiAgICAgICAgcmV0dXJuIChjZW50ZXJMaVJlZi5vZmZzZXRUb3AgLSAobGlzdEhlaWdodCAvIDIgLSBjZW50ZXJMaVJlZi5jbGllbnRIZWlnaHQgLyAyKSk7XG4gICAgfTtcbiAgICByZXR1cm4gVGltZTtcbn0oQ29tcG9uZW50KSk7XG5cbnZhciBWRVJUSUNBTF9OQVZJR0FUSU9OX09GRlNFVCA9IDM7XG4vKipcbiAqIGBZZWFyYCBpcyBhIGNvbXBvbmVudCB0aGF0IHJlcHJlc2VudHMgYSB5ZWFyIGluIGEgZGF0ZSBwaWNrZXIuXG4gKlxuICogQGNsYXNzXG4gKiBAcGFyYW0ge1llYXJQcm9wc30gcHJvcHMgLSBUaGUgcHJvcGVydGllcyB0aGF0IGRlZmluZSB0aGUgYFllYXJgIGNvbXBvbmVudC5cbiAqIEBwcm9wZXJ0eSB7Vm9pZEZ1bmN0aW9ufSBbcHJvcHMuY2xlYXJTZWxlY3RpbmdEYXRlXSAtIEZ1bmN0aW9uIHRvIGNsZWFyIHRoZSBzZWxlY3RlZCBkYXRlLlxuICogQHByb3BlcnR5IHtEYXRlfSBbcHJvcHMuZGF0ZV0gLSBUaGUgY3VycmVudGx5IHNlbGVjdGVkIGRhdGUuXG4gKiBAcHJvcGVydHkge2Jvb2xlYW59IFtwcm9wcy5kaXNhYmxlZEtleWJvYXJkTmF2aWdhdGlvbl0gLSBJZiB0cnVlLCBrZXlib2FyZCBuYXZpZ2F0aW9uIGlzIGRpc2FibGVkLlxuICogQHByb3BlcnR5IHtEYXRlfSBbcHJvcHMuZW5kRGF0ZV0gLSBUaGUgZW5kIGRhdGUgaW4gYSByYW5nZSBzZWxlY3Rpb24uXG4gKiBAcHJvcGVydHkgeyhkYXRlOiBEYXRlKSA9PiB2b2lkfSBwcm9wcy5vbkRheUNsaWNrIC0gRnVuY3Rpb24gdG8gaGFuZGxlIGRheSBjbGljayBldmVudHMuXG4gKiBAcHJvcGVydHkge0RhdGV9IHByb3BzLnByZVNlbGVjdGlvbiAtIFRoZSBkYXRlIHRoYXQgaXMgY3VycmVudGx5IGluIGZvY3VzLlxuICogQHByb3BlcnR5IHsoZGF0ZTogRGF0ZSkgPT4gdm9pZH0gcHJvcHMuc2V0UHJlU2VsZWN0aW9uIC0gRnVuY3Rpb24gdG8gc2V0IHRoZSBwcmUtc2VsZWN0ZWQgZGF0ZS5cbiAqIEBwcm9wZXJ0eSB7eyBba2V5OiBzdHJpbmddOiBhbnkgfX0gcHJvcHMuc2VsZWN0ZWQgLSBUaGUgc2VsZWN0ZWQgZGF0ZShzKS5cbiAqIEBwcm9wZXJ0eSB7Ym9vbGVhbn0gcHJvcHMuaW5saW5lIC0gSWYgdHJ1ZSwgdGhlIGRhdGUgcGlja2VyIGlzIGRpc3BsYXllZCBpbmxpbmUuXG4gKiBAcHJvcGVydHkge0RhdGV9IHByb3BzLm1heERhdGUgLSBUaGUgbWF4aW11bSBzZWxlY3RhYmxlIGRhdGUuXG4gKiBAcHJvcGVydHkge0RhdGV9IHByb3BzLm1pbkRhdGUgLSBUaGUgbWluaW11bSBzZWxlY3RhYmxlIGRhdGUuXG4gKiBAcHJvcGVydHkge2Jvb2xlYW59IHByb3BzLnVzZVBvaW50ZXJFdmVudCAtIElmIHRydWUsIHBvaW50ZXIgZXZlbnRzIGFyZSB1c2VkIGluc3RlYWQgb2YgbW91c2UgZXZlbnRzLlxuICogQHByb3BlcnR5IHsoZGF0ZTogRGF0ZSkgPT4gdm9pZH0gcHJvcHMub25ZZWFyTW91c2VFbnRlciAtIEZ1bmN0aW9uIHRvIGhhbmRsZSBtb3VzZSBlbnRlciBldmVudHMgb24gYSB5ZWFyLlxuICogQHByb3BlcnR5IHsoZGF0ZTogRGF0ZSkgPT4gdm9pZH0gcHJvcHMub25ZZWFyTW91c2VMZWF2ZSAtIEZ1bmN0aW9uIHRvIGhhbmRsZSBtb3VzZSBsZWF2ZSBldmVudHMgb24gYSB5ZWFyLlxuICovXG52YXIgWWVhciA9IC8qKiBAY2xhc3MgKi8gKGZ1bmN0aW9uIChfc3VwZXIpIHtcbiAgICBfX2V4dGVuZHMoWWVhciwgX3N1cGVyKTtcbiAgICBmdW5jdGlvbiBZZWFyKHByb3BzKSB7XG4gICAgICAgIHZhciBfdGhpcyA9IF9zdXBlci5jYWxsKHRoaXMsIHByb3BzKSB8fCB0aGlzO1xuICAgICAgICBfdGhpcy5ZRUFSX1JFRlMgPSBfX3NwcmVhZEFycmF5KFtdLCBBcnJheShfdGhpcy5wcm9wcy55ZWFySXRlbU51bWJlciksIHRydWUpLm1hcChmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICByZXR1cm4gY3JlYXRlUmVmKCk7XG4gICAgICAgIH0pO1xuICAgICAgICBfdGhpcy5pc0Rpc2FibGVkID0gZnVuY3Rpb24gKGRhdGUpIHtcbiAgICAgICAgICAgIHJldHVybiBpc0RheURpc2FibGVkKGRhdGUsIHtcbiAgICAgICAgICAgICAgICBtaW5EYXRlOiBfdGhpcy5wcm9wcy5taW5EYXRlLFxuICAgICAgICAgICAgICAgIG1heERhdGU6IF90aGlzLnByb3BzLm1heERhdGUsXG4gICAgICAgICAgICAgICAgZXhjbHVkZURhdGVzOiBfdGhpcy5wcm9wcy5leGNsdWRlRGF0ZXMsXG4gICAgICAgICAgICAgICAgaW5jbHVkZURhdGVzOiBfdGhpcy5wcm9wcy5pbmNsdWRlRGF0ZXMsXG4gICAgICAgICAgICAgICAgZmlsdGVyRGF0ZTogX3RoaXMucHJvcHMuZmlsdGVyRGF0ZSxcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9O1xuICAgICAgICBfdGhpcy5pc0V4Y2x1ZGVkID0gZnVuY3Rpb24gKGRhdGUpIHtcbiAgICAgICAgICAgIHJldHVybiBpc0RheUV4Y2x1ZGVkKGRhdGUsIHtcbiAgICAgICAgICAgICAgICBleGNsdWRlRGF0ZXM6IF90aGlzLnByb3BzLmV4Y2x1ZGVEYXRlcyxcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9O1xuICAgICAgICBfdGhpcy5zZWxlY3RpbmdEYXRlID0gZnVuY3Rpb24gKCkgeyB2YXIgX2E7IHJldHVybiAoX2EgPSBfdGhpcy5wcm9wcy5zZWxlY3RpbmdEYXRlKSAhPT0gbnVsbCAmJiBfYSAhPT0gdm9pZCAwID8gX2EgOiBfdGhpcy5wcm9wcy5wcmVTZWxlY3Rpb247IH07XG4gICAgICAgIF90aGlzLnVwZGF0ZUZvY3VzT25QYWdpbmF0ZSA9IGZ1bmN0aW9uIChyZWZJbmRleCkge1xuICAgICAgICAgICAgdmFyIHdhaXRGb3JSZVJlbmRlciA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgICAgICB2YXIgX2EsIF9iO1xuICAgICAgICAgICAgICAgIChfYiA9IChfYSA9IF90aGlzLllFQVJfUkVGU1tyZWZJbmRleF0pID09PSBudWxsIHx8IF9hID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYS5jdXJyZW50KSA9PT0gbnVsbCB8fCBfYiA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2IuZm9jdXMoKTtcbiAgICAgICAgICAgIH07XG4gICAgICAgICAgICB3aW5kb3cucmVxdWVzdEFuaW1hdGlvbkZyYW1lKHdhaXRGb3JSZVJlbmRlcik7XG4gICAgICAgIH07XG4gICAgICAgIF90aGlzLmhhbmRsZVllYXJDbGljayA9IGZ1bmN0aW9uIChkYXksIGV2ZW50KSB7XG4gICAgICAgICAgICBpZiAoX3RoaXMucHJvcHMub25EYXlDbGljaykge1xuICAgICAgICAgICAgICAgIF90aGlzLnByb3BzLm9uRGF5Q2xpY2soZGF5LCBldmVudCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH07XG4gICAgICAgIF90aGlzLmhhbmRsZVllYXJOYXZpZ2F0aW9uID0gZnVuY3Rpb24gKG5ld1llYXIsIG5ld0RhdGUpIHtcbiAgICAgICAgICAgIHZhciBfYSwgX2IsIF9jLCBfZDtcbiAgICAgICAgICAgIHZhciBfZSA9IF90aGlzLnByb3BzLCBkYXRlID0gX2UuZGF0ZSwgeWVhckl0ZW1OdW1iZXIgPSBfZS55ZWFySXRlbU51bWJlcjtcbiAgICAgICAgICAgIGlmIChkYXRlID09PSB1bmRlZmluZWQgfHwgeWVhckl0ZW1OdW1iZXIgPT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHZhciBzdGFydFBlcmlvZCA9IGdldFllYXJzUGVyaW9kKGRhdGUsIHllYXJJdGVtTnVtYmVyKS5zdGFydFBlcmlvZDtcbiAgICAgICAgICAgIGlmIChfdGhpcy5pc0Rpc2FibGVkKG5ld0RhdGUpIHx8IF90aGlzLmlzRXhjbHVkZWQobmV3RGF0ZSkpIHtcbiAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICAoX2IgPSAoX2EgPSBfdGhpcy5wcm9wcykuc2V0UHJlU2VsZWN0aW9uKSA9PT0gbnVsbCB8fCBfYiA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2IuY2FsbChfYSwgbmV3RGF0ZSk7XG4gICAgICAgICAgICBpZiAobmV3WWVhciAtIHN0YXJ0UGVyaW9kIDwgMCkge1xuICAgICAgICAgICAgICAgIF90aGlzLnVwZGF0ZUZvY3VzT25QYWdpbmF0ZSh5ZWFySXRlbU51bWJlciAtIChzdGFydFBlcmlvZCAtIG5ld1llYXIpKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2UgaWYgKG5ld1llYXIgLSBzdGFydFBlcmlvZCA+PSB5ZWFySXRlbU51bWJlcikge1xuICAgICAgICAgICAgICAgIF90aGlzLnVwZGF0ZUZvY3VzT25QYWdpbmF0ZShNYXRoLmFicyh5ZWFySXRlbU51bWJlciAtIChuZXdZZWFyIC0gc3RhcnRQZXJpb2QpKSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlXG4gICAgICAgICAgICAgICAgKF9kID0gKF9jID0gX3RoaXMuWUVBUl9SRUZTW25ld1llYXIgLSBzdGFydFBlcmlvZF0pID09PSBudWxsIHx8IF9jID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYy5jdXJyZW50KSA9PT0gbnVsbCB8fCBfZCA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2QuZm9jdXMoKTtcbiAgICAgICAgfTtcbiAgICAgICAgX3RoaXMuaXNTYW1lRGF5ID0gZnVuY3Rpb24gKHksIG90aGVyKSB7IHJldHVybiBpc1NhbWVEYXkoeSwgb3RoZXIpOyB9O1xuICAgICAgICBfdGhpcy5pc0N1cnJlbnRZZWFyID0gZnVuY3Rpb24gKHkpIHsgcmV0dXJuIHkgPT09IGdldFllYXIobmV3RGF0ZSgpKTsgfTtcbiAgICAgICAgX3RoaXMuaXNSYW5nZVN0YXJ0ID0gZnVuY3Rpb24gKHkpIHtcbiAgICAgICAgICAgIHJldHVybiBfdGhpcy5wcm9wcy5zdGFydERhdGUgJiZcbiAgICAgICAgICAgICAgICBfdGhpcy5wcm9wcy5lbmREYXRlICYmXG4gICAgICAgICAgICAgICAgaXNTYW1lWWVhcihzZXRZZWFyKG5ld0RhdGUoKSwgeSksIF90aGlzLnByb3BzLnN0YXJ0RGF0ZSk7XG4gICAgICAgIH07XG4gICAgICAgIF90aGlzLmlzUmFuZ2VFbmQgPSBmdW5jdGlvbiAoeSkge1xuICAgICAgICAgICAgcmV0dXJuIF90aGlzLnByb3BzLnN0YXJ0RGF0ZSAmJlxuICAgICAgICAgICAgICAgIF90aGlzLnByb3BzLmVuZERhdGUgJiZcbiAgICAgICAgICAgICAgICBpc1NhbWVZZWFyKHNldFllYXIobmV3RGF0ZSgpLCB5KSwgX3RoaXMucHJvcHMuZW5kRGF0ZSk7XG4gICAgICAgIH07XG4gICAgICAgIF90aGlzLmlzSW5SYW5nZSA9IGZ1bmN0aW9uICh5KSB7XG4gICAgICAgICAgICByZXR1cm4gaXNZZWFySW5SYW5nZSh5LCBfdGhpcy5wcm9wcy5zdGFydERhdGUsIF90aGlzLnByb3BzLmVuZERhdGUpO1xuICAgICAgICB9O1xuICAgICAgICBfdGhpcy5pc0luU2VsZWN0aW5nUmFuZ2UgPSBmdW5jdGlvbiAoeSkge1xuICAgICAgICAgICAgdmFyIF9hID0gX3RoaXMucHJvcHMsIHNlbGVjdHNTdGFydCA9IF9hLnNlbGVjdHNTdGFydCwgc2VsZWN0c0VuZCA9IF9hLnNlbGVjdHNFbmQsIHNlbGVjdHNSYW5nZSA9IF9hLnNlbGVjdHNSYW5nZSwgc3RhcnREYXRlID0gX2Euc3RhcnREYXRlLCBlbmREYXRlID0gX2EuZW5kRGF0ZTtcbiAgICAgICAgICAgIGlmICghKHNlbGVjdHNTdGFydCB8fCBzZWxlY3RzRW5kIHx8IHNlbGVjdHNSYW5nZSkgfHxcbiAgICAgICAgICAgICAgICAhX3RoaXMuc2VsZWN0aW5nRGF0ZSgpKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKHNlbGVjdHNTdGFydCAmJiBlbmREYXRlKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGlzWWVhckluUmFuZ2UoeSwgX3RoaXMuc2VsZWN0aW5nRGF0ZSgpLCBlbmREYXRlKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChzZWxlY3RzRW5kICYmIHN0YXJ0RGF0ZSkge1xuICAgICAgICAgICAgICAgIHJldHVybiBpc1llYXJJblJhbmdlKHksIHN0YXJ0RGF0ZSwgX3RoaXMuc2VsZWN0aW5nRGF0ZSgpKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChzZWxlY3RzUmFuZ2UgJiYgc3RhcnREYXRlICYmICFlbmREYXRlKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGlzWWVhckluUmFuZ2UoeSwgc3RhcnREYXRlLCBfdGhpcy5zZWxlY3RpbmdEYXRlKCkpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICB9O1xuICAgICAgICBfdGhpcy5pc1NlbGVjdGluZ1JhbmdlU3RhcnQgPSBmdW5jdGlvbiAoeSkge1xuICAgICAgICAgICAgdmFyIF9hO1xuICAgICAgICAgICAgaWYgKCFfdGhpcy5pc0luU2VsZWN0aW5nUmFuZ2UoeSkpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB2YXIgX2IgPSBfdGhpcy5wcm9wcywgc3RhcnREYXRlID0gX2Iuc3RhcnREYXRlLCBzZWxlY3RzU3RhcnQgPSBfYi5zZWxlY3RzU3RhcnQ7XG4gICAgICAgICAgICB2YXIgX3llYXIgPSBzZXRZZWFyKG5ld0RhdGUoKSwgeSk7XG4gICAgICAgICAgICBpZiAoc2VsZWN0c1N0YXJ0KSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGlzU2FtZVllYXIoX3llYXIsIChfYSA9IF90aGlzLnNlbGVjdGluZ0RhdGUoKSkgIT09IG51bGwgJiYgX2EgIT09IHZvaWQgMCA/IF9hIDogbnVsbCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gaXNTYW1lWWVhcihfeWVhciwgc3RhcnREYXRlICE9PSBudWxsICYmIHN0YXJ0RGF0ZSAhPT0gdm9pZCAwID8gc3RhcnREYXRlIDogbnVsbCk7XG4gICAgICAgIH07XG4gICAgICAgIF90aGlzLmlzU2VsZWN0aW5nUmFuZ2VFbmQgPSBmdW5jdGlvbiAoeSkge1xuICAgICAgICAgICAgdmFyIF9hO1xuICAgICAgICAgICAgaWYgKCFfdGhpcy5pc0luU2VsZWN0aW5nUmFuZ2UoeSkpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB2YXIgX2IgPSBfdGhpcy5wcm9wcywgZW5kRGF0ZSA9IF9iLmVuZERhdGUsIHNlbGVjdHNFbmQgPSBfYi5zZWxlY3RzRW5kLCBzZWxlY3RzUmFuZ2UgPSBfYi5zZWxlY3RzUmFuZ2U7XG4gICAgICAgICAgICB2YXIgX3llYXIgPSBzZXRZZWFyKG5ld0RhdGUoKSwgeSk7XG4gICAgICAgICAgICBpZiAoc2VsZWN0c0VuZCB8fCBzZWxlY3RzUmFuZ2UpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gaXNTYW1lWWVhcihfeWVhciwgKF9hID0gX3RoaXMuc2VsZWN0aW5nRGF0ZSgpKSAhPT0gbnVsbCAmJiBfYSAhPT0gdm9pZCAwID8gX2EgOiBudWxsKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiBpc1NhbWVZZWFyKF95ZWFyLCBlbmREYXRlICE9PSBudWxsICYmIGVuZERhdGUgIT09IHZvaWQgMCA/IGVuZERhdGUgOiBudWxsKTtcbiAgICAgICAgfTtcbiAgICAgICAgX3RoaXMuaXNLZXlib2FyZFNlbGVjdGVkID0gZnVuY3Rpb24gKHkpIHtcbiAgICAgICAgICAgIGlmIChfdGhpcy5wcm9wcy5kaXNhYmxlZEtleWJvYXJkTmF2aWdhdGlvbiB8fFxuICAgICAgICAgICAgICAgIF90aGlzLnByb3BzLmRhdGUgPT09IHVuZGVmaW5lZCB8fFxuICAgICAgICAgICAgICAgIF90aGlzLnByb3BzLnByZVNlbGVjdGlvbiA9PSBudWxsKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdmFyIF9hID0gX3RoaXMucHJvcHMsIG1pbkRhdGUgPSBfYS5taW5EYXRlLCBtYXhEYXRlID0gX2EubWF4RGF0ZSwgZXhjbHVkZURhdGVzID0gX2EuZXhjbHVkZURhdGVzLCBpbmNsdWRlRGF0ZXMgPSBfYS5pbmNsdWRlRGF0ZXMsIGZpbHRlckRhdGUgPSBfYS5maWx0ZXJEYXRlLCBzZWxlY3RlZCA9IF9hLnNlbGVjdGVkO1xuICAgICAgICAgICAgdmFyIGRhdGUgPSBnZXRTdGFydE9mWWVhcihzZXRZZWFyKF90aGlzLnByb3BzLmRhdGUsIHkpKTtcbiAgICAgICAgICAgIHZhciBpc0Rpc2FibGVkID0gKG1pbkRhdGUgfHwgbWF4RGF0ZSB8fCBleGNsdWRlRGF0ZXMgfHwgaW5jbHVkZURhdGVzIHx8IGZpbHRlckRhdGUpICYmXG4gICAgICAgICAgICAgICAgaXNZZWFyRGlzYWJsZWQoeSwgX3RoaXMucHJvcHMpO1xuICAgICAgICAgICAgdmFyIGlzU2VsZWN0ZWREYXkgPSAhIXNlbGVjdGVkICYmIGlzU2FtZURheShkYXRlLCBnZXRTdGFydE9mWWVhcihzZWxlY3RlZCkpO1xuICAgICAgICAgICAgdmFyIGlzS2V5Ym9hcmRTZWxlY3RlZERheSA9IGlzU2FtZURheShkYXRlLCBnZXRTdGFydE9mWWVhcihfdGhpcy5wcm9wcy5wcmVTZWxlY3Rpb24pKTtcbiAgICAgICAgICAgIHJldHVybiAoIV90aGlzLnByb3BzLmlubGluZSAmJlxuICAgICAgICAgICAgICAgICFpc1NlbGVjdGVkRGF5ICYmXG4gICAgICAgICAgICAgICAgaXNLZXlib2FyZFNlbGVjdGVkRGF5ICYmXG4gICAgICAgICAgICAgICAgIWlzRGlzYWJsZWQpO1xuICAgICAgICB9O1xuICAgICAgICBfdGhpcy5pc1NlbGVjdGVkWWVhciA9IGZ1bmN0aW9uICh5ZWFyKSB7XG4gICAgICAgICAgICB2YXIgX2EgPSBfdGhpcy5wcm9wcywgc2VsZWN0c011bHRpcGxlID0gX2Euc2VsZWN0c011bHRpcGxlLCBzZWxlY3RlZCA9IF9hLnNlbGVjdGVkLCBzZWxlY3RlZERhdGVzID0gX2Euc2VsZWN0ZWREYXRlcztcbiAgICAgICAgICAgIGlmIChzZWxlY3RzTXVsdGlwbGUpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gc2VsZWN0ZWREYXRlcyA9PT0gbnVsbCB8fCBzZWxlY3RlZERhdGVzID09PSB2b2lkIDAgPyB2b2lkIDAgOiBzZWxlY3RlZERhdGVzLnNvbWUoZnVuY3Rpb24gKGRhdGUpIHsgcmV0dXJuIHllYXIgPT09IGdldFllYXIoZGF0ZSk7IH0pO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuICEhc2VsZWN0ZWQgJiYgeWVhciA9PT0gZ2V0WWVhcihzZWxlY3RlZCk7XG4gICAgICAgIH07XG4gICAgICAgIF90aGlzLm9uWWVhckNsaWNrID0gZnVuY3Rpb24gKGV2ZW50LCB5KSB7XG4gICAgICAgICAgICB2YXIgZGF0ZSA9IF90aGlzLnByb3BzLmRhdGU7XG4gICAgICAgICAgICBpZiAoZGF0ZSA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgX3RoaXMuaGFuZGxlWWVhckNsaWNrKGdldFN0YXJ0T2ZZZWFyKHNldFllYXIoZGF0ZSwgeSkpLCBldmVudCk7XG4gICAgICAgIH07XG4gICAgICAgIF90aGlzLm9uWWVhcktleURvd24gPSBmdW5jdGlvbiAoZXZlbnQsIHkpIHtcbiAgICAgICAgICAgIHZhciBfYSwgX2I7XG4gICAgICAgICAgICB2YXIga2V5ID0gZXZlbnQua2V5O1xuICAgICAgICAgICAgdmFyIF9jID0gX3RoaXMucHJvcHMsIGRhdGUgPSBfYy5kYXRlLCB5ZWFySXRlbU51bWJlciA9IF9jLnllYXJJdGVtTnVtYmVyLCBoYW5kbGVPbktleURvd24gPSBfYy5oYW5kbGVPbktleURvd247XG4gICAgICAgICAgICBpZiAoa2V5ICE9PSBLZXlUeXBlLlRhYikge1xuICAgICAgICAgICAgICAgIC8vIHByZXZlbnREZWZhdWx0IG9uIHRhYiBldmVudCBibG9ja3MgZm9jdXMgY2hhbmdlXG4gICAgICAgICAgICAgICAgZXZlbnQucHJldmVudERlZmF1bHQoKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmICghX3RoaXMucHJvcHMuZGlzYWJsZWRLZXlib2FyZE5hdmlnYXRpb24pIHtcbiAgICAgICAgICAgICAgICBzd2l0Y2ggKGtleSkge1xuICAgICAgICAgICAgICAgICAgICBjYXNlIEtleVR5cGUuRW50ZXI6XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoX3RoaXMucHJvcHMuc2VsZWN0ZWQgPT0gbnVsbCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgX3RoaXMub25ZZWFyQ2xpY2soZXZlbnQsIHkpO1xuICAgICAgICAgICAgICAgICAgICAgICAgKF9iID0gKF9hID0gX3RoaXMucHJvcHMpLnNldFByZVNlbGVjdGlvbikgPT09IG51bGwgfHwgX2IgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9iLmNhbGwoX2EsIF90aGlzLnByb3BzLnNlbGVjdGVkKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgICAgICBjYXNlIEtleVR5cGUuQXJyb3dSaWdodDpcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChfdGhpcy5wcm9wcy5wcmVTZWxlY3Rpb24gPT0gbnVsbCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgX3RoaXMuaGFuZGxlWWVhck5hdmlnYXRpb24oeSArIDEsIGFkZFllYXJzKF90aGlzLnByb3BzLnByZVNlbGVjdGlvbiwgMSkpO1xuICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgICAgIGNhc2UgS2V5VHlwZS5BcnJvd0xlZnQ6XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoX3RoaXMucHJvcHMucHJlU2VsZWN0aW9uID09IG51bGwpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIF90aGlzLmhhbmRsZVllYXJOYXZpZ2F0aW9uKHkgLSAxLCBzdWJZZWFycyhfdGhpcy5wcm9wcy5wcmVTZWxlY3Rpb24sIDEpKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgICAgICBjYXNlIEtleVR5cGUuQXJyb3dVcDoge1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGRhdGUgPT09IHVuZGVmaW5lZCB8fFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHllYXJJdGVtTnVtYmVyID09PSB1bmRlZmluZWQgfHxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBfdGhpcy5wcm9wcy5wcmVTZWxlY3Rpb24gPT0gbnVsbCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgdmFyIHN0YXJ0UGVyaW9kID0gZ2V0WWVhcnNQZXJpb2QoZGF0ZSwgeWVhckl0ZW1OdW1iZXIpLnN0YXJ0UGVyaW9kO1xuICAgICAgICAgICAgICAgICAgICAgICAgdmFyIG9mZnNldCA9IFZFUlRJQ0FMX05BVklHQVRJT05fT0ZGU0VUO1xuICAgICAgICAgICAgICAgICAgICAgICAgdmFyIG5ld1llYXIgPSB5IC0gb2Zmc2V0O1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKG5ld1llYXIgPCBzdGFydFBlcmlvZCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZhciBsZWZ0T3Zlck9mZnNldCA9IHllYXJJdGVtTnVtYmVyICUgb2Zmc2V0O1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmICh5ID49IHN0YXJ0UGVyaW9kICYmIHkgPCBzdGFydFBlcmlvZCArIGxlZnRPdmVyT2Zmc2V0KSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIG9mZnNldCA9IGxlZnRPdmVyT2Zmc2V0O1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgb2Zmc2V0ICs9IGxlZnRPdmVyT2Zmc2V0O1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBuZXdZZWFyID0geSAtIG9mZnNldDtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIF90aGlzLmhhbmRsZVllYXJOYXZpZ2F0aW9uKG5ld1llYXIsIHN1YlllYXJzKF90aGlzLnByb3BzLnByZVNlbGVjdGlvbiwgb2Zmc2V0KSk7XG4gICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBjYXNlIEtleVR5cGUuQXJyb3dEb3duOiB7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoZGF0ZSA9PT0gdW5kZWZpbmVkIHx8XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgeWVhckl0ZW1OdW1iZXIgPT09IHVuZGVmaW5lZCB8fFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIF90aGlzLnByb3BzLnByZVNlbGVjdGlvbiA9PSBudWxsKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICB2YXIgZW5kUGVyaW9kID0gZ2V0WWVhcnNQZXJpb2QoZGF0ZSwgeWVhckl0ZW1OdW1iZXIpLmVuZFBlcmlvZDtcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhciBvZmZzZXQgPSBWRVJUSUNBTF9OQVZJR0FUSU9OX09GRlNFVDtcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhciBuZXdZZWFyID0geSArIG9mZnNldDtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChuZXdZZWFyID4gZW5kUGVyaW9kKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdmFyIGxlZnRPdmVyT2Zmc2V0ID0geWVhckl0ZW1OdW1iZXIgJSBvZmZzZXQ7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKHkgPD0gZW5kUGVyaW9kICYmIHkgPiBlbmRQZXJpb2QgLSBsZWZ0T3Zlck9mZnNldCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBvZmZzZXQgPSBsZWZ0T3Zlck9mZnNldDtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIG9mZnNldCArPSBsZWZ0T3Zlck9mZnNldDtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgbmV3WWVhciA9IHkgKyBvZmZzZXQ7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICBfdGhpcy5oYW5kbGVZZWFyTmF2aWdhdGlvbihuZXdZZWFyLCBhZGRZZWFycyhfdGhpcy5wcm9wcy5wcmVTZWxlY3Rpb24sIG9mZnNldCkpO1xuICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBoYW5kbGVPbktleURvd24gJiYgaGFuZGxlT25LZXlEb3duKGV2ZW50KTtcbiAgICAgICAgfTtcbiAgICAgICAgX3RoaXMuZ2V0WWVhckNsYXNzTmFtZXMgPSBmdW5jdGlvbiAoeSkge1xuICAgICAgICAgICAgdmFyIF9hID0gX3RoaXMucHJvcHMsIGRhdGUgPSBfYS5kYXRlLCBkaXNhYmxlZCA9IF9hLmRpc2FibGVkLCBtaW5EYXRlID0gX2EubWluRGF0ZSwgbWF4RGF0ZSA9IF9hLm1heERhdGUsIGV4Y2x1ZGVEYXRlcyA9IF9hLmV4Y2x1ZGVEYXRlcywgaW5jbHVkZURhdGVzID0gX2EuaW5jbHVkZURhdGVzLCBmaWx0ZXJEYXRlID0gX2EuZmlsdGVyRGF0ZSwgeWVhckNsYXNzTmFtZSA9IF9hLnllYXJDbGFzc05hbWU7XG4gICAgICAgICAgICByZXR1cm4gY2xzeChcInJlYWN0LWRhdGVwaWNrZXJfX3llYXItdGV4dFwiLCBcInJlYWN0LWRhdGVwaWNrZXJfX3llYXItXCIuY29uY2F0KHkpLCBkYXRlID8geWVhckNsYXNzTmFtZSA9PT0gbnVsbCB8fCB5ZWFyQ2xhc3NOYW1lID09PSB2b2lkIDAgPyB2b2lkIDAgOiB5ZWFyQ2xhc3NOYW1lKHNldFllYXIoZGF0ZSwgeSkpIDogdW5kZWZpbmVkLCB7XG4gICAgICAgICAgICAgICAgXCJyZWFjdC1kYXRlcGlja2VyX195ZWFyLXRleHQtLXNlbGVjdGVkXCI6IF90aGlzLmlzU2VsZWN0ZWRZZWFyKHkpLFxuICAgICAgICAgICAgICAgIFwicmVhY3QtZGF0ZXBpY2tlcl9feWVhci10ZXh0LS1kaXNhYmxlZFwiOiAobWluRGF0ZSB8fFxuICAgICAgICAgICAgICAgICAgICBtYXhEYXRlIHx8XG4gICAgICAgICAgICAgICAgICAgIGV4Y2x1ZGVEYXRlcyB8fFxuICAgICAgICAgICAgICAgICAgICBpbmNsdWRlRGF0ZXMgfHxcbiAgICAgICAgICAgICAgICAgICAgZmlsdGVyRGF0ZSB8fFxuICAgICAgICAgICAgICAgICAgICBkaXNhYmxlZCkgJiZcbiAgICAgICAgICAgICAgICAgICAgaXNZZWFyRGlzYWJsZWQoeSwgX3RoaXMucHJvcHMpLFxuICAgICAgICAgICAgICAgIFwicmVhY3QtZGF0ZXBpY2tlcl9feWVhci10ZXh0LS1rZXlib2FyZC1zZWxlY3RlZFwiOiBfdGhpcy5pc0tleWJvYXJkU2VsZWN0ZWQoeSksXG4gICAgICAgICAgICAgICAgXCJyZWFjdC1kYXRlcGlja2VyX195ZWFyLXRleHQtLXJhbmdlLXN0YXJ0XCI6IF90aGlzLmlzUmFuZ2VTdGFydCh5KSxcbiAgICAgICAgICAgICAgICBcInJlYWN0LWRhdGVwaWNrZXJfX3llYXItdGV4dC0tcmFuZ2UtZW5kXCI6IF90aGlzLmlzUmFuZ2VFbmQoeSksXG4gICAgICAgICAgICAgICAgXCJyZWFjdC1kYXRlcGlja2VyX195ZWFyLXRleHQtLWluLXJhbmdlXCI6IF90aGlzLmlzSW5SYW5nZSh5KSxcbiAgICAgICAgICAgICAgICBcInJlYWN0LWRhdGVwaWNrZXJfX3llYXItdGV4dC0taW4tc2VsZWN0aW5nLXJhbmdlXCI6IF90aGlzLmlzSW5TZWxlY3RpbmdSYW5nZSh5KSxcbiAgICAgICAgICAgICAgICBcInJlYWN0LWRhdGVwaWNrZXJfX3llYXItdGV4dC0tc2VsZWN0aW5nLXJhbmdlLXN0YXJ0XCI6IF90aGlzLmlzU2VsZWN0aW5nUmFuZ2VTdGFydCh5KSxcbiAgICAgICAgICAgICAgICBcInJlYWN0LWRhdGVwaWNrZXJfX3llYXItdGV4dC0tc2VsZWN0aW5nLXJhbmdlLWVuZFwiOiBfdGhpcy5pc1NlbGVjdGluZ1JhbmdlRW5kKHkpLFxuICAgICAgICAgICAgICAgIFwicmVhY3QtZGF0ZXBpY2tlcl9feWVhci10ZXh0LS10b2RheVwiOiBfdGhpcy5pc0N1cnJlbnRZZWFyKHkpLFxuICAgICAgICAgICAgfSk7XG4gICAgICAgIH07XG4gICAgICAgIF90aGlzLmdldFllYXJUYWJJbmRleCA9IGZ1bmN0aW9uICh5KSB7XG4gICAgICAgICAgICBpZiAoX3RoaXMucHJvcHMuZGlzYWJsZWRLZXlib2FyZE5hdmlnYXRpb24gfHxcbiAgICAgICAgICAgICAgICBfdGhpcy5wcm9wcy5wcmVTZWxlY3Rpb24gPT0gbnVsbCkge1xuICAgICAgICAgICAgICAgIHJldHVybiBcIi0xXCI7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB2YXIgcHJlU2VsZWN0ZWQgPSBnZXRZZWFyKF90aGlzLnByb3BzLnByZVNlbGVjdGlvbik7XG4gICAgICAgICAgICB2YXIgaXNQcmVTZWxlY3RlZFllYXJEaXNhYmxlZCA9IGlzWWVhckRpc2FibGVkKHksIF90aGlzLnByb3BzKTtcbiAgICAgICAgICAgIHJldHVybiB5ID09PSBwcmVTZWxlY3RlZCAmJiAhaXNQcmVTZWxlY3RlZFllYXJEaXNhYmxlZCA/IFwiMFwiIDogXCItMVwiO1xuICAgICAgICB9O1xuICAgICAgICBfdGhpcy5nZXRZZWFyQ29udGVudCA9IGZ1bmN0aW9uICh5KSB7XG4gICAgICAgICAgICByZXR1cm4gX3RoaXMucHJvcHMucmVuZGVyWWVhckNvbnRlbnQgPyBfdGhpcy5wcm9wcy5yZW5kZXJZZWFyQ29udGVudCh5KSA6IHk7XG4gICAgICAgIH07XG4gICAgICAgIHJldHVybiBfdGhpcztcbiAgICB9XG4gICAgWWVhci5wcm90b3R5cGUucmVuZGVyID0gZnVuY3Rpb24gKCkge1xuICAgICAgICB2YXIgX3RoaXMgPSB0aGlzO1xuICAgICAgICB2YXIgeWVhcnNMaXN0ID0gW107XG4gICAgICAgIHZhciBfYSA9IHRoaXMucHJvcHMsIGRhdGUgPSBfYS5kYXRlLCB5ZWFySXRlbU51bWJlciA9IF9hLnllYXJJdGVtTnVtYmVyLCBvblllYXJNb3VzZUVudGVyID0gX2Eub25ZZWFyTW91c2VFbnRlciwgb25ZZWFyTW91c2VMZWF2ZSA9IF9hLm9uWWVhck1vdXNlTGVhdmU7XG4gICAgICAgIGlmIChkYXRlID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICB9XG4gICAgICAgIHZhciBfYiA9IGdldFllYXJzUGVyaW9kKGRhdGUsIHllYXJJdGVtTnVtYmVyKSwgc3RhcnRQZXJpb2QgPSBfYi5zdGFydFBlcmlvZCwgZW5kUGVyaW9kID0gX2IuZW5kUGVyaW9kO1xuICAgICAgICB2YXIgX2xvb3BfMSA9IGZ1bmN0aW9uICh5KSB7XG4gICAgICAgICAgICB5ZWFyc0xpc3QucHVzaChSZWFjdC5jcmVhdGVFbGVtZW50KFwiZGl2XCIsIHsgcmVmOiB0aGlzXzEuWUVBUl9SRUZTW3kgLSBzdGFydFBlcmlvZF0sIG9uQ2xpY2s6IGZ1bmN0aW9uIChldmVudCkge1xuICAgICAgICAgICAgICAgICAgICBfdGhpcy5vblllYXJDbGljayhldmVudCwgeSk7XG4gICAgICAgICAgICAgICAgfSwgb25LZXlEb3duOiBmdW5jdGlvbiAoZXZlbnQpIHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKGlzU3BhY2VLZXlEb3duKGV2ZW50KSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgZXZlbnQucHJldmVudERlZmF1bHQoKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGV2ZW50LmtleSA9IEtleVR5cGUuRW50ZXI7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgX3RoaXMub25ZZWFyS2V5RG93bihldmVudCwgeSk7XG4gICAgICAgICAgICAgICAgfSwgdGFiSW5kZXg6IE51bWJlcih0aGlzXzEuZ2V0WWVhclRhYkluZGV4KHkpKSwgY2xhc3NOYW1lOiB0aGlzXzEuZ2V0WWVhckNsYXNzTmFtZXMoeSksIG9uTW91c2VFbnRlcjogIXRoaXNfMS5wcm9wcy51c2VQb2ludGVyRXZlbnRcbiAgICAgICAgICAgICAgICAgICAgPyBmdW5jdGlvbiAoZXZlbnQpIHsgcmV0dXJuIG9uWWVhck1vdXNlRW50ZXIoZXZlbnQsIHkpOyB9XG4gICAgICAgICAgICAgICAgICAgIDogdW5kZWZpbmVkLCBvblBvaW50ZXJFbnRlcjogdGhpc18xLnByb3BzLnVzZVBvaW50ZXJFdmVudFxuICAgICAgICAgICAgICAgICAgICA/IGZ1bmN0aW9uIChldmVudCkgeyByZXR1cm4gb25ZZWFyTW91c2VFbnRlcihldmVudCwgeSk7IH1cbiAgICAgICAgICAgICAgICAgICAgOiB1bmRlZmluZWQsIG9uTW91c2VMZWF2ZTogIXRoaXNfMS5wcm9wcy51c2VQb2ludGVyRXZlbnRcbiAgICAgICAgICAgICAgICAgICAgPyBmdW5jdGlvbiAoZXZlbnQpIHsgcmV0dXJuIG9uWWVhck1vdXNlTGVhdmUoZXZlbnQsIHkpOyB9XG4gICAgICAgICAgICAgICAgICAgIDogdW5kZWZpbmVkLCBvblBvaW50ZXJMZWF2ZTogdGhpc18xLnByb3BzLnVzZVBvaW50ZXJFdmVudFxuICAgICAgICAgICAgICAgICAgICA/IGZ1bmN0aW9uIChldmVudCkgeyByZXR1cm4gb25ZZWFyTW91c2VMZWF2ZShldmVudCwgeSk7IH1cbiAgICAgICAgICAgICAgICAgICAgOiB1bmRlZmluZWQsIGtleTogeSwgXCJhcmlhLWN1cnJlbnRcIjogdGhpc18xLmlzQ3VycmVudFllYXIoeSkgPyBcImRhdGVcIiA6IHVuZGVmaW5lZCB9LCB0aGlzXzEuZ2V0WWVhckNvbnRlbnQoeSkpKTtcbiAgICAgICAgfTtcbiAgICAgICAgdmFyIHRoaXNfMSA9IHRoaXM7XG4gICAgICAgIGZvciAodmFyIHkgPSBzdGFydFBlcmlvZDsgeSA8PSBlbmRQZXJpb2Q7IHkrKykge1xuICAgICAgICAgICAgX2xvb3BfMSh5KTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gKFJlYWN0LmNyZWF0ZUVsZW1lbnQoXCJkaXZcIiwgeyBjbGFzc05hbWU6IFwicmVhY3QtZGF0ZXBpY2tlcl9feWVhclwiIH0sXG4gICAgICAgICAgICBSZWFjdC5jcmVhdGVFbGVtZW50KFwiZGl2XCIsIHsgY2xhc3NOYW1lOiBcInJlYWN0LWRhdGVwaWNrZXJfX3llYXItd3JhcHBlclwiLCBvbk1vdXNlTGVhdmU6ICF0aGlzLnByb3BzLnVzZVBvaW50ZXJFdmVudFxuICAgICAgICAgICAgICAgICAgICA/IHRoaXMucHJvcHMuY2xlYXJTZWxlY3RpbmdEYXRlXG4gICAgICAgICAgICAgICAgICAgIDogdW5kZWZpbmVkLCBvblBvaW50ZXJMZWF2ZTogdGhpcy5wcm9wcy51c2VQb2ludGVyRXZlbnRcbiAgICAgICAgICAgICAgICAgICAgPyB0aGlzLnByb3BzLmNsZWFyU2VsZWN0aW5nRGF0ZVxuICAgICAgICAgICAgICAgICAgICA6IHVuZGVmaW5lZCB9LCB5ZWFyc0xpc3QpKSk7XG4gICAgfTtcbiAgICByZXR1cm4gWWVhcjtcbn0oQ29tcG9uZW50KSk7XG5cbmZ1bmN0aW9uIGdlbmVyYXRlWWVhcnMoeWVhciwgbm9PZlllYXIsIG1pbkRhdGUsIG1heERhdGUpIHtcbiAgICB2YXIgbGlzdCA9IFtdO1xuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgMiAqIG5vT2ZZZWFyICsgMTsgaSsrKSB7XG4gICAgICAgIHZhciBuZXdZZWFyID0geWVhciArIG5vT2ZZZWFyIC0gaTtcbiAgICAgICAgdmFyIGlzSW5SYW5nZSA9IHRydWU7XG4gICAgICAgIGlmIChtaW5EYXRlKSB7XG4gICAgICAgICAgICBpc0luUmFuZ2UgPSBnZXRZZWFyKG1pbkRhdGUpIDw9IG5ld1llYXI7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKG1heERhdGUgJiYgaXNJblJhbmdlKSB7XG4gICAgICAgICAgICBpc0luUmFuZ2UgPSBnZXRZZWFyKG1heERhdGUpID49IG5ld1llYXI7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGlzSW5SYW5nZSkge1xuICAgICAgICAgICAgbGlzdC5wdXNoKG5ld1llYXIpO1xuICAgICAgICB9XG4gICAgfVxuICAgIHJldHVybiBsaXN0O1xufVxudmFyIFllYXJEcm9wZG93bk9wdGlvbnMgPSAvKiogQGNsYXNzICovIChmdW5jdGlvbiAoX3N1cGVyKSB7XG4gICAgX19leHRlbmRzKFllYXJEcm9wZG93bk9wdGlvbnMsIF9zdXBlcik7XG4gICAgZnVuY3Rpb24gWWVhckRyb3Bkb3duT3B0aW9ucyhwcm9wcykge1xuICAgICAgICB2YXIgX3RoaXMgPSBfc3VwZXIuY2FsbCh0aGlzLCBwcm9wcykgfHwgdGhpcztcbiAgICAgICAgX3RoaXMueWVhck9wdGlvbkJ1dHRvbnNSZWYgPSB7fTtcbiAgICAgICAgX3RoaXMuaGFuZGxlT3B0aW9uS2V5RG93biA9IGZ1bmN0aW9uICh5ZWFyLCBlKSB7XG4gICAgICAgICAgICB2YXIgX2E7XG4gICAgICAgICAgICBzd2l0Y2ggKGUua2V5KSB7XG4gICAgICAgICAgICAgICAgY2FzZSBcIkVudGVyXCI6XG4gICAgICAgICAgICAgICAgICAgIGUucHJldmVudERlZmF1bHQoKTtcbiAgICAgICAgICAgICAgICAgICAgX3RoaXMub25DaGFuZ2UoeWVhcik7XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIGNhc2UgXCJFc2NhcGVcIjpcbiAgICAgICAgICAgICAgICAgICAgZS5wcmV2ZW50RGVmYXVsdCgpO1xuICAgICAgICAgICAgICAgICAgICBfdGhpcy5wcm9wcy5vbkNhbmNlbCgpO1xuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICBjYXNlIFwiQXJyb3dVcFwiOlxuICAgICAgICAgICAgICAgIGNhc2UgXCJBcnJvd0Rvd25cIjoge1xuICAgICAgICAgICAgICAgICAgICBlLnByZXZlbnREZWZhdWx0KCk7XG4gICAgICAgICAgICAgICAgICAgIHZhciBuZXdZZWFyID0geWVhciArIChlLmtleSA9PT0gXCJBcnJvd1VwXCIgPyAxIDogLTEpO1xuICAgICAgICAgICAgICAgICAgICAvLyBBZGQgYm91bmRzIGNoZWNraW5nIHRvIGVuc3VyZSB0aGUgeWVhciBleGlzdHMgaW4gb3VyIHJlZnNcbiAgICAgICAgICAgICAgICAgICAgaWYgKF90aGlzLnllYXJPcHRpb25CdXR0b25zUmVmW25ld1llYXJdKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAoX2EgPSBfdGhpcy55ZWFyT3B0aW9uQnV0dG9uc1JlZltuZXdZZWFyXSkgPT09IG51bGwgfHwgX2EgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9hLmZvY3VzKCk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9O1xuICAgICAgICBfdGhpcy5yZW5kZXJPcHRpb25zID0gZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgLy8gQ2xlYXIgcmVmcyB0byBwcmV2ZW50IG1lbW9yeSBsZWFrcyBvbiByZS1yZW5kZXJcbiAgICAgICAgICAgIF90aGlzLnllYXJPcHRpb25CdXR0b25zUmVmID0ge307XG4gICAgICAgICAgICB2YXIgc2VsZWN0ZWRZZWFyID0gX3RoaXMucHJvcHMueWVhcjtcbiAgICAgICAgICAgIHZhciBvcHRpb25zID0gX3RoaXMuc3RhdGUueWVhcnNMaXN0Lm1hcChmdW5jdGlvbiAoeWVhcikgeyByZXR1cm4gKFJlYWN0LmNyZWF0ZUVsZW1lbnQoXCJkaXZcIiwgeyByZWY6IGZ1bmN0aW9uIChlbCkge1xuICAgICAgICAgICAgICAgICAgICBfdGhpcy55ZWFyT3B0aW9uQnV0dG9uc1JlZlt5ZWFyXSA9IGVsO1xuICAgICAgICAgICAgICAgICAgICBpZiAoeWVhciA9PT0gc2VsZWN0ZWRZZWFyKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBlbCA9PT0gbnVsbCB8fCBlbCA9PT0gdm9pZCAwID8gdm9pZCAwIDogZWwuZm9jdXMoKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH0sIHJvbGU6IFwiYnV0dG9uXCIsIHRhYkluZGV4OiAwLCBjbGFzc05hbWU6IHNlbGVjdGVkWWVhciA9PT0geWVhclxuICAgICAgICAgICAgICAgICAgICA/IFwicmVhY3QtZGF0ZXBpY2tlcl9feWVhci1vcHRpb24gcmVhY3QtZGF0ZXBpY2tlcl9feWVhci1vcHRpb24tLXNlbGVjdGVkX3llYXJcIlxuICAgICAgICAgICAgICAgICAgICA6IFwicmVhY3QtZGF0ZXBpY2tlcl9feWVhci1vcHRpb25cIiwga2V5OiB5ZWFyLCBvbkNsaWNrOiBfdGhpcy5vbkNoYW5nZS5iaW5kKF90aGlzLCB5ZWFyKSwgb25LZXlEb3duOiBfdGhpcy5oYW5kbGVPcHRpb25LZXlEb3duLmJpbmQoX3RoaXMsIHllYXIpLCBcImFyaWEtc2VsZWN0ZWRcIjogc2VsZWN0ZWRZZWFyID09PSB5ZWFyID8gXCJ0cnVlXCIgOiB1bmRlZmluZWQgfSxcbiAgICAgICAgICAgICAgICBzZWxlY3RlZFllYXIgPT09IHllYXIgPyAoUmVhY3QuY3JlYXRlRWxlbWVudChcInNwYW5cIiwgeyBjbGFzc05hbWU6IFwicmVhY3QtZGF0ZXBpY2tlcl9feWVhci1vcHRpb24tLXNlbGVjdGVkXCIgfSwgXCJcXHUyNzEzXCIpKSA6IChcIlwiKSxcbiAgICAgICAgICAgICAgICB5ZWFyKSk7IH0pO1xuICAgICAgICAgICAgdmFyIG1pblllYXIgPSBfdGhpcy5wcm9wcy5taW5EYXRlID8gZ2V0WWVhcihfdGhpcy5wcm9wcy5taW5EYXRlKSA6IG51bGw7XG4gICAgICAgICAgICB2YXIgbWF4WWVhciA9IF90aGlzLnByb3BzLm1heERhdGUgPyBnZXRZZWFyKF90aGlzLnByb3BzLm1heERhdGUpIDogbnVsbDtcbiAgICAgICAgICAgIGlmICghbWF4WWVhciB8fCAhX3RoaXMuc3RhdGUueWVhcnNMaXN0LmZpbmQoZnVuY3Rpb24gKHllYXIpIHsgcmV0dXJuIHllYXIgPT09IG1heFllYXI7IH0pKSB7XG4gICAgICAgICAgICAgICAgb3B0aW9ucy51bnNoaWZ0KFJlYWN0LmNyZWF0ZUVsZW1lbnQoXCJkaXZcIiwgeyBjbGFzc05hbWU6IFwicmVhY3QtZGF0ZXBpY2tlcl9feWVhci1vcHRpb25cIiwga2V5OiBcInVwY29taW5nXCIsIG9uQ2xpY2s6IF90aGlzLmluY3JlbWVudFllYXJzIH0sXG4gICAgICAgICAgICAgICAgICAgIFJlYWN0LmNyZWF0ZUVsZW1lbnQoXCJhXCIsIHsgY2xhc3NOYW1lOiBcInJlYWN0LWRhdGVwaWNrZXJfX25hdmlnYXRpb24gcmVhY3QtZGF0ZXBpY2tlcl9fbmF2aWdhdGlvbi0teWVhcnMgcmVhY3QtZGF0ZXBpY2tlcl9fbmF2aWdhdGlvbi0teWVhcnMtdXBjb21pbmdcIiB9KSkpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKCFtaW5ZZWFyIHx8ICFfdGhpcy5zdGF0ZS55ZWFyc0xpc3QuZmluZChmdW5jdGlvbiAoeWVhcikgeyByZXR1cm4geWVhciA9PT0gbWluWWVhcjsgfSkpIHtcbiAgICAgICAgICAgICAgICBvcHRpb25zLnB1c2goUmVhY3QuY3JlYXRlRWxlbWVudChcImRpdlwiLCB7IGNsYXNzTmFtZTogXCJyZWFjdC1kYXRlcGlja2VyX195ZWFyLW9wdGlvblwiLCBrZXk6IFwicHJldmlvdXNcIiwgb25DbGljazogX3RoaXMuZGVjcmVtZW50WWVhcnMgfSxcbiAgICAgICAgICAgICAgICAgICAgUmVhY3QuY3JlYXRlRWxlbWVudChcImFcIiwgeyBjbGFzc05hbWU6IFwicmVhY3QtZGF0ZXBpY2tlcl9fbmF2aWdhdGlvbiByZWFjdC1kYXRlcGlja2VyX19uYXZpZ2F0aW9uLS15ZWFycyByZWFjdC1kYXRlcGlja2VyX19uYXZpZ2F0aW9uLS15ZWFycy1wcmV2aW91c1wiIH0pKSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gb3B0aW9ucztcbiAgICAgICAgfTtcbiAgICAgICAgX3RoaXMub25DaGFuZ2UgPSBmdW5jdGlvbiAoeWVhcikge1xuICAgICAgICAgICAgX3RoaXMucHJvcHMub25DaGFuZ2UoeWVhcik7XG4gICAgICAgIH07XG4gICAgICAgIF90aGlzLmhhbmRsZUNsaWNrT3V0c2lkZSA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIF90aGlzLnByb3BzLm9uQ2FuY2VsKCk7XG4gICAgICAgIH07XG4gICAgICAgIF90aGlzLnNoaWZ0WWVhcnMgPSBmdW5jdGlvbiAoYW1vdW50KSB7XG4gICAgICAgICAgICB2YXIgeWVhcnMgPSBfdGhpcy5zdGF0ZS55ZWFyc0xpc3QubWFwKGZ1bmN0aW9uICh5ZWFyKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHllYXIgKyBhbW91bnQ7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIF90aGlzLnNldFN0YXRlKHtcbiAgICAgICAgICAgICAgICB5ZWFyc0xpc3Q6IHllYXJzLFxuICAgICAgICAgICAgfSk7XG4gICAgICAgIH07XG4gICAgICAgIF90aGlzLmluY3JlbWVudFllYXJzID0gZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgcmV0dXJuIF90aGlzLnNoaWZ0WWVhcnMoMSk7XG4gICAgICAgIH07XG4gICAgICAgIF90aGlzLmRlY3JlbWVudFllYXJzID0gZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgcmV0dXJuIF90aGlzLnNoaWZ0WWVhcnMoLTEpO1xuICAgICAgICB9O1xuICAgICAgICB2YXIgeWVhckRyb3Bkb3duSXRlbU51bWJlciA9IHByb3BzLnllYXJEcm9wZG93bkl0ZW1OdW1iZXIsIHNjcm9sbGFibGVZZWFyRHJvcGRvd24gPSBwcm9wcy5zY3JvbGxhYmxlWWVhckRyb3Bkb3duO1xuICAgICAgICB2YXIgbm9PZlllYXIgPSB5ZWFyRHJvcGRvd25JdGVtTnVtYmVyIHx8IChzY3JvbGxhYmxlWWVhckRyb3Bkb3duID8gMTAgOiA1KTtcbiAgICAgICAgX3RoaXMuc3RhdGUgPSB7XG4gICAgICAgICAgICB5ZWFyc0xpc3Q6IGdlbmVyYXRlWWVhcnMoX3RoaXMucHJvcHMueWVhciwgbm9PZlllYXIsIF90aGlzLnByb3BzLm1pbkRhdGUsIF90aGlzLnByb3BzLm1heERhdGUpLFxuICAgICAgICB9O1xuICAgICAgICBfdGhpcy5kcm9wZG93blJlZiA9IGNyZWF0ZVJlZigpO1xuICAgICAgICByZXR1cm4gX3RoaXM7XG4gICAgfVxuICAgIFllYXJEcm9wZG93bk9wdGlvbnMucHJvdG90eXBlLmNvbXBvbmVudERpZE1vdW50ID0gZnVuY3Rpb24gKCkge1xuICAgICAgICB2YXIgZHJvcGRvd25DdXJyZW50ID0gdGhpcy5kcm9wZG93blJlZi5jdXJyZW50O1xuICAgICAgICBpZiAoZHJvcGRvd25DdXJyZW50KSB7XG4gICAgICAgICAgICAvLyBHZXQgYXJyYXkgZnJvbSBIVE1MQ29sbGVjdGlvblxuICAgICAgICAgICAgdmFyIGRyb3Bkb3duQ3VycmVudENoaWxkcmVuID0gZHJvcGRvd25DdXJyZW50LmNoaWxkcmVuXG4gICAgICAgICAgICAgICAgPyBBcnJheS5mcm9tKGRyb3Bkb3duQ3VycmVudC5jaGlsZHJlbilcbiAgICAgICAgICAgICAgICA6IG51bGw7XG4gICAgICAgICAgICB2YXIgc2VsZWN0ZWRZZWFyT3B0aW9uRWwgPSBkcm9wZG93bkN1cnJlbnRDaGlsZHJlblxuICAgICAgICAgICAgICAgID8gZHJvcGRvd25DdXJyZW50Q2hpbGRyZW4uZmluZChmdW5jdGlvbiAoY2hpbGRFbCkgeyByZXR1cm4gY2hpbGRFbC5hcmlhU2VsZWN0ZWQ7IH0pXG4gICAgICAgICAgICAgICAgOiBudWxsO1xuICAgICAgICAgICAgZHJvcGRvd25DdXJyZW50LnNjcm9sbFRvcCA9XG4gICAgICAgICAgICAgICAgc2VsZWN0ZWRZZWFyT3B0aW9uRWwgJiYgc2VsZWN0ZWRZZWFyT3B0aW9uRWwgaW5zdGFuY2VvZiBIVE1MRWxlbWVudFxuICAgICAgICAgICAgICAgICAgICA/IHNlbGVjdGVkWWVhck9wdGlvbkVsLm9mZnNldFRvcCArXG4gICAgICAgICAgICAgICAgICAgICAgICAoc2VsZWN0ZWRZZWFyT3B0aW9uRWwuY2xpZW50SGVpZ2h0IC0gZHJvcGRvd25DdXJyZW50LmNsaWVudEhlaWdodCkgL1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIDJcbiAgICAgICAgICAgICAgICAgICAgOiAoZHJvcGRvd25DdXJyZW50LnNjcm9sbEhlaWdodCAtIGRyb3Bkb3duQ3VycmVudC5jbGllbnRIZWlnaHQpIC8gMjtcbiAgICAgICAgfVxuICAgIH07XG4gICAgWWVhckRyb3Bkb3duT3B0aW9ucy5wcm90b3R5cGUucmVuZGVyID0gZnVuY3Rpb24gKCkge1xuICAgICAgICB2YXIgZHJvcGRvd25DbGFzcyA9IGNsc3goe1xuICAgICAgICAgICAgXCJyZWFjdC1kYXRlcGlja2VyX195ZWFyLWRyb3Bkb3duXCI6IHRydWUsXG4gICAgICAgICAgICBcInJlYWN0LWRhdGVwaWNrZXJfX3llYXItZHJvcGRvd24tLXNjcm9sbGFibGVcIjogdGhpcy5wcm9wcy5zY3JvbGxhYmxlWWVhckRyb3Bkb3duLFxuICAgICAgICB9KTtcbiAgICAgICAgcmV0dXJuIChSZWFjdC5jcmVhdGVFbGVtZW50KENsaWNrT3V0c2lkZVdyYXBwZXIsIHsgY2xhc3NOYW1lOiBkcm9wZG93bkNsYXNzLCBjb250YWluZXJSZWY6IHRoaXMuZHJvcGRvd25SZWYsIG9uQ2xpY2tPdXRzaWRlOiB0aGlzLmhhbmRsZUNsaWNrT3V0c2lkZSB9LCB0aGlzLnJlbmRlck9wdGlvbnMoKSkpO1xuICAgIH07XG4gICAgcmV0dXJuIFllYXJEcm9wZG93bk9wdGlvbnM7XG59KENvbXBvbmVudCkpO1xuXG52YXIgWWVhckRyb3Bkb3duID0gLyoqIEBjbGFzcyAqLyAoZnVuY3Rpb24gKF9zdXBlcikge1xuICAgIF9fZXh0ZW5kcyhZZWFyRHJvcGRvd24sIF9zdXBlcik7XG4gICAgZnVuY3Rpb24gWWVhckRyb3Bkb3duKCkge1xuICAgICAgICB2YXIgX3RoaXMgPSBfc3VwZXIgIT09IG51bGwgJiYgX3N1cGVyLmFwcGx5KHRoaXMsIGFyZ3VtZW50cykgfHwgdGhpcztcbiAgICAgICAgX3RoaXMuc3RhdGUgPSB7XG4gICAgICAgICAgICBkcm9wZG93blZpc2libGU6IGZhbHNlLFxuICAgICAgICB9O1xuICAgICAgICBfdGhpcy5yZW5kZXJTZWxlY3RPcHRpb25zID0gZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgdmFyIG1pblllYXIgPSBfdGhpcy5wcm9wcy5taW5EYXRlXG4gICAgICAgICAgICAgICAgPyBnZXRZZWFyKF90aGlzLnByb3BzLm1pbkRhdGUpXG4gICAgICAgICAgICAgICAgOiAxOTAwO1xuICAgICAgICAgICAgdmFyIG1heFllYXIgPSBfdGhpcy5wcm9wcy5tYXhEYXRlXG4gICAgICAgICAgICAgICAgPyBnZXRZZWFyKF90aGlzLnByb3BzLm1heERhdGUpXG4gICAgICAgICAgICAgICAgOiAyMTAwO1xuICAgICAgICAgICAgdmFyIG9wdGlvbnMgPSBbXTtcbiAgICAgICAgICAgIGZvciAodmFyIGkgPSBtaW5ZZWFyOyBpIDw9IG1heFllYXI7IGkrKykge1xuICAgICAgICAgICAgICAgIG9wdGlvbnMucHVzaChSZWFjdC5jcmVhdGVFbGVtZW50KFwib3B0aW9uXCIsIHsga2V5OiBpLCB2YWx1ZTogaSB9LCBpKSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gb3B0aW9ucztcbiAgICAgICAgfTtcbiAgICAgICAgX3RoaXMub25TZWxlY3RDaGFuZ2UgPSBmdW5jdGlvbiAoZXZlbnQpIHtcbiAgICAgICAgICAgIF90aGlzLm9uQ2hhbmdlKHBhcnNlSW50KGV2ZW50LnRhcmdldC52YWx1ZSkpO1xuICAgICAgICB9O1xuICAgICAgICBfdGhpcy5yZW5kZXJTZWxlY3RNb2RlID0gZnVuY3Rpb24gKCkgeyByZXR1cm4gKFJlYWN0LmNyZWF0ZUVsZW1lbnQoXCJzZWxlY3RcIiwgeyB2YWx1ZTogX3RoaXMucHJvcHMueWVhciwgY2xhc3NOYW1lOiBcInJlYWN0LWRhdGVwaWNrZXJfX3llYXItc2VsZWN0XCIsIG9uQ2hhbmdlOiBfdGhpcy5vblNlbGVjdENoYW5nZSB9LCBfdGhpcy5yZW5kZXJTZWxlY3RPcHRpb25zKCkpKTsgfTtcbiAgICAgICAgX3RoaXMucmVuZGVyUmVhZFZpZXcgPSBmdW5jdGlvbiAodmlzaWJsZSkgeyByZXR1cm4gKFJlYWN0LmNyZWF0ZUVsZW1lbnQoXCJidXR0b25cIiwgeyBrZXk6IFwicmVhZFwiLCB0eXBlOiBcImJ1dHRvblwiLCBzdHlsZTogeyB2aXNpYmlsaXR5OiB2aXNpYmxlID8gXCJ2aXNpYmxlXCIgOiBcImhpZGRlblwiIH0sIGNsYXNzTmFtZTogXCJyZWFjdC1kYXRlcGlja2VyX195ZWFyLXJlYWQtdmlld1wiLCBvbkNsaWNrOiBfdGhpcy50b2dnbGVEcm9wZG93biB9LFxuICAgICAgICAgICAgUmVhY3QuY3JlYXRlRWxlbWVudChcInNwYW5cIiwgeyBjbGFzc05hbWU6IFwicmVhY3QtZGF0ZXBpY2tlcl9feWVhci1yZWFkLXZpZXctLWRvd24tYXJyb3dcIiB9KSxcbiAgICAgICAgICAgIFJlYWN0LmNyZWF0ZUVsZW1lbnQoXCJzcGFuXCIsIHsgY2xhc3NOYW1lOiBcInJlYWN0LWRhdGVwaWNrZXJfX3llYXItcmVhZC12aWV3LS1zZWxlY3RlZC15ZWFyXCIgfSwgX3RoaXMucHJvcHMueWVhcikpKTsgfTtcbiAgICAgICAgX3RoaXMucmVuZGVyRHJvcGRvd24gPSBmdW5jdGlvbiAoKSB7IHJldHVybiAoUmVhY3QuY3JlYXRlRWxlbWVudChZZWFyRHJvcGRvd25PcHRpb25zLCBfYXNzaWduKHsga2V5OiBcImRyb3Bkb3duXCIgfSwgX3RoaXMucHJvcHMsIHsgb25DaGFuZ2U6IF90aGlzLm9uQ2hhbmdlLCBvbkNhbmNlbDogX3RoaXMudG9nZ2xlRHJvcGRvd24gfSkpKTsgfTtcbiAgICAgICAgX3RoaXMucmVuZGVyU2Nyb2xsTW9kZSA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIHZhciBkcm9wZG93blZpc2libGUgPSBfdGhpcy5zdGF0ZS5kcm9wZG93blZpc2libGU7XG4gICAgICAgICAgICB2YXIgcmVzdWx0ID0gW190aGlzLnJlbmRlclJlYWRWaWV3KCFkcm9wZG93blZpc2libGUpXTtcbiAgICAgICAgICAgIGlmIChkcm9wZG93blZpc2libGUpIHtcbiAgICAgICAgICAgICAgICByZXN1bHQudW5zaGlmdChfdGhpcy5yZW5kZXJEcm9wZG93bigpKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgICAgIH07XG4gICAgICAgIF90aGlzLm9uQ2hhbmdlID0gZnVuY3Rpb24gKHllYXIpIHtcbiAgICAgICAgICAgIF90aGlzLnRvZ2dsZURyb3Bkb3duKCk7XG4gICAgICAgICAgICBpZiAoeWVhciA9PT0gX3RoaXMucHJvcHMueWVhcilcbiAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICBfdGhpcy5wcm9wcy5vbkNoYW5nZSh5ZWFyKTtcbiAgICAgICAgfTtcbiAgICAgICAgX3RoaXMudG9nZ2xlRHJvcGRvd24gPSBmdW5jdGlvbiAoZXZlbnQpIHtcbiAgICAgICAgICAgIF90aGlzLnNldFN0YXRlKHtcbiAgICAgICAgICAgICAgICBkcm9wZG93blZpc2libGU6ICFfdGhpcy5zdGF0ZS5kcm9wZG93blZpc2libGUsXG4gICAgICAgICAgICB9LCBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICAgICAgaWYgKF90aGlzLnByb3BzLmFkanVzdERhdGVPbkNoYW5nZSkge1xuICAgICAgICAgICAgICAgICAgICBfdGhpcy5oYW5kbGVZZWFyQ2hhbmdlKF90aGlzLnByb3BzLmRhdGUsIGV2ZW50KTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfTtcbiAgICAgICAgX3RoaXMuaGFuZGxlWWVhckNoYW5nZSA9IGZ1bmN0aW9uIChkYXRlLCBldmVudCkge1xuICAgICAgICAgICAgdmFyIF9hO1xuICAgICAgICAgICAgKF9hID0gX3RoaXMub25TZWxlY3QpID09PSBudWxsIHx8IF9hID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYS5jYWxsKF90aGlzLCBkYXRlLCBldmVudCk7XG4gICAgICAgICAgICBfdGhpcy5zZXRPcGVuKCk7XG4gICAgICAgIH07XG4gICAgICAgIF90aGlzLm9uU2VsZWN0ID0gZnVuY3Rpb24gKGRhdGUsIGV2ZW50KSB7XG4gICAgICAgICAgICB2YXIgX2EsIF9iO1xuICAgICAgICAgICAgKF9iID0gKF9hID0gX3RoaXMucHJvcHMpLm9uU2VsZWN0KSA9PT0gbnVsbCB8fCBfYiA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2IuY2FsbChfYSwgZGF0ZSwgZXZlbnQpO1xuICAgICAgICB9O1xuICAgICAgICBfdGhpcy5zZXRPcGVuID0gZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgdmFyIF9hLCBfYjtcbiAgICAgICAgICAgIChfYiA9IChfYSA9IF90aGlzLnByb3BzKS5zZXRPcGVuKSA9PT0gbnVsbCB8fCBfYiA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2IuY2FsbChfYSwgdHJ1ZSk7XG4gICAgICAgIH07XG4gICAgICAgIHJldHVybiBfdGhpcztcbiAgICB9XG4gICAgWWVhckRyb3Bkb3duLnByb3RvdHlwZS5yZW5kZXIgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHZhciByZW5kZXJlZERyb3Bkb3duO1xuICAgICAgICBzd2l0Y2ggKHRoaXMucHJvcHMuZHJvcGRvd25Nb2RlKSB7XG4gICAgICAgICAgICBjYXNlIFwic2Nyb2xsXCI6XG4gICAgICAgICAgICAgICAgcmVuZGVyZWREcm9wZG93biA9IHRoaXMucmVuZGVyU2Nyb2xsTW9kZSgpO1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgY2FzZSBcInNlbGVjdFwiOlxuICAgICAgICAgICAgICAgIHJlbmRlcmVkRHJvcGRvd24gPSB0aGlzLnJlbmRlclNlbGVjdE1vZGUoKTtcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gKFJlYWN0LmNyZWF0ZUVsZW1lbnQoXCJkaXZcIiwgeyBjbGFzc05hbWU6IFwicmVhY3QtZGF0ZXBpY2tlcl9feWVhci1kcm9wZG93bi1jb250YWluZXIgcmVhY3QtZGF0ZXBpY2tlcl9feWVhci1kcm9wZG93bi1jb250YWluZXItLVwiLmNvbmNhdCh0aGlzLnByb3BzLmRyb3Bkb3duTW9kZSkgfSwgcmVuZGVyZWREcm9wZG93bikpO1xuICAgIH07XG4gICAgcmV0dXJuIFllYXJEcm9wZG93bjtcbn0oQ29tcG9uZW50KSk7XG5cbnZhciBEUk9QRE9XTl9GT0NVU19DTEFTU05BTUVTID0gW1xuICAgIFwicmVhY3QtZGF0ZXBpY2tlcl9feWVhci1zZWxlY3RcIixcbiAgICBcInJlYWN0LWRhdGVwaWNrZXJfX21vbnRoLXNlbGVjdFwiLFxuICAgIFwicmVhY3QtZGF0ZXBpY2tlcl9fbW9udGgteWVhci1zZWxlY3RcIixcbl07XG52YXIgT1VUU0lERV9DTElDS19JR05PUkVfQ0xBU1MgPSBcInJlYWN0LWRhdGVwaWNrZXItaWdub3JlLW9uY2xpY2tvdXRzaWRlXCI7XG52YXIgaXNEcm9wZG93blNlbGVjdCA9IGZ1bmN0aW9uIChlbGVtZW50KSB7XG4gICAgdmFyIGNsYXNzTmFtZXMgPSAoZWxlbWVudC5jbGFzc05hbWUgfHwgXCJcIikuc3BsaXQoL1xccysvKTtcbiAgICByZXR1cm4gRFJPUERPV05fRk9DVVNfQ0xBU1NOQU1FUy5zb21lKGZ1bmN0aW9uICh0ZXN0Q2xhc3NuYW1lKSB7IHJldHVybiBjbGFzc05hbWVzLmluZGV4T2YodGVzdENsYXNzbmFtZSkgPj0gMDsgfSk7XG59O1xudmFyIENhbGVuZGFyID0gLyoqIEBjbGFzcyAqLyAoZnVuY3Rpb24gKF9zdXBlcikge1xuICAgIF9fZXh0ZW5kcyhDYWxlbmRhciwgX3N1cGVyKTtcbiAgICBmdW5jdGlvbiBDYWxlbmRhcihwcm9wcykge1xuICAgICAgICB2YXIgX3RoaXMgPSBfc3VwZXIuY2FsbCh0aGlzLCBwcm9wcykgfHwgdGhpcztcbiAgICAgICAgX3RoaXMubW9udGhDb250YWluZXIgPSB1bmRlZmluZWQ7XG4gICAgICAgIF90aGlzLmhhbmRsZUNsaWNrT3V0c2lkZSA9IGZ1bmN0aW9uIChldmVudCkge1xuICAgICAgICAgICAgX3RoaXMucHJvcHMub25DbGlja091dHNpZGUoZXZlbnQpO1xuICAgICAgICB9O1xuICAgICAgICBfdGhpcy5zZXRDbGlja091dHNpZGVSZWYgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICByZXR1cm4gX3RoaXMuY29udGFpbmVyUmVmLmN1cnJlbnQ7XG4gICAgICAgIH07XG4gICAgICAgIF90aGlzLmhhbmRsZURyb3Bkb3duRm9jdXMgPSBmdW5jdGlvbiAoZXZlbnQpIHtcbiAgICAgICAgICAgIHZhciBfYSwgX2I7XG4gICAgICAgICAgICBpZiAoaXNEcm9wZG93blNlbGVjdChldmVudC50YXJnZXQpKSB7XG4gICAgICAgICAgICAgICAgKF9iID0gKF9hID0gX3RoaXMucHJvcHMpLm9uRHJvcGRvd25Gb2N1cykgPT09IG51bGwgfHwgX2IgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9iLmNhbGwoX2EsIGV2ZW50KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfTtcbiAgICAgICAgX3RoaXMuZ2V0RGF0ZUluVmlldyA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIHZhciBfYSA9IF90aGlzLnByb3BzLCBwcmVTZWxlY3Rpb24gPSBfYS5wcmVTZWxlY3Rpb24sIHNlbGVjdGVkID0gX2Euc2VsZWN0ZWQsIG9wZW5Ub0RhdGUgPSBfYS5vcGVuVG9EYXRlO1xuICAgICAgICAgICAgdmFyIG1pbkRhdGUgPSBnZXRFZmZlY3RpdmVNaW5EYXRlKF90aGlzLnByb3BzKTtcbiAgICAgICAgICAgIHZhciBtYXhEYXRlID0gZ2V0RWZmZWN0aXZlTWF4RGF0ZShfdGhpcy5wcm9wcyk7XG4gICAgICAgICAgICB2YXIgY3VycmVudCA9IG5ld0RhdGUoKTtcbiAgICAgICAgICAgIHZhciBpbml0aWFsRGF0ZSA9IG9wZW5Ub0RhdGUgfHwgc2VsZWN0ZWQgfHwgcHJlU2VsZWN0aW9uO1xuICAgICAgICAgICAgaWYgKGluaXRpYWxEYXRlKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGluaXRpYWxEYXRlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgaWYgKG1pbkRhdGUgJiYgaXNCZWZvcmUoY3VycmVudCwgbWluRGF0ZSkpIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIG1pbkRhdGU7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2UgaWYgKG1heERhdGUgJiYgaXNBZnRlcihjdXJyZW50LCBtYXhEYXRlKSkge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gbWF4RGF0ZTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gY3VycmVudDtcbiAgICAgICAgfTtcbiAgICAgICAgX3RoaXMuaW5jcmVhc2VNb250aCA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIF90aGlzLnNldFN0YXRlKGZ1bmN0aW9uIChfYSkge1xuICAgICAgICAgICAgICAgIHZhciBkYXRlID0gX2EuZGF0ZTtcbiAgICAgICAgICAgICAgICByZXR1cm4gKHtcbiAgICAgICAgICAgICAgICAgICAgZGF0ZTogYWRkTW9udGhzKGRhdGUsIDEpLFxuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgfSwgZnVuY3Rpb24gKCkgeyByZXR1cm4gX3RoaXMuaGFuZGxlTW9udGhDaGFuZ2UoX3RoaXMuc3RhdGUuZGF0ZSk7IH0pO1xuICAgICAgICB9O1xuICAgICAgICBfdGhpcy5kZWNyZWFzZU1vbnRoID0gZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgX3RoaXMuc2V0U3RhdGUoZnVuY3Rpb24gKF9hKSB7XG4gICAgICAgICAgICAgICAgdmFyIGRhdGUgPSBfYS5kYXRlO1xuICAgICAgICAgICAgICAgIHJldHVybiAoe1xuICAgICAgICAgICAgICAgICAgICBkYXRlOiBzdWJNb250aHMoZGF0ZSwgMSksXG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB9LCBmdW5jdGlvbiAoKSB7IHJldHVybiBfdGhpcy5oYW5kbGVNb250aENoYW5nZShfdGhpcy5zdGF0ZS5kYXRlKTsgfSk7XG4gICAgICAgIH07XG4gICAgICAgIF90aGlzLmhhbmRsZURheUNsaWNrID0gZnVuY3Rpb24gKGRheSwgZXZlbnQsIG1vbnRoU2VsZWN0ZWRJbikge1xuICAgICAgICAgICAgX3RoaXMucHJvcHMub25TZWxlY3QoZGF5LCBldmVudCwgbW9udGhTZWxlY3RlZEluKTtcbiAgICAgICAgICAgIF90aGlzLnByb3BzLnNldFByZVNlbGVjdGlvbiAmJiBfdGhpcy5wcm9wcy5zZXRQcmVTZWxlY3Rpb24oZGF5KTtcbiAgICAgICAgfTtcbiAgICAgICAgX3RoaXMuaGFuZGxlRGF5TW91c2VFbnRlciA9IGZ1bmN0aW9uIChkYXkpIHtcbiAgICAgICAgICAgIF90aGlzLnNldFN0YXRlKHsgc2VsZWN0aW5nRGF0ZTogZGF5IH0pO1xuICAgICAgICAgICAgX3RoaXMucHJvcHMub25EYXlNb3VzZUVudGVyICYmIF90aGlzLnByb3BzLm9uRGF5TW91c2VFbnRlcihkYXkpO1xuICAgICAgICB9O1xuICAgICAgICBfdGhpcy5oYW5kbGVNb250aE1vdXNlTGVhdmUgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICBfdGhpcy5zZXRTdGF0ZSh7IHNlbGVjdGluZ0RhdGU6IHVuZGVmaW5lZCB9KTtcbiAgICAgICAgICAgIF90aGlzLnByb3BzLm9uTW9udGhNb3VzZUxlYXZlICYmIF90aGlzLnByb3BzLm9uTW9udGhNb3VzZUxlYXZlKCk7XG4gICAgICAgIH07XG4gICAgICAgIF90aGlzLmhhbmRsZVllYXJNb3VzZUVudGVyID0gZnVuY3Rpb24gKGV2ZW50LCB5ZWFyKSB7XG4gICAgICAgICAgICBfdGhpcy5zZXRTdGF0ZSh7IHNlbGVjdGluZ0RhdGU6IHNldFllYXIobmV3RGF0ZSgpLCB5ZWFyKSB9KTtcbiAgICAgICAgICAgICEhX3RoaXMucHJvcHMub25ZZWFyTW91c2VFbnRlciAmJiBfdGhpcy5wcm9wcy5vblllYXJNb3VzZUVudGVyKGV2ZW50LCB5ZWFyKTtcbiAgICAgICAgfTtcbiAgICAgICAgX3RoaXMuaGFuZGxlWWVhck1vdXNlTGVhdmUgPSBmdW5jdGlvbiAoZXZlbnQsIHllYXIpIHtcbiAgICAgICAgICAgICEhX3RoaXMucHJvcHMub25ZZWFyTW91c2VMZWF2ZSAmJiBfdGhpcy5wcm9wcy5vblllYXJNb3VzZUxlYXZlKGV2ZW50LCB5ZWFyKTtcbiAgICAgICAgfTtcbiAgICAgICAgX3RoaXMuaGFuZGxlWWVhckNoYW5nZSA9IGZ1bmN0aW9uIChkYXRlKSB7XG4gICAgICAgICAgICB2YXIgX2EsIF9iLCBfYywgX2Q7XG4gICAgICAgICAgICAoX2IgPSAoX2EgPSBfdGhpcy5wcm9wcykub25ZZWFyQ2hhbmdlKSA9PT0gbnVsbCB8fCBfYiA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2IuY2FsbChfYSwgZGF0ZSk7XG4gICAgICAgICAgICBfdGhpcy5zZXRTdGF0ZSh7IGlzUmVuZGVyQXJpYUxpdmVNZXNzYWdlOiB0cnVlIH0pO1xuICAgICAgICAgICAgaWYgKF90aGlzLnByb3BzLmFkanVzdERhdGVPbkNoYW5nZSkge1xuICAgICAgICAgICAgICAgIF90aGlzLnByb3BzLm9uU2VsZWN0KGRhdGUpO1xuICAgICAgICAgICAgICAgIChfZCA9IChfYyA9IF90aGlzLnByb3BzKS5zZXRPcGVuKSA9PT0gbnVsbCB8fCBfZCA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2QuY2FsbChfYywgdHJ1ZSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBfdGhpcy5wcm9wcy5zZXRQcmVTZWxlY3Rpb24gJiYgX3RoaXMucHJvcHMuc2V0UHJlU2VsZWN0aW9uKGRhdGUpO1xuICAgICAgICB9O1xuICAgICAgICBfdGhpcy5nZXRFbmFibGVkUHJlU2VsZWN0aW9uRGF0ZUZvck1vbnRoID0gZnVuY3Rpb24gKGRhdGUpIHtcbiAgICAgICAgICAgIGlmICghaXNEYXlEaXNhYmxlZChkYXRlLCBfdGhpcy5wcm9wcykpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gZGF0ZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHZhciBzdGFydE9mTW9udGggPSBnZXRTdGFydE9mTW9udGgoZGF0ZSk7XG4gICAgICAgICAgICB2YXIgZW5kT2ZNb250aCA9IGdldEVuZE9mTW9udGgoZGF0ZSk7XG4gICAgICAgICAgICB2YXIgdG90YWxEYXlzID0gZGlmZmVyZW5jZUluRGF5cyhlbmRPZk1vbnRoLCBzdGFydE9mTW9udGgpO1xuICAgICAgICAgICAgdmFyIHByZVNlbGVjdGVkRGF0ZSA9IG51bGw7XG4gICAgICAgICAgICBmb3IgKHZhciBkYXlJZHggPSAwOyBkYXlJZHggPD0gdG90YWxEYXlzOyBkYXlJZHgrKykge1xuICAgICAgICAgICAgICAgIHZhciBwcm9jZXNzaW5nRGF0ZSA9IGFkZERheXMoc3RhcnRPZk1vbnRoLCBkYXlJZHgpO1xuICAgICAgICAgICAgICAgIGlmICghaXNEYXlEaXNhYmxlZChwcm9jZXNzaW5nRGF0ZSwgX3RoaXMucHJvcHMpKSB7XG4gICAgICAgICAgICAgICAgICAgIHByZVNlbGVjdGVkRGF0ZSA9IHByb2Nlc3NpbmdEYXRlO1xuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gcHJlU2VsZWN0ZWREYXRlO1xuICAgICAgICB9O1xuICAgICAgICBfdGhpcy5oYW5kbGVNb250aENoYW5nZSA9IGZ1bmN0aW9uIChkYXRlKSB7XG4gICAgICAgICAgICB2YXIgX2EsIF9iLCBfYztcbiAgICAgICAgICAgIHZhciBlbmFibGVkUHJlU2VsZWN0aW9uRGF0ZSA9IChfYSA9IF90aGlzLmdldEVuYWJsZWRQcmVTZWxlY3Rpb25EYXRlRm9yTW9udGgoZGF0ZSkpICE9PSBudWxsICYmIF9hICE9PSB2b2lkIDAgPyBfYSA6IGRhdGU7XG4gICAgICAgICAgICBfdGhpcy5oYW5kbGVDdXN0b21Nb250aENoYW5nZShlbmFibGVkUHJlU2VsZWN0aW9uRGF0ZSk7XG4gICAgICAgICAgICBpZiAoX3RoaXMucHJvcHMuYWRqdXN0RGF0ZU9uQ2hhbmdlKSB7XG4gICAgICAgICAgICAgICAgX3RoaXMucHJvcHMub25TZWxlY3QoZW5hYmxlZFByZVNlbGVjdGlvbkRhdGUpO1xuICAgICAgICAgICAgICAgIChfYyA9IChfYiA9IF90aGlzLnByb3BzKS5zZXRPcGVuKSA9PT0gbnVsbCB8fCBfYyA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2MuY2FsbChfYiwgdHJ1ZSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBfdGhpcy5wcm9wcy5zZXRQcmVTZWxlY3Rpb24gJiZcbiAgICAgICAgICAgICAgICBfdGhpcy5wcm9wcy5zZXRQcmVTZWxlY3Rpb24oZW5hYmxlZFByZVNlbGVjdGlvbkRhdGUpO1xuICAgICAgICB9O1xuICAgICAgICBfdGhpcy5oYW5kbGVDdXN0b21Nb250aENoYW5nZSA9IGZ1bmN0aW9uIChkYXRlKSB7XG4gICAgICAgICAgICB2YXIgX2EsIF9iO1xuICAgICAgICAgICAgKF9iID0gKF9hID0gX3RoaXMucHJvcHMpLm9uTW9udGhDaGFuZ2UpID09PSBudWxsIHx8IF9iID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYi5jYWxsKF9hLCBkYXRlKTtcbiAgICAgICAgICAgIF90aGlzLnNldFN0YXRlKHsgaXNSZW5kZXJBcmlhTGl2ZU1lc3NhZ2U6IHRydWUgfSk7XG4gICAgICAgIH07XG4gICAgICAgIF90aGlzLmhhbmRsZU1vbnRoWWVhckNoYW5nZSA9IGZ1bmN0aW9uIChkYXRlKSB7XG4gICAgICAgICAgICBfdGhpcy5oYW5kbGVZZWFyQ2hhbmdlKGRhdGUpO1xuICAgICAgICAgICAgX3RoaXMuaGFuZGxlTW9udGhDaGFuZ2UoZGF0ZSk7XG4gICAgICAgIH07XG4gICAgICAgIF90aGlzLmNoYW5nZVllYXIgPSBmdW5jdGlvbiAoeWVhcikge1xuICAgICAgICAgICAgX3RoaXMuc2V0U3RhdGUoZnVuY3Rpb24gKF9hKSB7XG4gICAgICAgICAgICAgICAgdmFyIGRhdGUgPSBfYS5kYXRlO1xuICAgICAgICAgICAgICAgIHJldHVybiAoe1xuICAgICAgICAgICAgICAgICAgICBkYXRlOiBzZXRZZWFyKGRhdGUsIE51bWJlcih5ZWFyKSksXG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB9LCBmdW5jdGlvbiAoKSB7IHJldHVybiBfdGhpcy5oYW5kbGVZZWFyQ2hhbmdlKF90aGlzLnN0YXRlLmRhdGUpOyB9KTtcbiAgICAgICAgfTtcbiAgICAgICAgX3RoaXMuY2hhbmdlTW9udGggPSBmdW5jdGlvbiAobW9udGgpIHtcbiAgICAgICAgICAgIF90aGlzLnNldFN0YXRlKGZ1bmN0aW9uIChfYSkge1xuICAgICAgICAgICAgICAgIHZhciBkYXRlID0gX2EuZGF0ZTtcbiAgICAgICAgICAgICAgICByZXR1cm4gKHtcbiAgICAgICAgICAgICAgICAgICAgZGF0ZTogc2V0TW9udGgoZGF0ZSwgTnVtYmVyKG1vbnRoKSksXG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB9LCBmdW5jdGlvbiAoKSB7IHJldHVybiBfdGhpcy5oYW5kbGVNb250aENoYW5nZShfdGhpcy5zdGF0ZS5kYXRlKTsgfSk7XG4gICAgICAgIH07XG4gICAgICAgIF90aGlzLmNoYW5nZU1vbnRoWWVhciA9IGZ1bmN0aW9uIChtb250aFllYXIpIHtcbiAgICAgICAgICAgIF90aGlzLnNldFN0YXRlKGZ1bmN0aW9uIChfYSkge1xuICAgICAgICAgICAgICAgIHZhciBkYXRlID0gX2EuZGF0ZTtcbiAgICAgICAgICAgICAgICByZXR1cm4gKHtcbiAgICAgICAgICAgICAgICAgICAgZGF0ZTogc2V0WWVhcihzZXRNb250aChkYXRlLCBnZXRNb250aChtb250aFllYXIpKSwgZ2V0WWVhcihtb250aFllYXIpKSxcbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIH0sIGZ1bmN0aW9uICgpIHsgcmV0dXJuIF90aGlzLmhhbmRsZU1vbnRoWWVhckNoYW5nZShfdGhpcy5zdGF0ZS5kYXRlKTsgfSk7XG4gICAgICAgIH07XG4gICAgICAgIF90aGlzLmhlYWRlciA9IGZ1bmN0aW9uIChkYXRlKSB7XG4gICAgICAgICAgICBpZiAoZGF0ZSA9PT0gdm9pZCAwKSB7IGRhdGUgPSBfdGhpcy5zdGF0ZS5kYXRlOyB9XG4gICAgICAgICAgICAvLyBSZXR1cm4gZW1wdHkgYXJyYXkgaWYgZGF0ZSBpcyBpbnZhbGlkXG4gICAgICAgICAgICBpZiAoIWlzVmFsaWQoZGF0ZSkpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gW107XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB2YXIgZGlzYWJsZWQgPSBfdGhpcy5wcm9wcy5kaXNhYmxlZDtcbiAgICAgICAgICAgIHZhciBzdGFydE9mV2VlayA9IGdldFN0YXJ0T2ZXZWVrKGRhdGUsIF90aGlzLnByb3BzLmxvY2FsZSwgX3RoaXMucHJvcHMuY2FsZW5kYXJTdGFydERheSk7XG4gICAgICAgICAgICB2YXIgZGF5TmFtZXMgPSBbXTtcbiAgICAgICAgICAgIGlmIChfdGhpcy5wcm9wcy5zaG93V2Vla051bWJlcnMpIHtcbiAgICAgICAgICAgICAgICBkYXlOYW1lcy5wdXNoKFJlYWN0LmNyZWF0ZUVsZW1lbnQoXCJkaXZcIiwgeyBrZXk6IFwiV1wiLCBjbGFzc05hbWU6IFwicmVhY3QtZGF0ZXBpY2tlcl9fZGF5LW5hbWUgXCIuY29uY2F0KGRpc2FibGVkID8gXCJyZWFjdC1kYXRlcGlja2VyX19kYXktbmFtZS0tZGlzYWJsZWRcIiA6IFwiXCIpLCByb2xlOiBcImNvbHVtbmhlYWRlclwiIH0sXG4gICAgICAgICAgICAgICAgICAgIFJlYWN0LmNyZWF0ZUVsZW1lbnQoXCJzcGFuXCIsIHsgY2xhc3NOYW1lOiBcInJlYWN0LWRhdGVwaWNrZXJfX3NyLW9ubHlcIiB9LCBcIldlZWsgbnVtYmVyXCIpLFxuICAgICAgICAgICAgICAgICAgICBSZWFjdC5jcmVhdGVFbGVtZW50KFwic3BhblwiLCB7IFwiYXJpYS1oaWRkZW5cIjogXCJ0cnVlXCIgfSwgX3RoaXMucHJvcHMud2Vla0xhYmVsIHx8IFwiI1wiKSkpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIGRheU5hbWVzLmNvbmNhdChbMCwgMSwgMiwgMywgNCwgNSwgNl0ubWFwKGZ1bmN0aW9uIChvZmZzZXQpIHtcbiAgICAgICAgICAgICAgICB2YXIgZGF5ID0gYWRkRGF5cyhzdGFydE9mV2Vlaywgb2Zmc2V0KTtcbiAgICAgICAgICAgICAgICB2YXIgd2Vla0RheU5hbWUgPSBfdGhpcy5mb3JtYXRXZWVrZGF5KGRheSwgX3RoaXMucHJvcHMubG9jYWxlKTtcbiAgICAgICAgICAgICAgICB2YXIgd2Vla0RheUNsYXNzTmFtZSA9IF90aGlzLnByb3BzLndlZWtEYXlDbGFzc05hbWVcbiAgICAgICAgICAgICAgICAgICAgPyBfdGhpcy5wcm9wcy53ZWVrRGF5Q2xhc3NOYW1lKGRheSlcbiAgICAgICAgICAgICAgICAgICAgOiB1bmRlZmluZWQ7XG4gICAgICAgICAgICAgICAgcmV0dXJuIChSZWFjdC5jcmVhdGVFbGVtZW50KFwiZGl2XCIsIHsga2V5OiBvZmZzZXQsIHJvbGU6IFwiY29sdW1uaGVhZGVyXCIsIGNsYXNzTmFtZTogY2xzeChcInJlYWN0LWRhdGVwaWNrZXJfX2RheS1uYW1lXCIsIHdlZWtEYXlDbGFzc05hbWUsIGRpc2FibGVkID8gXCJyZWFjdC1kYXRlcGlja2VyX19kYXktbmFtZS0tZGlzYWJsZWRcIiA6IFwiXCIpIH0sXG4gICAgICAgICAgICAgICAgICAgIFJlYWN0LmNyZWF0ZUVsZW1lbnQoXCJzcGFuXCIsIHsgY2xhc3NOYW1lOiBcInJlYWN0LWRhdGVwaWNrZXJfX3NyLW9ubHlcIiB9LCBmb3JtYXREYXRlKGRheSwgXCJFRUVFXCIsIF90aGlzLnByb3BzLmxvY2FsZSkpLFxuICAgICAgICAgICAgICAgICAgICBSZWFjdC5jcmVhdGVFbGVtZW50KFwic3BhblwiLCB7IFwiYXJpYS1oaWRkZW5cIjogXCJ0cnVlXCIgfSwgd2Vla0RheU5hbWUpKSk7XG4gICAgICAgICAgICB9KSk7XG4gICAgICAgIH07XG4gICAgICAgIF90aGlzLmZvcm1hdFdlZWtkYXkgPSBmdW5jdGlvbiAoZGF5LCBsb2NhbGUpIHtcbiAgICAgICAgICAgIGlmIChfdGhpcy5wcm9wcy5mb3JtYXRXZWVrRGF5KSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGdldEZvcm1hdHRlZFdlZWtkYXlJbkxvY2FsZShkYXksIF90aGlzLnByb3BzLmZvcm1hdFdlZWtEYXksIGxvY2FsZSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gX3RoaXMucHJvcHMudXNlV2Vla2RheXNTaG9ydFxuICAgICAgICAgICAgICAgID8gZ2V0V2Vla2RheVNob3J0SW5Mb2NhbGUoZGF5LCBsb2NhbGUpXG4gICAgICAgICAgICAgICAgOiBnZXRXZWVrZGF5TWluSW5Mb2NhbGUoZGF5LCBsb2NhbGUpO1xuICAgICAgICB9O1xuICAgICAgICBfdGhpcy5kZWNyZWFzZVllYXIgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICBfdGhpcy5zZXRTdGF0ZShmdW5jdGlvbiAoX2EpIHtcbiAgICAgICAgICAgICAgICB2YXIgX2I7XG4gICAgICAgICAgICAgICAgdmFyIGRhdGUgPSBfYS5kYXRlO1xuICAgICAgICAgICAgICAgIHJldHVybiAoe1xuICAgICAgICAgICAgICAgICAgICBkYXRlOiBzdWJZZWFycyhkYXRlLCBfdGhpcy5wcm9wcy5zaG93WWVhclBpY2tlclxuICAgICAgICAgICAgICAgICAgICAgICAgPyAoKF9iID0gX3RoaXMucHJvcHMueWVhckl0ZW1OdW1iZXIpICE9PSBudWxsICYmIF9iICE9PSB2b2lkIDAgPyBfYiA6IENhbGVuZGFyLmRlZmF1bHRQcm9wcy55ZWFySXRlbU51bWJlcilcbiAgICAgICAgICAgICAgICAgICAgICAgIDogMSksXG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB9LCBmdW5jdGlvbiAoKSB7IHJldHVybiBfdGhpcy5oYW5kbGVZZWFyQ2hhbmdlKF90aGlzLnN0YXRlLmRhdGUpOyB9KTtcbiAgICAgICAgfTtcbiAgICAgICAgX3RoaXMuY2xlYXJTZWxlY3RpbmdEYXRlID0gZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgX3RoaXMuc2V0U3RhdGUoeyBzZWxlY3RpbmdEYXRlOiB1bmRlZmluZWQgfSk7XG4gICAgICAgIH07XG4gICAgICAgIF90aGlzLnJlbmRlclByZXZpb3VzQnV0dG9uID0gZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgdmFyIF9hLCBfYiwgX2M7XG4gICAgICAgICAgICBpZiAoX3RoaXMucHJvcHMucmVuZGVyQ3VzdG9tSGVhZGVyKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdmFyIG1vbnRoc1Nob3duID0gKF9hID0gX3RoaXMucHJvcHMubW9udGhzU2hvd24pICE9PSBudWxsICYmIF9hICE9PSB2b2lkIDAgPyBfYSA6IENhbGVuZGFyLmRlZmF1bHRQcm9wcy5tb250aHNTaG93bjtcbiAgICAgICAgICAgIHZhciBtb250aHNUb1N1YnRyYWN0ID0gX3RoaXMucHJvcHMuc2hvd1ByZXZpb3VzTW9udGhzXG4gICAgICAgICAgICAgICAgPyBtb250aHNTaG93biAtIDFcbiAgICAgICAgICAgICAgICA6IDA7XG4gICAgICAgICAgICB2YXIgbW9udGhTZWxlY3RlZEluID0gKF9iID0gX3RoaXMucHJvcHMubW9udGhTZWxlY3RlZEluKSAhPT0gbnVsbCAmJiBfYiAhPT0gdm9pZCAwID8gX2IgOiBtb250aHNUb1N1YnRyYWN0O1xuICAgICAgICAgICAgdmFyIGZyb21Nb250aERhdGUgPSBzdWJNb250aHMoX3RoaXMuc3RhdGUuZGF0ZSwgbW9udGhTZWxlY3RlZEluKTtcbiAgICAgICAgICAgIHZhciBhbGxQcmV2RGF5c0Rpc2FibGVkO1xuICAgICAgICAgICAgc3dpdGNoICh0cnVlKSB7XG4gICAgICAgICAgICAgICAgY2FzZSBfdGhpcy5wcm9wcy5kaXNhYmxlZDpcbiAgICAgICAgICAgICAgICAgICAgYWxsUHJldkRheXNEaXNhYmxlZCA9IHRydWU7XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIGNhc2UgX3RoaXMucHJvcHMuc2hvd01vbnRoWWVhclBpY2tlcjpcbiAgICAgICAgICAgICAgICAgICAgYWxsUHJldkRheXNEaXNhYmxlZCA9IHllYXJEaXNhYmxlZEJlZm9yZShfdGhpcy5zdGF0ZS5kYXRlLCBfdGhpcy5wcm9wcyk7XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIGNhc2UgX3RoaXMucHJvcHMuc2hvd1llYXJQaWNrZXI6XG4gICAgICAgICAgICAgICAgICAgIGFsbFByZXZEYXlzRGlzYWJsZWQgPSB5ZWFyc0Rpc2FibGVkQmVmb3JlKF90aGlzLnN0YXRlLmRhdGUsIF90aGlzLnByb3BzKTtcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgY2FzZSBfdGhpcy5wcm9wcy5zaG93UXVhcnRlclllYXJQaWNrZXI6XG4gICAgICAgICAgICAgICAgICAgIGFsbFByZXZEYXlzRGlzYWJsZWQgPSBxdWFydGVyRGlzYWJsZWRCZWZvcmUoX3RoaXMuc3RhdGUuZGF0ZSwgX3RoaXMucHJvcHMpO1xuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgICAgICAgICAgICBhbGxQcmV2RGF5c0Rpc2FibGVkID0gbW9udGhEaXNhYmxlZEJlZm9yZShmcm9tTW9udGhEYXRlLCBfdGhpcy5wcm9wcyk7XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKCghKChfYyA9IF90aGlzLnByb3BzLmZvcmNlU2hvd01vbnRoTmF2aWdhdGlvbikgIT09IG51bGwgJiYgX2MgIT09IHZvaWQgMCA/IF9jIDogQ2FsZW5kYXIuZGVmYXVsdFByb3BzLmZvcmNlU2hvd01vbnRoTmF2aWdhdGlvbikgJiZcbiAgICAgICAgICAgICAgICAhX3RoaXMucHJvcHMuc2hvd0Rpc2FibGVkTW9udGhOYXZpZ2F0aW9uICYmXG4gICAgICAgICAgICAgICAgYWxsUHJldkRheXNEaXNhYmxlZCkgfHxcbiAgICAgICAgICAgICAgICBfdGhpcy5wcm9wcy5zaG93VGltZVNlbGVjdE9ubHkpIHtcbiAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB2YXIgaWNvbkNsYXNzZXMgPSBbXG4gICAgICAgICAgICAgICAgXCJyZWFjdC1kYXRlcGlja2VyX19uYXZpZ2F0aW9uLWljb25cIixcbiAgICAgICAgICAgICAgICBcInJlYWN0LWRhdGVwaWNrZXJfX25hdmlnYXRpb24taWNvbi0tcHJldmlvdXNcIixcbiAgICAgICAgICAgIF07XG4gICAgICAgICAgICB2YXIgY2xhc3NlcyA9IFtcbiAgICAgICAgICAgICAgICBcInJlYWN0LWRhdGVwaWNrZXJfX25hdmlnYXRpb25cIixcbiAgICAgICAgICAgICAgICBcInJlYWN0LWRhdGVwaWNrZXJfX25hdmlnYXRpb24tLXByZXZpb3VzXCIsXG4gICAgICAgICAgICBdO1xuICAgICAgICAgICAgdmFyIGNsaWNrSGFuZGxlciA9IF90aGlzLmRlY3JlYXNlTW9udGg7XG4gICAgICAgICAgICBpZiAoX3RoaXMucHJvcHMuc2hvd01vbnRoWWVhclBpY2tlciB8fFxuICAgICAgICAgICAgICAgIF90aGlzLnByb3BzLnNob3dRdWFydGVyWWVhclBpY2tlciB8fFxuICAgICAgICAgICAgICAgIF90aGlzLnByb3BzLnNob3dZZWFyUGlja2VyKSB7XG4gICAgICAgICAgICAgICAgY2xpY2tIYW5kbGVyID0gX3RoaXMuZGVjcmVhc2VZZWFyO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKGFsbFByZXZEYXlzRGlzYWJsZWQgJiYgX3RoaXMucHJvcHMuc2hvd0Rpc2FibGVkTW9udGhOYXZpZ2F0aW9uKSB7XG4gICAgICAgICAgICAgICAgY2xhc3Nlcy5wdXNoKFwicmVhY3QtZGF0ZXBpY2tlcl9fbmF2aWdhdGlvbi0tcHJldmlvdXMtLWRpc2FibGVkXCIpO1xuICAgICAgICAgICAgICAgIGNsaWNrSGFuZGxlciA9IHVuZGVmaW5lZDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHZhciBpc0ZvclllYXIgPSBfdGhpcy5wcm9wcy5zaG93TW9udGhZZWFyUGlja2VyIHx8XG4gICAgICAgICAgICAgICAgX3RoaXMucHJvcHMuc2hvd1F1YXJ0ZXJZZWFyUGlja2VyIHx8XG4gICAgICAgICAgICAgICAgX3RoaXMucHJvcHMuc2hvd1llYXJQaWNrZXI7XG4gICAgICAgICAgICB2YXIgX2QgPSBfdGhpcy5wcm9wcywgX2UgPSBfZC5wcmV2aW91c01vbnRoQnV0dG9uTGFiZWwsIHByZXZpb3VzTW9udGhCdXR0b25MYWJlbCA9IF9lID09PSB2b2lkIDAgPyBDYWxlbmRhci5kZWZhdWx0UHJvcHMucHJldmlvdXNNb250aEJ1dHRvbkxhYmVsIDogX2UsIF9mID0gX2QucHJldmlvdXNZZWFyQnV0dG9uTGFiZWwsIHByZXZpb3VzWWVhckJ1dHRvbkxhYmVsID0gX2YgPT09IHZvaWQgMCA/IENhbGVuZGFyLmRlZmF1bHRQcm9wcy5wcmV2aW91c1llYXJCdXR0b25MYWJlbCA6IF9mO1xuICAgICAgICAgICAgdmFyIF9nID0gX3RoaXMucHJvcHMsIF9oID0gX2cucHJldmlvdXNNb250aEFyaWFMYWJlbCwgcHJldmlvdXNNb250aEFyaWFMYWJlbCA9IF9oID09PSB2b2lkIDAgPyB0eXBlb2YgcHJldmlvdXNNb250aEJ1dHRvbkxhYmVsID09PSBcInN0cmluZ1wiXG4gICAgICAgICAgICAgICAgPyBwcmV2aW91c01vbnRoQnV0dG9uTGFiZWxcbiAgICAgICAgICAgICAgICA6IFwiUHJldmlvdXMgTW9udGhcIiA6IF9oLCBfaiA9IF9nLnByZXZpb3VzWWVhckFyaWFMYWJlbCwgcHJldmlvdXNZZWFyQXJpYUxhYmVsID0gX2ogPT09IHZvaWQgMCA/IHR5cGVvZiBwcmV2aW91c1llYXJCdXR0b25MYWJlbCA9PT0gXCJzdHJpbmdcIlxuICAgICAgICAgICAgICAgID8gcHJldmlvdXNZZWFyQnV0dG9uTGFiZWxcbiAgICAgICAgICAgICAgICA6IFwiUHJldmlvdXMgWWVhclwiIDogX2o7XG4gICAgICAgICAgICByZXR1cm4gKFJlYWN0LmNyZWF0ZUVsZW1lbnQoXCJidXR0b25cIiwgeyB0eXBlOiBcImJ1dHRvblwiLCBjbGFzc05hbWU6IGNsYXNzZXMuam9pbihcIiBcIiksIG9uQ2xpY2s6IGNsaWNrSGFuZGxlciwgb25LZXlEb3duOiBfdGhpcy5wcm9wcy5oYW5kbGVPbktleURvd24sIFwiYXJpYS1sYWJlbFwiOiBpc0ZvclllYXIgPyBwcmV2aW91c1llYXJBcmlhTGFiZWwgOiBwcmV2aW91c01vbnRoQXJpYUxhYmVsIH0sXG4gICAgICAgICAgICAgICAgUmVhY3QuY3JlYXRlRWxlbWVudChcInNwYW5cIiwgeyBjbGFzc05hbWU6IGljb25DbGFzc2VzLmpvaW4oXCIgXCIpIH0sIGlzRm9yWWVhciA/IHByZXZpb3VzWWVhckJ1dHRvbkxhYmVsIDogcHJldmlvdXNNb250aEJ1dHRvbkxhYmVsKSkpO1xuICAgICAgICB9O1xuICAgICAgICBfdGhpcy5pbmNyZWFzZVllYXIgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICBfdGhpcy5zZXRTdGF0ZShmdW5jdGlvbiAoX2EpIHtcbiAgICAgICAgICAgICAgICB2YXIgX2I7XG4gICAgICAgICAgICAgICAgdmFyIGRhdGUgPSBfYS5kYXRlO1xuICAgICAgICAgICAgICAgIHJldHVybiAoe1xuICAgICAgICAgICAgICAgICAgICBkYXRlOiBhZGRZZWFycyhkYXRlLCBfdGhpcy5wcm9wcy5zaG93WWVhclBpY2tlclxuICAgICAgICAgICAgICAgICAgICAgICAgPyAoKF9iID0gX3RoaXMucHJvcHMueWVhckl0ZW1OdW1iZXIpICE9PSBudWxsICYmIF9iICE9PSB2b2lkIDAgPyBfYiA6IENhbGVuZGFyLmRlZmF1bHRQcm9wcy55ZWFySXRlbU51bWJlcilcbiAgICAgICAgICAgICAgICAgICAgICAgIDogMSksXG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB9LCBmdW5jdGlvbiAoKSB7IHJldHVybiBfdGhpcy5oYW5kbGVZZWFyQ2hhbmdlKF90aGlzLnN0YXRlLmRhdGUpOyB9KTtcbiAgICAgICAgfTtcbiAgICAgICAgX3RoaXMucmVuZGVyTmV4dEJ1dHRvbiA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIHZhciBfYTtcbiAgICAgICAgICAgIGlmIChfdGhpcy5wcm9wcy5yZW5kZXJDdXN0b21IZWFkZXIpIHtcbiAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB2YXIgYWxsTmV4dERheXNEaXNhYmxlZDtcbiAgICAgICAgICAgIHN3aXRjaCAodHJ1ZSkge1xuICAgICAgICAgICAgICAgIGNhc2UgX3RoaXMucHJvcHMuZGlzYWJsZWQ6XG4gICAgICAgICAgICAgICAgICAgIGFsbE5leHREYXlzRGlzYWJsZWQgPSB0cnVlO1xuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICBjYXNlIF90aGlzLnByb3BzLnNob3dNb250aFllYXJQaWNrZXI6XG4gICAgICAgICAgICAgICAgICAgIGFsbE5leHREYXlzRGlzYWJsZWQgPSB5ZWFyRGlzYWJsZWRBZnRlcihfdGhpcy5zdGF0ZS5kYXRlLCBfdGhpcy5wcm9wcyk7XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIGNhc2UgX3RoaXMucHJvcHMuc2hvd1llYXJQaWNrZXI6XG4gICAgICAgICAgICAgICAgICAgIGFsbE5leHREYXlzRGlzYWJsZWQgPSB5ZWFyc0Rpc2FibGVkQWZ0ZXIoX3RoaXMuc3RhdGUuZGF0ZSwgX3RoaXMucHJvcHMpO1xuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICBjYXNlIF90aGlzLnByb3BzLnNob3dRdWFydGVyWWVhclBpY2tlcjpcbiAgICAgICAgICAgICAgICAgICAgYWxsTmV4dERheXNEaXNhYmxlZCA9IHF1YXJ0ZXJEaXNhYmxlZEFmdGVyKF90aGlzLnN0YXRlLmRhdGUsIF90aGlzLnByb3BzKTtcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICAgICAgICAgICAgYWxsTmV4dERheXNEaXNhYmxlZCA9IG1vbnRoRGlzYWJsZWRBZnRlcihfdGhpcy5zdGF0ZS5kYXRlLCBfdGhpcy5wcm9wcyk7XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKCghKChfYSA9IF90aGlzLnByb3BzLmZvcmNlU2hvd01vbnRoTmF2aWdhdGlvbikgIT09IG51bGwgJiYgX2EgIT09IHZvaWQgMCA/IF9hIDogQ2FsZW5kYXIuZGVmYXVsdFByb3BzLmZvcmNlU2hvd01vbnRoTmF2aWdhdGlvbikgJiZcbiAgICAgICAgICAgICAgICAhX3RoaXMucHJvcHMuc2hvd0Rpc2FibGVkTW9udGhOYXZpZ2F0aW9uICYmXG4gICAgICAgICAgICAgICAgYWxsTmV4dERheXNEaXNhYmxlZCkgfHxcbiAgICAgICAgICAgICAgICBfdGhpcy5wcm9wcy5zaG93VGltZVNlbGVjdE9ubHkpIHtcbiAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB2YXIgY2xhc3NlcyA9IFtcbiAgICAgICAgICAgICAgICBcInJlYWN0LWRhdGVwaWNrZXJfX25hdmlnYXRpb25cIixcbiAgICAgICAgICAgICAgICBcInJlYWN0LWRhdGVwaWNrZXJfX25hdmlnYXRpb24tLW5leHRcIixcbiAgICAgICAgICAgIF07XG4gICAgICAgICAgICB2YXIgaWNvbkNsYXNzZXMgPSBbXG4gICAgICAgICAgICAgICAgXCJyZWFjdC1kYXRlcGlja2VyX19uYXZpZ2F0aW9uLWljb25cIixcbiAgICAgICAgICAgICAgICBcInJlYWN0LWRhdGVwaWNrZXJfX25hdmlnYXRpb24taWNvbi0tbmV4dFwiLFxuICAgICAgICAgICAgXTtcbiAgICAgICAgICAgIGlmIChfdGhpcy5wcm9wcy5zaG93VGltZVNlbGVjdCkge1xuICAgICAgICAgICAgICAgIGNsYXNzZXMucHVzaChcInJlYWN0LWRhdGVwaWNrZXJfX25hdmlnYXRpb24tLW5leHQtLXdpdGgtdGltZVwiKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChfdGhpcy5wcm9wcy50b2RheUJ1dHRvbikge1xuICAgICAgICAgICAgICAgIGNsYXNzZXMucHVzaChcInJlYWN0LWRhdGVwaWNrZXJfX25hdmlnYXRpb24tLW5leHQtLXdpdGgtdG9kYXktYnV0dG9uXCIpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdmFyIGNsaWNrSGFuZGxlciA9IF90aGlzLmluY3JlYXNlTW9udGg7XG4gICAgICAgICAgICBpZiAoX3RoaXMucHJvcHMuc2hvd01vbnRoWWVhclBpY2tlciB8fFxuICAgICAgICAgICAgICAgIF90aGlzLnByb3BzLnNob3dRdWFydGVyWWVhclBpY2tlciB8fFxuICAgICAgICAgICAgICAgIF90aGlzLnByb3BzLnNob3dZZWFyUGlja2VyKSB7XG4gICAgICAgICAgICAgICAgY2xpY2tIYW5kbGVyID0gX3RoaXMuaW5jcmVhc2VZZWFyO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKGFsbE5leHREYXlzRGlzYWJsZWQgJiYgX3RoaXMucHJvcHMuc2hvd0Rpc2FibGVkTW9udGhOYXZpZ2F0aW9uKSB7XG4gICAgICAgICAgICAgICAgY2xhc3Nlcy5wdXNoKFwicmVhY3QtZGF0ZXBpY2tlcl9fbmF2aWdhdGlvbi0tbmV4dC0tZGlzYWJsZWRcIik7XG4gICAgICAgICAgICAgICAgY2xpY2tIYW5kbGVyID0gdW5kZWZpbmVkO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdmFyIGlzRm9yWWVhciA9IF90aGlzLnByb3BzLnNob3dNb250aFllYXJQaWNrZXIgfHxcbiAgICAgICAgICAgICAgICBfdGhpcy5wcm9wcy5zaG93UXVhcnRlclllYXJQaWNrZXIgfHxcbiAgICAgICAgICAgICAgICBfdGhpcy5wcm9wcy5zaG93WWVhclBpY2tlcjtcbiAgICAgICAgICAgIHZhciBfYiA9IF90aGlzLnByb3BzLCBfYyA9IF9iLm5leHRNb250aEJ1dHRvbkxhYmVsLCBuZXh0TW9udGhCdXR0b25MYWJlbCA9IF9jID09PSB2b2lkIDAgPyBDYWxlbmRhci5kZWZhdWx0UHJvcHMubmV4dE1vbnRoQnV0dG9uTGFiZWwgOiBfYywgX2QgPSBfYi5uZXh0WWVhckJ1dHRvbkxhYmVsLCBuZXh0WWVhckJ1dHRvbkxhYmVsID0gX2QgPT09IHZvaWQgMCA/IENhbGVuZGFyLmRlZmF1bHRQcm9wcy5uZXh0WWVhckJ1dHRvbkxhYmVsIDogX2Q7XG4gICAgICAgICAgICB2YXIgX2UgPSBfdGhpcy5wcm9wcywgX2YgPSBfZS5uZXh0TW9udGhBcmlhTGFiZWwsIG5leHRNb250aEFyaWFMYWJlbCA9IF9mID09PSB2b2lkIDAgPyB0eXBlb2YgbmV4dE1vbnRoQnV0dG9uTGFiZWwgPT09IFwic3RyaW5nXCJcbiAgICAgICAgICAgICAgICA/IG5leHRNb250aEJ1dHRvbkxhYmVsXG4gICAgICAgICAgICAgICAgOiBcIk5leHQgTW9udGhcIiA6IF9mLCBfZyA9IF9lLm5leHRZZWFyQXJpYUxhYmVsLCBuZXh0WWVhckFyaWFMYWJlbCA9IF9nID09PSB2b2lkIDAgPyB0eXBlb2YgbmV4dFllYXJCdXR0b25MYWJlbCA9PT0gXCJzdHJpbmdcIlxuICAgICAgICAgICAgICAgID8gbmV4dFllYXJCdXR0b25MYWJlbFxuICAgICAgICAgICAgICAgIDogXCJOZXh0IFllYXJcIiA6IF9nO1xuICAgICAgICAgICAgcmV0dXJuIChSZWFjdC5jcmVhdGVFbGVtZW50KFwiYnV0dG9uXCIsIHsgdHlwZTogXCJidXR0b25cIiwgY2xhc3NOYW1lOiBjbGFzc2VzLmpvaW4oXCIgXCIpLCBvbkNsaWNrOiBjbGlja0hhbmRsZXIsIG9uS2V5RG93bjogX3RoaXMucHJvcHMuaGFuZGxlT25LZXlEb3duLCBcImFyaWEtbGFiZWxcIjogaXNGb3JZZWFyID8gbmV4dFllYXJBcmlhTGFiZWwgOiBuZXh0TW9udGhBcmlhTGFiZWwgfSxcbiAgICAgICAgICAgICAgICBSZWFjdC5jcmVhdGVFbGVtZW50KFwic3BhblwiLCB7IGNsYXNzTmFtZTogaWNvbkNsYXNzZXMuam9pbihcIiBcIikgfSwgaXNGb3JZZWFyID8gbmV4dFllYXJCdXR0b25MYWJlbCA6IG5leHRNb250aEJ1dHRvbkxhYmVsKSkpO1xuICAgICAgICB9O1xuICAgICAgICBfdGhpcy5yZW5kZXJDdXJyZW50TW9udGggPSBmdW5jdGlvbiAoZGF0ZSkge1xuICAgICAgICAgICAgaWYgKGRhdGUgPT09IHZvaWQgMCkgeyBkYXRlID0gX3RoaXMuc3RhdGUuZGF0ZTsgfVxuICAgICAgICAgICAgdmFyIGNsYXNzZXMgPSBbXCJyZWFjdC1kYXRlcGlja2VyX19jdXJyZW50LW1vbnRoXCJdO1xuICAgICAgICAgICAgaWYgKF90aGlzLnByb3BzLnNob3dZZWFyRHJvcGRvd24pIHtcbiAgICAgICAgICAgICAgICBjbGFzc2VzLnB1c2goXCJyZWFjdC1kYXRlcGlja2VyX19jdXJyZW50LW1vbnRoLS1oYXNZZWFyRHJvcGRvd25cIik7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoX3RoaXMucHJvcHMuc2hvd01vbnRoRHJvcGRvd24pIHtcbiAgICAgICAgICAgICAgICBjbGFzc2VzLnB1c2goXCJyZWFjdC1kYXRlcGlja2VyX19jdXJyZW50LW1vbnRoLS1oYXNNb250aERyb3Bkb3duXCIpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKF90aGlzLnByb3BzLnNob3dNb250aFllYXJEcm9wZG93bikge1xuICAgICAgICAgICAgICAgIGNsYXNzZXMucHVzaChcInJlYWN0LWRhdGVwaWNrZXJfX2N1cnJlbnQtbW9udGgtLWhhc01vbnRoWWVhckRyb3Bkb3duXCIpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIChSZWFjdC5jcmVhdGVFbGVtZW50KFwiaDJcIiwgeyBjbGFzc05hbWU6IGNsYXNzZXMuam9pbihcIiBcIikgfSwgaXNWYWxpZChkYXRlKVxuICAgICAgICAgICAgICAgID8gZm9ybWF0RGF0ZShkYXRlLCBfdGhpcy5wcm9wcy5kYXRlRm9ybWF0LCBfdGhpcy5wcm9wcy5sb2NhbGUpXG4gICAgICAgICAgICAgICAgOiBcIlwiKSk7XG4gICAgICAgIH07XG4gICAgICAgIF90aGlzLnJlbmRlclllYXJEcm9wZG93biA9IGZ1bmN0aW9uIChvdmVycmlkZUhpZGUpIHtcbiAgICAgICAgICAgIGlmIChvdmVycmlkZUhpZGUgPT09IHZvaWQgMCkgeyBvdmVycmlkZUhpZGUgPSBmYWxzZTsgfVxuICAgICAgICAgICAgaWYgKCFfdGhpcy5wcm9wcy5zaG93WWVhckRyb3Bkb3duIHx8IG92ZXJyaWRlSGlkZSkge1xuICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiAoUmVhY3QuY3JlYXRlRWxlbWVudChZZWFyRHJvcGRvd24sIF9hc3NpZ24oe30sIENhbGVuZGFyLmRlZmF1bHRQcm9wcywgX3RoaXMucHJvcHMsIHsgZGF0ZTogX3RoaXMuc3RhdGUuZGF0ZSwgb25DaGFuZ2U6IF90aGlzLmNoYW5nZVllYXIsIHllYXI6IGdldFllYXIoX3RoaXMuc3RhdGUuZGF0ZSkgfSkpKTtcbiAgICAgICAgfTtcbiAgICAgICAgX3RoaXMucmVuZGVyTW9udGhEcm9wZG93biA9IGZ1bmN0aW9uIChvdmVycmlkZUhpZGUpIHtcbiAgICAgICAgICAgIGlmIChvdmVycmlkZUhpZGUgPT09IHZvaWQgMCkgeyBvdmVycmlkZUhpZGUgPSBmYWxzZTsgfVxuICAgICAgICAgICAgaWYgKCFfdGhpcy5wcm9wcy5zaG93TW9udGhEcm9wZG93biB8fCBvdmVycmlkZUhpZGUpIHtcbiAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gKFJlYWN0LmNyZWF0ZUVsZW1lbnQoTW9udGhEcm9wZG93biwgX2Fzc2lnbih7fSwgQ2FsZW5kYXIuZGVmYXVsdFByb3BzLCBfdGhpcy5wcm9wcywgeyBtb250aDogZ2V0TW9udGgoX3RoaXMuc3RhdGUuZGF0ZSksIG9uQ2hhbmdlOiBfdGhpcy5jaGFuZ2VNb250aCB9KSkpO1xuICAgICAgICB9O1xuICAgICAgICBfdGhpcy5yZW5kZXJNb250aFllYXJEcm9wZG93biA9IGZ1bmN0aW9uIChvdmVycmlkZUhpZGUpIHtcbiAgICAgICAgICAgIGlmIChvdmVycmlkZUhpZGUgPT09IHZvaWQgMCkgeyBvdmVycmlkZUhpZGUgPSBmYWxzZTsgfVxuICAgICAgICAgICAgaWYgKCFfdGhpcy5wcm9wcy5zaG93TW9udGhZZWFyRHJvcGRvd24gfHwgb3ZlcnJpZGVIaWRlKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIChSZWFjdC5jcmVhdGVFbGVtZW50KE1vbnRoWWVhckRyb3Bkb3duLCBfYXNzaWduKHt9LCBDYWxlbmRhci5kZWZhdWx0UHJvcHMsIF90aGlzLnByb3BzLCB7IGRhdGU6IF90aGlzLnN0YXRlLmRhdGUsIG9uQ2hhbmdlOiBfdGhpcy5jaGFuZ2VNb250aFllYXIgfSkpKTtcbiAgICAgICAgfTtcbiAgICAgICAgX3RoaXMuaGFuZGxlVG9kYXlCdXR0b25DbGljayA9IGZ1bmN0aW9uIChldmVudCkge1xuICAgICAgICAgICAgX3RoaXMucHJvcHMub25TZWxlY3QoZ2V0U3RhcnRPZlRvZGF5KCksIGV2ZW50KTtcbiAgICAgICAgICAgIF90aGlzLnByb3BzLnNldFByZVNlbGVjdGlvbiAmJiBfdGhpcy5wcm9wcy5zZXRQcmVTZWxlY3Rpb24oZ2V0U3RhcnRPZlRvZGF5KCkpO1xuICAgICAgICB9O1xuICAgICAgICBfdGhpcy5yZW5kZXJUb2RheUJ1dHRvbiA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIGlmICghX3RoaXMucHJvcHMudG9kYXlCdXR0b24gfHwgX3RoaXMucHJvcHMuc2hvd1RpbWVTZWxlY3RPbmx5KSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIChSZWFjdC5jcmVhdGVFbGVtZW50KFwiZGl2XCIsIHsgY2xhc3NOYW1lOiBcInJlYWN0LWRhdGVwaWNrZXJfX3RvZGF5LWJ1dHRvblwiLCBvbkNsaWNrOiBfdGhpcy5oYW5kbGVUb2RheUJ1dHRvbkNsaWNrIH0sIF90aGlzLnByb3BzLnRvZGF5QnV0dG9uKSk7XG4gICAgICAgIH07XG4gICAgICAgIF90aGlzLnJlbmRlckRheU5hbWVzSGVhZGVyID0gZnVuY3Rpb24gKG1vbnRoRGF0ZSkgeyByZXR1cm4gKFJlYWN0LmNyZWF0ZUVsZW1lbnQoXCJkaXZcIiwgeyBjbGFzc05hbWU6IFwicmVhY3QtZGF0ZXBpY2tlcl9fZGF5LW5hbWVzXCIsIHJvbGU6IFwicm93XCIgfSwgX3RoaXMuaGVhZGVyKG1vbnRoRGF0ZSkpKTsgfTtcbiAgICAgICAgX3RoaXMucmVuZGVyRGVmYXVsdEhlYWRlciA9IGZ1bmN0aW9uIChfYSkge1xuICAgICAgICAgICAgdmFyIG1vbnRoRGF0ZSA9IF9hLm1vbnRoRGF0ZSwgaSA9IF9hLmk7XG4gICAgICAgICAgICByZXR1cm4gKFJlYWN0LmNyZWF0ZUVsZW1lbnQoXCJkaXZcIiwgeyBjbGFzc05hbWU6IFwicmVhY3QtZGF0ZXBpY2tlcl9faGVhZGVyIFwiLmNvbmNhdChfdGhpcy5wcm9wcy5zaG93VGltZVNlbGVjdFxuICAgICAgICAgICAgICAgICAgICA/IFwicmVhY3QtZGF0ZXBpY2tlcl9faGVhZGVyLS1oYXMtdGltZS1zZWxlY3RcIlxuICAgICAgICAgICAgICAgICAgICA6IFwiXCIpIH0sXG4gICAgICAgICAgICAgICAgX3RoaXMucmVuZGVyQ3VycmVudE1vbnRoKG1vbnRoRGF0ZSksXG4gICAgICAgICAgICAgICAgUmVhY3QuY3JlYXRlRWxlbWVudChcImRpdlwiLCB7IGNsYXNzTmFtZTogXCJyZWFjdC1kYXRlcGlja2VyX19oZWFkZXJfX2Ryb3Bkb3duIHJlYWN0LWRhdGVwaWNrZXJfX2hlYWRlcl9fZHJvcGRvd24tLVwiLmNvbmNhdChfdGhpcy5wcm9wcy5kcm9wZG93bk1vZGUpLCBvbkZvY3VzOiBfdGhpcy5oYW5kbGVEcm9wZG93bkZvY3VzIH0sXG4gICAgICAgICAgICAgICAgICAgIF90aGlzLnJlbmRlck1vbnRoRHJvcGRvd24oaSAhPT0gMCksXG4gICAgICAgICAgICAgICAgICAgIF90aGlzLnJlbmRlck1vbnRoWWVhckRyb3Bkb3duKGkgIT09IDApLFxuICAgICAgICAgICAgICAgICAgICBfdGhpcy5yZW5kZXJZZWFyRHJvcGRvd24oaSAhPT0gMCkpKSk7XG4gICAgICAgIH07XG4gICAgICAgIF90aGlzLnJlbmRlckN1c3RvbUhlYWRlciA9IGZ1bmN0aW9uIChoZWFkZXJBcmdzKSB7XG4gICAgICAgICAgICB2YXIgX2EsIF9iO1xuICAgICAgICAgICAgdmFyIG1vbnRoRGF0ZSA9IGhlYWRlckFyZ3MubW9udGhEYXRlLCBpID0gaGVhZGVyQXJncy5pO1xuICAgICAgICAgICAgaWYgKChfdGhpcy5wcm9wcy5zaG93VGltZVNlbGVjdCAmJiAhX3RoaXMuc3RhdGUubW9udGhDb250YWluZXIpIHx8XG4gICAgICAgICAgICAgICAgX3RoaXMucHJvcHMuc2hvd1RpbWVTZWxlY3RPbmx5KSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB2YXIgX2MgPSBfdGhpcy5wcm9wcywgc2hvd1llYXJQaWNrZXIgPSBfYy5zaG93WWVhclBpY2tlciwgeWVhckl0ZW1OdW1iZXIgPSBfYy55ZWFySXRlbU51bWJlcjtcbiAgICAgICAgICAgIHZhciB2aXNpYmxlWWVhcnNSYW5nZTtcbiAgICAgICAgICAgIGlmIChzaG93WWVhclBpY2tlcikge1xuICAgICAgICAgICAgICAgIHZhciBfZCA9IGdldFllYXJzUGVyaW9kKG1vbnRoRGF0ZSwgeWVhckl0ZW1OdW1iZXIpLCBzdGFydFllYXIgPSBfZC5zdGFydFBlcmlvZCwgZW5kWWVhciA9IF9kLmVuZFBlcmlvZDtcbiAgICAgICAgICAgICAgICB2aXNpYmxlWWVhcnNSYW5nZSA9IHtcbiAgICAgICAgICAgICAgICAgICAgc3RhcnRZZWFyOiBzdGFydFllYXIsXG4gICAgICAgICAgICAgICAgICAgIGVuZFllYXI6IGVuZFllYXIsXG4gICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHZhciBwcmV2TW9udGhCdXR0b25EaXNhYmxlZCA9IG1vbnRoRGlzYWJsZWRCZWZvcmUoX3RoaXMuc3RhdGUuZGF0ZSwgX3RoaXMucHJvcHMpO1xuICAgICAgICAgICAgdmFyIG5leHRNb250aEJ1dHRvbkRpc2FibGVkID0gbW9udGhEaXNhYmxlZEFmdGVyKF90aGlzLnN0YXRlLmRhdGUsIF90aGlzLnByb3BzKTtcbiAgICAgICAgICAgIHZhciBwcmV2WWVhckJ1dHRvbkRpc2FibGVkID0geWVhckRpc2FibGVkQmVmb3JlKF90aGlzLnN0YXRlLmRhdGUsIF90aGlzLnByb3BzKTtcbiAgICAgICAgICAgIHZhciBuZXh0WWVhckJ1dHRvbkRpc2FibGVkID0geWVhckRpc2FibGVkQWZ0ZXIoX3RoaXMuc3RhdGUuZGF0ZSwgX3RoaXMucHJvcHMpO1xuICAgICAgICAgICAgcmV0dXJuIChSZWFjdC5jcmVhdGVFbGVtZW50KFwiZGl2XCIsIHsgY2xhc3NOYW1lOiBcInJlYWN0LWRhdGVwaWNrZXJfX2hlYWRlciByZWFjdC1kYXRlcGlja2VyX19oZWFkZXItLWN1c3RvbVwiLCBvbkZvY3VzOiBfdGhpcy5wcm9wcy5vbkRyb3Bkb3duRm9jdXMgfSwgKF9iID0gKF9hID0gX3RoaXMucHJvcHMpLnJlbmRlckN1c3RvbUhlYWRlcikgPT09IG51bGwgfHwgX2IgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9iLmNhbGwoX2EsIF9hc3NpZ24oX2Fzc2lnbihfYXNzaWduKHt9LCBfdGhpcy5zdGF0ZSksIChzaG93WWVhclBpY2tlciAmJiB7IHZpc2libGVZZWFyc1JhbmdlOiB2aXNpYmxlWWVhcnNSYW5nZSB9KSksIHsgY3VzdG9tSGVhZGVyQ291bnQ6IGksIG1vbnRoRGF0ZTogbW9udGhEYXRlLCBjaGFuZ2VNb250aDogX3RoaXMuY2hhbmdlTW9udGgsIGNoYW5nZVllYXI6IF90aGlzLmNoYW5nZVllYXIsIGRlY3JlYXNlTW9udGg6IF90aGlzLmRlY3JlYXNlTW9udGgsIGluY3JlYXNlTW9udGg6IF90aGlzLmluY3JlYXNlTW9udGgsIGRlY3JlYXNlWWVhcjogX3RoaXMuZGVjcmVhc2VZZWFyLCBpbmNyZWFzZVllYXI6IF90aGlzLmluY3JlYXNlWWVhciwgcHJldk1vbnRoQnV0dG9uRGlzYWJsZWQ6IHByZXZNb250aEJ1dHRvbkRpc2FibGVkLCBuZXh0TW9udGhCdXR0b25EaXNhYmxlZDogbmV4dE1vbnRoQnV0dG9uRGlzYWJsZWQsIHByZXZZZWFyQnV0dG9uRGlzYWJsZWQ6IHByZXZZZWFyQnV0dG9uRGlzYWJsZWQsIG5leHRZZWFyQnV0dG9uRGlzYWJsZWQ6IG5leHRZZWFyQnV0dG9uRGlzYWJsZWQgfSkpKSk7XG4gICAgICAgIH07XG4gICAgICAgIF90aGlzLnJlbmRlclllYXJIZWFkZXIgPSBmdW5jdGlvbiAoX2EpIHtcbiAgICAgICAgICAgIHZhciBtb250aERhdGUgPSBfYS5tb250aERhdGU7XG4gICAgICAgICAgICB2YXIgX2IgPSBfdGhpcy5wcm9wcywgc2hvd1llYXJQaWNrZXIgPSBfYi5zaG93WWVhclBpY2tlciwgX2MgPSBfYi55ZWFySXRlbU51bWJlciwgeWVhckl0ZW1OdW1iZXIgPSBfYyA9PT0gdm9pZCAwID8gQ2FsZW5kYXIuZGVmYXVsdFByb3BzLnllYXJJdGVtTnVtYmVyIDogX2M7XG4gICAgICAgICAgICB2YXIgX2QgPSBnZXRZZWFyc1BlcmlvZChtb250aERhdGUsIHllYXJJdGVtTnVtYmVyKSwgc3RhcnRQZXJpb2QgPSBfZC5zdGFydFBlcmlvZCwgZW5kUGVyaW9kID0gX2QuZW5kUGVyaW9kO1xuICAgICAgICAgICAgcmV0dXJuIChSZWFjdC5jcmVhdGVFbGVtZW50KFwiZGl2XCIsIHsgY2xhc3NOYW1lOiBcInJlYWN0LWRhdGVwaWNrZXJfX2hlYWRlciByZWFjdC1kYXRlcGlja2VyLXllYXItaGVhZGVyXCIgfSwgc2hvd1llYXJQaWNrZXIgPyBcIlwiLmNvbmNhdChzdGFydFBlcmlvZCwgXCIgLSBcIikuY29uY2F0KGVuZFBlcmlvZCkgOiBnZXRZZWFyKG1vbnRoRGF0ZSkpKTtcbiAgICAgICAgfTtcbiAgICAgICAgX3RoaXMucmVuZGVySGVhZGVyID0gZnVuY3Rpb24gKF9hKSB7XG4gICAgICAgICAgICB2YXIgbW9udGhEYXRlID0gX2EubW9udGhEYXRlLCBfYiA9IF9hLmksIGkgPSBfYiA9PT0gdm9pZCAwID8gMCA6IF9iO1xuICAgICAgICAgICAgdmFyIGhlYWRlckFyZ3MgPSB7IG1vbnRoRGF0ZTogbW9udGhEYXRlLCBpOiBpIH07XG4gICAgICAgICAgICBzd2l0Y2ggKHRydWUpIHtcbiAgICAgICAgICAgICAgICBjYXNlIF90aGlzLnByb3BzLnJlbmRlckN1c3RvbUhlYWRlciAhPT0gdW5kZWZpbmVkOlxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gX3RoaXMucmVuZGVyQ3VzdG9tSGVhZGVyKGhlYWRlckFyZ3MpO1xuICAgICAgICAgICAgICAgIGNhc2UgX3RoaXMucHJvcHMuc2hvd01vbnRoWWVhclBpY2tlciB8fFxuICAgICAgICAgICAgICAgICAgICBfdGhpcy5wcm9wcy5zaG93UXVhcnRlclllYXJQaWNrZXIgfHxcbiAgICAgICAgICAgICAgICAgICAgX3RoaXMucHJvcHMuc2hvd1llYXJQaWNrZXI6XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBfdGhpcy5yZW5kZXJZZWFySGVhZGVyKGhlYWRlckFyZ3MpO1xuICAgICAgICAgICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBfdGhpcy5yZW5kZXJEZWZhdWx0SGVhZGVyKGhlYWRlckFyZ3MpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9O1xuICAgICAgICBfdGhpcy5yZW5kZXJNb250aHMgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICB2YXIgX2EsIF9iO1xuICAgICAgICAgICAgaWYgKF90aGlzLnByb3BzLnNob3dUaW1lU2VsZWN0T25seSB8fCBfdGhpcy5wcm9wcy5zaG93WWVhclBpY2tlcikge1xuICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHZhciBtb250aExpc3QgPSBbXTtcbiAgICAgICAgICAgIHZhciBtb250aHNTaG93biA9IChfYSA9IF90aGlzLnByb3BzLm1vbnRoc1Nob3duKSAhPT0gbnVsbCAmJiBfYSAhPT0gdm9pZCAwID8gX2EgOiBDYWxlbmRhci5kZWZhdWx0UHJvcHMubW9udGhzU2hvd247XG4gICAgICAgICAgICB2YXIgbW9udGhzVG9TdWJ0cmFjdCA9IF90aGlzLnByb3BzLnNob3dQcmV2aW91c01vbnRoc1xuICAgICAgICAgICAgICAgID8gbW9udGhzU2hvd24gLSAxXG4gICAgICAgICAgICAgICAgOiAwO1xuICAgICAgICAgICAgdmFyIGZyb21Nb250aERhdGUgPSBfdGhpcy5wcm9wcy5zaG93TW9udGhZZWFyUGlja2VyIHx8IF90aGlzLnByb3BzLnNob3dRdWFydGVyWWVhclBpY2tlclxuICAgICAgICAgICAgICAgID8gYWRkWWVhcnMoX3RoaXMuc3RhdGUuZGF0ZSwgbW9udGhzVG9TdWJ0cmFjdClcbiAgICAgICAgICAgICAgICA6IHN1Yk1vbnRocyhfdGhpcy5zdGF0ZS5kYXRlLCBtb250aHNUb1N1YnRyYWN0KTtcbiAgICAgICAgICAgIHZhciBtb250aFNlbGVjdGVkSW4gPSAoX2IgPSBfdGhpcy5wcm9wcy5tb250aFNlbGVjdGVkSW4pICE9PSBudWxsICYmIF9iICE9PSB2b2lkIDAgPyBfYiA6IG1vbnRoc1RvU3VidHJhY3Q7XG4gICAgICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IG1vbnRoc1Nob3duOyArK2kpIHtcbiAgICAgICAgICAgICAgICB2YXIgbW9udGhzVG9BZGQgPSBpIC0gbW9udGhTZWxlY3RlZEluICsgbW9udGhzVG9TdWJ0cmFjdDtcbiAgICAgICAgICAgICAgICB2YXIgbW9udGhEYXRlID0gX3RoaXMucHJvcHMuc2hvd01vbnRoWWVhclBpY2tlciB8fCBfdGhpcy5wcm9wcy5zaG93UXVhcnRlclllYXJQaWNrZXJcbiAgICAgICAgICAgICAgICAgICAgPyBhZGRZZWFycyhmcm9tTW9udGhEYXRlLCBtb250aHNUb0FkZClcbiAgICAgICAgICAgICAgICAgICAgOiBhZGRNb250aHMoZnJvbU1vbnRoRGF0ZSwgbW9udGhzVG9BZGQpO1xuICAgICAgICAgICAgICAgIHZhciBtb250aEtleSA9IFwibW9udGgtXCIuY29uY2F0KGkpO1xuICAgICAgICAgICAgICAgIHZhciBtb250aFNob3dzRHVwbGljYXRlRGF5c0VuZCA9IGkgPCBtb250aHNTaG93biAtIDE7XG4gICAgICAgICAgICAgICAgdmFyIG1vbnRoU2hvd3NEdXBsaWNhdGVEYXlzU3RhcnQgPSBpID4gMDtcbiAgICAgICAgICAgICAgICBtb250aExpc3QucHVzaChSZWFjdC5jcmVhdGVFbGVtZW50KFwiZGl2XCIsIHsga2V5OiBtb250aEtleSwgcmVmOiBmdW5jdGlvbiAoZGl2KSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBfdGhpcy5tb250aENvbnRhaW5lciA9IGRpdiAhPT0gbnVsbCAmJiBkaXYgIT09IHZvaWQgMCA/IGRpdiA6IHVuZGVmaW5lZDtcbiAgICAgICAgICAgICAgICAgICAgfSwgY2xhc3NOYW1lOiBcInJlYWN0LWRhdGVwaWNrZXJfX21vbnRoLWNvbnRhaW5lclwiIH0sXG4gICAgICAgICAgICAgICAgICAgIF90aGlzLnJlbmRlckhlYWRlcih7IG1vbnRoRGF0ZTogbW9udGhEYXRlLCBpOiBpIH0pLFxuICAgICAgICAgICAgICAgICAgICBSZWFjdC5jcmVhdGVFbGVtZW50KE1vbnRoLCBfYXNzaWduKHt9LCBDYWxlbmRhci5kZWZhdWx0UHJvcHMsIF90aGlzLnByb3BzLCB7IGNvbnRhaW5lclJlZjogX3RoaXMuY29udGFpbmVyUmVmLCBhcmlhTGFiZWxQcmVmaXg6IF90aGlzLnByb3BzLm1vbnRoQXJpYUxhYmVsUHJlZml4LCBkYXk6IG1vbnRoRGF0ZSwgb25EYXlDbGljazogX3RoaXMuaGFuZGxlRGF5Q2xpY2ssIGhhbmRsZU9uS2V5RG93bjogX3RoaXMucHJvcHMuaGFuZGxlT25EYXlLZXlEb3duLCBoYW5kbGVPbk1vbnRoS2V5RG93bjogX3RoaXMucHJvcHMuaGFuZGxlT25LZXlEb3duLCBvbkRheU1vdXNlRW50ZXI6IF90aGlzLmhhbmRsZURheU1vdXNlRW50ZXIsIG9uTW91c2VMZWF2ZTogX3RoaXMuaGFuZGxlTW9udGhNb3VzZUxlYXZlLCBvcmRlckluRGlzcGxheTogaSwgc2VsZWN0aW5nRGF0ZTogX3RoaXMuc3RhdGUuc2VsZWN0aW5nRGF0ZSwgbW9udGhTaG93c0R1cGxpY2F0ZURheXNFbmQ6IG1vbnRoU2hvd3NEdXBsaWNhdGVEYXlzRW5kLCBtb250aFNob3dzRHVwbGljYXRlRGF5c1N0YXJ0OiBtb250aFNob3dzRHVwbGljYXRlRGF5c1N0YXJ0LCBkYXlOYW1lc0hlYWRlcjogX3RoaXMucmVuZGVyRGF5TmFtZXNIZWFkZXIobW9udGhEYXRlKSB9KSkpKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiBtb250aExpc3Q7XG4gICAgICAgIH07XG4gICAgICAgIF90aGlzLnJlbmRlclllYXJzID0gZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgaWYgKF90aGlzLnByb3BzLnNob3dUaW1lU2VsZWN0T25seSkge1xuICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChfdGhpcy5wcm9wcy5zaG93WWVhclBpY2tlcikge1xuICAgICAgICAgICAgICAgIHJldHVybiAoUmVhY3QuY3JlYXRlRWxlbWVudChcImRpdlwiLCB7IGNsYXNzTmFtZTogXCJyZWFjdC1kYXRlcGlja2VyX195ZWFyLS1jb250YWluZXJcIiB9LFxuICAgICAgICAgICAgICAgICAgICBfdGhpcy5yZW5kZXJIZWFkZXIoeyBtb250aERhdGU6IF90aGlzLnN0YXRlLmRhdGUgfSksXG4gICAgICAgICAgICAgICAgICAgIFJlYWN0LmNyZWF0ZUVsZW1lbnQoWWVhciwgX2Fzc2lnbih7fSwgQ2FsZW5kYXIuZGVmYXVsdFByb3BzLCBfdGhpcy5wcm9wcywgeyBzZWxlY3RpbmdEYXRlOiBfdGhpcy5zdGF0ZS5zZWxlY3RpbmdEYXRlLCBkYXRlOiBfdGhpcy5zdGF0ZS5kYXRlLCBvbkRheUNsaWNrOiBfdGhpcy5oYW5kbGVEYXlDbGljaywgY2xlYXJTZWxlY3RpbmdEYXRlOiBfdGhpcy5jbGVhclNlbGVjdGluZ0RhdGUsIG9uWWVhck1vdXNlRW50ZXI6IF90aGlzLmhhbmRsZVllYXJNb3VzZUVudGVyLCBvblllYXJNb3VzZUxlYXZlOiBfdGhpcy5oYW5kbGVZZWFyTW91c2VMZWF2ZSB9KSkpKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfTtcbiAgICAgICAgX3RoaXMucmVuZGVyVGltZVNlY3Rpb24gPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICBpZiAoX3RoaXMucHJvcHMuc2hvd1RpbWVTZWxlY3QgJiZcbiAgICAgICAgICAgICAgICAoX3RoaXMuc3RhdGUubW9udGhDb250YWluZXIgfHwgX3RoaXMucHJvcHMuc2hvd1RpbWVTZWxlY3RPbmx5KSkge1xuICAgICAgICAgICAgICAgIHJldHVybiAoUmVhY3QuY3JlYXRlRWxlbWVudChUaW1lLCBfYXNzaWduKHt9LCBDYWxlbmRhci5kZWZhdWx0UHJvcHMsIF90aGlzLnByb3BzLCB7IG9uQ2hhbmdlOiBfdGhpcy5wcm9wcy5vblRpbWVDaGFuZ2UsIGZvcm1hdDogX3RoaXMucHJvcHMudGltZUZvcm1hdCwgaW50ZXJ2YWxzOiBfdGhpcy5wcm9wcy50aW1lSW50ZXJ2YWxzLCBtb250aFJlZjogX3RoaXMuc3RhdGUubW9udGhDb250YWluZXIgfSkpKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfTtcbiAgICAgICAgX3RoaXMucmVuZGVySW5wdXRUaW1lU2VjdGlvbiA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIHZhciB0aW1lID0gX3RoaXMucHJvcHMuc2VsZWN0ZWRcbiAgICAgICAgICAgICAgICA/IG5ldyBEYXRlKF90aGlzLnByb3BzLnNlbGVjdGVkKVxuICAgICAgICAgICAgICAgIDogdW5kZWZpbmVkO1xuICAgICAgICAgICAgdmFyIHRpbWVWYWxpZCA9IHRpbWUgJiYgaXNWYWxpZCh0aW1lKSAmJiBCb29sZWFuKF90aGlzLnByb3BzLnNlbGVjdGVkKTtcbiAgICAgICAgICAgIHZhciB0aW1lU3RyaW5nID0gdGltZVZhbGlkXG4gICAgICAgICAgICAgICAgPyBcIlwiLmNvbmNhdChhZGRaZXJvKHRpbWUuZ2V0SG91cnMoKSksIFwiOlwiKS5jb25jYXQoYWRkWmVybyh0aW1lLmdldE1pbnV0ZXMoKSkpXG4gICAgICAgICAgICAgICAgOiBcIlwiO1xuICAgICAgICAgICAgaWYgKF90aGlzLnByb3BzLnNob3dUaW1lSW5wdXQpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gKFJlYWN0LmNyZWF0ZUVsZW1lbnQoSW5wdXRUaW1lLCBfYXNzaWduKHt9LCBDYWxlbmRhci5kZWZhdWx0UHJvcHMsIF90aGlzLnByb3BzLCB7IGRhdGU6IHRpbWUsIHRpbWVTdHJpbmc6IHRpbWVTdHJpbmcsIG9uQ2hhbmdlOiBfdGhpcy5wcm9wcy5vblRpbWVDaGFuZ2UgfSkpKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfTtcbiAgICAgICAgX3RoaXMucmVuZGVyQXJpYUxpdmVSZWdpb24gPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICB2YXIgX2E7XG4gICAgICAgICAgICAvLyBEb24ndCByZW5kZXIgYXJpYS1saXZlIG1lc3NhZ2UgaWYgZGF0ZSBpcyBpbnZhbGlkXG4gICAgICAgICAgICBpZiAoIWlzVmFsaWQoX3RoaXMuc3RhdGUuZGF0ZSkpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gKFJlYWN0LmNyZWF0ZUVsZW1lbnQoXCJzcGFuXCIsIHsgcm9sZTogXCJhbGVydFwiLCBcImFyaWEtbGl2ZVwiOiBcInBvbGl0ZVwiLCBjbGFzc05hbWU6IFwicmVhY3QtZGF0ZXBpY2tlcl9fYXJpYS1saXZlXCIgfSkpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdmFyIF9iID0gZ2V0WWVhcnNQZXJpb2QoX3RoaXMuc3RhdGUuZGF0ZSwgKF9hID0gX3RoaXMucHJvcHMueWVhckl0ZW1OdW1iZXIpICE9PSBudWxsICYmIF9hICE9PSB2b2lkIDAgPyBfYSA6IENhbGVuZGFyLmRlZmF1bHRQcm9wcy55ZWFySXRlbU51bWJlciksIHN0YXJ0UGVyaW9kID0gX2Iuc3RhcnRQZXJpb2QsIGVuZFBlcmlvZCA9IF9iLmVuZFBlcmlvZDtcbiAgICAgICAgICAgIHZhciBhcmlhTGl2ZU1lc3NhZ2U7XG4gICAgICAgICAgICBpZiAoX3RoaXMucHJvcHMuc2hvd1llYXJQaWNrZXIpIHtcbiAgICAgICAgICAgICAgICBhcmlhTGl2ZU1lc3NhZ2UgPSBcIlwiLmNvbmNhdChzdGFydFBlcmlvZCwgXCIgLSBcIikuY29uY2F0KGVuZFBlcmlvZCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIGlmIChfdGhpcy5wcm9wcy5zaG93TW9udGhZZWFyUGlja2VyIHx8XG4gICAgICAgICAgICAgICAgX3RoaXMucHJvcHMuc2hvd1F1YXJ0ZXJZZWFyUGlja2VyKSB7XG4gICAgICAgICAgICAgICAgYXJpYUxpdmVNZXNzYWdlID0gZ2V0WWVhcihfdGhpcy5zdGF0ZS5kYXRlKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIGFyaWFMaXZlTWVzc2FnZSA9IFwiXCIuY29uY2F0KGdldE1vbnRoSW5Mb2NhbGUoZ2V0TW9udGgoX3RoaXMuc3RhdGUuZGF0ZSksIF90aGlzLnByb3BzLmxvY2FsZSksIFwiIFwiKS5jb25jYXQoZ2V0WWVhcihfdGhpcy5zdGF0ZS5kYXRlKSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gKFJlYWN0LmNyZWF0ZUVsZW1lbnQoXCJzcGFuXCIsIHsgcm9sZTogXCJhbGVydFwiLCBcImFyaWEtbGl2ZVwiOiBcInBvbGl0ZVwiLCBjbGFzc05hbWU6IFwicmVhY3QtZGF0ZXBpY2tlcl9fYXJpYS1saXZlXCIgfSwgX3RoaXMuc3RhdGUuaXNSZW5kZXJBcmlhTGl2ZU1lc3NhZ2UgJiYgYXJpYUxpdmVNZXNzYWdlKSk7XG4gICAgICAgIH07XG4gICAgICAgIF90aGlzLnJlbmRlckNoaWxkcmVuID0gZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgaWYgKF90aGlzLnByb3BzLmNoaWxkcmVuKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIChSZWFjdC5jcmVhdGVFbGVtZW50KFwiZGl2XCIsIHsgY2xhc3NOYW1lOiBcInJlYWN0LWRhdGVwaWNrZXJfX2NoaWxkcmVuLWNvbnRhaW5lclwiIH0sIF90aGlzLnByb3BzLmNoaWxkcmVuKSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH07XG4gICAgICAgIF90aGlzLmNvbnRhaW5lclJlZiA9IGNyZWF0ZVJlZigpO1xuICAgICAgICBfdGhpcy5zdGF0ZSA9IHtcbiAgICAgICAgICAgIGRhdGU6IF90aGlzLmdldERhdGVJblZpZXcoKSxcbiAgICAgICAgICAgIHNlbGVjdGluZ0RhdGU6IHVuZGVmaW5lZCxcbiAgICAgICAgICAgIG1vbnRoQ29udGFpbmVyOiB1bmRlZmluZWQsXG4gICAgICAgICAgICBpc1JlbmRlckFyaWFMaXZlTWVzc2FnZTogZmFsc2UsXG4gICAgICAgIH07XG4gICAgICAgIHJldHVybiBfdGhpcztcbiAgICB9XG4gICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KENhbGVuZGFyLCBcImRlZmF1bHRQcm9wc1wiLCB7XG4gICAgICAgIGdldDogZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgICAgICBtb250aHNTaG93bjogMSxcbiAgICAgICAgICAgICAgICBmb3JjZVNob3dNb250aE5hdmlnYXRpb246IGZhbHNlLFxuICAgICAgICAgICAgICAgIG91dHNpZGVDbGlja0lnbm9yZUNsYXNzOiBPVVRTSURFX0NMSUNLX0lHTk9SRV9DTEFTUyxcbiAgICAgICAgICAgICAgICB0aW1lQ2FwdGlvbjogXCJUaW1lXCIsXG4gICAgICAgICAgICAgICAgcHJldmlvdXNZZWFyQnV0dG9uTGFiZWw6IFwiUHJldmlvdXMgWWVhclwiLFxuICAgICAgICAgICAgICAgIG5leHRZZWFyQnV0dG9uTGFiZWw6IFwiTmV4dCBZZWFyXCIsXG4gICAgICAgICAgICAgICAgcHJldmlvdXNNb250aEJ1dHRvbkxhYmVsOiBcIlByZXZpb3VzIE1vbnRoXCIsXG4gICAgICAgICAgICAgICAgbmV4dE1vbnRoQnV0dG9uTGFiZWw6IFwiTmV4dCBNb250aFwiLFxuICAgICAgICAgICAgICAgIHllYXJJdGVtTnVtYmVyOiBERUZBVUxUX1lFQVJfSVRFTV9OVU1CRVIsXG4gICAgICAgICAgICB9O1xuICAgICAgICB9LFxuICAgICAgICBlbnVtZXJhYmxlOiBmYWxzZSxcbiAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlXG4gICAgfSk7XG4gICAgQ2FsZW5kYXIucHJvdG90eXBlLmNvbXBvbmVudERpZE1vdW50ID0gZnVuY3Rpb24gKCkge1xuICAgICAgICB2YXIgX3RoaXMgPSB0aGlzO1xuICAgICAgICAvLyBtb250aENvbnRhaW5lciBoZWlnaHQgaXMgbmVlZGVkIGluIHRpbWUgY29tcG9uZW50XG4gICAgICAgIC8vIHRvIGRldGVybWluZSB0aGUgaGVpZ2h0IGZvciB0aGUgdWwgaW4gdGhlIHRpbWUgY29tcG9uZW50XG4gICAgICAgIC8vIHNldFN0YXRlIGhlcmUgc28gaGVpZ2h0IGlzIGdpdmVuIGFmdGVyIGZpbmFsIGNvbXBvbmVudFxuICAgICAgICAvLyBsYXlvdXQgaXMgcmVuZGVyZWRcbiAgICAgICAgaWYgKHRoaXMucHJvcHMuc2hvd1RpbWVTZWxlY3QpIHtcbiAgICAgICAgICAgIHRoaXMuYXNzaWduTW9udGhDb250YWluZXIgPSAoZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgICAgIF90aGlzLnNldFN0YXRlKHsgbW9udGhDb250YWluZXI6IF90aGlzLm1vbnRoQ29udGFpbmVyIH0pO1xuICAgICAgICAgICAgfSkoKTtcbiAgICAgICAgfVxuICAgIH07XG4gICAgQ2FsZW5kYXIucHJvdG90eXBlLmNvbXBvbmVudERpZFVwZGF0ZSA9IGZ1bmN0aW9uIChwcmV2UHJvcHMpIHtcbiAgICAgICAgdmFyIF90aGlzID0gdGhpcztcbiAgICAgICAgaWYgKHRoaXMucHJvcHMucHJlU2VsZWN0aW9uICYmXG4gICAgICAgICAgICBpc1ZhbGlkKHRoaXMucHJvcHMucHJlU2VsZWN0aW9uKSAmJlxuICAgICAgICAgICAgKCFpc1NhbWVEYXkodGhpcy5wcm9wcy5wcmVTZWxlY3Rpb24sIHByZXZQcm9wcy5wcmVTZWxlY3Rpb24pIHx8XG4gICAgICAgICAgICAgICAgdGhpcy5wcm9wcy5tb250aFNlbGVjdGVkSW4gIT09IHByZXZQcm9wcy5tb250aFNlbGVjdGVkSW4pKSB7XG4gICAgICAgICAgICB2YXIgaGFzTW9udGhDaGFuZ2VkXzEgPSAhaXNTYW1lTW9udGgodGhpcy5zdGF0ZS5kYXRlLCB0aGlzLnByb3BzLnByZVNlbGVjdGlvbik7XG4gICAgICAgICAgICB0aGlzLnNldFN0YXRlKHtcbiAgICAgICAgICAgICAgICBkYXRlOiB0aGlzLnByb3BzLnByZVNlbGVjdGlvbixcbiAgICAgICAgICAgIH0sIGZ1bmN0aW9uICgpIHsgcmV0dXJuIGhhc01vbnRoQ2hhbmdlZF8xICYmIF90aGlzLmhhbmRsZUN1c3RvbU1vbnRoQ2hhbmdlKF90aGlzLnN0YXRlLmRhdGUpOyB9KTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmICh0aGlzLnByb3BzLm9wZW5Ub0RhdGUgJiZcbiAgICAgICAgICAgICFpc1NhbWVEYXkodGhpcy5wcm9wcy5vcGVuVG9EYXRlLCBwcmV2UHJvcHMub3BlblRvRGF0ZSkpIHtcbiAgICAgICAgICAgIHRoaXMuc2V0U3RhdGUoe1xuICAgICAgICAgICAgICAgIGRhdGU6IHRoaXMucHJvcHMub3BlblRvRGF0ZSxcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgfTtcbiAgICBDYWxlbmRhci5wcm90b3R5cGUucmVuZGVyID0gZnVuY3Rpb24gKCkge1xuICAgICAgICB2YXIgQ29udGFpbmVyID0gdGhpcy5wcm9wcy5jb250YWluZXIgfHwgQ2FsZW5kYXJDb250YWluZXI7XG4gICAgICAgIHJldHVybiAoUmVhY3QuY3JlYXRlRWxlbWVudChDbGlja091dHNpZGVXcmFwcGVyLCB7IG9uQ2xpY2tPdXRzaWRlOiB0aGlzLmhhbmRsZUNsaWNrT3V0c2lkZSwgc3R5bGU6IHsgZGlzcGxheTogXCJjb250ZW50c1wiIH0sIGlnbm9yZUNsYXNzOiB0aGlzLnByb3BzLm91dHNpZGVDbGlja0lnbm9yZUNsYXNzIH0sXG4gICAgICAgICAgICBSZWFjdC5jcmVhdGVFbGVtZW50KFwiZGl2XCIsIHsgc3R5bGU6IHsgZGlzcGxheTogXCJjb250ZW50c1wiIH0sIHJlZjogdGhpcy5jb250YWluZXJSZWYgfSxcbiAgICAgICAgICAgICAgICBSZWFjdC5jcmVhdGVFbGVtZW50KENvbnRhaW5lciwgeyBjbGFzc05hbWU6IGNsc3goXCJyZWFjdC1kYXRlcGlja2VyXCIsIHRoaXMucHJvcHMuY2xhc3NOYW1lLCB7XG4gICAgICAgICAgICAgICAgICAgICAgICBcInJlYWN0LWRhdGVwaWNrZXItLXRpbWUtb25seVwiOiB0aGlzLnByb3BzLnNob3dUaW1lU2VsZWN0T25seSxcbiAgICAgICAgICAgICAgICAgICAgfSksIHNob3dUaW1lOiB0aGlzLnByb3BzLnNob3dUaW1lU2VsZWN0IHx8IHRoaXMucHJvcHMuc2hvd1RpbWVJbnB1dCwgc2hvd1RpbWVTZWxlY3RPbmx5OiB0aGlzLnByb3BzLnNob3dUaW1lU2VsZWN0T25seSwgaW5saW5lOiB0aGlzLnByb3BzLmlubGluZSB9LFxuICAgICAgICAgICAgICAgICAgICB0aGlzLnJlbmRlckFyaWFMaXZlUmVnaW9uKCksXG4gICAgICAgICAgICAgICAgICAgIHRoaXMucmVuZGVyUHJldmlvdXNCdXR0b24oKSxcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5yZW5kZXJOZXh0QnV0dG9uKCksXG4gICAgICAgICAgICAgICAgICAgIHRoaXMucmVuZGVyTW9udGhzKCksXG4gICAgICAgICAgICAgICAgICAgIHRoaXMucmVuZGVyWWVhcnMoKSxcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5yZW5kZXJUb2RheUJ1dHRvbigpLFxuICAgICAgICAgICAgICAgICAgICB0aGlzLnJlbmRlclRpbWVTZWN0aW9uKCksXG4gICAgICAgICAgICAgICAgICAgIHRoaXMucmVuZGVySW5wdXRUaW1lU2VjdGlvbigpLFxuICAgICAgICAgICAgICAgICAgICB0aGlzLnJlbmRlckNoaWxkcmVuKCkpKSkpO1xuICAgIH07XG4gICAgcmV0dXJuIENhbGVuZGFyO1xufShDb21wb25lbnQpKTtcblxuLyoqXG4gKiBgQ2FsZW5kYXJJY29uYCBpcyBhIFJlYWN0IGNvbXBvbmVudCB0aGF0IHJlbmRlcnMgYW4gaWNvbiBmb3IgYSBjYWxlbmRhci5cbiAqIFRoZSBpY29uIGNhbiBiZSBhIHN0cmluZyByZXByZXNlbnRpbmcgYSBDU1MgY2xhc3MsIGEgUmVhY3Qgbm9kZSwgb3IgYSBkZWZhdWx0IFNWRyBpY29uLlxuICpcbiAqIEBjb21wb25lbnRcbiAqIEBwcm9wICBpY29uIC0gVGhlIGljb24gdG8gYmUgZGlzcGxheWVkLiBUaGlzIGNhbiBiZSBhIHN0cmluZyByZXByZXNlbnRpbmcgYSBDU1MgY2xhc3Mgb3IgYSBSZWFjdCBub2RlLlxuICogQHByb3AgIGNsYXNzTmFtZSAtIEFuIG9wdGlvbmFsIHN0cmluZyByZXByZXNlbnRpbmcgYWRkaXRpb25hbCBDU1MgY2xhc3NlcyB0byBiZSBhcHBsaWVkIHRvIHRoZSBpY29uLlxuICogQHByb3AgIG9uQ2xpY2sgLSBBbiBvcHRpb25hbCBmdW5jdGlvbiB0byBiZSBjYWxsZWQgd2hlbiB0aGUgaWNvbiBpcyBjbGlja2VkLlxuICpcbiAqIEBleGFtcGxlXG4gKiAvLyBUbyB1c2UgYSBDU1MgY2xhc3MgYXMgdGhlIGljb25cbiAqIDxDYWxlbmRhckljb24gaWNvbj1cIm15LWljb24tY2xhc3NcIiBvbkNsaWNrPXtteUNsaWNrSGFuZGxlcn0gLz5cbiAqXG4gKiBAZXhhbXBsZVxuICogLy8gVG8gdXNlIGEgUmVhY3Qgbm9kZSBhcyB0aGUgaWNvblxuICogPENhbGVuZGFySWNvbiBpY29uPXs8TXlJY29uQ29tcG9uZW50IC8+fSBvbkNsaWNrPXtteUNsaWNrSGFuZGxlcn0gLz5cbiAqXG4gKiBAcmV0dXJucyAgVGhlIGBDYWxlbmRhckljb25gIGNvbXBvbmVudC5cbiAqL1xudmFyIENhbGVuZGFySWNvbiA9IGZ1bmN0aW9uIChfYSkge1xuICAgIHZhciBpY29uID0gX2EuaWNvbiwgX2IgPSBfYS5jbGFzc05hbWUsIGNsYXNzTmFtZSA9IF9iID09PSB2b2lkIDAgPyBcIlwiIDogX2IsIG9uQ2xpY2sgPSBfYS5vbkNsaWNrO1xuICAgIHZhciBkZWZhdWx0Q2xhc3MgPSBcInJlYWN0LWRhdGVwaWNrZXJfX2NhbGVuZGFyLWljb25cIjtcbiAgICBpZiAodHlwZW9mIGljb24gPT09IFwic3RyaW5nXCIpIHtcbiAgICAgICAgcmV0dXJuIChSZWFjdC5jcmVhdGVFbGVtZW50KFwiaVwiLCB7IGNsYXNzTmFtZTogXCJcIi5jb25jYXQoZGVmYXVsdENsYXNzLCBcIiBcIikuY29uY2F0KGljb24sIFwiIFwiKS5jb25jYXQoY2xhc3NOYW1lKSwgXCJhcmlhLWhpZGRlblwiOiBcInRydWVcIiwgb25DbGljazogb25DbGljayB9KSk7XG4gICAgfVxuICAgIGlmIChSZWFjdC5pc1ZhbGlkRWxlbWVudChpY29uKSkge1xuICAgICAgICAvLyBCZWNhdXNlIHdlIGFyZSBjaGVja2luZyB0aGF0IHR5cGVvZiBpY29uIGlzIHN0cmluZyBmaXJzdCwgd2UgY2FuIHNhZmVseSBjYXN0IGljb24gYXMgUmVhY3QuUmVhY3RFbGVtZW50IG9uIHR5cGVzIGxldmVsIGFuZCBjb2RlIGxldmVsXG4gICAgICAgIHZhciBpY29uRWxlbWVudF8xID0gaWNvbjtcbiAgICAgICAgcmV0dXJuIFJlYWN0LmNsb25lRWxlbWVudChpY29uRWxlbWVudF8xLCB7XG4gICAgICAgICAgICBjbGFzc05hbWU6IFwiXCIuY29uY2F0KGljb25FbGVtZW50XzEucHJvcHMuY2xhc3NOYW1lIHx8IFwiXCIsIFwiIFwiKS5jb25jYXQoZGVmYXVsdENsYXNzLCBcIiBcIikuY29uY2F0KGNsYXNzTmFtZSksXG4gICAgICAgICAgICBvbkNsaWNrOiBmdW5jdGlvbiAoZXZlbnQpIHtcbiAgICAgICAgICAgICAgICBpZiAodHlwZW9mIGljb25FbGVtZW50XzEucHJvcHMub25DbGljayA9PT0gXCJmdW5jdGlvblwiKSB7XG4gICAgICAgICAgICAgICAgICAgIGljb25FbGVtZW50XzEucHJvcHMub25DbGljayhldmVudCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGlmICh0eXBlb2Ygb25DbGljayA9PT0gXCJmdW5jdGlvblwiKSB7XG4gICAgICAgICAgICAgICAgICAgIG9uQ2xpY2soZXZlbnQpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0sXG4gICAgICAgIH0pO1xuICAgIH1cbiAgICAvLyBEZWZhdWx0IFNWRyBJY29uXG4gICAgcmV0dXJuIChSZWFjdC5jcmVhdGVFbGVtZW50KFwic3ZnXCIsIHsgY2xhc3NOYW1lOiBcIlwiLmNvbmNhdChkZWZhdWx0Q2xhc3MsIFwiIFwiKS5jb25jYXQoY2xhc3NOYW1lKSwgeG1sbnM6IFwiaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmdcIiwgdmlld0JveDogXCIwIDAgNDQ4IDUxMlwiLCBvbkNsaWNrOiBvbkNsaWNrIH0sXG4gICAgICAgIFJlYWN0LmNyZWF0ZUVsZW1lbnQoXCJwYXRoXCIsIHsgZDogXCJNOTYgMzJWNjRINDhDMjEuNSA2NCAwIDg1LjUgMCAxMTJ2NDhINDQ4VjExMmMwLTI2LjUtMjEuNS00OC00OC00OEgzNTJWMzJjMC0xNy43LTE0LjMtMzItMzItMzJzLTMyIDE0LjMtMzIgMzJWNjRIMTYwVjMyYzAtMTcuNy0xNC4zLTMyLTMyLTMyUzk2IDE0LjMgOTYgMzJ6TTQ0OCAxOTJIMFY0NjRjMCAyNi41IDIxLjUgNDggNDggNDhINDAwYzI2LjUgMCA0OC0yMS41IDQ4LTQ4VjE5MnpcIiB9KSkpO1xufTtcblxuLyoqXG4gKiBgUG9ydGFsYCBpcyBhIFJlYWN0IGNvbXBvbmVudCB0aGF0IGFsbG93cyB5b3UgdG8gcmVuZGVyIGNoaWxkcmVuIGludG8gYSBET00gbm9kZVxuICogdGhhdCBleGlzdHMgb3V0c2lkZSB0aGUgRE9NIGhpZXJhcmNoeSBvZiB0aGUgcGFyZW50IGNvbXBvbmVudC5cbiAqXG4gKiBAY2xhc3NcbiAqIEBwYXJhbSB7UG9ydGFsUHJvcHN9IHByb3BzIC0gVGhlIHByb3BlcnRpZXMgdGhhdCBkZWZpbmUgdGhlIGBQb3J0YWxgIGNvbXBvbmVudC5cbiAqIEBwcm9wZXJ0eSB7UmVhY3QuUmVhY3ROb2RlfSBwcm9wcy5jaGlsZHJlbiAtIFRoZSBjaGlsZHJlbiB0byBiZSByZW5kZXJlZCBpbnRvIHRoZSBgUG9ydGFsYC5cbiAqIEBwcm9wZXJ0eSB7c3RyaW5nfSBwcm9wcy5wb3J0YWxJZCAtIFRoZSBpZCBvZiB0aGUgRE9NIG5vZGUgaW50byB3aGljaCB0aGUgYFBvcnRhbGAgd2lsbCByZW5kZXIuXG4gKiBAcHJvcGVydHkge1NoYWRvd1Jvb3R9IFtwcm9wcy5wb3J0YWxIb3N0XSAtIFRoZSBET00gbm9kZSB0byBob3N0IHRoZSBgUG9ydGFsYC5cbiAqL1xudmFyIFBvcnRhbCA9IC8qKiBAY2xhc3MgKi8gKGZ1bmN0aW9uIChfc3VwZXIpIHtcbiAgICBfX2V4dGVuZHMoUG9ydGFsLCBfc3VwZXIpO1xuICAgIGZ1bmN0aW9uIFBvcnRhbChwcm9wcykge1xuICAgICAgICB2YXIgX3RoaXMgPSBfc3VwZXIuY2FsbCh0aGlzLCBwcm9wcykgfHwgdGhpcztcbiAgICAgICAgX3RoaXMucG9ydGFsUm9vdCA9IG51bGw7XG4gICAgICAgIF90aGlzLmVsID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudChcImRpdlwiKTtcbiAgICAgICAgcmV0dXJuIF90aGlzO1xuICAgIH1cbiAgICBQb3J0YWwucHJvdG90eXBlLmNvbXBvbmVudERpZE1vdW50ID0gZnVuY3Rpb24gKCkge1xuICAgICAgICB0aGlzLnBvcnRhbFJvb3QgPSAodGhpcy5wcm9wcy5wb3J0YWxIb3N0IHx8IGRvY3VtZW50KS5nZXRFbGVtZW50QnlJZCh0aGlzLnByb3BzLnBvcnRhbElkKTtcbiAgICAgICAgaWYgKCF0aGlzLnBvcnRhbFJvb3QpIHtcbiAgICAgICAgICAgIHRoaXMucG9ydGFsUm9vdCA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoXCJkaXZcIik7XG4gICAgICAgICAgICB0aGlzLnBvcnRhbFJvb3Quc2V0QXR0cmlidXRlKFwiaWRcIiwgdGhpcy5wcm9wcy5wb3J0YWxJZCk7XG4gICAgICAgICAgICAodGhpcy5wcm9wcy5wb3J0YWxIb3N0IHx8IGRvY3VtZW50LmJvZHkpLmFwcGVuZENoaWxkKHRoaXMucG9ydGFsUm9vdCk7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5wb3J0YWxSb290LmFwcGVuZENoaWxkKHRoaXMuZWwpO1xuICAgIH07XG4gICAgUG9ydGFsLnByb3RvdHlwZS5jb21wb25lbnRXaWxsVW5tb3VudCA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgaWYgKHRoaXMucG9ydGFsUm9vdCkge1xuICAgICAgICAgICAgdGhpcy5wb3J0YWxSb290LnJlbW92ZUNoaWxkKHRoaXMuZWwpO1xuICAgICAgICB9XG4gICAgfTtcbiAgICBQb3J0YWwucHJvdG90eXBlLnJlbmRlciA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgcmV0dXJuIFJlYWN0RE9NLmNyZWF0ZVBvcnRhbCh0aGlzLnByb3BzLmNoaWxkcmVuLCB0aGlzLmVsKTtcbiAgICB9O1xuICAgIHJldHVybiBQb3J0YWw7XG59KENvbXBvbmVudCkpO1xuXG52YXIgZm9jdXNhYmxlRWxlbWVudHNTZWxlY3RvciA9IFwiW3RhYmluZGV4XSwgYSwgYnV0dG9uLCBpbnB1dCwgc2VsZWN0LCB0ZXh0YXJlYVwiO1xudmFyIGZvY3VzYWJsZUZpbHRlciA9IGZ1bmN0aW9uIChub2RlKSB7XG4gICAgaWYgKG5vZGUgaW5zdGFuY2VvZiBIVE1MQW5jaG9yRWxlbWVudCkge1xuICAgICAgICByZXR1cm4gbm9kZS50YWJJbmRleCAhPT0gLTE7XG4gICAgfVxuICAgIHJldHVybiAhbm9kZS5kaXNhYmxlZCAmJiBub2RlLnRhYkluZGV4ICE9PSAtMTtcbn07XG4vKipcbiAqIGBUYWJMb29wYCBpcyBhIFJlYWN0IGNvbXBvbmVudCB0aGF0IG1hbmFnZXMgdGFiYmluZyBiZWhhdmlvciBmb3IgaXRzIGNoaWxkcmVuLlxuICpcbiAqIFRhYkxvb3AgcHJldmVudHMgdGhlIHVzZXIgZnJvbSB0YWJiaW5nIG91dHNpZGUgb2YgdGhlIHBvcHBlclxuICogSXQgY3JlYXRlcyBhIHRhYmluZGV4IGxvb3Agc28gdGhhdCBcIlRhYlwiIG9uIHRoZSBsYXN0IGVsZW1lbnQgd2lsbCBmb2N1cyB0aGUgZmlyc3QgZWxlbWVudFxuICogYW5kIFwiU2hpZnQgVGFiXCIgb24gdGhlIGZpcnN0IGVsZW1lbnQgd2lsbCBmb2N1cyB0aGUgbGFzdCBlbGVtZW50XG4gKlxuICogQGNvbXBvbmVudFxuICogQGV4YW1wbGVcbiAqIDxUYWJMb29wIGVuYWJsZVRhYkxvb3A9e3RydWV9PlxuICogICA8Q2hpbGRDb21wb25lbnQgLz5cbiAqIDwvVGFiTG9vcD5cbiAqXG4gKiBAcGFyYW0gcHJvcHMgLSBUaGUgcHJvcGVydGllcyB0aGF0IGRlZmluZSB0aGUgYFRhYkxvb3BgIGNvbXBvbmVudC5cbiAqIEBwYXJhbSBwcm9wcy5jaGlsZHJlbiAtIFRoZSBjaGlsZCBjb21wb25lbnRzLlxuICogQHBhcmFtIHByb3BzLmVuYWJsZVRhYkxvb3AgLSBXaGV0aGVyIHRvIGVuYWJsZSB0aGUgdGFiIGxvb3AuXG4gKlxuICogQHJldHVybnMgVGhlIGBUYWJMb29wYCBjb21wb25lbnQuXG4gKi9cbnZhciBUYWJMb29wID0gLyoqIEBjbGFzcyAqLyAoZnVuY3Rpb24gKF9zdXBlcikge1xuICAgIF9fZXh0ZW5kcyhUYWJMb29wLCBfc3VwZXIpO1xuICAgIGZ1bmN0aW9uIFRhYkxvb3AocHJvcHMpIHtcbiAgICAgICAgdmFyIF90aGlzID0gX3N1cGVyLmNhbGwodGhpcywgcHJvcHMpIHx8IHRoaXM7XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBgZ2V0VGFiQ2hpbGRyZW5gIGlzIGEgbWV0aG9kIG9mIHRoZSBgVGFiTG9vcGAgY2xhc3MgdGhhdCByZXRyaWV2ZXMgYWxsIHRhYmJhYmxlIGNoaWxkcmVuIG9mIHRoZSBjb21wb25lbnQuXG4gICAgICAgICAqXG4gICAgICAgICAqIFRoaXMgbWV0aG9kIHVzZXMgdGhlIGB0YWJiYWJsZWAgbGlicmFyeSB0byBmaW5kIGFsbCB0YWJiYWJsZSBlbGVtZW50cyB3aXRoaW4gdGhlIGBUYWJMb29wYCBjb21wb25lbnQuXG4gICAgICAgICAqIEl0IHRoZW4gZmlsdGVycyBvdXQgYW55IGVsZW1lbnRzIHRoYXQgYXJlIG5vdCB2aXNpYmxlLlxuICAgICAgICAgKlxuICAgICAgICAgKiBAcmV0dXJucyBBbiBhcnJheSBvZiBhbGwgdGFiYmFibGUgYW5kIHZpc2libGUgY2hpbGRyZW4gb2YgdGhlIGBUYWJMb29wYCBjb21wb25lbnQuXG4gICAgICAgICAqL1xuICAgICAgICBfdGhpcy5nZXRUYWJDaGlsZHJlbiA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIHZhciBfYTtcbiAgICAgICAgICAgIHJldHVybiBBcnJheS5wcm90b3R5cGUuc2xpY2VcbiAgICAgICAgICAgICAgICAuY2FsbCgoX2EgPSBfdGhpcy50YWJMb29wUmVmLmN1cnJlbnQpID09PSBudWxsIHx8IF9hID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYS5xdWVyeVNlbGVjdG9yQWxsKGZvY3VzYWJsZUVsZW1lbnRzU2VsZWN0b3IpLCAxLCAtMSlcbiAgICAgICAgICAgICAgICAuZmlsdGVyKGZvY3VzYWJsZUZpbHRlcik7XG4gICAgICAgIH07XG4gICAgICAgIF90aGlzLmhhbmRsZUZvY3VzU3RhcnQgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICB2YXIgdGFiQ2hpbGRyZW4gPSBfdGhpcy5nZXRUYWJDaGlsZHJlbigpO1xuICAgICAgICAgICAgdGFiQ2hpbGRyZW4gJiZcbiAgICAgICAgICAgICAgICB0YWJDaGlsZHJlbi5sZW5ndGggPiAxICYmXG4gICAgICAgICAgICAgICAgdGFiQ2hpbGRyZW5bdGFiQ2hpbGRyZW4ubGVuZ3RoIC0gMV0uZm9jdXMoKTtcbiAgICAgICAgfTtcbiAgICAgICAgX3RoaXMuaGFuZGxlRm9jdXNFbmQgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICB2YXIgdGFiQ2hpbGRyZW4gPSBfdGhpcy5nZXRUYWJDaGlsZHJlbigpO1xuICAgICAgICAgICAgdGFiQ2hpbGRyZW4gJiYgdGFiQ2hpbGRyZW4ubGVuZ3RoID4gMSAmJiB0YWJDaGlsZHJlblswXS5mb2N1cygpO1xuICAgICAgICB9O1xuICAgICAgICBfdGhpcy50YWJMb29wUmVmID0gY3JlYXRlUmVmKCk7XG4gICAgICAgIHJldHVybiBfdGhpcztcbiAgICB9XG4gICAgVGFiTG9vcC5wcm90b3R5cGUucmVuZGVyID0gZnVuY3Rpb24gKCkge1xuICAgICAgICB2YXIgX2E7XG4gICAgICAgIGlmICghKChfYSA9IHRoaXMucHJvcHMuZW5hYmxlVGFiTG9vcCkgIT09IG51bGwgJiYgX2EgIT09IHZvaWQgMCA/IF9hIDogVGFiTG9vcC5kZWZhdWx0UHJvcHMuZW5hYmxlVGFiTG9vcCkpIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLnByb3BzLmNoaWxkcmVuO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiAoUmVhY3QuY3JlYXRlRWxlbWVudChcImRpdlwiLCB7IGNsYXNzTmFtZTogXCJyZWFjdC1kYXRlcGlja2VyX190YWItbG9vcFwiLCByZWY6IHRoaXMudGFiTG9vcFJlZiB9LFxuICAgICAgICAgICAgUmVhY3QuY3JlYXRlRWxlbWVudChcImRpdlwiLCB7IGNsYXNzTmFtZTogXCJyZWFjdC1kYXRlcGlja2VyX190YWItbG9vcF9fc3RhcnRcIiwgdGFiSW5kZXg6IDAsIG9uRm9jdXM6IHRoaXMuaGFuZGxlRm9jdXNTdGFydCB9KSxcbiAgICAgICAgICAgIHRoaXMucHJvcHMuY2hpbGRyZW4sXG4gICAgICAgICAgICBSZWFjdC5jcmVhdGVFbGVtZW50KFwiZGl2XCIsIHsgY2xhc3NOYW1lOiBcInJlYWN0LWRhdGVwaWNrZXJfX3RhYi1sb29wX19lbmRcIiwgdGFiSW5kZXg6IDAsIG9uRm9jdXM6IHRoaXMuaGFuZGxlRm9jdXNFbmQgfSkpKTtcbiAgICB9O1xuICAgIFRhYkxvb3AuZGVmYXVsdFByb3BzID0ge1xuICAgICAgICBlbmFibGVUYWJMb29wOiB0cnVlLFxuICAgIH07XG4gICAgcmV0dXJuIFRhYkxvb3A7XG59KENvbXBvbmVudCkpO1xuXG4vKipcbiAqIGB3aXRoRmxvYXRpbmdgIGlzIGEgaGlnaGVyLW9yZGVyIGNvbXBvbmVudCB0aGF0IGFkZHMgZmxvYXRpbmcgYmVoYXZpb3IgdG8gYSBjb21wb25lbnQuXG4gKlxuICogQHBhcmFtIENvbXBvbmVudCAtIFRoZSBjb21wb25lbnQgdG8gZW5oYW5jZS5cbiAqXG4gKiBAZXhhbXBsZVxuICogY29uc3QgRmxvYXRpbmdDb21wb25lbnQgPSB3aXRoRmxvYXRpbmcoTXlDb21wb25lbnQpO1xuICogPEZsb2F0aW5nQ29tcG9uZW50IHBvcHBlck1vZGlmaWVycz17W119IHBvcHBlclByb3BzPXt7fX0gaGlkZVBvcHBlcj17dHJ1ZX0gLz5cbiAqXG4gKiBAcGFyYW0gcG9wcGVyTW9kaWZpZXJzIC0gVGhlIG1vZGlmaWVycyB0byB1c2UgZm9yIHRoZSBwb3BwZXIuXG4gKiBAcGFyYW0gcG9wcGVyUHJvcHMgLSBUaGUgcHJvcHMgdG8gcGFzcyB0byB0aGUgcG9wcGVyLlxuICogQHBhcmFtIGhpZGVQb3BwZXIgLSBXaGV0aGVyIHRvIGhpZGUgdGhlIHBvcHBlci5cbiAqIEBwYXJhbSBwb3BwZXJQbGFjZW1lbnQgLSBUaGUgcGxhY2VtZW50IG9mIHRoZSBwb3BwZXIuXG4gKlxuICogQHJldHVybnMgQSBuZXcgY29tcG9uZW50IHdpdGggZmxvYXRpbmcgYmVoYXZpb3IuXG4gKi9cbmZ1bmN0aW9uIHdpdGhGbG9hdGluZyhDb21wb25lbnQpIHtcbiAgICBmdW5jdGlvbiBXaXRoRmxvYXRpbmcocHJvcHMpIHtcbiAgICAgICAgdmFyIF9hO1xuICAgICAgICB2YXIgaGlkZVBvcHBlciA9IHR5cGVvZiBwcm9wcy5oaWRlUG9wcGVyID09PSBcImJvb2xlYW5cIiA/IHByb3BzLmhpZGVQb3BwZXIgOiB0cnVlO1xuICAgICAgICB2YXIgYXJyb3dSZWYgPSB1c2VSZWYobnVsbCk7XG4gICAgICAgIHZhciBmbG9hdGluZ1Byb3BzID0gdXNlRmxvYXRpbmcoX2Fzc2lnbih7IG9wZW46ICFoaWRlUG9wcGVyLCB3aGlsZUVsZW1lbnRzTW91bnRlZDogYXV0b1VwZGF0ZSwgcGxhY2VtZW50OiBwcm9wcy5wb3BwZXJQbGFjZW1lbnQsIG1pZGRsZXdhcmU6IF9fc3ByZWFkQXJyYXkoW1xuICAgICAgICAgICAgICAgIGZsaXAoeyBwYWRkaW5nOiAxNSB9KSxcbiAgICAgICAgICAgICAgICBvZmZzZXQoMTApLFxuICAgICAgICAgICAgICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSByZWFjdC1ob29rcy9yZWZzIC0tIEZsb2F0aW5nIFVJIHJlcXVpcmVzIHJlZnMgdG8gYmUgcGFzc2VkIGR1cmluZyByZW5kZXJcbiAgICAgICAgICAgICAgICBhcnJvdyh7IGVsZW1lbnQ6IGFycm93UmVmIH0pXG4gICAgICAgICAgICBdLCAoKF9hID0gcHJvcHMucG9wcGVyTW9kaWZpZXJzKSAhPT0gbnVsbCAmJiBfYSAhPT0gdm9pZCAwID8gX2EgOiBbXSksIHRydWUpIH0sIHByb3BzLnBvcHBlclByb3BzKSk7XG4gICAgICAgIHZhciBjb21wb25lbnRQcm9wcyA9IF9hc3NpZ24oX2Fzc2lnbih7fSwgcHJvcHMpLCB7IGhpZGVQb3BwZXI6IGhpZGVQb3BwZXIsIHBvcHBlclByb3BzOiBfYXNzaWduKF9hc3NpZ24oe30sIGZsb2F0aW5nUHJvcHMpLCB7IGFycm93UmVmOiBhcnJvd1JlZiB9KSB9KTtcbiAgICAgICAgcmV0dXJuIFJlYWN0LmNyZWF0ZUVsZW1lbnQoQ29tcG9uZW50LCBfYXNzaWduKHt9LCBjb21wb25lbnRQcm9wcykpO1xuICAgIH1cbiAgICBXaXRoRmxvYXRpbmcuZGlzcGxheU5hbWUgPSBcIndpdGhGbG9hdGluZyhcIi5jb25jYXQoQ29tcG9uZW50LmRpc3BsYXlOYW1lIHx8IENvbXBvbmVudC5uYW1lIHx8IFwiQ29tcG9uZW50XCIsIFwiKVwiKTtcbiAgICByZXR1cm4gV2l0aEZsb2F0aW5nO1xufVxuXG4vLyBFeHBvcnRlZCBmb3IgdGVzdGluZyBwdXJwb3Nlc1xudmFyIFBvcHBlckNvbXBvbmVudCQxID0gZnVuY3Rpb24gKHByb3BzKSB7XG4gICAgdmFyIGNsYXNzTmFtZSA9IHByb3BzLmNsYXNzTmFtZSwgd3JhcHBlckNsYXNzTmFtZSA9IHByb3BzLndyYXBwZXJDbGFzc05hbWUsIF9hID0gcHJvcHMuaGlkZVBvcHBlciwgaGlkZVBvcHBlciA9IF9hID09PSB2b2lkIDAgPyB0cnVlIDogX2EsIHBvcHBlckNvbXBvbmVudCA9IHByb3BzLnBvcHBlckNvbXBvbmVudCwgdGFyZ2V0Q29tcG9uZW50ID0gcHJvcHMudGFyZ2V0Q29tcG9uZW50LCBlbmFibGVUYWJMb29wID0gcHJvcHMuZW5hYmxlVGFiTG9vcCwgcG9wcGVyT25LZXlEb3duID0gcHJvcHMucG9wcGVyT25LZXlEb3duLCBwb3J0YWxJZCA9IHByb3BzLnBvcnRhbElkLCBwb3J0YWxIb3N0ID0gcHJvcHMucG9ydGFsSG9zdCwgcG9wcGVyUHJvcHMgPSBwcm9wcy5wb3BwZXJQcm9wcywgc2hvd0Fycm93ID0gcHJvcHMuc2hvd0Fycm93O1xuICAgIHZhciBwb3BwZXIgPSB1bmRlZmluZWQ7XG4gICAgaWYgKCFoaWRlUG9wcGVyKSB7XG4gICAgICAgIHZhciBjbGFzc2VzID0gY2xzeChcInJlYWN0LWRhdGVwaWNrZXItcG9wcGVyXCIsIGNsYXNzTmFtZSk7XG4gICAgICAgIHBvcHBlciA9IChSZWFjdC5jcmVhdGVFbGVtZW50KFRhYkxvb3AsIHsgZW5hYmxlVGFiTG9vcDogZW5hYmxlVGFiTG9vcCB9LFxuICAgICAgICAgICAgUmVhY3QuY3JlYXRlRWxlbWVudChcImRpdlwiLCB7IHJlZjogcG9wcGVyUHJvcHMucmVmcy5zZXRGbG9hdGluZywgc3R5bGU6IHBvcHBlclByb3BzLmZsb2F0aW5nU3R5bGVzLCBjbGFzc05hbWU6IGNsYXNzZXMsIFwiZGF0YS1wbGFjZW1lbnRcIjogcG9wcGVyUHJvcHMucGxhY2VtZW50LCBvbktleURvd246IHBvcHBlck9uS2V5RG93biB9LFxuICAgICAgICAgICAgICAgIHBvcHBlckNvbXBvbmVudCxcbiAgICAgICAgICAgICAgICBzaG93QXJyb3cgJiYgKFJlYWN0LmNyZWF0ZUVsZW1lbnQoRmxvYXRpbmdBcnJvdywgeyByZWY6IHBvcHBlclByb3BzLmFycm93UmVmLCBjb250ZXh0OiBwb3BwZXJQcm9wcy5jb250ZXh0LCBmaWxsOiBcImN1cnJlbnRDb2xvclwiLCBzdHJva2VXaWR0aDogMSwgaGVpZ2h0OiA4LCB3aWR0aDogMTYsIHN0eWxlOiB7IHRyYW5zZm9ybTogXCJ0cmFuc2xhdGVZKC0xcHgpXCIgfSwgY2xhc3NOYW1lOiBcInJlYWN0LWRhdGVwaWNrZXJfX3RyaWFuZ2xlXCIgfSkpKSkpO1xuICAgIH1cbiAgICBpZiAocHJvcHMucG9wcGVyQ29udGFpbmVyKSB7XG4gICAgICAgIHBvcHBlciA9IGNyZWF0ZUVsZW1lbnQocHJvcHMucG9wcGVyQ29udGFpbmVyLCB7fSwgcG9wcGVyKTtcbiAgICB9XG4gICAgaWYgKHBvcnRhbElkICYmICFoaWRlUG9wcGVyKSB7XG4gICAgICAgIHBvcHBlciA9IChSZWFjdC5jcmVhdGVFbGVtZW50KFBvcnRhbCwgeyBwb3J0YWxJZDogcG9ydGFsSWQsIHBvcnRhbEhvc3Q6IHBvcnRhbEhvc3QgfSwgcG9wcGVyKSk7XG4gICAgfVxuICAgIHZhciB3cmFwcGVyQ2xhc3NlcyA9IGNsc3goXCJyZWFjdC1kYXRlcGlja2VyLXdyYXBwZXJcIiwgd3JhcHBlckNsYXNzTmFtZSk7XG4gICAgcmV0dXJuIChSZWFjdC5jcmVhdGVFbGVtZW50KFJlYWN0LkZyYWdtZW50LCBudWxsLFxuICAgICAgICBSZWFjdC5jcmVhdGVFbGVtZW50KFwiZGl2XCIsIHsgcmVmOiBwb3BwZXJQcm9wcy5yZWZzLnNldFJlZmVyZW5jZSwgY2xhc3NOYW1lOiB3cmFwcGVyQ2xhc3NlcyB9LCB0YXJnZXRDb21wb25lbnQpLFxuICAgICAgICBwb3BwZXIpKTtcbn07XG52YXIgUG9wcGVyQ29tcG9uZW50ID0gd2l0aEZsb2F0aW5nKFBvcHBlckNvbXBvbmVudCQxKTtcblxuLy8gQ29tcGFyZXMgZGF0ZXMgeWVhcittb250aCBjb21iaW5hdGlvbnNcbmZ1bmN0aW9uIGhhc1ByZVNlbGVjdGlvbkNoYW5nZWQoZGF0ZTEsIGRhdGUyKSB7XG4gICAgaWYgKGRhdGUxICYmIGRhdGUyKSB7XG4gICAgICAgIHJldHVybiAoZ2V0TW9udGgoZGF0ZTEpICE9PSBnZXRNb250aChkYXRlMikgfHwgZ2V0WWVhcihkYXRlMSkgIT09IGdldFllYXIoZGF0ZTIpKTtcbiAgICB9XG4gICAgcmV0dXJuIGRhdGUxICE9PSBkYXRlMjtcbn1cbi8qKlxuICogR2VuZXJhbCBkYXRlcGlja2VyIGNvbXBvbmVudC5cbiAqL1xudmFyIElOUFVUX0VSUl8xID0gXCJEYXRlIGlucHV0IG5vdCB2YWxpZC5cIjtcbnZhciBEYXRlUGlja2VyID0gLyoqIEBjbGFzcyAqLyAoZnVuY3Rpb24gKF9zdXBlcikge1xuICAgIF9fZXh0ZW5kcyhEYXRlUGlja2VyLCBfc3VwZXIpO1xuICAgIGZ1bmN0aW9uIERhdGVQaWNrZXIocHJvcHMpIHtcbiAgICAgICAgdmFyIF90aGlzID0gX3N1cGVyLmNhbGwodGhpcywgcHJvcHMpIHx8IHRoaXM7XG4gICAgICAgIF90aGlzLmNhbGVuZGFyID0gbnVsbDtcbiAgICAgICAgX3RoaXMuaW5wdXQgPSBudWxsO1xuICAgICAgICBfdGhpcy5nZXRQcmVTZWxlY3Rpb24gPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICByZXR1cm4gX3RoaXMucHJvcHMub3BlblRvRGF0ZVxuICAgICAgICAgICAgICAgID8gX3RoaXMucHJvcHMub3BlblRvRGF0ZVxuICAgICAgICAgICAgICAgIDogX3RoaXMucHJvcHMuc2VsZWN0c0VuZCAmJiBfdGhpcy5wcm9wcy5zdGFydERhdGVcbiAgICAgICAgICAgICAgICAgICAgPyBfdGhpcy5wcm9wcy5zdGFydERhdGVcbiAgICAgICAgICAgICAgICAgICAgOiBfdGhpcy5wcm9wcy5zZWxlY3RzU3RhcnQgJiYgX3RoaXMucHJvcHMuZW5kRGF0ZVxuICAgICAgICAgICAgICAgICAgICAgICAgPyBfdGhpcy5wcm9wcy5lbmREYXRlXG4gICAgICAgICAgICAgICAgICAgICAgICA6IG5ld0RhdGUoKTtcbiAgICAgICAgfTtcbiAgICAgICAgLy8gQ29udmVydCB0aGUgZGF0ZSBmcm9tIHN0cmluZyBmb3JtYXQgdG8gc3RhbmRhcmQgRGF0ZSBmb3JtYXRcbiAgICAgICAgX3RoaXMubW9kaWZ5SG9saWRheXMgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICB2YXIgX2E7XG4gICAgICAgICAgICByZXR1cm4gKF9hID0gX3RoaXMucHJvcHMuaG9saWRheXMpID09PSBudWxsIHx8IF9hID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYS5yZWR1Y2UoZnVuY3Rpb24gKGFjY3VtdWxhdG9yLCBob2xpZGF5KSB7XG4gICAgICAgICAgICAgICAgdmFyIGRhdGUgPSBuZXcgRGF0ZShob2xpZGF5LmRhdGUpO1xuICAgICAgICAgICAgICAgIGlmICghaXNWYWxpZChkYXRlKSkge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gYWNjdW11bGF0b3I7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHJldHVybiBfX3NwcmVhZEFycmF5KF9fc3ByZWFkQXJyYXkoW10sIGFjY3VtdWxhdG9yLCB0cnVlKSwgW19hc3NpZ24oX2Fzc2lnbih7fSwgaG9saWRheSksIHsgZGF0ZTogZGF0ZSB9KV0sIGZhbHNlKTtcbiAgICAgICAgICAgIH0sIFtdKTtcbiAgICAgICAgfTtcbiAgICAgICAgX3RoaXMuY2FsY0luaXRpYWxTdGF0ZSA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIHZhciBfYTtcbiAgICAgICAgICAgIHZhciBkZWZhdWx0UHJlU2VsZWN0aW9uID0gX3RoaXMuZ2V0UHJlU2VsZWN0aW9uKCk7XG4gICAgICAgICAgICB2YXIgbWluRGF0ZSA9IGdldEVmZmVjdGl2ZU1pbkRhdGUoX3RoaXMucHJvcHMpO1xuICAgICAgICAgICAgdmFyIG1heERhdGUgPSBnZXRFZmZlY3RpdmVNYXhEYXRlKF90aGlzLnByb3BzKTtcbiAgICAgICAgICAgIHZhciBib3VuZGVkUHJlU2VsZWN0aW9uID0gbWluRGF0ZSAmJiBpc0JlZm9yZShkZWZhdWx0UHJlU2VsZWN0aW9uLCBnZXRTdGFydE9mRGF5KG1pbkRhdGUpKVxuICAgICAgICAgICAgICAgID8gbWluRGF0ZVxuICAgICAgICAgICAgICAgIDogbWF4RGF0ZSAmJiBpc0FmdGVyKGRlZmF1bHRQcmVTZWxlY3Rpb24sIGdldEVuZE9mRGF5KG1heERhdGUpKVxuICAgICAgICAgICAgICAgICAgICA/IG1heERhdGVcbiAgICAgICAgICAgICAgICAgICAgOiBkZWZhdWx0UHJlU2VsZWN0aW9uO1xuICAgICAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgICAgICBvcGVuOiBfdGhpcy5wcm9wcy5zdGFydE9wZW4gfHwgZmFsc2UsXG4gICAgICAgICAgICAgICAgcHJldmVudEZvY3VzOiBmYWxzZSxcbiAgICAgICAgICAgICAgICBpbnB1dFZhbHVlOiBudWxsLFxuICAgICAgICAgICAgICAgIHByZVNlbGVjdGlvbjogKF9hID0gKF90aGlzLnByb3BzLnNlbGVjdHNSYW5nZVxuICAgICAgICAgICAgICAgICAgICA/IF90aGlzLnByb3BzLnN0YXJ0RGF0ZVxuICAgICAgICAgICAgICAgICAgICA6IF90aGlzLnByb3BzLnNlbGVjdGVkKSkgIT09IG51bGwgJiYgX2EgIT09IHZvaWQgMCA/IF9hIDogYm91bmRlZFByZVNlbGVjdGlvbixcbiAgICAgICAgICAgICAgICAvLyB0cmFuc2Zvcm1pbmcgaGlnaGxpZ2h0ZWQgZGF5cyAocGVyaGFwcyBuZXN0ZWQgYXJyYXkpXG4gICAgICAgICAgICAgICAgLy8gdG8gZmxhdCBNYXAgZm9yIGZhc3RlciBhY2Nlc3MgaW4gZGF5LmpzeFxuICAgICAgICAgICAgICAgIGhpZ2hsaWdodERhdGVzOiBnZXRIaWdoTGlnaHREYXlzTWFwKF90aGlzLnByb3BzLmhpZ2hsaWdodERhdGVzKSxcbiAgICAgICAgICAgICAgICBmb2N1c2VkOiBmYWxzZSxcbiAgICAgICAgICAgICAgICAvLyB1c2VkIHRvIGZvY3VzIGRheSBpbiBpbmxpbmUgdmVyc2lvbiBhZnRlciBtb250aCBoYXMgY2hhbmdlZCwgYnV0IG5vdCBvblxuICAgICAgICAgICAgICAgIC8vIGluaXRpYWwgcmVuZGVyXG4gICAgICAgICAgICAgICAgc2hvdWxkRm9jdXNEYXlJbmxpbmU6IGZhbHNlLFxuICAgICAgICAgICAgICAgIGlzUmVuZGVyQXJpYUxpdmVNZXNzYWdlOiBmYWxzZSxcbiAgICAgICAgICAgICAgICB3YXNIaWRkZW46IGZhbHNlLFxuICAgICAgICAgICAgfTtcbiAgICAgICAgfTtcbiAgICAgICAgX3RoaXMuZ2V0SW5wdXRWYWx1ZSA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIHZhciBfYTtcbiAgICAgICAgICAgIHZhciBfYiA9IF90aGlzLnByb3BzLCBsb2NhbGUgPSBfYi5sb2NhbGUsIHN0YXJ0RGF0ZSA9IF9iLnN0YXJ0RGF0ZSwgZW5kRGF0ZSA9IF9iLmVuZERhdGUsIHJhbmdlU2VwYXJhdG9yID0gX2IucmFuZ2VTZXBhcmF0b3IsIHNlbGVjdGVkID0gX2Iuc2VsZWN0ZWQsIHNlbGVjdGVkRGF0ZXMgPSBfYi5zZWxlY3RlZERhdGVzLCBzZWxlY3RzTXVsdGlwbGUgPSBfYi5zZWxlY3RzTXVsdGlwbGUsIHNlbGVjdHNSYW5nZSA9IF9iLnNlbGVjdHNSYW5nZSwgdmFsdWUgPSBfYi52YWx1ZTtcbiAgICAgICAgICAgIHZhciBkYXRlRm9ybWF0ID0gKF9hID0gX3RoaXMucHJvcHMuZGF0ZUZvcm1hdCkgIT09IG51bGwgJiYgX2EgIT09IHZvaWQgMCA/IF9hIDogRGF0ZVBpY2tlci5kZWZhdWx0UHJvcHMuZGF0ZUZvcm1hdDtcbiAgICAgICAgICAgIHZhciBpbnB1dFZhbHVlID0gX3RoaXMuc3RhdGUuaW5wdXRWYWx1ZTtcbiAgICAgICAgICAgIGlmICh0eXBlb2YgdmFsdWUgPT09IFwic3RyaW5nXCIpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gdmFsdWU7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIGlmICh0eXBlb2YgaW5wdXRWYWx1ZSA9PT0gXCJzdHJpbmdcIikge1xuICAgICAgICAgICAgICAgIHJldHVybiBpbnB1dFZhbHVlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSBpZiAoc2VsZWN0c1JhbmdlKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHNhZmVEYXRlUmFuZ2VGb3JtYXQoc3RhcnREYXRlLCBlbmREYXRlLCB7XG4gICAgICAgICAgICAgICAgICAgIGRhdGVGb3JtYXQ6IGRhdGVGb3JtYXQsXG4gICAgICAgICAgICAgICAgICAgIGxvY2FsZTogbG9jYWxlLFxuICAgICAgICAgICAgICAgICAgICByYW5nZVNlcGFyYXRvcjogcmFuZ2VTZXBhcmF0b3IsXG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIGlmIChzZWxlY3RzTXVsdGlwbGUpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gc2FmZU11bHRpcGxlRGF0ZXNGb3JtYXQoc2VsZWN0ZWREYXRlcyAhPT0gbnVsbCAmJiBzZWxlY3RlZERhdGVzICE9PSB2b2lkIDAgPyBzZWxlY3RlZERhdGVzIDogW10sIHtcbiAgICAgICAgICAgICAgICAgICAgZGF0ZUZvcm1hdDogZGF0ZUZvcm1hdCxcbiAgICAgICAgICAgICAgICAgICAgbG9jYWxlOiBsb2NhbGUsXG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gc2FmZURhdGVGb3JtYXQoc2VsZWN0ZWQsIHtcbiAgICAgICAgICAgICAgICBkYXRlRm9ybWF0OiBkYXRlRm9ybWF0LFxuICAgICAgICAgICAgICAgIGxvY2FsZTogbG9jYWxlLFxuICAgICAgICAgICAgfSk7XG4gICAgICAgIH07XG4gICAgICAgIF90aGlzLnJlc2V0SGlkZGVuU3RhdHVzID0gZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgX3RoaXMuc2V0U3RhdGUoX2Fzc2lnbihfYXNzaWduKHt9LCBfdGhpcy5zdGF0ZSksIHsgd2FzSGlkZGVuOiBmYWxzZSB9KSk7XG4gICAgICAgIH07XG4gICAgICAgIF90aGlzLnNldEhpZGRlblN0YXR1cyA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIF90aGlzLnNldFN0YXRlKF9hc3NpZ24oX2Fzc2lnbih7fSwgX3RoaXMuc3RhdGUpLCB7IHdhc0hpZGRlbjogdHJ1ZSB9KSk7XG4gICAgICAgIH07XG4gICAgICAgIF90aGlzLnNldEhpZGRlblN0YXRlT25WaXNpYmlsaXR5SGlkZGVuID0gZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgaWYgKGRvY3VtZW50LnZpc2liaWxpdHlTdGF0ZSAhPT0gXCJoaWRkZW5cIikge1xuICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIF90aGlzLnNldEhpZGRlblN0YXR1cygpO1xuICAgICAgICB9O1xuICAgICAgICBfdGhpcy5jbGVhclByZXZlbnRGb2N1c1RpbWVvdXQgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICBpZiAoX3RoaXMucHJldmVudEZvY3VzVGltZW91dCkge1xuICAgICAgICAgICAgICAgIGNsZWFyVGltZW91dChfdGhpcy5wcmV2ZW50Rm9jdXNUaW1lb3V0KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfTtcbiAgICAgICAgX3RoaXMuc2V0Rm9jdXMgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICB2YXIgX2EsIF9iO1xuICAgICAgICAgICAgKF9iID0gKF9hID0gX3RoaXMuaW5wdXQpID09PSBudWxsIHx8IF9hID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYS5mb2N1cykgPT09IG51bGwgfHwgX2IgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9iLmNhbGwoX2EsIHsgcHJldmVudFNjcm9sbDogdHJ1ZSB9KTtcbiAgICAgICAgfTtcbiAgICAgICAgX3RoaXMuc2V0Qmx1ciA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIHZhciBfYSwgX2I7XG4gICAgICAgICAgICAoX2IgPSAoX2EgPSBfdGhpcy5pbnB1dCkgPT09IG51bGwgfHwgX2EgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9hLmJsdXIpID09PSBudWxsIHx8IF9iID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYi5jYWxsKF9hKTtcbiAgICAgICAgICAgIF90aGlzLmNhbmNlbEZvY3VzSW5wdXQoKTtcbiAgICAgICAgfTtcbiAgICAgICAgX3RoaXMuZGVmZXJCbHVyID0gZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgcmVxdWVzdEFuaW1hdGlvbkZyYW1lKGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgICAgICBfdGhpcy5zZXRCbHVyKCk7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfTtcbiAgICAgICAgX3RoaXMuc2V0T3BlbiA9IGZ1bmN0aW9uIChvcGVuLCBza2lwU2V0Qmx1cikge1xuICAgICAgICAgICAgaWYgKHNraXBTZXRCbHVyID09PSB2b2lkIDApIHsgc2tpcFNldEJsdXIgPSBmYWxzZTsgfVxuICAgICAgICAgICAgX3RoaXMuc2V0U3RhdGUoe1xuICAgICAgICAgICAgICAgIG9wZW46IG9wZW4sXG4gICAgICAgICAgICAgICAgcHJlU2VsZWN0aW9uOiBvcGVuICYmIF90aGlzLnN0YXRlLm9wZW5cbiAgICAgICAgICAgICAgICAgICAgPyBfdGhpcy5zdGF0ZS5wcmVTZWxlY3Rpb25cbiAgICAgICAgICAgICAgICAgICAgOiBfdGhpcy5jYWxjSW5pdGlhbFN0YXRlKCkucHJlU2VsZWN0aW9uLFxuICAgICAgICAgICAgICAgIGxhc3RQcmVTZWxlY3RDaGFuZ2U6IFBSRVNFTEVDVF9DSEFOR0VfVklBX05BVklHQVRFLFxuICAgICAgICAgICAgfSwgZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgICAgIGlmICghb3Blbikge1xuICAgICAgICAgICAgICAgICAgICBfdGhpcy5zZXRTdGF0ZShmdW5jdGlvbiAocHJldikgeyByZXR1cm4gKHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGZvY3VzZWQ6IHNraXBTZXRCbHVyID8gcHJldi5mb2N1c2VkIDogZmFsc2UsXG4gICAgICAgICAgICAgICAgICAgIH0pOyB9LCBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAhc2tpcFNldEJsdXIgJiYgX3RoaXMuZGVmZXJCbHVyKCk7XG4gICAgICAgICAgICAgICAgICAgICAgICBfdGhpcy5zZXRTdGF0ZSh7IGlucHV0VmFsdWU6IG51bGwgfSk7XG4gICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9O1xuICAgICAgICBfdGhpcy5pbnB1dE9rID0gZnVuY3Rpb24gKCkgeyByZXR1cm4gaXNEYXRlKF90aGlzLnN0YXRlLnByZVNlbGVjdGlvbik7IH07XG4gICAgICAgIF90aGlzLmlzQ2FsZW5kYXJPcGVuID0gZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgcmV0dXJuIF90aGlzLnByb3BzLm9wZW4gPT09IHVuZGVmaW5lZFxuICAgICAgICAgICAgICAgID8gX3RoaXMuc3RhdGUub3BlbiAmJiAhX3RoaXMucHJvcHMuZGlzYWJsZWQgJiYgIV90aGlzLnByb3BzLnJlYWRPbmx5XG4gICAgICAgICAgICAgICAgOiBfdGhpcy5wcm9wcy5vcGVuO1xuICAgICAgICB9O1xuICAgICAgICBfdGhpcy5oYW5kbGVGb2N1cyA9IGZ1bmN0aW9uIChldmVudCkge1xuICAgICAgICAgICAgdmFyIF9hLCBfYjtcbiAgICAgICAgICAgIHZhciBpc0F1dG9SZUZvY3VzID0gX3RoaXMuc3RhdGUud2FzSGlkZGVuO1xuICAgICAgICAgICAgdmFyIGlzT3BlbkFsbG93ZWQgPSBpc0F1dG9SZUZvY3VzID8gX3RoaXMuc3RhdGUub3BlbiA6IHRydWU7XG4gICAgICAgICAgICBpZiAoaXNBdXRvUmVGb2N1cykge1xuICAgICAgICAgICAgICAgIF90aGlzLnJlc2V0SGlkZGVuU3RhdHVzKCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoIV90aGlzLnN0YXRlLnByZXZlbnRGb2N1cykge1xuICAgICAgICAgICAgICAgIChfYiA9IChfYSA9IF90aGlzLnByb3BzKS5vbkZvY3VzKSA9PT0gbnVsbCB8fCBfYiA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2IuY2FsbChfYSwgZXZlbnQpO1xuICAgICAgICAgICAgICAgIGlmIChpc09wZW5BbGxvd2VkICYmXG4gICAgICAgICAgICAgICAgICAgICFfdGhpcy5wcm9wcy5wcmV2ZW50T3Blbk9uRm9jdXMgJiZcbiAgICAgICAgICAgICAgICAgICAgIV90aGlzLnByb3BzLnJlYWRPbmx5KSB7XG4gICAgICAgICAgICAgICAgICAgIF90aGlzLnNldE9wZW4odHJ1ZSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgX3RoaXMuc2V0U3RhdGUoeyBmb2N1c2VkOiB0cnVlIH0pO1xuICAgICAgICB9O1xuICAgICAgICBfdGhpcy5zZW5kRm9jdXNCYWNrVG9JbnB1dCA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIC8vIENsZWFyIHByZXZpb3VzIHRpbWVvdXQgaWYgaXQgZXhpc3RzXG4gICAgICAgICAgICBpZiAoX3RoaXMucHJldmVudEZvY3VzVGltZW91dCkge1xuICAgICAgICAgICAgICAgIF90aGlzLmNsZWFyUHJldmVudEZvY3VzVGltZW91dCgpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgLy8gY2xvc2UgdGhlIHBvcHBlciBhbmQgcmVmb2N1cyB0aGUgaW5wdXRcbiAgICAgICAgICAgIC8vIHN0b3AgdGhlIGlucHV0IGZyb20gYXV0byBvcGVuaW5nIG9uRm9jdXNcbiAgICAgICAgICAgIC8vIHNldEZvY3VzIHRvIHRoZSBpbnB1dFxuICAgICAgICAgICAgX3RoaXMuc2V0U3RhdGUoeyBwcmV2ZW50Rm9jdXM6IHRydWUgfSwgZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgICAgIF90aGlzLnByZXZlbnRGb2N1c1RpbWVvdXQgPSBzZXRUaW1lb3V0KGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgICAgICAgICAgX3RoaXMuc2V0Rm9jdXMoKTtcbiAgICAgICAgICAgICAgICAgICAgX3RoaXMuc2V0U3RhdGUoeyBwcmV2ZW50Rm9jdXM6IGZhbHNlIH0pO1xuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgIH07XG4gICAgICAgIF90aGlzLmNhbmNlbEZvY3VzSW5wdXQgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICBjbGVhclRpbWVvdXQoX3RoaXMuaW5wdXRGb2N1c1RpbWVvdXQpO1xuICAgICAgICAgICAgX3RoaXMuaW5wdXRGb2N1c1RpbWVvdXQgPSB1bmRlZmluZWQ7XG4gICAgICAgIH07XG4gICAgICAgIF90aGlzLmRlZmVyRm9jdXNJbnB1dCA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIF90aGlzLmNhbmNlbEZvY3VzSW5wdXQoKTtcbiAgICAgICAgICAgIF90aGlzLmlucHV0Rm9jdXNUaW1lb3V0ID0gc2V0VGltZW91dChmdW5jdGlvbiAoKSB7IHJldHVybiBfdGhpcy5zZXRGb2N1cygpOyB9LCAxKTtcbiAgICAgICAgfTtcbiAgICAgICAgX3RoaXMuaGFuZGxlRHJvcGRvd25Gb2N1cyA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIF90aGlzLmNhbmNlbEZvY3VzSW5wdXQoKTtcbiAgICAgICAgfTtcbiAgICAgICAgX3RoaXMucmVzZXRJbnB1dFZhbHVlID0gZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgX3RoaXMuc2V0U3RhdGUoX2Fzc2lnbihfYXNzaWduKHt9LCBfdGhpcy5zdGF0ZSksIHsgaW5wdXRWYWx1ZTogbnVsbCB9KSk7XG4gICAgICAgIH07XG4gICAgICAgIF90aGlzLmhhbmRsZUJsdXIgPSBmdW5jdGlvbiAoZXZlbnQpIHtcbiAgICAgICAgICAgIHZhciBfYSwgX2I7XG4gICAgICAgICAgICBpZiAoIV90aGlzLnN0YXRlLm9wZW4gfHwgX3RoaXMucHJvcHMud2l0aFBvcnRhbCB8fCBfdGhpcy5wcm9wcy5zaG93VGltZUlucHV0KSB7XG4gICAgICAgICAgICAgICAgKF9iID0gKF9hID0gX3RoaXMucHJvcHMpLm9uQmx1cikgPT09IG51bGwgfHwgX2IgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9iLmNhbGwoX2EsIGV2ZW50KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIF90aGlzLnJlc2V0SW5wdXRWYWx1ZSgpO1xuICAgICAgICAgICAgaWYgKF90aGlzLnN0YXRlLm9wZW4gJiYgX3RoaXMucHJvcHMub3BlbiA9PT0gZmFsc2UpIHtcbiAgICAgICAgICAgICAgICBfdGhpcy5zZXRPcGVuKGZhbHNlKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIF90aGlzLnNldFN0YXRlKHsgZm9jdXNlZDogZmFsc2UgfSk7XG4gICAgICAgIH07XG4gICAgICAgIF90aGlzLmhhbmRsZUNhbGVuZGFyQ2xpY2tPdXRzaWRlID0gZnVuY3Rpb24gKGV2ZW50KSB7XG4gICAgICAgICAgICB2YXIgX2EsIF9iO1xuICAgICAgICAgICAgaWYgKCFfdGhpcy5wcm9wcy5pbmxpbmUpIHtcbiAgICAgICAgICAgICAgICBfdGhpcy5zZXRPcGVuKGZhbHNlKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIChfYiA9IChfYSA9IF90aGlzLnByb3BzKS5vbkNsaWNrT3V0c2lkZSkgPT09IG51bGwgfHwgX2IgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9iLmNhbGwoX2EsIGV2ZW50KTtcbiAgICAgICAgICAgIGlmIChfdGhpcy5wcm9wcy53aXRoUG9ydGFsKSB7XG4gICAgICAgICAgICAgICAgZXZlbnQucHJldmVudERlZmF1bHQoKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfTtcbiAgICAgICAgLy8gaGFuZGxlQ2hhbmdlIGlzIGNhbGxlZCB3aGVuIHVzZXIgdHlwZXMgaW4gdGhlIHRleHRib3hcbiAgICAgICAgX3RoaXMuaGFuZGxlQ2hhbmdlID0gZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgdmFyIF9hLCBfYiwgX2MsIF9kLCBfZTtcbiAgICAgICAgICAgIHZhciBhbGxBcmdzID0gW107XG4gICAgICAgICAgICBmb3IgKHZhciBfaSA9IDA7IF9pIDwgYXJndW1lbnRzLmxlbmd0aDsgX2krKykge1xuICAgICAgICAgICAgICAgIGFsbEFyZ3NbX2ldID0gYXJndW1lbnRzW19pXTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHZhciBldmVudCA9IGFsbEFyZ3NbMF07XG4gICAgICAgICAgICBpZiAoX3RoaXMucHJvcHMub25DaGFuZ2VSYXcpIHtcbiAgICAgICAgICAgICAgICBfdGhpcy5wcm9wcy5vbkNoYW5nZVJhdy5hcHBseShfdGhpcywgYWxsQXJncyk7XG4gICAgICAgICAgICAgICAgaWYgKCFldmVudCB8fFxuICAgICAgICAgICAgICAgICAgICB0eXBlb2YgZXZlbnQuaXNEZWZhdWx0UHJldmVudGVkICE9PSBcImZ1bmN0aW9uXCIgfHxcbiAgICAgICAgICAgICAgICAgICAgZXZlbnQuaXNEZWZhdWx0UHJldmVudGVkKCkpIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIF90aGlzLnNldFN0YXRlKHtcbiAgICAgICAgICAgICAgICBpbnB1dFZhbHVlOiAoZXZlbnQgPT09IG51bGwgfHwgZXZlbnQgPT09IHZvaWQgMCA/IHZvaWQgMCA6IGV2ZW50LnRhcmdldCkgaW5zdGFuY2VvZiBIVE1MSW5wdXRFbGVtZW50ID8gZXZlbnQudGFyZ2V0LnZhbHVlIDogbnVsbCxcbiAgICAgICAgICAgICAgICBsYXN0UHJlU2VsZWN0Q2hhbmdlOiBQUkVTRUxFQ1RfQ0hBTkdFX1ZJQV9JTlBVVCxcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgdmFyIF9mID0gX3RoaXMucHJvcHMsIHNlbGVjdHNSYW5nZSA9IF9mLnNlbGVjdHNSYW5nZSwgc3RhcnREYXRlID0gX2Yuc3RhcnREYXRlLCBlbmREYXRlID0gX2YuZW5kRGF0ZTtcbiAgICAgICAgICAgIHZhciBkYXRlRm9ybWF0ID0gKF9hID0gX3RoaXMucHJvcHMuZGF0ZUZvcm1hdCkgIT09IG51bGwgJiYgX2EgIT09IHZvaWQgMCA/IF9hIDogRGF0ZVBpY2tlci5kZWZhdWx0UHJvcHMuZGF0ZUZvcm1hdDtcbiAgICAgICAgICAgIHZhciBzdHJpY3RQYXJzaW5nID0gKF9iID0gX3RoaXMucHJvcHMuc3RyaWN0UGFyc2luZykgIT09IG51bGwgJiYgX2IgIT09IHZvaWQgMCA/IF9iIDogRGF0ZVBpY2tlci5kZWZhdWx0UHJvcHMuc3RyaWN0UGFyc2luZztcbiAgICAgICAgICAgIHZhciB2YWx1ZSA9IChldmVudCA9PT0gbnVsbCB8fCBldmVudCA9PT0gdm9pZCAwID8gdm9pZCAwIDogZXZlbnQudGFyZ2V0KSBpbnN0YW5jZW9mIEhUTUxJbnB1dEVsZW1lbnQgPyBldmVudC50YXJnZXQudmFsdWUgOiBcIlwiO1xuICAgICAgICAgICAgaWYgKHNlbGVjdHNSYW5nZSkge1xuICAgICAgICAgICAgICAgIHZhciByYW5nZVNlcGFyYXRvciA9IF90aGlzLnByb3BzLnJhbmdlU2VwYXJhdG9yO1xuICAgICAgICAgICAgICAgIHZhciB0cmltbWVkUmFuZ2VTZXBhcmF0b3IgPSByYW5nZVNlcGFyYXRvci50cmltKCk7XG4gICAgICAgICAgICAgICAgdmFyIF9nID0gdmFsdWVcbiAgICAgICAgICAgICAgICAgICAgLnNwbGl0KGRhdGVGb3JtYXQuaW5jbHVkZXModHJpbW1lZFJhbmdlU2VwYXJhdG9yKVxuICAgICAgICAgICAgICAgICAgICA/IHJhbmdlU2VwYXJhdG9yXG4gICAgICAgICAgICAgICAgICAgIDogdHJpbW1lZFJhbmdlU2VwYXJhdG9yLCAyKVxuICAgICAgICAgICAgICAgICAgICAubWFwKGZ1bmN0aW9uICh2YWwpIHsgcmV0dXJuIHZhbC50cmltKCk7IH0pLCB2YWx1ZVN0YXJ0ID0gX2dbMF0sIHZhbHVlRW5kID0gX2dbMV07XG4gICAgICAgICAgICAgICAgdmFyIHN0YXJ0RGF0ZU5ldyA9IHBhcnNlRGF0ZSh2YWx1ZVN0YXJ0ICE9PSBudWxsICYmIHZhbHVlU3RhcnQgIT09IHZvaWQgMCA/IHZhbHVlU3RhcnQgOiBcIlwiLCBkYXRlRm9ybWF0LCBfdGhpcy5wcm9wcy5sb2NhbGUsIHN0cmljdFBhcnNpbmcpO1xuICAgICAgICAgICAgICAgIHZhciBlbmREYXRlTmV3ID0gc3RhcnREYXRlTmV3XG4gICAgICAgICAgICAgICAgICAgID8gcGFyc2VEYXRlKHZhbHVlRW5kICE9PSBudWxsICYmIHZhbHVlRW5kICE9PSB2b2lkIDAgPyB2YWx1ZUVuZCA6IFwiXCIsIGRhdGVGb3JtYXQsIF90aGlzLnByb3BzLmxvY2FsZSwgc3RyaWN0UGFyc2luZylcbiAgICAgICAgICAgICAgICAgICAgOiBudWxsO1xuICAgICAgICAgICAgICAgIHZhciBzdGFydENoYW5nZWQgPSAoc3RhcnREYXRlID09PSBudWxsIHx8IHN0YXJ0RGF0ZSA9PT0gdm9pZCAwID8gdm9pZCAwIDogc3RhcnREYXRlLmdldFRpbWUoKSkgIT09IChzdGFydERhdGVOZXcgPT09IG51bGwgfHwgc3RhcnREYXRlTmV3ID09PSB2b2lkIDAgPyB2b2lkIDAgOiBzdGFydERhdGVOZXcuZ2V0VGltZSgpKTtcbiAgICAgICAgICAgICAgICB2YXIgZW5kQ2hhbmdlZCA9IChlbmREYXRlID09PSBudWxsIHx8IGVuZERhdGUgPT09IHZvaWQgMCA/IHZvaWQgMCA6IGVuZERhdGUuZ2V0VGltZSgpKSAhPT0gKGVuZERhdGVOZXcgPT09IG51bGwgfHwgZW5kRGF0ZU5ldyA9PT0gdm9pZCAwID8gdm9pZCAwIDogZW5kRGF0ZU5ldy5nZXRUaW1lKCkpO1xuICAgICAgICAgICAgICAgIGlmICghc3RhcnRDaGFuZ2VkICYmICFlbmRDaGFuZ2VkKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgaWYgKHN0YXJ0RGF0ZU5ldyAmJiBpc0RheURpc2FibGVkKHN0YXJ0RGF0ZU5ldywgX3RoaXMucHJvcHMpKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgaWYgKGVuZERhdGVOZXcgJiYgaXNEYXlEaXNhYmxlZChlbmREYXRlTmV3LCBfdGhpcy5wcm9wcykpIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAoX2QgPSAoX2MgPSBfdGhpcy5wcm9wcykub25DaGFuZ2UpID09PSBudWxsIHx8IF9kID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfZC5jYWxsKF9jLCBbc3RhcnREYXRlTmV3LCBlbmREYXRlTmV3XSwgZXZlbnQpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgLy8gbm90IHNlbGVjdHNSYW5nZVxuICAgICAgICAgICAgICAgIHZhciBkYXRlID0gcGFyc2VEYXRlKHZhbHVlLCBkYXRlRm9ybWF0LCBfdGhpcy5wcm9wcy5sb2NhbGUsIHN0cmljdFBhcnNpbmcsIChfZSA9IF90aGlzLnByb3BzLnNlbGVjdGVkKSAhPT0gbnVsbCAmJiBfZSAhPT0gdm9pZCAwID8gX2UgOiB1bmRlZmluZWQpO1xuICAgICAgICAgICAgICAgIC8vIFVwZGF0ZSBzZWxlY3Rpb24gaWYgZWl0aGVyICgxKSBkYXRlIHdhcyBzdWNjZXNzZnVsbHkgcGFyc2VkLCBvciAoMikgaW5wdXQgZmllbGQgaXMgZW1wdHlcbiAgICAgICAgICAgICAgICBpZiAoZGF0ZSB8fCAhdmFsdWUpIHtcbiAgICAgICAgICAgICAgICAgICAgX3RoaXMuc2V0U2VsZWN0ZWQoZGF0ZSwgZXZlbnQsIHRydWUpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfTtcbiAgICAgICAgX3RoaXMuaGFuZGxlU2VsZWN0ID0gZnVuY3Rpb24gKGRhdGUsIGV2ZW50LCBtb250aFNlbGVjdGVkSW4pIHtcbiAgICAgICAgICAgIHZhciBfYTtcbiAgICAgICAgICAgIGlmIChfdGhpcy5wcm9wcy5yZWFkT25seSlcbiAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICB2YXIgX2IgPSBfdGhpcy5wcm9wcywgc2VsZWN0c1JhbmdlID0gX2Iuc2VsZWN0c1JhbmdlLCBzdGFydERhdGUgPSBfYi5zdGFydERhdGUsIGVuZERhdGUgPSBfYi5lbmREYXRlLCBsb2NhbGUgPSBfYi5sb2NhbGUsIHN3YXBSYW5nZSA9IF9iLnN3YXBSYW5nZTtcbiAgICAgICAgICAgIHZhciBkYXRlRm9ybWF0ID0gKF9hID0gX3RoaXMucHJvcHMuZGF0ZUZvcm1hdCkgIT09IG51bGwgJiYgX2EgIT09IHZvaWQgMCA/IF9hIDogRGF0ZVBpY2tlci5kZWZhdWx0UHJvcHMuZGF0ZUZvcm1hdDtcbiAgICAgICAgICAgIHZhciBpc0RhdGVTZWxlY3Rpb25Db21wbGV0ZSA9ICFzZWxlY3RzUmFuZ2UgfHxcbiAgICAgICAgICAgICAgICAoc3RhcnREYXRlICYmICFlbmREYXRlICYmIChzd2FwUmFuZ2UgfHwgIWlzRGF0ZUJlZm9yZShkYXRlLCBzdGFydERhdGUpKSk7XG4gICAgICAgICAgICBpZiAoX3RoaXMucHJvcHMuc2hvdWxkQ2xvc2VPblNlbGVjdCAmJlxuICAgICAgICAgICAgICAgICFfdGhpcy5wcm9wcy5zaG93VGltZVNlbGVjdCAmJlxuICAgICAgICAgICAgICAgIGlzRGF0ZVNlbGVjdGlvbkNvbXBsZXRlKSB7XG4gICAgICAgICAgICAgICAgLy8gUHJldmVudGluZyBvbkZvY3VzIGV2ZW50IHRvIGZpeCBpc3N1ZVxuICAgICAgICAgICAgICAgIC8vIGh0dHBzOi8vZ2l0aHViLmNvbS9IYWNrZXIweDAxL3JlYWN0LWRhdGVwaWNrZXIvaXNzdWVzLzYyOFxuICAgICAgICAgICAgICAgIF90aGlzLnNlbmRGb2N1c0JhY2tUb0lucHV0KCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoX3RoaXMucHJvcHMub25DaGFuZ2VSYXcpIHtcbiAgICAgICAgICAgICAgICB2YXIgZm9ybWF0dGVkRGF0ZSA9IHNhZmVEYXRlRm9ybWF0KGRhdGUsIHtcbiAgICAgICAgICAgICAgICAgICAgZGF0ZUZvcm1hdDogZGF0ZUZvcm1hdCxcbiAgICAgICAgICAgICAgICAgICAgbG9jYWxlOiBsb2NhbGUsXG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgX3RoaXMucHJvcHMub25DaGFuZ2VSYXcoZXZlbnQsIHsgZGF0ZTogZGF0ZSwgZm9ybWF0dGVkRGF0ZTogZm9ybWF0dGVkRGF0ZSB9KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIF90aGlzLnNldFNlbGVjdGVkKGRhdGUsIGV2ZW50LCBmYWxzZSwgbW9udGhTZWxlY3RlZEluKTtcbiAgICAgICAgICAgIGlmIChfdGhpcy5wcm9wcy5zaG93RGF0ZVNlbGVjdCkge1xuICAgICAgICAgICAgICAgIF90aGlzLnNldFN0YXRlKHsgaXNSZW5kZXJBcmlhTGl2ZU1lc3NhZ2U6IHRydWUgfSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoIV90aGlzLnByb3BzLnNob3VsZENsb3NlT25TZWxlY3QgfHwgX3RoaXMucHJvcHMuc2hvd1RpbWVTZWxlY3QpIHtcbiAgICAgICAgICAgICAgICBfdGhpcy5zZXRQcmVTZWxlY3Rpb24oZGF0ZSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIGlmIChpc0RhdGVTZWxlY3Rpb25Db21wbGV0ZSkge1xuICAgICAgICAgICAgICAgIF90aGlzLnNldE9wZW4oZmFsc2UpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9O1xuICAgICAgICAvLyBzZXRTZWxlY3RlZCBpcyBjYWxsZWQgZWl0aGVyIGZyb20gaGFuZGxlQ2hhbmdlICh1c2VyIHR5cGVkIGRhdGUgaW50byB0ZXh0Ym94IGFuZCBpdCB3YXMgcGFyc2VkKSBvciBoYW5kbGVTZWxlY3QgKHVzZXIgc2VsZWN0ZWQgZGF0ZSBmcm9tIGNhbGVuZGFyIHVzaW5nIG1vdXNlIG9yIGtleWJvYXJkKVxuICAgICAgICBfdGhpcy5zZXRTZWxlY3RlZCA9IGZ1bmN0aW9uIChkYXRlLCBldmVudCwga2VlcElucHV0LCBtb250aFNlbGVjdGVkSW4pIHtcbiAgICAgICAgICAgIHZhciBfYSwgX2I7XG4gICAgICAgICAgICB2YXIgY2hhbmdlZERhdGUgPSBkYXRlO1xuICAgICAgICAgICAgLy8gRWFybHkgcmV0dXJuIGlmIHNlbGVjdGVkIHllYXIvbW9udGgvZGF5IGlzIGRpc2FibGVkXG4gICAgICAgICAgICBpZiAoX3RoaXMucHJvcHMuc2hvd1llYXJQaWNrZXIpIHtcbiAgICAgICAgICAgICAgICBpZiAoY2hhbmdlZERhdGUgIT09IG51bGwgJiZcbiAgICAgICAgICAgICAgICAgICAgaXNZZWFyRGlzYWJsZWQoZ2V0WWVhcihjaGFuZ2VkRGF0ZSksIF90aGlzLnByb3BzKSkge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSBpZiAoX3RoaXMucHJvcHMuc2hvd01vbnRoWWVhclBpY2tlcikge1xuICAgICAgICAgICAgICAgIGlmIChjaGFuZ2VkRGF0ZSAhPT0gbnVsbCAmJiBpc01vbnRoRGlzYWJsZWQoY2hhbmdlZERhdGUsIF90aGlzLnByb3BzKSkge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgaWYgKGNoYW5nZWREYXRlICE9PSBudWxsICYmIGlzRGF5RGlzYWJsZWQoY2hhbmdlZERhdGUsIF90aGlzLnByb3BzKSkge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdmFyIF9jID0gX3RoaXMucHJvcHMsIG9uQ2hhbmdlID0gX2Mub25DaGFuZ2UsIHNlbGVjdHNSYW5nZSA9IF9jLnNlbGVjdHNSYW5nZSwgc3RhcnREYXRlID0gX2Muc3RhcnREYXRlLCBlbmREYXRlID0gX2MuZW5kRGF0ZSwgc2VsZWN0c011bHRpcGxlID0gX2Muc2VsZWN0c011bHRpcGxlLCBzZWxlY3RlZERhdGVzID0gX2Muc2VsZWN0ZWREYXRlcywgbWluVGltZSA9IF9jLm1pblRpbWUsIHN3YXBSYW5nZSA9IF9jLnN3YXBSYW5nZTtcbiAgICAgICAgICAgIGlmICghaXNFcXVhbChfdGhpcy5wcm9wcy5zZWxlY3RlZCwgY2hhbmdlZERhdGUpIHx8XG4gICAgICAgICAgICAgICAgX3RoaXMucHJvcHMuYWxsb3dTYW1lRGF5IHx8XG4gICAgICAgICAgICAgICAgc2VsZWN0c1JhbmdlIHx8XG4gICAgICAgICAgICAgICAgc2VsZWN0c011bHRpcGxlKSB7XG4gICAgICAgICAgICAgICAgaWYgKGNoYW5nZWREYXRlICE9PSBudWxsKSB7XG4gICAgICAgICAgICAgICAgICAgIC8vIFByZXNlcnZlIHByZXZpb3VzbHkgc2VsZWN0ZWQgdGltZSBpZiBvbmx5IGRhdGUgaXMgY3VycmVudGx5IGJlaW5nIGNoYW5nZWRcbiAgICAgICAgICAgICAgICAgICAgaWYgKF90aGlzLnByb3BzLnNlbGVjdGVkICYmXG4gICAgICAgICAgICAgICAgICAgICAgICAoIWtlZXBJbnB1dCB8fFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICghX3RoaXMucHJvcHMuc2hvd1RpbWVTZWxlY3QgJiZcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIV90aGlzLnByb3BzLnNob3dUaW1lU2VsZWN0T25seSAmJlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAhX3RoaXMucHJvcHMuc2hvd1RpbWVJbnB1dCkpKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBjaGFuZ2VkRGF0ZSA9IHNldFRpbWUoY2hhbmdlZERhdGUsIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBob3VyOiBnZXRIb3VycyhfdGhpcy5wcm9wcy5zZWxlY3RlZCksXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgbWludXRlOiBnZXRNaW51dGVzKF90aGlzLnByb3BzLnNlbGVjdGVkKSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBzZWNvbmQ6IGdldFNlY29uZHMoX3RoaXMucHJvcHMuc2VsZWN0ZWQpLFxuICAgICAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgLy8gSWYgbWluVGltZSBpcyBwcmVzZW50IHRoZW4gc2V0IHRoZSB0aW1lIHRvIG1pblRpbWVcbiAgICAgICAgICAgICAgICAgICAgaWYgKCFrZWVwSW5wdXQgJiZcbiAgICAgICAgICAgICAgICAgICAgICAgIChfdGhpcy5wcm9wcy5zaG93VGltZVNlbGVjdCB8fCBfdGhpcy5wcm9wcy5zaG93VGltZVNlbGVjdE9ubHkpKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAobWluVGltZSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNoYW5nZWREYXRlID0gc2V0VGltZShjaGFuZ2VkRGF0ZSwge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBob3VyOiBtaW5UaW1lLmdldEhvdXJzKCksXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIG1pbnV0ZTogbWluVGltZS5nZXRNaW51dGVzKCksXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHNlY29uZDogbWluVGltZS5nZXRTZWNvbmRzKCksXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgaWYgKCFfdGhpcy5wcm9wcy5pbmxpbmUpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIF90aGlzLnNldFN0YXRlKHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBwcmVTZWxlY3Rpb246IGNoYW5nZWREYXRlLFxuICAgICAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgaWYgKCFfdGhpcy5wcm9wcy5mb2N1c1NlbGVjdGVkTW9udGgpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIF90aGlzLnNldFN0YXRlKHsgbW9udGhTZWxlY3RlZEluOiBtb250aFNlbGVjdGVkSW4gfSk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgaWYgKHNlbGVjdHNSYW5nZSkge1xuICAgICAgICAgICAgICAgICAgICB2YXIgbm9SYW5nZXMgPSAhc3RhcnREYXRlICYmICFlbmREYXRlO1xuICAgICAgICAgICAgICAgICAgICB2YXIgaGFzU3RhcnRSYW5nZSA9IHN0YXJ0RGF0ZSAmJiAhZW5kRGF0ZTtcbiAgICAgICAgICAgICAgICAgICAgdmFyIGhhc09ubHlFbmRSYW5nZSA9ICFzdGFydERhdGUgJiYgISFlbmREYXRlO1xuICAgICAgICAgICAgICAgICAgICB2YXIgaXNSYW5nZUZpbGxlZCA9IHN0YXJ0RGF0ZSAmJiBlbmREYXRlO1xuICAgICAgICAgICAgICAgICAgICBpZiAobm9SYW5nZXMpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIG9uQ2hhbmdlID09PSBudWxsIHx8IG9uQ2hhbmdlID09PSB2b2lkIDAgPyB2b2lkIDAgOiBvbkNoYW5nZShbY2hhbmdlZERhdGUsIG51bGxdLCBldmVudCk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgZWxzZSBpZiAoaGFzU3RhcnRSYW5nZSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGNoYW5nZWREYXRlID09PSBudWxsKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgb25DaGFuZ2UgPT09IG51bGwgfHwgb25DaGFuZ2UgPT09IHZvaWQgMCA/IHZvaWQgMCA6IG9uQ2hhbmdlKFtudWxsLCBudWxsXSwgZXZlbnQpO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgZWxzZSBpZiAoaXNEYXRlQmVmb3JlKGNoYW5nZWREYXRlLCBzdGFydERhdGUpKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKHN3YXBSYW5nZSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBvbkNoYW5nZSA9PT0gbnVsbCB8fCBvbkNoYW5nZSA9PT0gdm9pZCAwID8gdm9pZCAwIDogb25DaGFuZ2UoW2NoYW5nZWREYXRlLCBzdGFydERhdGVdLCBldmVudCk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBvbkNoYW5nZSA9PT0gbnVsbCB8fCBvbkNoYW5nZSA9PT0gdm9pZCAwID8gdm9pZCAwIDogb25DaGFuZ2UoW2NoYW5nZWREYXRlLCBudWxsXSwgZXZlbnQpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIG9uQ2hhbmdlID09PSBudWxsIHx8IG9uQ2hhbmdlID09PSB2b2lkIDAgPyB2b2lkIDAgOiBvbkNoYW5nZShbc3RhcnREYXRlLCBjaGFuZ2VkRGF0ZV0sIGV2ZW50KTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBlbHNlIGlmIChoYXNPbmx5RW5kUmFuZ2UpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChjaGFuZ2VkRGF0ZSAmJiBpc0RhdGVCZWZvcmUoY2hhbmdlZERhdGUsIGVuZERhdGUpKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgb25DaGFuZ2UgPT09IG51bGwgfHwgb25DaGFuZ2UgPT09IHZvaWQgMCA/IHZvaWQgMCA6IG9uQ2hhbmdlKFtjaGFuZ2VkRGF0ZSwgZW5kRGF0ZV0sIGV2ZW50KTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIG9uQ2hhbmdlID09PSBudWxsIHx8IG9uQ2hhbmdlID09PSB2b2lkIDAgPyB2b2lkIDAgOiBvbkNoYW5nZShbY2hhbmdlZERhdGUsIG51bGxdLCBldmVudCk7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgaWYgKGlzUmFuZ2VGaWxsZWQpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIG9uQ2hhbmdlID09PSBudWxsIHx8IG9uQ2hhbmdlID09PSB2b2lkIDAgPyB2b2lkIDAgOiBvbkNoYW5nZShbY2hhbmdlZERhdGUsIG51bGxdLCBldmVudCk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZSBpZiAoc2VsZWN0c011bHRpcGxlKSB7XG4gICAgICAgICAgICAgICAgICAgIGlmIChjaGFuZ2VkRGF0ZSAhPT0gbnVsbCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKCEoc2VsZWN0ZWREYXRlcyA9PT0gbnVsbCB8fCBzZWxlY3RlZERhdGVzID09PSB2b2lkIDAgPyB2b2lkIDAgOiBzZWxlY3RlZERhdGVzLmxlbmd0aCkpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBvbkNoYW5nZSA9PT0gbnVsbCB8fCBvbkNoYW5nZSA9PT0gdm9pZCAwID8gdm9pZCAwIDogb25DaGFuZ2UoW2NoYW5nZWREYXRlXSwgZXZlbnQpO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdmFyIGlzQ2hhbmdlZERhdGVBbHJlYWR5U2VsZWN0ZWQgPSBzZWxlY3RlZERhdGVzLnNvbWUoZnVuY3Rpb24gKHNlbGVjdGVkRGF0ZSkgeyByZXR1cm4gaXNTYW1lRGF5KHNlbGVjdGVkRGF0ZSwgY2hhbmdlZERhdGUpOyB9KTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoaXNDaGFuZ2VkRGF0ZUFscmVhZHlTZWxlY3RlZCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB2YXIgbmV4dERhdGVzID0gc2VsZWN0ZWREYXRlcy5maWx0ZXIoZnVuY3Rpb24gKHNlbGVjdGVkRGF0ZSkgeyByZXR1cm4gIWlzU2FtZURheShzZWxlY3RlZERhdGUsIGNoYW5nZWREYXRlKTsgfSk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIG9uQ2hhbmdlID09PSBudWxsIHx8IG9uQ2hhbmdlID09PSB2b2lkIDAgPyB2b2lkIDAgOiBvbkNoYW5nZShuZXh0RGF0ZXMsIGV2ZW50KTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIG9uQ2hhbmdlID09PSBudWxsIHx8IG9uQ2hhbmdlID09PSB2b2lkIDAgPyB2b2lkIDAgOiBvbkNoYW5nZShfX3NwcmVhZEFycmF5KF9fc3ByZWFkQXJyYXkoW10sIHNlbGVjdGVkRGF0ZXMsIHRydWUpLCBbY2hhbmdlZERhdGVdLCBmYWxzZSksIGV2ZW50KTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIG9uQ2hhbmdlID09PSBudWxsIHx8IG9uQ2hhbmdlID09PSB2b2lkIDAgPyB2b2lkIDAgOiBvbkNoYW5nZShjaGFuZ2VkRGF0ZSwgZXZlbnQpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmICgha2VlcElucHV0KSB7XG4gICAgICAgICAgICAgICAgKF9iID0gKF9hID0gX3RoaXMucHJvcHMpLm9uU2VsZWN0KSA9PT0gbnVsbCB8fCBfYiA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2IuY2FsbChfYSwgY2hhbmdlZERhdGUsIGV2ZW50KTtcbiAgICAgICAgICAgICAgICBfdGhpcy5zZXRTdGF0ZSh7IGlucHV0VmFsdWU6IG51bGwgfSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH07XG4gICAgICAgIC8vIFdoZW4gY2hlY2tpbmcgcHJlU2VsZWN0aW9uIHZpYSBtaW4vbWF4RGF0ZSwgdGltZXMgbmVlZCB0byBiZSBtYW5pcHVsYXRlZCB2aWEgZ2V0U3RhcnRPZkRheS9nZXRFbmRPZkRheVxuICAgICAgICBfdGhpcy5zZXRQcmVTZWxlY3Rpb24gPSBmdW5jdGlvbiAoZGF0ZSkge1xuICAgICAgICAgICAgaWYgKF90aGlzLnByb3BzLnJlYWRPbmx5KVxuICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgIHZhciBoYXNNaW5EYXRlID0gaXNEYXRlKF90aGlzLnByb3BzLm1pbkRhdGUpO1xuICAgICAgICAgICAgdmFyIGhhc01heERhdGUgPSBpc0RhdGUoX3RoaXMucHJvcHMubWF4RGF0ZSk7XG4gICAgICAgICAgICB2YXIgaXNWYWxpZERhdGVTZWxlY3Rpb24gPSB0cnVlO1xuICAgICAgICAgICAgaWYgKGRhdGUpIHtcbiAgICAgICAgICAgICAgICB2YXIgZGF0ZVN0YXJ0T2ZEYXkgPSBnZXRTdGFydE9mRGF5KGRhdGUpO1xuICAgICAgICAgICAgICAgIGlmIChoYXNNaW5EYXRlICYmIGhhc01heERhdGUpIHtcbiAgICAgICAgICAgICAgICAgICAgLy8gaXNEYXlJblJhbmdlIHVzZXMgZ2V0U3RhcnRPZkRheSBpbnRlcm5hbGx5LCBzbyBub3QgbmVjZXNzYXJ5IHRvIG1hbmlwdWxhdGUgdGltZXMgaGVyZVxuICAgICAgICAgICAgICAgICAgICBpc1ZhbGlkRGF0ZVNlbGVjdGlvbiA9IGlzRGF5SW5SYW5nZShkYXRlLCBfdGhpcy5wcm9wcy5taW5EYXRlLCBfdGhpcy5wcm9wcy5tYXhEYXRlKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZSBpZiAoaGFzTWluRGF0ZSkge1xuICAgICAgICAgICAgICAgICAgICB2YXIgbWluRGF0ZVN0YXJ0T2ZEYXkgPSBnZXRTdGFydE9mRGF5KF90aGlzLnByb3BzLm1pbkRhdGUpO1xuICAgICAgICAgICAgICAgICAgICBpc1ZhbGlkRGF0ZVNlbGVjdGlvbiA9XG4gICAgICAgICAgICAgICAgICAgICAgICBpc0FmdGVyKGRhdGUsIG1pbkRhdGVTdGFydE9mRGF5KSB8fFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlzRXF1YWwoZGF0ZVN0YXJ0T2ZEYXksIG1pbkRhdGVTdGFydE9mRGF5KTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZSBpZiAoaGFzTWF4RGF0ZSkge1xuICAgICAgICAgICAgICAgICAgICB2YXIgbWF4RGF0ZUVuZE9mRGF5ID0gZ2V0RW5kT2ZEYXkoX3RoaXMucHJvcHMubWF4RGF0ZSk7XG4gICAgICAgICAgICAgICAgICAgIGlzVmFsaWREYXRlU2VsZWN0aW9uID1cbiAgICAgICAgICAgICAgICAgICAgICAgIGlzQmVmb3JlKGRhdGUsIG1heERhdGVFbmRPZkRheSkgfHxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpc0VxdWFsKGRhdGVTdGFydE9mRGF5LCBtYXhEYXRlRW5kT2ZEYXkpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChpc1ZhbGlkRGF0ZVNlbGVjdGlvbikge1xuICAgICAgICAgICAgICAgIF90aGlzLnNldFN0YXRlKHtcbiAgICAgICAgICAgICAgICAgICAgcHJlU2VsZWN0aW9uOiBkYXRlLFxuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgfVxuICAgICAgICB9O1xuICAgICAgICBfdGhpcy50b2dnbGVDYWxlbmRhciA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIF90aGlzLnNldE9wZW4oIV90aGlzLnN0YXRlLm9wZW4pO1xuICAgICAgICB9O1xuICAgICAgICBfdGhpcy5oYW5kbGVUaW1lQ2hhbmdlID0gZnVuY3Rpb24gKHRpbWUpIHtcbiAgICAgICAgICAgIHZhciBfYSwgX2I7XG4gICAgICAgICAgICBpZiAoX3RoaXMucHJvcHMuc2VsZWN0c1JhbmdlIHx8IF90aGlzLnByb3BzLnNlbGVjdHNNdWx0aXBsZSkge1xuICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHZhciBzZWxlY3RlZCA9IF90aGlzLnByb3BzLnNlbGVjdGVkXG4gICAgICAgICAgICAgICAgPyBfdGhpcy5wcm9wcy5zZWxlY3RlZFxuICAgICAgICAgICAgICAgIDogX3RoaXMuZ2V0UHJlU2VsZWN0aW9uKCk7XG4gICAgICAgICAgICB2YXIgY2hhbmdlZERhdGUgPSBfdGhpcy5wcm9wcy5zZWxlY3RlZFxuICAgICAgICAgICAgICAgID8gdGltZVxuICAgICAgICAgICAgICAgIDogc2V0VGltZShzZWxlY3RlZCwge1xuICAgICAgICAgICAgICAgICAgICBob3VyOiBnZXRIb3Vycyh0aW1lKSxcbiAgICAgICAgICAgICAgICAgICAgbWludXRlOiBnZXRNaW51dGVzKHRpbWUpLFxuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgX3RoaXMuc2V0U3RhdGUoe1xuICAgICAgICAgICAgICAgIHByZVNlbGVjdGlvbjogY2hhbmdlZERhdGUsXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIChfYiA9IChfYSA9IF90aGlzLnByb3BzKS5vbkNoYW5nZSkgPT09IG51bGwgfHwgX2IgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9iLmNhbGwoX2EsIGNoYW5nZWREYXRlKTtcbiAgICAgICAgICAgIGlmIChfdGhpcy5wcm9wcy5zaG91bGRDbG9zZU9uU2VsZWN0ICYmICFfdGhpcy5wcm9wcy5zaG93VGltZUlucHV0KSB7XG4gICAgICAgICAgICAgICAgX3RoaXMuc2VuZEZvY3VzQmFja1RvSW5wdXQoKTtcbiAgICAgICAgICAgICAgICBfdGhpcy5zZXRPcGVuKGZhbHNlKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChfdGhpcy5wcm9wcy5zaG93VGltZUlucHV0KSB7XG4gICAgICAgICAgICAgICAgX3RoaXMuc2V0T3Blbih0cnVlKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChfdGhpcy5wcm9wcy5zaG93VGltZVNlbGVjdE9ubHkgfHwgX3RoaXMucHJvcHMuc2hvd1RpbWVTZWxlY3QpIHtcbiAgICAgICAgICAgICAgICBfdGhpcy5zZXRTdGF0ZSh7IGlzUmVuZGVyQXJpYUxpdmVNZXNzYWdlOiB0cnVlIH0pO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgX3RoaXMuc2V0U3RhdGUoeyBpbnB1dFZhbHVlOiBudWxsIH0pO1xuICAgICAgICB9O1xuICAgICAgICBfdGhpcy5vbklucHV0Q2xpY2sgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICB2YXIgX2EsIF9iO1xuICAgICAgICAgICAgaWYgKCFfdGhpcy5wcm9wcy5kaXNhYmxlZCAmJiAhX3RoaXMucHJvcHMucmVhZE9ubHkpIHtcbiAgICAgICAgICAgICAgICBfdGhpcy5zZXRPcGVuKHRydWUpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgKF9iID0gKF9hID0gX3RoaXMucHJvcHMpLm9uSW5wdXRDbGljaykgPT09IG51bGwgfHwgX2IgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9iLmNhbGwoX2EpO1xuICAgICAgICB9O1xuICAgICAgICBfdGhpcy5oYW5kbGVUaW1lT25seUFycm93S2V5ID0gZnVuY3Rpb24gKGV2ZW50S2V5KSB7XG4gICAgICAgICAgICB2YXIgX2EsIF9iLCBfYywgX2Q7XG4gICAgICAgICAgICB2YXIgY3VycmVudFRpbWUgPSBfdGhpcy5wcm9wcy5zZWxlY3RlZCB8fCBfdGhpcy5zdGF0ZS5wcmVTZWxlY3Rpb24gfHwgbmV3RGF0ZSgpO1xuICAgICAgICAgICAgdmFyIHRpbWVJbnRlcnZhbHMgPSAoX2EgPSBfdGhpcy5wcm9wcy50aW1lSW50ZXJ2YWxzKSAhPT0gbnVsbCAmJiBfYSAhPT0gdm9pZCAwID8gX2EgOiAzMDtcbiAgICAgICAgICAgIHZhciBkYXRlRm9ybWF0ID0gKF9iID0gX3RoaXMucHJvcHMuZGF0ZUZvcm1hdCkgIT09IG51bGwgJiYgX2IgIT09IHZvaWQgMCA/IF9iIDogRGF0ZVBpY2tlci5kZWZhdWx0UHJvcHMuZGF0ZUZvcm1hdDtcbiAgICAgICAgICAgIHZhciBmb3JtYXRTdHIgPSBBcnJheS5pc0FycmF5KGRhdGVGb3JtYXQpID8gZGF0ZUZvcm1hdFswXSA6IGRhdGVGb3JtYXQ7XG4gICAgICAgICAgICB2YXIgYmFzZURhdGUgPSBnZXRTdGFydE9mRGF5KGN1cnJlbnRUaW1lKTtcbiAgICAgICAgICAgIHZhciBjdXJyZW50TWludXRlcyA9IGdldEhvdXJzKGN1cnJlbnRUaW1lKSAqIDYwICsgZ2V0TWludXRlcyhjdXJyZW50VGltZSk7XG4gICAgICAgICAgICB2YXIgbWF4TWludXRlcyA9IDIzICogNjAgKyA2MCAtIHRpbWVJbnRlcnZhbHM7IC8vIENhcCBhdCBsYXN0IHZhbGlkIGludGVydmFsIG9mIHRoZSBkYXlcbiAgICAgICAgICAgIHZhciBuZXdUaW1lO1xuICAgICAgICAgICAgaWYgKGV2ZW50S2V5ID09PSBLZXlUeXBlLkFycm93VXApIHtcbiAgICAgICAgICAgICAgICB2YXIgbmV3TWludXRlcyA9IE1hdGgubWF4KDAsIGN1cnJlbnRNaW51dGVzIC0gdGltZUludGVydmFscyk7XG4gICAgICAgICAgICAgICAgbmV3VGltZSA9IGFkZE1pbnV0ZXMoYmFzZURhdGUsIG5ld01pbnV0ZXMpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgdmFyIG5ld01pbnV0ZXMgPSBNYXRoLm1pbihtYXhNaW51dGVzLCBjdXJyZW50TWludXRlcyArIHRpbWVJbnRlcnZhbHMpO1xuICAgICAgICAgICAgICAgIG5ld1RpbWUgPSBhZGRNaW51dGVzKGJhc2VEYXRlLCBuZXdNaW51dGVzKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHZhciBmb3JtYXR0ZWRUaW1lID0gZm9ybWF0RGF0ZShuZXdUaW1lLCBmb3JtYXRTdHIgfHwgRGF0ZVBpY2tlci5kZWZhdWx0UHJvcHMuZGF0ZUZvcm1hdCwgX3RoaXMucHJvcHMubG9jYWxlKTtcbiAgICAgICAgICAgIF90aGlzLnNldFN0YXRlKHtcbiAgICAgICAgICAgICAgICBwcmVTZWxlY3Rpb246IG5ld1RpbWUsXG4gICAgICAgICAgICAgICAgaW5wdXRWYWx1ZTogZm9ybWF0dGVkVGltZSxcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgaWYgKF90aGlzLnByb3BzLnNlbGVjdHNSYW5nZSB8fCBfdGhpcy5wcm9wcy5zZWxlY3RzTXVsdGlwbGUpIHtcbiAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB2YXIgc2VsZWN0ZWQgPSBfdGhpcy5wcm9wcy5zZWxlY3RlZFxuICAgICAgICAgICAgICAgID8gX3RoaXMucHJvcHMuc2VsZWN0ZWRcbiAgICAgICAgICAgICAgICA6IF90aGlzLmdldFByZVNlbGVjdGlvbigpO1xuICAgICAgICAgICAgdmFyIGNoYW5nZWREYXRlID0gX3RoaXMucHJvcHMuc2VsZWN0ZWRcbiAgICAgICAgICAgICAgICA/IG5ld1RpbWVcbiAgICAgICAgICAgICAgICA6IHNldFRpbWUoc2VsZWN0ZWQsIHtcbiAgICAgICAgICAgICAgICAgICAgaG91cjogZ2V0SG91cnMobmV3VGltZSksXG4gICAgICAgICAgICAgICAgICAgIG1pbnV0ZTogZ2V0TWludXRlcyhuZXdUaW1lKSxcbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIChfZCA9IChfYyA9IF90aGlzLnByb3BzKS5vbkNoYW5nZSkgPT09IG51bGwgfHwgX2QgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9kLmNhbGwoX2MsIGNoYW5nZWREYXRlKTtcbiAgICAgICAgICAgIGlmIChfdGhpcy5wcm9wcy5zaG93VGltZVNlbGVjdE9ubHkgfHwgX3RoaXMucHJvcHMuc2hvd1RpbWVTZWxlY3QpIHtcbiAgICAgICAgICAgICAgICBfdGhpcy5zZXRTdGF0ZSh7IGlzUmVuZGVyQXJpYUxpdmVNZXNzYWdlOiB0cnVlIH0pO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmVxdWVzdEFuaW1hdGlvbkZyYW1lKGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgICAgICBfdGhpcy5zY3JvbGxUb1RpbWVPcHRpb24obmV3VGltZSk7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfTtcbiAgICAgICAgX3RoaXMuaGFuZGxlVGltZU9ubHlFbnRlcktleSA9IGZ1bmN0aW9uIChldmVudCkge1xuICAgICAgICAgICAgdmFyIF9hLCBfYiwgX2MsIF9kO1xuICAgICAgICAgICAgdmFyIGlucHV0RWxlbWVudCA9IGV2ZW50LnRhcmdldDtcbiAgICAgICAgICAgIHZhciBpbnB1dFZhbHVlID0gaW5wdXRFbGVtZW50LnZhbHVlO1xuICAgICAgICAgICAgdmFyIGRhdGVGb3JtYXQgPSAoX2EgPSBfdGhpcy5wcm9wcy5kYXRlRm9ybWF0KSAhPT0gbnVsbCAmJiBfYSAhPT0gdm9pZCAwID8gX2EgOiBEYXRlUGlja2VyLmRlZmF1bHRQcm9wcy5kYXRlRm9ybWF0O1xuICAgICAgICAgICAgdmFyIHRpbWVGb3JtYXQgPSBfdGhpcy5wcm9wcy50aW1lRm9ybWF0IHx8IFwicFwiO1xuICAgICAgICAgICAgdmFyIGRlZmF1bHRUaW1lID0gX3RoaXMuc3RhdGUucHJlU2VsZWN0aW9uIHx8IF90aGlzLnByb3BzLnNlbGVjdGVkIHx8IG5ld0RhdGUoKTtcbiAgICAgICAgICAgIHZhciBwYXJzZWREYXRlID0gcGFyc2VEYXRlKGlucHV0VmFsdWUsIGRhdGVGb3JtYXQsIF90aGlzLnByb3BzLmxvY2FsZSwgKF9iID0gX3RoaXMucHJvcHMuc3RyaWN0UGFyc2luZykgIT09IG51bGwgJiYgX2IgIT09IHZvaWQgMCA/IF9iIDogZmFsc2UsIGRlZmF1bHRUaW1lKTtcbiAgICAgICAgICAgIHZhciB0aW1lVG9Db21taXQgPSBkZWZhdWx0VGltZTtcbiAgICAgICAgICAgIGlmIChwYXJzZWREYXRlICYmIGlzVmFsaWQocGFyc2VkRGF0ZSkpIHtcbiAgICAgICAgICAgICAgICB0aW1lVG9Db21taXQgPSBwYXJzZWREYXRlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgdmFyIGhpZ2hsaWdodGVkSXRlbSA9ICgoX2MgPSBfdGhpcy5jYWxlbmRhcikgPT09IG51bGwgfHwgX2MgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9jLmNvbnRhaW5lclJlZi5jdXJyZW50KSBpbnN0YW5jZW9mIEVsZW1lbnQgJiZcbiAgICAgICAgICAgICAgICAgICAgX3RoaXMuY2FsZW5kYXIuY29udGFpbmVyUmVmLmN1cnJlbnQucXVlcnlTZWxlY3RvcihcIi5yZWFjdC1kYXRlcGlja2VyX190aW1lLWxpc3QtaXRlbVt0YWJpbmRleD0nMCddXCIpO1xuICAgICAgICAgICAgICAgIGlmIChoaWdobGlnaHRlZEl0ZW0gaW5zdGFuY2VvZiBIVE1MRWxlbWVudCkge1xuICAgICAgICAgICAgICAgICAgICB2YXIgaXRlbVRleHQgPSAoX2QgPSBoaWdobGlnaHRlZEl0ZW0udGV4dENvbnRlbnQpID09PSBudWxsIHx8IF9kID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfZC50cmltKCk7XG4gICAgICAgICAgICAgICAgICAgIGlmIChpdGVtVGV4dCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgdmFyIGl0ZW1UaW1lID0gcGFyc2VEYXRlKGl0ZW1UZXh0LCB0aW1lRm9ybWF0LCBfdGhpcy5wcm9wcy5sb2NhbGUsIGZhbHNlLCBkZWZhdWx0VGltZSk7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoaXRlbVRpbWUgJiYgaXNWYWxpZChpdGVtVGltZSkpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB0aW1lVG9Db21taXQgPSBpdGVtVGltZTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIF90aGlzLmhhbmRsZVRpbWVDaGFuZ2UodGltZVRvQ29tbWl0KTtcbiAgICAgICAgICAgIF90aGlzLnNldE9wZW4oZmFsc2UpO1xuICAgICAgICAgICAgX3RoaXMuc2VuZEZvY3VzQmFja1RvSW5wdXQoKTtcbiAgICAgICAgfTtcbiAgICAgICAgX3RoaXMuc2Nyb2xsVG9UaW1lT3B0aW9uID0gZnVuY3Rpb24gKHRpbWUpIHtcbiAgICAgICAgICAgIHZhciBfYSwgX2I7XG4gICAgICAgICAgICBpZiAoISgoX2EgPSBfdGhpcy5jYWxlbmRhcikgPT09IG51bGwgfHwgX2EgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9hLmNvbnRhaW5lclJlZi5jdXJyZW50KSkge1xuICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHZhciBjb250YWluZXIgPSBfdGhpcy5jYWxlbmRhci5jb250YWluZXJSZWYuY3VycmVudDtcbiAgICAgICAgICAgIHZhciB0aW1lTGlzdEl0ZW1zID0gQXJyYXkuZnJvbShjb250YWluZXIucXVlcnlTZWxlY3RvckFsbChcIi5yZWFjdC1kYXRlcGlja2VyX190aW1lLWxpc3QtaXRlbVwiKSk7XG4gICAgICAgICAgICB2YXIgdGFyZ2V0SXRlbSA9IG51bGw7XG4gICAgICAgICAgICB2YXIgY2xvc2VzdFRpbWVEaWZmID0gSW5maW5pdHk7XG4gICAgICAgICAgICB2YXIgdGltZUZvcm1hdCA9IF90aGlzLnByb3BzLnRpbWVGb3JtYXQgfHwgXCJwXCI7XG4gICAgICAgICAgICBmb3IgKHZhciBfaSA9IDAsIHRpbWVMaXN0SXRlbXNfMSA9IHRpbWVMaXN0SXRlbXM7IF9pIDwgdGltZUxpc3RJdGVtc18xLmxlbmd0aDsgX2krKykge1xuICAgICAgICAgICAgICAgIHZhciBpdGVtID0gdGltZUxpc3RJdGVtc18xW19pXTtcbiAgICAgICAgICAgICAgICB2YXIgaXRlbVRleHQgPSAoX2IgPSBpdGVtLnRleHRDb250ZW50KSA9PT0gbnVsbCB8fCBfYiA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2IudHJpbSgpO1xuICAgICAgICAgICAgICAgIGlmIChpdGVtVGV4dCkge1xuICAgICAgICAgICAgICAgICAgICB2YXIgaXRlbVRpbWUgPSBwYXJzZURhdGUoaXRlbVRleHQsIHRpbWVGb3JtYXQsIF90aGlzLnByb3BzLmxvY2FsZSwgZmFsc2UsIHRpbWUpO1xuICAgICAgICAgICAgICAgICAgICBpZiAoaXRlbVRpbWUgJiYgaXNWYWxpZChpdGVtVGltZSkpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChpc1NhbWVNaW51dGUoaXRlbVRpbWUsIHRpbWUpKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdGFyZ2V0SXRlbSA9IGl0ZW07XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICB2YXIgdGltZURpZmYgPSBNYXRoLmFicyhpdGVtVGltZS5nZXRUaW1lKCkgLSB0aW1lLmdldFRpbWUoKSk7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAodGltZURpZmYgPCBjbG9zZXN0VGltZURpZmYpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBjbG9zZXN0VGltZURpZmYgPSB0aW1lRGlmZjtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB0YXJnZXRJdGVtID0gaXRlbTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmICh0YXJnZXRJdGVtKSB7XG4gICAgICAgICAgICAgICAgdGltZUxpc3RJdGVtcy5mb3JFYWNoKGZ1bmN0aW9uIChpdGVtKSB7XG4gICAgICAgICAgICAgICAgICAgIGl0ZW0uc2V0QXR0cmlidXRlKFwidGFiaW5kZXhcIiwgXCItMVwiKTtcbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICB0YXJnZXRJdGVtLnNldEF0dHJpYnV0ZShcInRhYmluZGV4XCIsIFwiMFwiKTtcbiAgICAgICAgICAgICAgICB0YXJnZXRJdGVtLnNjcm9sbEludG9WaWV3KHtcbiAgICAgICAgICAgICAgICAgICAgYmVoYXZpb3I6IFwic21vb3RoXCIsXG4gICAgICAgICAgICAgICAgICAgIGJsb2NrOiBcImNlbnRlclwiLFxuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgfVxuICAgICAgICB9O1xuICAgICAgICBfdGhpcy5vbklucHV0S2V5RG93biA9IGZ1bmN0aW9uIChldmVudCkge1xuICAgICAgICAgICAgdmFyIF9hLCBfYiwgX2MsIF9kLCBfZSwgX2Y7XG4gICAgICAgICAgICAoX2IgPSAoX2EgPSBfdGhpcy5wcm9wcykub25LZXlEb3duKSA9PT0gbnVsbCB8fCBfYiA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2IuY2FsbChfYSwgZXZlbnQpO1xuICAgICAgICAgICAgdmFyIGV2ZW50S2V5ID0gZXZlbnQua2V5O1xuICAgICAgICAgICAgaWYgKCFfdGhpcy5zdGF0ZS5vcGVuICYmXG4gICAgICAgICAgICAgICAgIV90aGlzLnByb3BzLmlubGluZSAmJlxuICAgICAgICAgICAgICAgICFfdGhpcy5wcm9wcy5wcmV2ZW50T3Blbk9uRm9jdXMpIHtcbiAgICAgICAgICAgICAgICBpZiAoZXZlbnRLZXkgPT09IEtleVR5cGUuQXJyb3dEb3duIHx8XG4gICAgICAgICAgICAgICAgICAgIGV2ZW50S2V5ID09PSBLZXlUeXBlLkFycm93VXAgfHxcbiAgICAgICAgICAgICAgICAgICAgZXZlbnRLZXkgPT09IEtleVR5cGUuRW50ZXIpIHtcbiAgICAgICAgICAgICAgICAgICAgKF9jID0gX3RoaXMub25JbnB1dENsaWNrKSA9PT0gbnVsbCB8fCBfYyA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2MuY2FsbChfdGhpcyk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChfdGhpcy5zdGF0ZS5vcGVuICYmIF90aGlzLnByb3BzLnNob3dUaW1lU2VsZWN0T25seSkge1xuICAgICAgICAgICAgICAgIGlmIChldmVudEtleSA9PT0gS2V5VHlwZS5BcnJvd0Rvd24gfHwgZXZlbnRLZXkgPT09IEtleVR5cGUuQXJyb3dVcCkge1xuICAgICAgICAgICAgICAgICAgICBldmVudC5wcmV2ZW50RGVmYXVsdCgpO1xuICAgICAgICAgICAgICAgICAgICBfdGhpcy5oYW5kbGVUaW1lT25seUFycm93S2V5KGV2ZW50S2V5KTtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBpZiAoZXZlbnRLZXkgPT09IEtleVR5cGUuRW50ZXIpIHtcbiAgICAgICAgICAgICAgICAgICAgZXZlbnQucHJldmVudERlZmF1bHQoKTtcbiAgICAgICAgICAgICAgICAgICAgX3RoaXMuaGFuZGxlVGltZU9ubHlFbnRlcktleShldmVudCk7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICAvLyBpZiBjYWxlbmRhciBpcyBvcGVuLCB0aGVzZSBrZXlzIHdpbGwgZm9jdXMgdGhlIHNlbGVjdGVkIGl0ZW1cbiAgICAgICAgICAgIGlmIChfdGhpcy5zdGF0ZS5vcGVuKSB7XG4gICAgICAgICAgICAgICAgaWYgKGV2ZW50S2V5ID09PSBLZXlUeXBlLkFycm93RG93biB8fCBldmVudEtleSA9PT0gS2V5VHlwZS5BcnJvd1VwKSB7XG4gICAgICAgICAgICAgICAgICAgIGV2ZW50LnByZXZlbnREZWZhdWx0KCk7XG4gICAgICAgICAgICAgICAgICAgIHZhciBzZWxlY3RvclN0cmluZyA9IF90aGlzLnByb3BzLnNob3dUaW1lU2VsZWN0T25seVxuICAgICAgICAgICAgICAgICAgICAgICAgPyBcIi5yZWFjdC1kYXRlcGlja2VyX190aW1lLWxpc3QtaXRlbVt0YWJpbmRleD0nMCddXCJcbiAgICAgICAgICAgICAgICAgICAgICAgIDogX3RoaXMucHJvcHMuc2hvd1dlZWtQaWNrZXIgJiYgX3RoaXMucHJvcHMuc2hvd1dlZWtOdW1iZXJzXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgPyAnLnJlYWN0LWRhdGVwaWNrZXJfX3dlZWstbnVtYmVyW3RhYmluZGV4PVwiMFwiXSdcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICA6IF90aGlzLnByb3BzLnNob3dGdWxsTW9udGhZZWFyUGlja2VyIHx8XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIF90aGlzLnByb3BzLnNob3dNb250aFllYXJQaWNrZXJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgPyAnLnJlYWN0LWRhdGVwaWNrZXJfX21vbnRoLXRleHRbdGFiaW5kZXg9XCIwXCJdJ1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICA6ICcucmVhY3QtZGF0ZXBpY2tlcl9fZGF5W3RhYmluZGV4PVwiMFwiXSc7XG4gICAgICAgICAgICAgICAgICAgIHZhciBzZWxlY3RlZEl0ZW0gPSAoKF9kID0gX3RoaXMuY2FsZW5kYXIpID09PSBudWxsIHx8IF9kID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfZC5jb250YWluZXJSZWYuY3VycmVudCkgaW5zdGFuY2VvZiBFbGVtZW50ICYmXG4gICAgICAgICAgICAgICAgICAgICAgICBfdGhpcy5jYWxlbmRhci5jb250YWluZXJSZWYuY3VycmVudC5xdWVyeVNlbGVjdG9yKHNlbGVjdG9yU3RyaW5nKTtcbiAgICAgICAgICAgICAgICAgICAgc2VsZWN0ZWRJdGVtIGluc3RhbmNlb2YgSFRNTEVsZW1lbnQgJiZcbiAgICAgICAgICAgICAgICAgICAgICAgIHNlbGVjdGVkSXRlbS5mb2N1cyh7IHByZXZlbnRTY3JvbGw6IHRydWUgfSk7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgdmFyIGNvcHkgPSBuZXdEYXRlKF90aGlzLnN0YXRlLnByZVNlbGVjdGlvbik7XG4gICAgICAgICAgICAgICAgaWYgKGV2ZW50S2V5ID09PSBLZXlUeXBlLkVudGVyKSB7XG4gICAgICAgICAgICAgICAgICAgIGV2ZW50LnByZXZlbnREZWZhdWx0KCk7XG4gICAgICAgICAgICAgICAgICAgIGV2ZW50LnRhcmdldC5ibHVyKCk7XG4gICAgICAgICAgICAgICAgICAgIGlmIChfdGhpcy5pbnB1dE9rKCkgJiZcbiAgICAgICAgICAgICAgICAgICAgICAgIF90aGlzLnN0YXRlLmxhc3RQcmVTZWxlY3RDaGFuZ2UgPT09IFBSRVNFTEVDVF9DSEFOR0VfVklBX05BVklHQVRFKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBfdGhpcy5oYW5kbGVTZWxlY3QoY29weSwgZXZlbnQpO1xuICAgICAgICAgICAgICAgICAgICAgICAgIV90aGlzLnByb3BzLnNob3VsZENsb3NlT25TZWxlY3QgJiYgX3RoaXMuc2V0UHJlU2VsZWN0aW9uKGNvcHkpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgX3RoaXMuc2V0T3BlbihmYWxzZSk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZSBpZiAoZXZlbnRLZXkgPT09IEtleVR5cGUuRXNjYXBlKSB7XG4gICAgICAgICAgICAgICAgICAgIGV2ZW50LnByZXZlbnREZWZhdWx0KCk7XG4gICAgICAgICAgICAgICAgICAgIGV2ZW50LnRhcmdldC5ibHVyKCk7XG4gICAgICAgICAgICAgICAgICAgIF90aGlzLnNlbmRGb2N1c0JhY2tUb0lucHV0KCk7XG4gICAgICAgICAgICAgICAgICAgIF90aGlzLnNldE9wZW4oZmFsc2UpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIGlmIChldmVudEtleSA9PT0gS2V5VHlwZS5UYWIpIHtcbiAgICAgICAgICAgICAgICAgICAgX3RoaXMuc2V0T3BlbihmYWxzZSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGlmICghX3RoaXMuaW5wdXRPaygpKSB7XG4gICAgICAgICAgICAgICAgICAgIChfZiA9IChfZSA9IF90aGlzLnByb3BzKS5vbklucHV0RXJyb3IpID09PSBudWxsIHx8IF9mID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfZi5jYWxsKF9lLCB7IGNvZGU6IDEsIG1zZzogSU5QVVRfRVJSXzEgfSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9O1xuICAgICAgICBfdGhpcy5vblBvcnRhbEtleURvd24gPSBmdW5jdGlvbiAoZXZlbnQpIHtcbiAgICAgICAgICAgIHZhciBldmVudEtleSA9IGV2ZW50LmtleTtcbiAgICAgICAgICAgIGlmIChldmVudEtleSA9PT0gS2V5VHlwZS5Fc2NhcGUpIHtcbiAgICAgICAgICAgICAgICBldmVudC5wcmV2ZW50RGVmYXVsdCgpO1xuICAgICAgICAgICAgICAgIF90aGlzLnNldFN0YXRlKHtcbiAgICAgICAgICAgICAgICAgICAgcHJldmVudEZvY3VzOiB0cnVlLFxuICAgICAgICAgICAgICAgIH0sIGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgICAgICAgICAgX3RoaXMuc2V0T3BlbihmYWxzZSk7XG4gICAgICAgICAgICAgICAgICAgIHNldFRpbWVvdXQoZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgX3RoaXMuc2V0Rm9jdXMoKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIF90aGlzLnNldFN0YXRlKHsgcHJldmVudEZvY3VzOiBmYWxzZSB9KTtcbiAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH07XG4gICAgICAgIC8vIGtleURvd24gZXZlbnRzIHBhc3NlZCBkb3duIHRvIGRheS5qc3hcbiAgICAgICAgX3RoaXMub25EYXlLZXlEb3duID0gZnVuY3Rpb24gKGV2ZW50KSB7XG4gICAgICAgICAgICB2YXIgX2EsIF9iLCBfYywgX2QsIF9lLCBfZjtcbiAgICAgICAgICAgIHZhciBfZyA9IF90aGlzLnByb3BzLCBtaW5EYXRlID0gX2cubWluRGF0ZSwgbWF4RGF0ZSA9IF9nLm1heERhdGUsIGRpc2FibGVkS2V5Ym9hcmROYXZpZ2F0aW9uID0gX2cuZGlzYWJsZWRLZXlib2FyZE5hdmlnYXRpb24sIHNob3dXZWVrUGlja2VyID0gX2cuc2hvd1dlZWtQaWNrZXIsIHNob3VsZENsb3NlT25TZWxlY3QgPSBfZy5zaG91bGRDbG9zZU9uU2VsZWN0LCBsb2NhbGUgPSBfZy5sb2NhbGUsIGNhbGVuZGFyU3RhcnREYXkgPSBfZy5jYWxlbmRhclN0YXJ0RGF5LCBhZGp1c3REYXRlT25DaGFuZ2UgPSBfZy5hZGp1c3REYXRlT25DaGFuZ2UsIGlubGluZSA9IF9nLmlubGluZTtcbiAgICAgICAgICAgIChfYiA9IChfYSA9IF90aGlzLnByb3BzKS5vbktleURvd24pID09PSBudWxsIHx8IF9iID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYi5jYWxsKF9hLCBldmVudCk7XG4gICAgICAgICAgICBpZiAoZGlzYWJsZWRLZXlib2FyZE5hdmlnYXRpb24pXG4gICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgdmFyIGV2ZW50S2V5ID0gZXZlbnQua2V5O1xuICAgICAgICAgICAgdmFyIGlzU2hpZnRLZXlBY3RpdmUgPSBldmVudC5zaGlmdEtleTtcbiAgICAgICAgICAgIHZhciBjb3B5ID0gbmV3RGF0ZShfdGhpcy5zdGF0ZS5wcmVTZWxlY3Rpb24pO1xuICAgICAgICAgICAgdmFyIGNhbGN1bGF0ZU5ld0RhdGUgPSBmdW5jdGlvbiAoZXZlbnRLZXksIGRhdGUpIHtcbiAgICAgICAgICAgICAgICB2YXIgbmV3Q2FsY3VsYXRlZERhdGUgPSBkYXRlO1xuICAgICAgICAgICAgICAgIHN3aXRjaCAoZXZlbnRLZXkpIHtcbiAgICAgICAgICAgICAgICAgICAgY2FzZSBLZXlUeXBlLkFycm93UmlnaHQ6XG4gICAgICAgICAgICAgICAgICAgICAgICBuZXdDYWxjdWxhdGVkRGF0ZSA9IHNob3dXZWVrUGlja2VyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgPyBhZGRXZWVrcyhkYXRlLCAxKVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIDogYWRkRGF5cyhkYXRlLCAxKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgICAgICBjYXNlIEtleVR5cGUuQXJyb3dMZWZ0OlxuICAgICAgICAgICAgICAgICAgICAgICAgbmV3Q2FsY3VsYXRlZERhdGUgPSBzaG93V2Vla1BpY2tlclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgID8gc3ViV2Vla3MoZGF0ZSwgMSlcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICA6IHN1YkRheXMoZGF0ZSwgMSk7XG4gICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICAgICAgY2FzZSBLZXlUeXBlLkFycm93VXA6XG4gICAgICAgICAgICAgICAgICAgICAgICBuZXdDYWxjdWxhdGVkRGF0ZSA9IHN1YldlZWtzKGRhdGUsIDEpO1xuICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgICAgIGNhc2UgS2V5VHlwZS5BcnJvd0Rvd246XG4gICAgICAgICAgICAgICAgICAgICAgICBuZXdDYWxjdWxhdGVkRGF0ZSA9IGFkZFdlZWtzKGRhdGUsIDEpO1xuICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgICAgIGNhc2UgS2V5VHlwZS5QYWdlVXA6XG4gICAgICAgICAgICAgICAgICAgICAgICBuZXdDYWxjdWxhdGVkRGF0ZSA9IGlzU2hpZnRLZXlBY3RpdmVcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICA/IHN1YlllYXJzKGRhdGUsIDEpXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgOiBzdWJNb250aHMoZGF0ZSwgMSk7XG4gICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICAgICAgY2FzZSBLZXlUeXBlLlBhZ2VEb3duOlxuICAgICAgICAgICAgICAgICAgICAgICAgbmV3Q2FsY3VsYXRlZERhdGUgPSBpc1NoaWZ0S2V5QWN0aXZlXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgPyBhZGRZZWFycyhkYXRlLCAxKVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIDogYWRkTW9udGhzKGRhdGUsIDEpO1xuICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgICAgIGNhc2UgS2V5VHlwZS5Ib21lOlxuICAgICAgICAgICAgICAgICAgICAgICAgbmV3Q2FsY3VsYXRlZERhdGUgPSBnZXRTdGFydE9mV2VlayhkYXRlLCBsb2NhbGUsIGNhbGVuZGFyU3RhcnREYXkpO1xuICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgICAgIGNhc2UgS2V5VHlwZS5FbmQ6XG4gICAgICAgICAgICAgICAgICAgICAgICBuZXdDYWxjdWxhdGVkRGF0ZSA9IGdldEVuZE9mV2VlayhkYXRlKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICByZXR1cm4gbmV3Q2FsY3VsYXRlZERhdGU7XG4gICAgICAgICAgICB9O1xuICAgICAgICAgICAgdmFyIGdldE5ld0RhdGUgPSBmdW5jdGlvbiAoZXZlbnRLZXksIGRhdGUpIHtcbiAgICAgICAgICAgICAgICB2YXIgTUFYX0lURVJBVElPTlMgPSA0MDtcbiAgICAgICAgICAgICAgICB2YXIgZXZlbnRLZXlDb3B5ID0gZXZlbnRLZXk7XG4gICAgICAgICAgICAgICAgdmFyIHZhbGlkRGF0ZUZvdW5kID0gZmFsc2U7XG4gICAgICAgICAgICAgICAgdmFyIGl0ZXJhdGlvbnMgPSAwO1xuICAgICAgICAgICAgICAgIHZhciBuZXdTZWxlY3Rpb24gPSBjYWxjdWxhdGVOZXdEYXRlKGV2ZW50S2V5LCBkYXRlKTtcbiAgICAgICAgICAgICAgICB3aGlsZSAoIXZhbGlkRGF0ZUZvdW5kKSB7XG4gICAgICAgICAgICAgICAgICAgIGlmIChpdGVyYXRpb25zID49IE1BWF9JVEVSQVRJT05TKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBuZXdTZWxlY3Rpb24gPSBkYXRlO1xuICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgLy8gaWYgbWluRGF0ZSBleGlzdHMgYW5kIHRoZSBuZXcgc2VsZWN0aW9uIGlzIGJlZm9yZSB0aGUgbWluIGRhdGUsIGdldCB0aGUgbmVhcmVzdCBkYXRlIHRoYXQgaXNuJ3QgZGlzYWJsZWRcbiAgICAgICAgICAgICAgICAgICAgaWYgKG1pbkRhdGUgJiYgbmV3U2VsZWN0aW9uIDwgbWluRGF0ZSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgZXZlbnRLZXlDb3B5ID0gS2V5VHlwZS5BcnJvd1JpZ2h0O1xuICAgICAgICAgICAgICAgICAgICAgICAgbmV3U2VsZWN0aW9uID0gaXNEYXlEaXNhYmxlZChtaW5EYXRlLCBfdGhpcy5wcm9wcylcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICA/IGNhbGN1bGF0ZU5ld0RhdGUoZXZlbnRLZXlDb3B5LCBuZXdTZWxlY3Rpb24pXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgOiBtaW5EYXRlO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIC8vIGlmIG1heERhdGUgZXhpc3RzIGFuZCB0aGUgbmV3IHNlbGVjdGlvbiBpcyBhZnRlciB0aGUgbWF4IGRhdGUsIGdldCB0aGUgbmVhcmVzdCBkYXRlIHRoYXQgaXNuJ3QgZGlzYWJsZWRcbiAgICAgICAgICAgICAgICAgICAgaWYgKG1heERhdGUgJiYgbmV3U2VsZWN0aW9uID4gbWF4RGF0ZSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgZXZlbnRLZXlDb3B5ID0gS2V5VHlwZS5BcnJvd0xlZnQ7XG4gICAgICAgICAgICAgICAgICAgICAgICBuZXdTZWxlY3Rpb24gPSBpc0RheURpc2FibGVkKG1heERhdGUsIF90aGlzLnByb3BzKVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgID8gY2FsY3VsYXRlTmV3RGF0ZShldmVudEtleUNvcHksIG5ld1NlbGVjdGlvbilcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICA6IG1heERhdGU7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgaWYgKGlzRGF5RGlzYWJsZWQobmV3U2VsZWN0aW9uLCBfdGhpcy5wcm9wcykpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIGlmIFBhZ2VVcCBhbmQgSG9tZSBpcyBwcmVzc2VkIHRvIGEgZGlzYWJsZWQgZGF0ZSwgaXQgd2lsbCB0cnkgdG8gZmluZCB0aGUgbmV4dCBhdmFpbGFibGUgZGF0ZSBhZnRlclxuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGV2ZW50S2V5Q29weSA9PT0gS2V5VHlwZS5QYWdlVXAgfHxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBldmVudEtleUNvcHkgPT09IEtleVR5cGUuSG9tZSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGV2ZW50S2V5Q29weSA9IEtleVR5cGUuQXJyb3dSaWdodDtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIGlmIFBhZ2VEb3duIGFuZCBFbmQgaXMgcHJlc3NlZCB0byBhIGRpc2FibGVkIGRhdGUsIGl0IHdpbGwgdHJ5IHRvIGZpbmQgdGhlIG5leHQgYXZhaWxhYmxlIGRhdGUgYmVmb3JlXG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoZXZlbnRLZXlDb3B5ID09PSBLZXlUeXBlLlBhZ2VEb3duIHx8XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgZXZlbnRLZXlDb3B5ID09PSBLZXlUeXBlLkVuZCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGV2ZW50S2V5Q29weSA9IEtleVR5cGUuQXJyb3dMZWZ0O1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgbmV3U2VsZWN0aW9uID0gY2FsY3VsYXRlTmV3RGF0ZShldmVudEtleUNvcHksIG5ld1NlbGVjdGlvbik7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICB2YWxpZERhdGVGb3VuZCA9IHRydWU7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgaXRlcmF0aW9ucysrO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICByZXR1cm4gbmV3U2VsZWN0aW9uO1xuICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIGlmIChldmVudEtleSA9PT0gS2V5VHlwZS5FbnRlcikge1xuICAgICAgICAgICAgICAgIGV2ZW50LnByZXZlbnREZWZhdWx0KCk7XG4gICAgICAgICAgICAgICAgX3RoaXMuaGFuZGxlU2VsZWN0KGNvcHksIGV2ZW50KTtcbiAgICAgICAgICAgICAgICAhc2hvdWxkQ2xvc2VPblNlbGVjdCAmJiBfdGhpcy5zZXRQcmVTZWxlY3Rpb24oY29weSk7XG4gICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSBpZiAoZXZlbnRLZXkgPT09IEtleVR5cGUuRXNjYXBlKSB7XG4gICAgICAgICAgICAgICAgZXZlbnQucHJldmVudERlZmF1bHQoKTtcbiAgICAgICAgICAgICAgICBfdGhpcy5zZXRPcGVuKGZhbHNlKTtcbiAgICAgICAgICAgICAgICBpZiAoIV90aGlzLmlucHV0T2soKSkge1xuICAgICAgICAgICAgICAgICAgICAoX2QgPSAoX2MgPSBfdGhpcy5wcm9wcykub25JbnB1dEVycm9yKSA9PT0gbnVsbCB8fCBfZCA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2QuY2FsbChfYywgeyBjb2RlOiAxLCBtc2c6IElOUFVUX0VSUl8xIH0pO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB2YXIgbmV3U2VsZWN0aW9uID0gbnVsbDtcbiAgICAgICAgICAgIHN3aXRjaCAoZXZlbnRLZXkpIHtcbiAgICAgICAgICAgICAgICBjYXNlIEtleVR5cGUuQXJyb3dMZWZ0OlxuICAgICAgICAgICAgICAgIGNhc2UgS2V5VHlwZS5BcnJvd1JpZ2h0OlxuICAgICAgICAgICAgICAgIGNhc2UgS2V5VHlwZS5BcnJvd1VwOlxuICAgICAgICAgICAgICAgIGNhc2UgS2V5VHlwZS5BcnJvd0Rvd246XG4gICAgICAgICAgICAgICAgY2FzZSBLZXlUeXBlLlBhZ2VVcDpcbiAgICAgICAgICAgICAgICBjYXNlIEtleVR5cGUuUGFnZURvd246XG4gICAgICAgICAgICAgICAgY2FzZSBLZXlUeXBlLkhvbWU6XG4gICAgICAgICAgICAgICAgY2FzZSBLZXlUeXBlLkVuZDpcbiAgICAgICAgICAgICAgICAgICAgbmV3U2VsZWN0aW9uID0gZ2V0TmV3RGF0ZShldmVudEtleSwgY29weSk7XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKCFuZXdTZWxlY3Rpb24pIHtcbiAgICAgICAgICAgICAgICAoX2YgPSAoX2UgPSBfdGhpcy5wcm9wcykub25JbnB1dEVycm9yKSA9PT0gbnVsbCB8fCBfZiA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2YuY2FsbChfZSwgeyBjb2RlOiAxLCBtc2c6IElOUFVUX0VSUl8xIH0pO1xuICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGV2ZW50LnByZXZlbnREZWZhdWx0KCk7XG4gICAgICAgICAgICBfdGhpcy5zZXRTdGF0ZSh7IGxhc3RQcmVTZWxlY3RDaGFuZ2U6IFBSRVNFTEVDVF9DSEFOR0VfVklBX05BVklHQVRFIH0pO1xuICAgICAgICAgICAgaWYgKGFkanVzdERhdGVPbkNoYW5nZSkge1xuICAgICAgICAgICAgICAgIF90aGlzLnNldFNlbGVjdGVkKG5ld1NlbGVjdGlvbik7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBfdGhpcy5zZXRQcmVTZWxlY3Rpb24obmV3U2VsZWN0aW9uKTtcbiAgICAgICAgICAgIC8vIEluIGlubGluZSBtb2RlLCBhbHdheXMgc2V0IHNob3VsZEZvY3VzRGF5SW5saW5lIHRvIHRydWUgd2hlbiBuYXZpZ2F0aW5nIHZpYSBrZXlib2FyZC5cbiAgICAgICAgICAgIC8vIFRoaXMgZW5zdXJlcyBmb2N1cyBpcyBwcm9wZXJseSB0cmFuc2ZlcnJlZCB0byB0aGUgbmV3IGRheSBlbGVtZW50IHJlZ2FyZGxlc3Mgb2ZcbiAgICAgICAgICAgIC8vIHdoZXRoZXIgdGhlIG1vbnRoIGNoYW5nZWQuIFRoZSB1c2VyIGluaXRpYXRlZCB0aGlzIG5hdmlnYXRpb24gZnJvbSBhIGZvY3VzZWQgZGF5LFxuICAgICAgICAgICAgLy8gc28gd2Ugc2hvdWxkIGFsd2F5cyBmb2N1cyB0aGUgZGVzdGluYXRpb24gZGF5LlxuICAgICAgICAgICAgaWYgKGlubGluZSkge1xuICAgICAgICAgICAgICAgIF90aGlzLnNldFN0YXRlKHsgc2hvdWxkRm9jdXNEYXlJbmxpbmU6IHRydWUgfSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH07XG4gICAgICAgIC8vIGhhbmRsZSBnZW5lcmljIGtleSBkb3duIGV2ZW50cyBpbiB0aGUgcG9wcGVyIHRoYXQgZG8gbm90IGFkanVzdCBvciBzZWxlY3QgZGF0ZXNcbiAgICAgICAgLy8gZXg6IHdoaWxlIGZvY3VzaW5nIHByZXYgYW5kIG5leHQgbW9udGggYnV0dG9uc1xuICAgICAgICBfdGhpcy5vblBvcHBlcktleURvd24gPSBmdW5jdGlvbiAoZXZlbnQpIHtcbiAgICAgICAgICAgIHZhciBldmVudEtleSA9IGV2ZW50LmtleTtcbiAgICAgICAgICAgIGlmIChldmVudEtleSA9PT0gS2V5VHlwZS5Fc2NhcGUpIHtcbiAgICAgICAgICAgICAgICBldmVudC5wcmV2ZW50RGVmYXVsdCgpO1xuICAgICAgICAgICAgICAgIF90aGlzLnNlbmRGb2N1c0JhY2tUb0lucHV0KCk7XG4gICAgICAgICAgICAgICAgX3RoaXMuc2V0T3BlbihmYWxzZSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH07XG4gICAgICAgIF90aGlzLm9uQ2xlYXJDbGljayA9IGZ1bmN0aW9uIChldmVudCkge1xuICAgICAgICAgICAgaWYgKGV2ZW50KSB7XG4gICAgICAgICAgICAgICAgaWYgKGV2ZW50LnByZXZlbnREZWZhdWx0KSB7XG4gICAgICAgICAgICAgICAgICAgIGV2ZW50LnByZXZlbnREZWZhdWx0KCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgX3RoaXMuc2VuZEZvY3VzQmFja1RvSW5wdXQoKTtcbiAgICAgICAgICAgIHZhciBfYSA9IF90aGlzLnByb3BzLCBzZWxlY3RzUmFuZ2UgPSBfYS5zZWxlY3RzUmFuZ2UsIG9uQ2hhbmdlID0gX2Eub25DaGFuZ2U7XG4gICAgICAgICAgICBpZiAoc2VsZWN0c1JhbmdlKSB7XG4gICAgICAgICAgICAgICAgb25DaGFuZ2UgPT09IG51bGwgfHwgb25DaGFuZ2UgPT09IHZvaWQgMCA/IHZvaWQgMCA6IG9uQ2hhbmdlKFtudWxsLCBudWxsXSwgZXZlbnQpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgb25DaGFuZ2UgPT09IG51bGwgfHwgb25DaGFuZ2UgPT09IHZvaWQgMCA/IHZvaWQgMCA6IG9uQ2hhbmdlKG51bGwsIGV2ZW50KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIF90aGlzLnNldFN0YXRlKHsgaW5wdXRWYWx1ZTogbnVsbCB9KTtcbiAgICAgICAgfTtcbiAgICAgICAgX3RoaXMuY2xlYXIgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICBfdGhpcy5vbkNsZWFyQ2xpY2soKTtcbiAgICAgICAgfTtcbiAgICAgICAgX3RoaXMub25TY3JvbGwgPSBmdW5jdGlvbiAoZXZlbnQpIHtcbiAgICAgICAgICAgIGlmICh0eXBlb2YgX3RoaXMucHJvcHMuY2xvc2VPblNjcm9sbCA9PT0gXCJib29sZWFuXCIgJiZcbiAgICAgICAgICAgICAgICBfdGhpcy5wcm9wcy5jbG9zZU9uU2Nyb2xsKSB7XG4gICAgICAgICAgICAgICAgaWYgKGV2ZW50LnRhcmdldCA9PT0gZG9jdW1lbnQgfHxcbiAgICAgICAgICAgICAgICAgICAgZXZlbnQudGFyZ2V0ID09PSBkb2N1bWVudC5kb2N1bWVudEVsZW1lbnQgfHxcbiAgICAgICAgICAgICAgICAgICAgZXZlbnQudGFyZ2V0ID09PSBkb2N1bWVudC5ib2R5KSB7XG4gICAgICAgICAgICAgICAgICAgIF90aGlzLnNldE9wZW4oZmFsc2UpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2UgaWYgKHR5cGVvZiBfdGhpcy5wcm9wcy5jbG9zZU9uU2Nyb2xsID09PSBcImZ1bmN0aW9uXCIpIHtcbiAgICAgICAgICAgICAgICBpZiAoX3RoaXMucHJvcHMuY2xvc2VPblNjcm9sbChldmVudCkpIHtcbiAgICAgICAgICAgICAgICAgICAgX3RoaXMuc2V0T3BlbihmYWxzZSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9O1xuICAgICAgICBfdGhpcy5yZW5kZXJDYWxlbmRhciA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIHZhciBfYSwgX2I7XG4gICAgICAgICAgICBpZiAoIV90aGlzLnByb3BzLmlubGluZSAmJiAhX3RoaXMuaXNDYWxlbmRhck9wZW4oKSkge1xuICAgICAgICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIChSZWFjdC5jcmVhdGVFbGVtZW50KENhbGVuZGFyLCBfYXNzaWduKHsgc2hvd01vbnRoWWVhckRyb3Bkb3duOiB1bmRlZmluZWQsIHJlZjogZnVuY3Rpb24gKGVsZW0pIHtcbiAgICAgICAgICAgICAgICAgICAgX3RoaXMuY2FsZW5kYXIgPSBlbGVtO1xuICAgICAgICAgICAgICAgIH0gfSwgX3RoaXMucHJvcHMsIF90aGlzLnN0YXRlLCB7IHNldE9wZW46IF90aGlzLnNldE9wZW4sIGRhdGVGb3JtYXQ6IChfYSA9IF90aGlzLnByb3BzLmRhdGVGb3JtYXRDYWxlbmRhcikgIT09IG51bGwgJiYgX2EgIT09IHZvaWQgMCA/IF9hIDogRGF0ZVBpY2tlci5kZWZhdWx0UHJvcHMuZGF0ZUZvcm1hdENhbGVuZGFyLCBvblNlbGVjdDogX3RoaXMuaGFuZGxlU2VsZWN0LCBvbkNsaWNrT3V0c2lkZTogX3RoaXMuaGFuZGxlQ2FsZW5kYXJDbGlja091dHNpZGUsIGhvbGlkYXlzOiBnZXRIb2xpZGF5c01hcChfdGhpcy5tb2RpZnlIb2xpZGF5cygpKSwgb3V0c2lkZUNsaWNrSWdub3JlQ2xhc3M6IF90aGlzLnByb3BzLm91dHNpZGVDbGlja0lnbm9yZUNsYXNzLCBvbkRyb3Bkb3duRm9jdXM6IF90aGlzLmhhbmRsZURyb3Bkb3duRm9jdXMsIG9uVGltZUNoYW5nZTogX3RoaXMuaGFuZGxlVGltZUNoYW5nZSwgY2xhc3NOYW1lOiBfdGhpcy5wcm9wcy5jYWxlbmRhckNsYXNzTmFtZSwgY29udGFpbmVyOiBfdGhpcy5wcm9wcy5jYWxlbmRhckNvbnRhaW5lciwgaGFuZGxlT25LZXlEb3duOiBfdGhpcy5wcm9wcy5vbktleURvd24sIGhhbmRsZU9uRGF5S2V5RG93bjogX3RoaXMub25EYXlLZXlEb3duLCBzZXRQcmVTZWxlY3Rpb246IF90aGlzLnNldFByZVNlbGVjdGlvbiwgZHJvcGRvd25Nb2RlOiAoX2IgPSBfdGhpcy5wcm9wcy5kcm9wZG93bk1vZGUpICE9PSBudWxsICYmIF9iICE9PSB2b2lkIDAgPyBfYiA6IERhdGVQaWNrZXIuZGVmYXVsdFByb3BzLmRyb3Bkb3duTW9kZSB9KSwgX3RoaXMucHJvcHMuY2hpbGRyZW4pKTtcbiAgICAgICAgfTtcbiAgICAgICAgX3RoaXMucmVuZGVyQXJpYUxpdmVSZWdpb24gPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICB2YXIgX2E7XG4gICAgICAgICAgICB2YXIgbG9jYWxlID0gX3RoaXMucHJvcHMubG9jYWxlO1xuICAgICAgICAgICAgdmFyIGRhdGVGb3JtYXQgPSAoX2EgPSBfdGhpcy5wcm9wcy5kYXRlRm9ybWF0KSAhPT0gbnVsbCAmJiBfYSAhPT0gdm9pZCAwID8gX2EgOiBEYXRlUGlja2VyLmRlZmF1bHRQcm9wcy5kYXRlRm9ybWF0O1xuICAgICAgICAgICAgdmFyIGlzQ29udGFpbnNUaW1lID0gX3RoaXMucHJvcHMuc2hvd1RpbWVJbnB1dCB8fCBfdGhpcy5wcm9wcy5zaG93VGltZVNlbGVjdDtcbiAgICAgICAgICAgIHZhciBsb25nRGF0ZUZvcm1hdCA9IGlzQ29udGFpbnNUaW1lID8gXCJQUFBQcFwiIDogXCJQUFBQXCI7XG4gICAgICAgICAgICB2YXIgYXJpYUxpdmVNZXNzYWdlO1xuICAgICAgICAgICAgaWYgKF90aGlzLnByb3BzLnNlbGVjdHNSYW5nZSkge1xuICAgICAgICAgICAgICAgIGFyaWFMaXZlTWVzc2FnZSA9IFwiU2VsZWN0ZWQgc3RhcnQgZGF0ZTogXCIuY29uY2F0KHNhZmVEYXRlRm9ybWF0KF90aGlzLnByb3BzLnN0YXJ0RGF0ZSwge1xuICAgICAgICAgICAgICAgICAgICBkYXRlRm9ybWF0OiBsb25nRGF0ZUZvcm1hdCxcbiAgICAgICAgICAgICAgICAgICAgbG9jYWxlOiBsb2NhbGUsXG4gICAgICAgICAgICAgICAgfSksIFwiLiBcIikuY29uY2F0KF90aGlzLnByb3BzLmVuZERhdGVcbiAgICAgICAgICAgICAgICAgICAgPyBcIkVuZCBkYXRlOiBcIiArXG4gICAgICAgICAgICAgICAgICAgICAgICBzYWZlRGF0ZUZvcm1hdChfdGhpcy5wcm9wcy5lbmREYXRlLCB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgZGF0ZUZvcm1hdDogbG9uZ0RhdGVGb3JtYXQsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgbG9jYWxlOiBsb2NhbGUsXG4gICAgICAgICAgICAgICAgICAgICAgICB9KVxuICAgICAgICAgICAgICAgICAgICA6IFwiXCIpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgaWYgKF90aGlzLnByb3BzLnNob3dUaW1lU2VsZWN0T25seSkge1xuICAgICAgICAgICAgICAgICAgICBhcmlhTGl2ZU1lc3NhZ2UgPSBcIlNlbGVjdGVkIHRpbWU6IFwiLmNvbmNhdChzYWZlRGF0ZUZvcm1hdChfdGhpcy5wcm9wcy5zZWxlY3RlZCwgeyBkYXRlRm9ybWF0OiBkYXRlRm9ybWF0LCBsb2NhbGU6IGxvY2FsZSB9KSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2UgaWYgKF90aGlzLnByb3BzLnNob3dZZWFyUGlja2VyKSB7XG4gICAgICAgICAgICAgICAgICAgIGFyaWFMaXZlTWVzc2FnZSA9IFwiU2VsZWN0ZWQgeWVhcjogXCIuY29uY2F0KHNhZmVEYXRlRm9ybWF0KF90aGlzLnByb3BzLnNlbGVjdGVkLCB7IGRhdGVGb3JtYXQ6IFwieXl5eVwiLCBsb2NhbGU6IGxvY2FsZSB9KSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2UgaWYgKF90aGlzLnByb3BzLnNob3dNb250aFllYXJQaWNrZXIpIHtcbiAgICAgICAgICAgICAgICAgICAgYXJpYUxpdmVNZXNzYWdlID0gXCJTZWxlY3RlZCBtb250aDogXCIuY29uY2F0KHNhZmVEYXRlRm9ybWF0KF90aGlzLnByb3BzLnNlbGVjdGVkLCB7IGRhdGVGb3JtYXQ6IFwiTU1NTSB5eXl5XCIsIGxvY2FsZTogbG9jYWxlIH0pKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZSBpZiAoX3RoaXMucHJvcHMuc2hvd1F1YXJ0ZXJZZWFyUGlja2VyKSB7XG4gICAgICAgICAgICAgICAgICAgIGFyaWFMaXZlTWVzc2FnZSA9IFwiU2VsZWN0ZWQgcXVhcnRlcjogXCIuY29uY2F0KHNhZmVEYXRlRm9ybWF0KF90aGlzLnByb3BzLnNlbGVjdGVkLCB7XG4gICAgICAgICAgICAgICAgICAgICAgICBkYXRlRm9ybWF0OiBcInl5eXksIFFRUVwiLFxuICAgICAgICAgICAgICAgICAgICAgICAgbG9jYWxlOiBsb2NhbGUsXG4gICAgICAgICAgICAgICAgICAgIH0pKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIGFyaWFMaXZlTWVzc2FnZSA9IFwiU2VsZWN0ZWQgZGF0ZTogXCIuY29uY2F0KHNhZmVEYXRlRm9ybWF0KF90aGlzLnByb3BzLnNlbGVjdGVkLCB7XG4gICAgICAgICAgICAgICAgICAgICAgICBkYXRlRm9ybWF0OiBsb25nRGF0ZUZvcm1hdCxcbiAgICAgICAgICAgICAgICAgICAgICAgIGxvY2FsZTogbG9jYWxlLFxuICAgICAgICAgICAgICAgICAgICB9KSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIChSZWFjdC5jcmVhdGVFbGVtZW50KFwic3BhblwiLCB7IHJvbGU6IFwiYWxlcnRcIiwgXCJhcmlhLWxpdmVcIjogXCJwb2xpdGVcIiwgY2xhc3NOYW1lOiBcInJlYWN0LWRhdGVwaWNrZXJfX2FyaWEtbGl2ZVwiIH0sIGFyaWFMaXZlTWVzc2FnZSkpO1xuICAgICAgICB9O1xuICAgICAgICBfdGhpcy5yZW5kZXJEYXRlSW5wdXQgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICB2YXIgX2EsIF9iO1xuICAgICAgICAgICAgdmFyIF9jLCBfZCwgX2UsIF9mO1xuICAgICAgICAgICAgdmFyIGNsYXNzTmFtZSA9IGNsc3goX3RoaXMucHJvcHMuY2xhc3NOYW1lLCAoX2EgPSB7fSxcbiAgICAgICAgICAgICAgICBfYVtfdGhpcy5wcm9wcy5vdXRzaWRlQ2xpY2tJZ25vcmVDbGFzcyB8fFxuICAgICAgICAgICAgICAgICAgICBEYXRlUGlja2VyLmRlZmF1bHRQcm9wcy5vdXRzaWRlQ2xpY2tJZ25vcmVDbGFzc10gPSBfdGhpcy5zdGF0ZS5vcGVuLFxuICAgICAgICAgICAgICAgIF9hKSk7XG4gICAgICAgICAgICB2YXIgY3VzdG9tSW5wdXQgPSBfdGhpcy5wcm9wcy5jdXN0b21JbnB1dCB8fCBSZWFjdC5jcmVhdGVFbGVtZW50KFwiaW5wdXRcIiwgeyB0eXBlOiBcInRleHRcIiB9KTtcbiAgICAgICAgICAgIHZhciBjdXN0b21JbnB1dFJlZiA9IF90aGlzLnByb3BzLmN1c3RvbUlucHV0UmVmIHx8IFwicmVmXCI7XG4gICAgICAgICAgICAvLyBCdWlsZCBhcmlhIHByb3BzIG9iamVjdCwgb25seSBpbmNsdWRpbmcgZGVmaW5lZCB2YWx1ZXMgdG8gYXZvaWRcbiAgICAgICAgICAgIC8vIG92ZXJ3cml0aW5nIGFyaWEgYXR0cmlidXRlcyB0aGF0IG1heSBiZSBzZXQgb24gdGhlIGN1c3RvbSBpbnB1dFxuICAgICAgICAgICAgdmFyIGFyaWFQcm9wcyA9IHt9O1xuICAgICAgICAgICAgdmFyIGFyaWFEZXNjcmliZWRCeSA9IChfYyA9IF90aGlzLnByb3BzW1wiYXJpYS1kZXNjcmliZWRieVwiXSkgIT09IG51bGwgJiYgX2MgIT09IHZvaWQgMCA/IF9jIDogX3RoaXMucHJvcHMuYXJpYURlc2NyaWJlZEJ5O1xuICAgICAgICAgICAgdmFyIGFyaWFJbnZhbGlkID0gKF9kID0gX3RoaXMucHJvcHNbXCJhcmlhLWludmFsaWRcIl0pICE9PSBudWxsICYmIF9kICE9PSB2b2lkIDAgPyBfZCA6IF90aGlzLnByb3BzLmFyaWFJbnZhbGlkO1xuICAgICAgICAgICAgdmFyIGFyaWFMYWJlbGxlZEJ5ID0gKF9lID0gX3RoaXMucHJvcHNbXCJhcmlhLWxhYmVsbGVkYnlcIl0pICE9PSBudWxsICYmIF9lICE9PSB2b2lkIDAgPyBfZSA6IF90aGlzLnByb3BzLmFyaWFMYWJlbGxlZEJ5O1xuICAgICAgICAgICAgdmFyIGFyaWFSZXF1aXJlZCA9IChfZiA9IF90aGlzLnByb3BzW1wiYXJpYS1yZXF1aXJlZFwiXSkgIT09IG51bGwgJiYgX2YgIT09IHZvaWQgMCA/IF9mIDogX3RoaXMucHJvcHMuYXJpYVJlcXVpcmVkO1xuICAgICAgICAgICAgaWYgKGFyaWFEZXNjcmliZWRCeSAhPSBudWxsKVxuICAgICAgICAgICAgICAgIGFyaWFQcm9wc1tcImFyaWEtZGVzY3JpYmVkYnlcIl0gPSBhcmlhRGVzY3JpYmVkQnk7XG4gICAgICAgICAgICBpZiAoYXJpYUludmFsaWQgIT0gbnVsbClcbiAgICAgICAgICAgICAgICBhcmlhUHJvcHNbXCJhcmlhLWludmFsaWRcIl0gPSBhcmlhSW52YWxpZDtcbiAgICAgICAgICAgIGlmIChhcmlhTGFiZWxsZWRCeSAhPSBudWxsKVxuICAgICAgICAgICAgICAgIGFyaWFQcm9wc1tcImFyaWEtbGFiZWxsZWRieVwiXSA9IGFyaWFMYWJlbGxlZEJ5O1xuICAgICAgICAgICAgaWYgKGFyaWFSZXF1aXJlZCAhPSBudWxsKVxuICAgICAgICAgICAgICAgIGFyaWFQcm9wc1tcImFyaWEtcmVxdWlyZWRcIl0gPSBhcmlhUmVxdWlyZWQ7XG4gICAgICAgICAgICByZXR1cm4gY2xvbmVFbGVtZW50KGN1c3RvbUlucHV0LCBfYXNzaWduKChfYiA9IHt9LCBfYltjdXN0b21JbnB1dFJlZl0gPSBmdW5jdGlvbiAoaW5wdXQpIHtcbiAgICAgICAgICAgICAgICBfdGhpcy5pbnB1dCA9IGlucHV0O1xuICAgICAgICAgICAgfSwgX2IudmFsdWUgPSBfdGhpcy5nZXRJbnB1dFZhbHVlKCksIF9iLm9uQmx1ciA9IF90aGlzLmhhbmRsZUJsdXIsIF9iLm9uQ2hhbmdlID0gX3RoaXMuaGFuZGxlQ2hhbmdlLCBfYi5vbkNsaWNrID0gX3RoaXMub25JbnB1dENsaWNrLCBfYi5vbkZvY3VzID0gX3RoaXMuaGFuZGxlRm9jdXMsIF9iLm9uS2V5RG93biA9IF90aGlzLm9uSW5wdXRLZXlEb3duLCBfYi5pZCA9IF90aGlzLnByb3BzLmlkLCBfYi5uYW1lID0gX3RoaXMucHJvcHMubmFtZSwgX2IuZm9ybSA9IF90aGlzLnByb3BzLmZvcm0sIF9iLmF1dG9Gb2N1cyA9IF90aGlzLnByb3BzLmF1dG9Gb2N1cywgX2IucGxhY2Vob2xkZXIgPSBfdGhpcy5wcm9wcy5wbGFjZWhvbGRlclRleHQsIF9iLmRpc2FibGVkID0gX3RoaXMucHJvcHMuZGlzYWJsZWQsIF9iLmF1dG9Db21wbGV0ZSA9IF90aGlzLnByb3BzLmF1dG9Db21wbGV0ZSwgX2IuY2xhc3NOYW1lID0gY2xzeChjdXN0b21JbnB1dC5wcm9wcy5jbGFzc05hbWUsIGNsYXNzTmFtZSksIF9iLnRpdGxlID0gX3RoaXMucHJvcHMudGl0bGUsIF9iLnJlYWRPbmx5ID0gX3RoaXMucHJvcHMucmVhZE9ubHksIF9iLnJlcXVpcmVkID0gX3RoaXMucHJvcHMucmVxdWlyZWQsIF9iLnRhYkluZGV4ID0gX3RoaXMucHJvcHMudGFiSW5kZXgsIF9iKSwgYXJpYVByb3BzKSk7XG4gICAgICAgIH07XG4gICAgICAgIF90aGlzLnJlbmRlckNsZWFyQnV0dG9uID0gZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgdmFyIF9hID0gX3RoaXMucHJvcHMsIGlzQ2xlYXJhYmxlID0gX2EuaXNDbGVhcmFibGUsIGRpc2FibGVkID0gX2EuZGlzYWJsZWQsIHNlbGVjdGVkID0gX2Euc2VsZWN0ZWQsIHN0YXJ0RGF0ZSA9IF9hLnN0YXJ0RGF0ZSwgZW5kRGF0ZSA9IF9hLmVuZERhdGUsIGNsZWFyQnV0dG9uVGl0bGUgPSBfYS5jbGVhckJ1dHRvblRpdGxlLCBfYiA9IF9hLmNsZWFyQnV0dG9uQ2xhc3NOYW1lLCBjbGVhckJ1dHRvbkNsYXNzTmFtZSA9IF9iID09PSB2b2lkIDAgPyBcIlwiIDogX2IsIF9jID0gX2EuYXJpYUxhYmVsQ2xvc2UsIGFyaWFMYWJlbENsb3NlID0gX2MgPT09IHZvaWQgMCA/IFwiQ2xvc2VcIiA6IF9jLCBzZWxlY3RlZERhdGVzID0gX2Euc2VsZWN0ZWREYXRlcywgcmVhZE9ubHkgPSBfYS5yZWFkT25seTtcbiAgICAgICAgICAgIGlmIChpc0NsZWFyYWJsZSAmJlxuICAgICAgICAgICAgICAgICFyZWFkT25seSAmJlxuICAgICAgICAgICAgICAgIChzZWxlY3RlZCAhPSBudWxsIHx8XG4gICAgICAgICAgICAgICAgICAgIHN0YXJ0RGF0ZSAhPSBudWxsIHx8XG4gICAgICAgICAgICAgICAgICAgIGVuZERhdGUgIT0gbnVsbCB8fFxuICAgICAgICAgICAgICAgICAgICAoc2VsZWN0ZWREYXRlcyA9PT0gbnVsbCB8fCBzZWxlY3RlZERhdGVzID09PSB2b2lkIDAgPyB2b2lkIDAgOiBzZWxlY3RlZERhdGVzLmxlbmd0aCkpKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIChSZWFjdC5jcmVhdGVFbGVtZW50KFwiYnV0dG9uXCIsIHsgdHlwZTogXCJidXR0b25cIiwgY2xhc3NOYW1lOiBjbHN4KFwicmVhY3QtZGF0ZXBpY2tlcl9fY2xvc2UtaWNvblwiLCBjbGVhckJ1dHRvbkNsYXNzTmFtZSwgeyBcInJlYWN0LWRhdGVwaWNrZXJfX2Nsb3NlLWljb24tLWRpc2FibGVkXCI6IGRpc2FibGVkIH0pLCBkaXNhYmxlZDogZGlzYWJsZWQsIFwiYXJpYS1sYWJlbFwiOiBhcmlhTGFiZWxDbG9zZSwgb25DbGljazogX3RoaXMub25DbGVhckNsaWNrLCB0aXRsZTogY2xlYXJCdXR0b25UaXRsZSwgdGFiSW5kZXg6IC0xIH0pKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICAgICAgfVxuICAgICAgICB9O1xuICAgICAgICBfdGhpcy5zdGF0ZSA9IF90aGlzLmNhbGNJbml0aWFsU3RhdGUoKTtcbiAgICAgICAgX3RoaXMucHJldmVudEZvY3VzVGltZW91dCA9IHVuZGVmaW5lZDtcbiAgICAgICAgcmV0dXJuIF90aGlzO1xuICAgIH1cbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoRGF0ZVBpY2tlciwgXCJkZWZhdWx0UHJvcHNcIiwge1xuICAgICAgICBnZXQ6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICAgICAgYWxsb3dTYW1lRGF5OiBmYWxzZSxcbiAgICAgICAgICAgICAgICBkYXRlRm9ybWF0OiBcIk1NL2RkL3l5eXlcIixcbiAgICAgICAgICAgICAgICBkYXRlRm9ybWF0Q2FsZW5kYXI6IFwiTExMTCB5eXl5XCIsXG4gICAgICAgICAgICAgICAgZGlzYWJsZWQ6IGZhbHNlLFxuICAgICAgICAgICAgICAgIGRpc2FibGVkS2V5Ym9hcmROYXZpZ2F0aW9uOiBmYWxzZSxcbiAgICAgICAgICAgICAgICBkcm9wZG93bk1vZGU6IFwic2Nyb2xsXCIsXG4gICAgICAgICAgICAgICAgcHJldmVudE9wZW5PbkZvY3VzOiBmYWxzZSxcbiAgICAgICAgICAgICAgICBtb250aHNTaG93bjogMSxcbiAgICAgICAgICAgICAgICBvdXRzaWRlQ2xpY2tJZ25vcmVDbGFzczogT1VUU0lERV9DTElDS19JR05PUkVfQ0xBU1MsXG4gICAgICAgICAgICAgICAgcmVhZE9ubHk6IGZhbHNlLFxuICAgICAgICAgICAgICAgIHJhbmdlU2VwYXJhdG9yOiBEQVRFX1JBTkdFX1NFUEFSQVRPUixcbiAgICAgICAgICAgICAgICB3aXRoUG9ydGFsOiBmYWxzZSxcbiAgICAgICAgICAgICAgICBzZWxlY3RzRGlzYWJsZWREYXlzSW5SYW5nZTogZmFsc2UsXG4gICAgICAgICAgICAgICAgc2hvdWxkQ2xvc2VPblNlbGVjdDogdHJ1ZSxcbiAgICAgICAgICAgICAgICBzaG93VGltZVNlbGVjdDogZmFsc2UsXG4gICAgICAgICAgICAgICAgc2hvd1RpbWVJbnB1dDogZmFsc2UsXG4gICAgICAgICAgICAgICAgc2hvd1ByZXZpb3VzTW9udGhzOiBmYWxzZSxcbiAgICAgICAgICAgICAgICBzaG93TW9udGhZZWFyUGlja2VyOiBmYWxzZSxcbiAgICAgICAgICAgICAgICBzaG93RnVsbE1vbnRoWWVhclBpY2tlcjogZmFsc2UsXG4gICAgICAgICAgICAgICAgc2hvd1R3b0NvbHVtbk1vbnRoWWVhclBpY2tlcjogZmFsc2UsXG4gICAgICAgICAgICAgICAgc2hvd0ZvdXJDb2x1bW5Nb250aFllYXJQaWNrZXI6IGZhbHNlLFxuICAgICAgICAgICAgICAgIHNob3dZZWFyUGlja2VyOiBmYWxzZSxcbiAgICAgICAgICAgICAgICBzaG93UXVhcnRlclllYXJQaWNrZXI6IGZhbHNlLFxuICAgICAgICAgICAgICAgIHNob3dXZWVrUGlja2VyOiBmYWxzZSxcbiAgICAgICAgICAgICAgICBzdHJpY3RQYXJzaW5nOiBmYWxzZSxcbiAgICAgICAgICAgICAgICBzd2FwUmFuZ2U6IGZhbHNlLFxuICAgICAgICAgICAgICAgIHRpbWVJbnRlcnZhbHM6IDMwLFxuICAgICAgICAgICAgICAgIHRpbWVDYXB0aW9uOiBcIlRpbWVcIixcbiAgICAgICAgICAgICAgICBwcmV2aW91c01vbnRoQXJpYUxhYmVsOiBcIlByZXZpb3VzIE1vbnRoXCIsXG4gICAgICAgICAgICAgICAgcHJldmlvdXNNb250aEJ1dHRvbkxhYmVsOiBcIlByZXZpb3VzIE1vbnRoXCIsXG4gICAgICAgICAgICAgICAgbmV4dE1vbnRoQXJpYUxhYmVsOiBcIk5leHQgTW9udGhcIixcbiAgICAgICAgICAgICAgICBuZXh0TW9udGhCdXR0b25MYWJlbDogXCJOZXh0IE1vbnRoXCIsXG4gICAgICAgICAgICAgICAgcHJldmlvdXNZZWFyQXJpYUxhYmVsOiBcIlByZXZpb3VzIFllYXJcIixcbiAgICAgICAgICAgICAgICBwcmV2aW91c1llYXJCdXR0b25MYWJlbDogXCJQcmV2aW91cyBZZWFyXCIsXG4gICAgICAgICAgICAgICAgbmV4dFllYXJBcmlhTGFiZWw6IFwiTmV4dCBZZWFyXCIsXG4gICAgICAgICAgICAgICAgbmV4dFllYXJCdXR0b25MYWJlbDogXCJOZXh0IFllYXJcIixcbiAgICAgICAgICAgICAgICB0aW1lSW5wdXRMYWJlbDogXCJUaW1lXCIsXG4gICAgICAgICAgICAgICAgZW5hYmxlVGFiTG9vcDogdHJ1ZSxcbiAgICAgICAgICAgICAgICB5ZWFySXRlbU51bWJlcjogREVGQVVMVF9ZRUFSX0lURU1fTlVNQkVSLFxuICAgICAgICAgICAgICAgIGZvY3VzU2VsZWN0ZWRNb250aDogZmFsc2UsXG4gICAgICAgICAgICAgICAgc2hvd1BvcHBlckFycm93OiB0cnVlLFxuICAgICAgICAgICAgICAgIGV4Y2x1ZGVTY3JvbGxiYXI6IHRydWUsXG4gICAgICAgICAgICAgICAgY3VzdG9tVGltZUlucHV0OiBudWxsLFxuICAgICAgICAgICAgICAgIGNhbGVuZGFyU3RhcnREYXk6IHVuZGVmaW5lZCxcbiAgICAgICAgICAgICAgICB0b2dnbGVDYWxlbmRhck9uSWNvbkNsaWNrOiBmYWxzZSxcbiAgICAgICAgICAgICAgICB1c2VQb2ludGVyRXZlbnQ6IGZhbHNlLFxuICAgICAgICAgICAgfTtcbiAgICAgICAgfSxcbiAgICAgICAgZW51bWVyYWJsZTogZmFsc2UsXG4gICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZVxuICAgIH0pO1xuICAgIERhdGVQaWNrZXIucHJvdG90eXBlLmNvbXBvbmVudERpZE1vdW50ID0gZnVuY3Rpb24gKCkge1xuICAgICAgICB3aW5kb3cuYWRkRXZlbnRMaXN0ZW5lcihcInNjcm9sbFwiLCB0aGlzLm9uU2Nyb2xsLCB0cnVlKTtcbiAgICAgICAgZG9jdW1lbnQuYWRkRXZlbnRMaXN0ZW5lcihcInZpc2liaWxpdHljaGFuZ2VcIiwgdGhpcy5zZXRIaWRkZW5TdGF0ZU9uVmlzaWJpbGl0eUhpZGRlbik7XG4gICAgfTtcbiAgICBEYXRlUGlja2VyLnByb3RvdHlwZS5jb21wb25lbnREaWRVcGRhdGUgPSBmdW5jdGlvbiAocHJldlByb3BzLCBwcmV2U3RhdGUpIHtcbiAgICAgICAgdmFyIF9hLCBfYiwgX2MsIF9kO1xuICAgICAgICBpZiAocHJldlByb3BzLmlubGluZSAmJlxuICAgICAgICAgICAgaGFzUHJlU2VsZWN0aW9uQ2hhbmdlZChwcmV2UHJvcHMuc2VsZWN0ZWQsIHRoaXMucHJvcHMuc2VsZWN0ZWQpKSB7XG4gICAgICAgICAgICB0aGlzLnNldFByZVNlbGVjdGlvbih0aGlzLnByb3BzLnNlbGVjdGVkKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAodGhpcy5zdGF0ZS5tb250aFNlbGVjdGVkSW4gIT09IHVuZGVmaW5lZCAmJlxuICAgICAgICAgICAgcHJldlByb3BzLm1vbnRoc1Nob3duICE9PSB0aGlzLnByb3BzLm1vbnRoc1Nob3duKSB7XG4gICAgICAgICAgICB0aGlzLnNldFN0YXRlKHsgbW9udGhTZWxlY3RlZEluOiAwIH0pO1xuICAgICAgICB9XG4gICAgICAgIGlmICh0aGlzLnByb3BzLnNlbGVjdHNSYW5nZSAmJiB0aGlzLnN0YXRlLm1vbnRoU2VsZWN0ZWRJbiAhPT0gMCkge1xuICAgICAgICAgICAgdGhpcy5zZXRTdGF0ZSh7IG1vbnRoU2VsZWN0ZWRJbjogMCB9KTtcbiAgICAgICAgfVxuICAgICAgICBpZiAocHJldlByb3BzLmhpZ2hsaWdodERhdGVzICE9PSB0aGlzLnByb3BzLmhpZ2hsaWdodERhdGVzKSB7XG4gICAgICAgICAgICB0aGlzLnNldFN0YXRlKHtcbiAgICAgICAgICAgICAgICBoaWdobGlnaHREYXRlczogZ2V0SGlnaExpZ2h0RGF5c01hcCh0aGlzLnByb3BzLmhpZ2hsaWdodERhdGVzKSxcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgICAgIGlmICghcHJldlN0YXRlLmZvY3VzZWQgJiZcbiAgICAgICAgICAgICFpc0VxdWFsKHByZXZQcm9wcy5zZWxlY3RlZCwgdGhpcy5wcm9wcy5zZWxlY3RlZCkpIHtcbiAgICAgICAgICAgIHRoaXMuc2V0U3RhdGUoeyBpbnB1dFZhbHVlOiBudWxsIH0pO1xuICAgICAgICB9XG4gICAgICAgIGlmIChwcmV2U3RhdGUub3BlbiAhPT0gdGhpcy5zdGF0ZS5vcGVuKSB7XG4gICAgICAgICAgICBpZiAocHJldlN0YXRlLm9wZW4gPT09IGZhbHNlICYmIHRoaXMuc3RhdGUub3BlbiA9PT0gdHJ1ZSkge1xuICAgICAgICAgICAgICAgIChfYiA9IChfYSA9IHRoaXMucHJvcHMpLm9uQ2FsZW5kYXJPcGVuKSA9PT0gbnVsbCB8fCBfYiA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2IuY2FsbChfYSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAocHJldlN0YXRlLm9wZW4gPT09IHRydWUgJiYgdGhpcy5zdGF0ZS5vcGVuID09PSBmYWxzZSkge1xuICAgICAgICAgICAgICAgIChfZCA9IChfYyA9IHRoaXMucHJvcHMpLm9uQ2FsZW5kYXJDbG9zZSkgPT09IG51bGwgfHwgX2QgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9kLmNhbGwoX2MpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfTtcbiAgICBEYXRlUGlja2VyLnByb3RvdHlwZS5jb21wb25lbnRXaWxsVW5tb3VudCA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdGhpcy5jbGVhclByZXZlbnRGb2N1c1RpbWVvdXQoKTtcbiAgICAgICAgd2luZG93LnJlbW92ZUV2ZW50TGlzdGVuZXIoXCJzY3JvbGxcIiwgdGhpcy5vblNjcm9sbCwgdHJ1ZSk7XG4gICAgICAgIGRvY3VtZW50LnJlbW92ZUV2ZW50TGlzdGVuZXIoXCJ2aXNpYmlsaXR5Y2hhbmdlXCIsIHRoaXMuc2V0SGlkZGVuU3RhdGVPblZpc2liaWxpdHlIaWRkZW4pO1xuICAgIH07XG4gICAgRGF0ZVBpY2tlci5wcm90b3R5cGUucmVuZGVySW5wdXRDb250YWluZXIgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHZhciBfYSA9IHRoaXMucHJvcHMsIHNob3dJY29uID0gX2Euc2hvd0ljb24sIGljb24gPSBfYS5pY29uLCBjYWxlbmRhckljb25DbGFzc25hbWUgPSBfYS5jYWxlbmRhckljb25DbGFzc25hbWUsIGNhbGVuZGFySWNvbkNsYXNzTmFtZSA9IF9hLmNhbGVuZGFySWNvbkNsYXNzTmFtZSwgdG9nZ2xlQ2FsZW5kYXJPbkljb25DbGljayA9IF9hLnRvZ2dsZUNhbGVuZGFyT25JY29uQ2xpY2s7XG4gICAgICAgIHZhciBvcGVuID0gdGhpcy5zdGF0ZS5vcGVuO1xuICAgICAgICBpZiAoY2FsZW5kYXJJY29uQ2xhc3NuYW1lKSB7XG4gICAgICAgICAgICBjb25zb2xlLndhcm4oXCJjYWxlbmRhckljb25DbGFzc25hbWUgcHJvcHMgaXMgZGVwcmVjYXRlZC4gc2hvdWxkIHVzZSBjYWxlbmRhckljb25DbGFzc05hbWUgcHJvcHMuXCIpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiAoUmVhY3QuY3JlYXRlRWxlbWVudChcImRpdlwiLCB7IGNsYXNzTmFtZTogXCJyZWFjdC1kYXRlcGlja2VyX19pbnB1dC1jb250YWluZXJcIi5jb25jYXQoc2hvd0ljb24gPyBcIiByZWFjdC1kYXRlcGlja2VyX192aWV3LWNhbGVuZGFyLWljb25cIiA6IFwiXCIpIH0sXG4gICAgICAgICAgICBzaG93SWNvbiAmJiAoUmVhY3QuY3JlYXRlRWxlbWVudChDYWxlbmRhckljb24sIF9hc3NpZ24oeyBpY29uOiBpY29uLCBjbGFzc05hbWU6IGNsc3goY2FsZW5kYXJJY29uQ2xhc3NOYW1lLCAhY2FsZW5kYXJJY29uQ2xhc3NOYW1lICYmIGNhbGVuZGFySWNvbkNsYXNzbmFtZSwgb3BlbiAmJiBcInJlYWN0LWRhdGVwaWNrZXItaWdub3JlLW9uY2xpY2tvdXRzaWRlXCIpIH0sICh0b2dnbGVDYWxlbmRhck9uSWNvbkNsaWNrXG4gICAgICAgICAgICAgICAgPyB7XG4gICAgICAgICAgICAgICAgICAgIG9uQ2xpY2s6IHRoaXMudG9nZ2xlQ2FsZW5kYXIsXG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIDogbnVsbCkpKSksXG4gICAgICAgICAgICB0aGlzLnN0YXRlLmlzUmVuZGVyQXJpYUxpdmVNZXNzYWdlICYmIHRoaXMucmVuZGVyQXJpYUxpdmVSZWdpb24oKSxcbiAgICAgICAgICAgIHRoaXMucmVuZGVyRGF0ZUlucHV0KCksXG4gICAgICAgICAgICB0aGlzLnJlbmRlckNsZWFyQnV0dG9uKCkpKTtcbiAgICB9O1xuICAgIERhdGVQaWNrZXIucHJvdG90eXBlLnJlbmRlciA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdmFyIGNhbGVuZGFyID0gdGhpcy5yZW5kZXJDYWxlbmRhcigpO1xuICAgICAgICBpZiAodGhpcy5wcm9wcy5pbmxpbmUpXG4gICAgICAgICAgICByZXR1cm4gY2FsZW5kYXI7XG4gICAgICAgIGlmICh0aGlzLnByb3BzLndpdGhQb3J0YWwpIHtcbiAgICAgICAgICAgIHZhciBwb3J0YWxDb250YWluZXIgPSB0aGlzLnN0YXRlLm9wZW4gPyAoUmVhY3QuY3JlYXRlRWxlbWVudChUYWJMb29wLCB7IGVuYWJsZVRhYkxvb3A6IHRoaXMucHJvcHMuZW5hYmxlVGFiTG9vcCB9LFxuICAgICAgICAgICAgICAgIFJlYWN0LmNyZWF0ZUVsZW1lbnQoXCJkaXZcIiwgeyBjbGFzc05hbWU6IFwicmVhY3QtZGF0ZXBpY2tlcl9fcG9ydGFsXCIsIHRhYkluZGV4OiAtMSwgb25LZXlEb3duOiB0aGlzLm9uUG9ydGFsS2V5RG93biB9LCBjYWxlbmRhcikpKSA6IG51bGw7XG4gICAgICAgICAgICBpZiAodGhpcy5zdGF0ZS5vcGVuICYmIHRoaXMucHJvcHMucG9ydGFsSWQpIHtcbiAgICAgICAgICAgICAgICBwb3J0YWxDb250YWluZXIgPSAoUmVhY3QuY3JlYXRlRWxlbWVudChQb3J0YWwsIF9hc3NpZ24oeyBwb3J0YWxJZDogdGhpcy5wcm9wcy5wb3J0YWxJZCB9LCB0aGlzLnByb3BzKSwgcG9ydGFsQ29udGFpbmVyKSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gKFJlYWN0LmNyZWF0ZUVsZW1lbnQoXCJkaXZcIiwgbnVsbCxcbiAgICAgICAgICAgICAgICB0aGlzLnJlbmRlcklucHV0Q29udGFpbmVyKCksXG4gICAgICAgICAgICAgICAgcG9ydGFsQ29udGFpbmVyKSk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIChSZWFjdC5jcmVhdGVFbGVtZW50KFBvcHBlckNvbXBvbmVudCwgX2Fzc2lnbih7fSwgdGhpcy5wcm9wcywgeyBjbGFzc05hbWU6IHRoaXMucHJvcHMucG9wcGVyQ2xhc3NOYW1lLCBoaWRlUG9wcGVyOiAhdGhpcy5pc0NhbGVuZGFyT3BlbigpLCB0YXJnZXRDb21wb25lbnQ6IHRoaXMucmVuZGVySW5wdXRDb250YWluZXIoKSwgcG9wcGVyQ29tcG9uZW50OiBjYWxlbmRhciwgcG9wcGVyT25LZXlEb3duOiB0aGlzLm9uUG9wcGVyS2V5RG93biwgc2hvd0Fycm93OiB0aGlzLnByb3BzLnNob3dQb3BwZXJBcnJvdyB9KSkpO1xuICAgIH07XG4gICAgcmV0dXJuIERhdGVQaWNrZXI7XG59KENvbXBvbmVudCkpO1xudmFyIFBSRVNFTEVDVF9DSEFOR0VfVklBX0lOUFVUID0gXCJpbnB1dFwiO1xudmFyIFBSRVNFTEVDVF9DSEFOR0VfVklBX05BVklHQVRFID0gXCJuYXZpZ2F0ZVwiO1xuXG5leHBvcnQgeyBDYWxlbmRhckNvbnRhaW5lciwgRGF0ZVBpY2tlciwgRGF0ZVBpY2tlciBhcyBkZWZhdWx0LCBnZXREZWZhdWx0TG9jYWxlLCByZWdpc3RlckxvY2FsZSwgc2V0RGVmYXVsdExvY2FsZSB9O1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9aW5kZXguZXMuanMubWFwXG4iXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/react-datepicker/dist/index.es.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/react-datepicker/dist/react-datepicker.css":
/*!*****************************************************************!*\
  !*** ./node_modules/react-datepicker/dist/react-datepicker.css ***!
  \*****************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": () => (__WEBPACK_DEFAULT_EXPORT__)\n/* harmony export */ });\n/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (\"f9e39fc0b2ed\");\nif (false) {}\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvcmVhY3QtZGF0ZXBpY2tlci9kaXN0L3JlYWN0LWRhdGVwaWNrZXIuY3NzIiwibWFwcGluZ3MiOiI7Ozs7QUFBQSxpRUFBZSxjQUFjO0FBQzdCLElBQUksS0FBVSxFQUFFLEVBQXVCIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vaW52b2ljZS1hcHAvLi9ub2RlX21vZHVsZXMvcmVhY3QtZGF0ZXBpY2tlci9kaXN0L3JlYWN0LWRhdGVwaWNrZXIuY3NzP2MzNDQiXSwic291cmNlc0NvbnRlbnQiOlsiZXhwb3J0IGRlZmF1bHQgXCJmOWUzOWZjMGIyZWRcIlxuaWYgKG1vZHVsZS5ob3QpIHsgbW9kdWxlLmhvdC5hY2NlcHQoKSB9XG4iXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/react-datepicker/dist/react-datepicker.css\n");

/***/ }),

/***/ "(ssr)/./node_modules/react-datepicker/node_modules/@floating-ui/react/dist/floating-ui.react.mjs":
/*!**************************************************************************************************!*\
  !*** ./node_modules/react-datepicker/node_modules/@floating-ui/react/dist/floating-ui.react.mjs ***!
  \**************************************************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("var react__WEBPACK_IMPORTED_MODULE_0___namespace_cache;\n__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   Composite: () => (/* binding */ Composite),\n/* harmony export */   CompositeItem: () => (/* binding */ CompositeItem),\n/* harmony export */   FloatingArrow: () => (/* binding */ FloatingArrow),\n/* harmony export */   FloatingDelayGroup: () => (/* binding */ FloatingDelayGroup),\n/* harmony export */   FloatingFocusManager: () => (/* binding */ FloatingFocusManager),\n/* harmony export */   FloatingList: () => (/* binding */ FloatingList),\n/* harmony export */   FloatingNode: () => (/* binding */ FloatingNode),\n/* harmony export */   FloatingOverlay: () => (/* binding */ FloatingOverlay),\n/* harmony export */   FloatingPortal: () => (/* binding */ FloatingPortal),\n/* harmony export */   FloatingTree: () => (/* binding */ FloatingTree),\n/* harmony export */   NextFloatingDelayGroup: () => (/* binding */ NextFloatingDelayGroup),\n/* harmony export */   arrow: () => (/* reexport safe */ _floating_ui_react_dom__WEBPACK_IMPORTED_MODULE_3__.arrow),\n/* harmony export */   autoPlacement: () => (/* reexport safe */ _floating_ui_react_dom__WEBPACK_IMPORTED_MODULE_3__.autoPlacement),\n/* harmony export */   autoUpdate: () => (/* reexport safe */ _floating_ui_react_dom__WEBPACK_IMPORTED_MODULE_4__.autoUpdate),\n/* harmony export */   computePosition: () => (/* reexport safe */ _floating_ui_react_dom__WEBPACK_IMPORTED_MODULE_4__.computePosition),\n/* harmony export */   detectOverflow: () => (/* reexport safe */ _floating_ui_react_dom__WEBPACK_IMPORTED_MODULE_4__.detectOverflow),\n/* harmony export */   flip: () => (/* reexport safe */ _floating_ui_react_dom__WEBPACK_IMPORTED_MODULE_3__.flip),\n/* harmony export */   getOverflowAncestors: () => (/* reexport safe */ _floating_ui_react_dom__WEBPACK_IMPORTED_MODULE_5__.getOverflowAncestors),\n/* harmony export */   hide: () => (/* reexport safe */ _floating_ui_react_dom__WEBPACK_IMPORTED_MODULE_3__.hide),\n/* harmony export */   inline: () => (/* reexport safe */ _floating_ui_react_dom__WEBPACK_IMPORTED_MODULE_3__.inline),\n/* harmony export */   inner: () => (/* binding */ inner),\n/* harmony export */   limitShift: () => (/* reexport safe */ _floating_ui_react_dom__WEBPACK_IMPORTED_MODULE_3__.limitShift),\n/* harmony export */   offset: () => (/* reexport safe */ _floating_ui_react_dom__WEBPACK_IMPORTED_MODULE_3__.offset),\n/* harmony export */   platform: () => (/* reexport safe */ _floating_ui_react_dom__WEBPACK_IMPORTED_MODULE_4__.platform),\n/* harmony export */   safePolygon: () => (/* binding */ safePolygon),\n/* harmony export */   shift: () => (/* reexport safe */ _floating_ui_react_dom__WEBPACK_IMPORTED_MODULE_3__.shift),\n/* harmony export */   size: () => (/* reexport safe */ _floating_ui_react_dom__WEBPACK_IMPORTED_MODULE_3__.size),\n/* harmony export */   useClick: () => (/* binding */ useClick),\n/* harmony export */   useClientPoint: () => (/* binding */ useClientPoint),\n/* harmony export */   useDelayGroup: () => (/* binding */ useDelayGroup),\n/* harmony export */   useDelayGroupContext: () => (/* binding */ useDelayGroupContext),\n/* harmony export */   useDismiss: () => (/* binding */ useDismiss),\n/* harmony export */   useFloating: () => (/* binding */ useFloating),\n/* harmony export */   useFloatingNodeId: () => (/* binding */ useFloatingNodeId),\n/* harmony export */   useFloatingParentNodeId: () => (/* binding */ useFloatingParentNodeId),\n/* harmony export */   useFloatingPortalNode: () => (/* binding */ useFloatingPortalNode),\n/* harmony export */   useFloatingRootContext: () => (/* binding */ useFloatingRootContext),\n/* harmony export */   useFloatingTree: () => (/* binding */ useFloatingTree),\n/* harmony export */   useFocus: () => (/* binding */ useFocus),\n/* harmony export */   useHover: () => (/* binding */ useHover),\n/* harmony export */   useId: () => (/* binding */ useId),\n/* harmony export */   useInnerOffset: () => (/* binding */ useInnerOffset),\n/* harmony export */   useInteractions: () => (/* binding */ useInteractions),\n/* harmony export */   useListItem: () => (/* binding */ useListItem),\n/* harmony export */   useListNavigation: () => (/* binding */ useListNavigation),\n/* harmony export */   useMergeRefs: () => (/* binding */ useMergeRefs),\n/* harmony export */   useNextDelayGroup: () => (/* binding */ useNextDelayGroup),\n/* harmony export */   useRole: () => (/* binding */ useRole),\n/* harmony export */   useTransitionStatus: () => (/* binding */ useTransitionStatus),\n/* harmony export */   useTransitionStyles: () => (/* binding */ useTransitionStyles),\n/* harmony export */   useTypeahead: () => (/* binding */ useTypeahead)\n/* harmony export */ });\n/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! react */ \"(ssr)/./node_modules/next/dist/server/future/route-modules/app-page/vendored/ssr/react.js\");\n/* harmony import */ var _floating_ui_react_utils__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! @floating-ui/react/utils */ \"(ssr)/./node_modules/react-datepicker/node_modules/@floating-ui/react/dist/floating-ui.react.utils.mjs\");\n/* harmony import */ var react_jsx_runtime__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! react/jsx-runtime */ \"(ssr)/./node_modules/next/dist/server/future/route-modules/app-page/vendored/ssr/react-jsx-runtime.js\");\n/* harmony import */ var _floating_ui_react_dom__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! @floating-ui/react-dom */ \"(ssr)/./node_modules/@floating-ui/utils/dist/floating-ui.utils.dom.mjs\");\n/* harmony import */ var tabbable__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! tabbable */ \"(ssr)/./node_modules/tabbable/dist/index.esm.js\");\n/* harmony import */ var react_dom__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! react-dom */ \"(ssr)/./node_modules/next/dist/server/future/route-modules/app-page/vendored/ssr/react-dom.js\");\n/* harmony import */ var _floating_ui_react_dom__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! @floating-ui/react-dom */ \"(ssr)/./node_modules/react-datepicker/node_modules/@floating-ui/react/node_modules/@floating-ui/react-dom/dist/floating-ui.react-dom.mjs\");\n/* harmony import */ var _floating_ui_react_dom__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! @floating-ui/react-dom */ \"(ssr)/./node_modules/@floating-ui/dom/dist/floating-ui.dom.mjs\");\n/* harmony import */ var _floating_ui_utils__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(/*! @floating-ui/utils */ \"(ssr)/./node_modules/@floating-ui/utils/dist/floating-ui.utils.mjs\");\n\n\n\n\n\n\n\n\n\n\n/**\n * Merges an array of refs into a single memoized callback ref or `null`.\n * @see https://floating-ui.com/docs/react-utils#usemergerefs\n */\nfunction useMergeRefs(refs) {\n  const cleanupRef = react__WEBPACK_IMPORTED_MODULE_0__.useRef(undefined);\n  const refEffect = react__WEBPACK_IMPORTED_MODULE_0__.useCallback(instance => {\n    const cleanups = refs.map(ref => {\n      if (ref == null) {\n        return;\n      }\n      if (typeof ref === 'function') {\n        const refCallback = ref;\n        const refCleanup = refCallback(instance);\n        return typeof refCleanup === 'function' ? refCleanup : () => {\n          refCallback(null);\n        };\n      }\n      ref.current = instance;\n      return () => {\n        ref.current = null;\n      };\n    });\n    return () => {\n      cleanups.forEach(refCleanup => refCleanup == null ? void 0 : refCleanup());\n    };\n    // eslint-disable-next-line react-hooks/exhaustive-deps\n  }, refs);\n  return react__WEBPACK_IMPORTED_MODULE_0__.useMemo(() => {\n    if (refs.every(ref => ref == null)) {\n      return null;\n    }\n    return value => {\n      if (cleanupRef.current) {\n        cleanupRef.current();\n        cleanupRef.current = undefined;\n      }\n      if (value != null) {\n        cleanupRef.current = refEffect(value);\n      }\n    };\n    // eslint-disable-next-line react-hooks/exhaustive-deps\n  }, refs);\n}\n\nfunction sortByDocumentPosition(a, b) {\n  const position = a.compareDocumentPosition(b);\n  if (position & Node.DOCUMENT_POSITION_FOLLOWING || position & Node.DOCUMENT_POSITION_CONTAINED_BY) {\n    return -1;\n  }\n  if (position & Node.DOCUMENT_POSITION_PRECEDING || position & Node.DOCUMENT_POSITION_CONTAINS) {\n    return 1;\n  }\n  return 0;\n}\nconst FloatingListContext = /*#__PURE__*/react__WEBPACK_IMPORTED_MODULE_0__.createContext({\n  register: () => {},\n  unregister: () => {},\n  map: /*#__PURE__*/new Map(),\n  elementsRef: {\n    current: []\n  }\n});\n/**\n * Provides context for a list of items within the floating element.\n * @see https://floating-ui.com/docs/FloatingList\n */\nfunction FloatingList(props) {\n  const {\n    children,\n    elementsRef,\n    labelsRef\n  } = props;\n  const [nodes, setNodes] = react__WEBPACK_IMPORTED_MODULE_0__.useState(() => new Set());\n  const register = react__WEBPACK_IMPORTED_MODULE_0__.useCallback(node => {\n    setNodes(prevSet => new Set(prevSet).add(node));\n  }, []);\n  const unregister = react__WEBPACK_IMPORTED_MODULE_0__.useCallback(node => {\n    setNodes(prevSet => {\n      const set = new Set(prevSet);\n      set.delete(node);\n      return set;\n    });\n  }, []);\n  const map = react__WEBPACK_IMPORTED_MODULE_0__.useMemo(() => {\n    const newMap = new Map();\n    const sortedNodes = Array.from(nodes.keys()).sort(sortByDocumentPosition);\n    sortedNodes.forEach((node, index) => {\n      newMap.set(node, index);\n    });\n    return newMap;\n  }, [nodes]);\n  return /*#__PURE__*/(0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_1__.jsx)(FloatingListContext.Provider, {\n    value: react__WEBPACK_IMPORTED_MODULE_0__.useMemo(() => ({\n      register,\n      unregister,\n      map,\n      elementsRef,\n      labelsRef\n    }), [register, unregister, map, elementsRef, labelsRef]),\n    children: children\n  });\n}\n/**\n * Used to register a list item and its index (DOM position) in the\n * `FloatingList`.\n * @see https://floating-ui.com/docs/FloatingList#uselistitem\n */\nfunction useListItem(props) {\n  if (props === void 0) {\n    props = {};\n  }\n  const {\n    label\n  } = props;\n  const {\n    register,\n    unregister,\n    map,\n    elementsRef,\n    labelsRef\n  } = react__WEBPACK_IMPORTED_MODULE_0__.useContext(FloatingListContext);\n  const [index, setIndex] = react__WEBPACK_IMPORTED_MODULE_0__.useState(null);\n  const componentRef = react__WEBPACK_IMPORTED_MODULE_0__.useRef(null);\n  const ref = react__WEBPACK_IMPORTED_MODULE_0__.useCallback(node => {\n    componentRef.current = node;\n    if (index !== null) {\n      elementsRef.current[index] = node;\n      if (labelsRef) {\n        var _node$textContent;\n        const isLabelDefined = label !== undefined;\n        labelsRef.current[index] = isLabelDefined ? label : (_node$textContent = node == null ? void 0 : node.textContent) != null ? _node$textContent : null;\n      }\n    }\n  }, [index, elementsRef, labelsRef, label]);\n  (0,_floating_ui_react_utils__WEBPACK_IMPORTED_MODULE_6__.useModernLayoutEffect)(() => {\n    const node = componentRef.current;\n    if (node) {\n      register(node);\n      return () => {\n        unregister(node);\n      };\n    }\n  }, [register, unregister]);\n  (0,_floating_ui_react_utils__WEBPACK_IMPORTED_MODULE_6__.useModernLayoutEffect)(() => {\n    const index = componentRef.current ? map.get(componentRef.current) : null;\n    if (index != null) {\n      setIndex(index);\n    }\n  }, [map]);\n  return react__WEBPACK_IMPORTED_MODULE_0__.useMemo(() => ({\n    ref,\n    index: index == null ? -1 : index\n  }), [index, ref]);\n}\n\nconst FOCUSABLE_ATTRIBUTE = 'data-floating-ui-focusable';\nconst ACTIVE_KEY = 'active';\nconst SELECTED_KEY = 'selected';\nconst ARROW_LEFT = 'ArrowLeft';\nconst ARROW_RIGHT = 'ArrowRight';\nconst ARROW_UP = 'ArrowUp';\nconst ARROW_DOWN = 'ArrowDown';\n\nfunction renderJsx(render, computedProps) {\n  if (typeof render === 'function') {\n    return render(computedProps);\n  }\n  if (render) {\n    return /*#__PURE__*/react__WEBPACK_IMPORTED_MODULE_0__.cloneElement(render, computedProps);\n  }\n  return /*#__PURE__*/(0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_1__.jsx)(\"div\", {\n    ...computedProps\n  });\n}\nconst CompositeContext = /*#__PURE__*/react__WEBPACK_IMPORTED_MODULE_0__.createContext({\n  activeIndex: 0,\n  onNavigate: () => {}\n});\nconst horizontalKeys = [ARROW_LEFT, ARROW_RIGHT];\nconst verticalKeys = [ARROW_UP, ARROW_DOWN];\nconst allKeys = [...horizontalKeys, ...verticalKeys];\n\n/**\n * Creates a single tab stop whose items are navigated by arrow keys, which\n * provides list navigation outside of floating element contexts.\n *\n * This is useful to enable navigation of a list of items that arent part of a\n * floating element. A menubar is an example of a composite, with each reference\n * element being an item.\n * @see https://floating-ui.com/docs/Composite\n */\nconst Composite = /*#__PURE__*/react__WEBPACK_IMPORTED_MODULE_0__.forwardRef(function Composite(props, forwardedRef) {\n  const {\n    render,\n    orientation = 'both',\n    loop = true,\n    rtl = false,\n    cols = 1,\n    disabledIndices,\n    activeIndex: externalActiveIndex,\n    onNavigate: externalSetActiveIndex,\n    itemSizes,\n    dense = false,\n    ...domProps\n  } = props;\n  const [internalActiveIndex, internalSetActiveIndex] = react__WEBPACK_IMPORTED_MODULE_0__.useState(0);\n  const activeIndex = externalActiveIndex != null ? externalActiveIndex : internalActiveIndex;\n  const onNavigate = (0,_floating_ui_react_utils__WEBPACK_IMPORTED_MODULE_6__.useEffectEvent)(externalSetActiveIndex != null ? externalSetActiveIndex : internalSetActiveIndex);\n  const elementsRef = react__WEBPACK_IMPORTED_MODULE_0__.useRef([]);\n  const renderElementProps = render && typeof render !== 'function' ? render.props : {};\n  const contextValue = react__WEBPACK_IMPORTED_MODULE_0__.useMemo(() => ({\n    activeIndex,\n    onNavigate\n  }), [activeIndex, onNavigate]);\n  const isGrid = cols > 1;\n  function handleKeyDown(event) {\n    if (!allKeys.includes(event.key)) return;\n    let nextIndex = activeIndex;\n    const minIndex = (0,_floating_ui_react_utils__WEBPACK_IMPORTED_MODULE_6__.getMinListIndex)(elementsRef, disabledIndices);\n    const maxIndex = (0,_floating_ui_react_utils__WEBPACK_IMPORTED_MODULE_6__.getMaxListIndex)(elementsRef, disabledIndices);\n    const horizontalEndKey = rtl ? ARROW_LEFT : ARROW_RIGHT;\n    const horizontalStartKey = rtl ? ARROW_RIGHT : ARROW_LEFT;\n    if (isGrid) {\n      const sizes = itemSizes || Array.from({\n        length: elementsRef.current.length\n      }, () => ({\n        width: 1,\n        height: 1\n      }));\n      // To calculate movements on the grid, we use hypothetical cell indices\n      // as if every item was 1x1, then convert back to real indices.\n      const cellMap = (0,_floating_ui_react_utils__WEBPACK_IMPORTED_MODULE_6__.createGridCellMap)(sizes, cols, dense);\n      const minGridIndex = cellMap.findIndex(index => index != null && !(0,_floating_ui_react_utils__WEBPACK_IMPORTED_MODULE_6__.isListIndexDisabled)(elementsRef, index, disabledIndices));\n      // last enabled index\n      const maxGridIndex = cellMap.reduce((foundIndex, index, cellIndex) => index != null && !(0,_floating_ui_react_utils__WEBPACK_IMPORTED_MODULE_6__.isListIndexDisabled)(elementsRef, index, disabledIndices) ? cellIndex : foundIndex, -1);\n      const maybeNextIndex = cellMap[(0,_floating_ui_react_utils__WEBPACK_IMPORTED_MODULE_6__.getGridNavigatedIndex)({\n        current: cellMap.map(itemIndex => itemIndex ? elementsRef.current[itemIndex] : null)\n      }, {\n        event,\n        orientation,\n        loop,\n        rtl,\n        cols,\n        // treat undefined (empty grid spaces) as disabled indices so we\n        // don't end up in them\n        disabledIndices: (0,_floating_ui_react_utils__WEBPACK_IMPORTED_MODULE_6__.getGridCellIndices)([...((typeof disabledIndices !== 'function' ? disabledIndices : null) || elementsRef.current.map((_, index) => (0,_floating_ui_react_utils__WEBPACK_IMPORTED_MODULE_6__.isListIndexDisabled)(elementsRef, index, disabledIndices) ? index : undefined)), undefined], cellMap),\n        minIndex: minGridIndex,\n        maxIndex: maxGridIndex,\n        prevIndex: (0,_floating_ui_react_utils__WEBPACK_IMPORTED_MODULE_6__.getGridCellIndexOfCorner)(activeIndex > maxIndex ? minIndex : activeIndex, sizes, cellMap, cols,\n        // use a corner matching the edge closest to the direction we're\n        // moving in so we don't end up in the same item. Prefer\n        // top/left over bottom/right.\n        event.key === ARROW_DOWN ? 'bl' : event.key === horizontalEndKey ? 'tr' : 'tl')\n      })];\n      if (maybeNextIndex != null) {\n        nextIndex = maybeNextIndex;\n      }\n    }\n    const toEndKeys = {\n      horizontal: [horizontalEndKey],\n      vertical: [ARROW_DOWN],\n      both: [horizontalEndKey, ARROW_DOWN]\n    }[orientation];\n    const toStartKeys = {\n      horizontal: [horizontalStartKey],\n      vertical: [ARROW_UP],\n      both: [horizontalStartKey, ARROW_UP]\n    }[orientation];\n    const preventedKeys = isGrid ? allKeys : {\n      horizontal: horizontalKeys,\n      vertical: verticalKeys,\n      both: allKeys\n    }[orientation];\n    if (nextIndex === activeIndex && [...toEndKeys, ...toStartKeys].includes(event.key)) {\n      if (loop && nextIndex === maxIndex && toEndKeys.includes(event.key)) {\n        nextIndex = minIndex;\n      } else if (loop && nextIndex === minIndex && toStartKeys.includes(event.key)) {\n        nextIndex = maxIndex;\n      } else {\n        nextIndex = (0,_floating_ui_react_utils__WEBPACK_IMPORTED_MODULE_6__.findNonDisabledListIndex)(elementsRef, {\n          startingIndex: nextIndex,\n          decrement: toStartKeys.includes(event.key),\n          disabledIndices\n        });\n      }\n    }\n    if (nextIndex !== activeIndex && !(0,_floating_ui_react_utils__WEBPACK_IMPORTED_MODULE_6__.isIndexOutOfListBounds)(elementsRef, nextIndex)) {\n      var _elementsRef$current$;\n      event.stopPropagation();\n      if (preventedKeys.includes(event.key)) {\n        event.preventDefault();\n      }\n      onNavigate(nextIndex);\n      (_elementsRef$current$ = elementsRef.current[nextIndex]) == null || _elementsRef$current$.focus();\n    }\n  }\n  const computedProps = {\n    ...domProps,\n    ...renderElementProps,\n    ref: forwardedRef,\n    'aria-orientation': orientation === 'both' ? undefined : orientation,\n    onKeyDown(e) {\n      domProps.onKeyDown == null || domProps.onKeyDown(e);\n      renderElementProps.onKeyDown == null || renderElementProps.onKeyDown(e);\n      handleKeyDown(e);\n    }\n  };\n  return /*#__PURE__*/(0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_1__.jsx)(CompositeContext.Provider, {\n    value: contextValue,\n    children: /*#__PURE__*/(0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_1__.jsx)(FloatingList, {\n      elementsRef: elementsRef,\n      children: renderJsx(render, computedProps)\n    })\n  });\n});\n/**\n * @see https://floating-ui.com/docs/Composite\n */\nconst CompositeItem = /*#__PURE__*/react__WEBPACK_IMPORTED_MODULE_0__.forwardRef(function CompositeItem(props, forwardedRef) {\n  const {\n    render,\n    ...domProps\n  } = props;\n  const renderElementProps = render && typeof render !== 'function' ? render.props : {};\n  const {\n    activeIndex,\n    onNavigate\n  } = react__WEBPACK_IMPORTED_MODULE_0__.useContext(CompositeContext);\n  const {\n    ref,\n    index\n  } = useListItem();\n  const mergedRef = useMergeRefs([ref, forwardedRef, renderElementProps.ref]);\n  const isActive = activeIndex === index;\n  const computedProps = {\n    ...domProps,\n    ...renderElementProps,\n    ref: mergedRef,\n    tabIndex: isActive ? 0 : -1,\n    'data-active': isActive ? '' : undefined,\n    onFocus(e) {\n      domProps.onFocus == null || domProps.onFocus(e);\n      renderElementProps.onFocus == null || renderElementProps.onFocus(e);\n      onNavigate(index);\n    }\n  };\n  return renderJsx(render, computedProps);\n});\n\n// https://github.com/mui/material-ui/issues/41190#issuecomment-2040873379\nconst SafeReact = {\n  .../*#__PURE__*/ (react__WEBPACK_IMPORTED_MODULE_0___namespace_cache || (react__WEBPACK_IMPORTED_MODULE_0___namespace_cache = __webpack_require__.t(react__WEBPACK_IMPORTED_MODULE_0__, 2)))\n};\n\nlet serverHandoffComplete = false;\nlet count = 0;\nconst genId = () => // Ensure the id is unique with multiple independent versions of Floating UI\n// on <React 18\n\"floating-ui-\" + Math.random().toString(36).slice(2, 6) + count++;\nfunction useFloatingId() {\n  const [id, setId] = react__WEBPACK_IMPORTED_MODULE_0__.useState(() => serverHandoffComplete ? genId() : undefined);\n  (0,_floating_ui_react_utils__WEBPACK_IMPORTED_MODULE_6__.useModernLayoutEffect)(() => {\n    if (id == null) {\n      setId(genId());\n    }\n    // eslint-disable-next-line react-hooks/exhaustive-deps\n  }, []);\n  react__WEBPACK_IMPORTED_MODULE_0__.useEffect(() => {\n    serverHandoffComplete = true;\n  }, []);\n  return id;\n}\nconst useReactId = SafeReact.useId;\n\n/**\n * Uses React 18's built-in `useId()` when available, or falls back to a\n * slightly less performant (requiring a double render) implementation for\n * earlier React versions.\n * @see https://floating-ui.com/docs/react-utils#useid\n */\nconst useId = useReactId || useFloatingId;\n\nlet devMessageSet;\nif (true) {\n  devMessageSet = /*#__PURE__*/new Set();\n}\nfunction warn() {\n  var _devMessageSet;\n  for (var _len = arguments.length, messages = new Array(_len), _key = 0; _key < _len; _key++) {\n    messages[_key] = arguments[_key];\n  }\n  const message = \"Floating UI: \" + messages.join(' ');\n  if (!((_devMessageSet = devMessageSet) != null && _devMessageSet.has(message))) {\n    var _devMessageSet2;\n    (_devMessageSet2 = devMessageSet) == null || _devMessageSet2.add(message);\n    console.warn(message);\n  }\n}\nfunction error() {\n  var _devMessageSet3;\n  for (var _len2 = arguments.length, messages = new Array(_len2), _key2 = 0; _key2 < _len2; _key2++) {\n    messages[_key2] = arguments[_key2];\n  }\n  const message = \"Floating UI: \" + messages.join(' ');\n  if (!((_devMessageSet3 = devMessageSet) != null && _devMessageSet3.has(message))) {\n    var _devMessageSet4;\n    (_devMessageSet4 = devMessageSet) == null || _devMessageSet4.add(message);\n    console.error(message);\n  }\n}\n\n/**\n * Renders a pointing arrow triangle.\n * @see https://floating-ui.com/docs/FloatingArrow\n */\nconst FloatingArrow = /*#__PURE__*/react__WEBPACK_IMPORTED_MODULE_0__.forwardRef(function FloatingArrow(props, ref) {\n  const {\n    context: {\n      placement,\n      elements: {\n        floating\n      },\n      middlewareData: {\n        arrow,\n        shift\n      }\n    },\n    width = 14,\n    height = 7,\n    tipRadius = 0,\n    strokeWidth = 0,\n    staticOffset,\n    stroke,\n    d,\n    style: {\n      transform,\n      ...restStyle\n    } = {},\n    ...rest\n  } = props;\n  if (true) {\n    if (!ref) {\n      warn('The `ref` prop is required for `FloatingArrow`.');\n    }\n  }\n  const clipPathId = useId();\n  const [isRTL, setIsRTL] = react__WEBPACK_IMPORTED_MODULE_0__.useState(false);\n\n  // https://github.com/floating-ui/floating-ui/issues/2932\n  (0,_floating_ui_react_utils__WEBPACK_IMPORTED_MODULE_6__.useModernLayoutEffect)(() => {\n    if (!floating) return;\n    const isRTL = (0,_floating_ui_react_dom__WEBPACK_IMPORTED_MODULE_5__.getComputedStyle)(floating).direction === 'rtl';\n    if (isRTL) {\n      setIsRTL(true);\n    }\n  }, [floating]);\n  if (!floating) {\n    return null;\n  }\n  const [side, alignment] = placement.split('-');\n  const isVerticalSide = side === 'top' || side === 'bottom';\n  let computedStaticOffset = staticOffset;\n  if (isVerticalSide && shift != null && shift.x || !isVerticalSide && shift != null && shift.y) {\n    computedStaticOffset = null;\n  }\n\n  // Strokes must be double the border width, this ensures the stroke's width\n  // works as you'd expect.\n  const computedStrokeWidth = strokeWidth * 2;\n  const halfStrokeWidth = computedStrokeWidth / 2;\n  const svgX = width / 2 * (tipRadius / -8 + 1);\n  const svgY = height / 2 * tipRadius / 4;\n  const isCustomShape = !!d;\n  const yOffsetProp = computedStaticOffset && alignment === 'end' ? 'bottom' : 'top';\n  let xOffsetProp = computedStaticOffset && alignment === 'end' ? 'right' : 'left';\n  if (computedStaticOffset && isRTL) {\n    xOffsetProp = alignment === 'end' ? 'left' : 'right';\n  }\n  const arrowX = (arrow == null ? void 0 : arrow.x) != null ? computedStaticOffset || arrow.x : '';\n  const arrowY = (arrow == null ? void 0 : arrow.y) != null ? computedStaticOffset || arrow.y : '';\n  const dValue = d || 'M0,0' + (\" H\" + width) + (\" L\" + (width - svgX) + \",\" + (height - svgY)) + (\" Q\" + width / 2 + \",\" + height + \" \" + svgX + \",\" + (height - svgY)) + ' Z';\n  const rotation = {\n    top: isCustomShape ? 'rotate(180deg)' : '',\n    left: isCustomShape ? 'rotate(90deg)' : 'rotate(-90deg)',\n    bottom: isCustomShape ? '' : 'rotate(180deg)',\n    right: isCustomShape ? 'rotate(-90deg)' : 'rotate(90deg)'\n  }[side];\n  return /*#__PURE__*/(0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_1__.jsxs)(\"svg\", {\n    ...rest,\n    \"aria-hidden\": true,\n    ref: ref,\n    width: isCustomShape ? width : width + computedStrokeWidth,\n    height: width,\n    viewBox: \"0 0 \" + width + \" \" + (height > width ? height : width),\n    style: {\n      position: 'absolute',\n      pointerEvents: 'none',\n      [xOffsetProp]: arrowX,\n      [yOffsetProp]: arrowY,\n      [side]: isVerticalSide || isCustomShape ? '100%' : \"calc(100% - \" + computedStrokeWidth / 2 + \"px)\",\n      transform: [rotation, transform].filter(t => !!t).join(' '),\n      ...restStyle\n    },\n    children: [computedStrokeWidth > 0 && /*#__PURE__*/(0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_1__.jsx)(\"path\", {\n      clipPath: \"url(#\" + clipPathId + \")\",\n      fill: \"none\",\n      stroke: stroke\n      // Account for the stroke on the fill path rendered below.\n      ,\n      strokeWidth: computedStrokeWidth + (d ? 0 : 1),\n      d: dValue\n    }), /*#__PURE__*/(0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_1__.jsx)(\"path\", {\n      stroke: computedStrokeWidth && !d ? rest.fill : 'none',\n      d: dValue\n    }), /*#__PURE__*/(0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_1__.jsx)(\"clipPath\", {\n      id: clipPathId,\n      children: /*#__PURE__*/(0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_1__.jsx)(\"rect\", {\n        x: -halfStrokeWidth,\n        y: halfStrokeWidth * (isCustomShape ? -1 : 1),\n        width: width + computedStrokeWidth,\n        height: width\n      })\n    })]\n  });\n});\n\nfunction createEventEmitter() {\n  const map = new Map();\n  return {\n    emit(event, data) {\n      var _map$get;\n      (_map$get = map.get(event)) == null || _map$get.forEach(listener => listener(data));\n    },\n    on(event, listener) {\n      if (!map.has(event)) {\n        map.set(event, new Set());\n      }\n      map.get(event).add(listener);\n    },\n    off(event, listener) {\n      var _map$get2;\n      (_map$get2 = map.get(event)) == null || _map$get2.delete(listener);\n    }\n  };\n}\n\nconst FloatingNodeContext = /*#__PURE__*/react__WEBPACK_IMPORTED_MODULE_0__.createContext(null);\nconst FloatingTreeContext = /*#__PURE__*/react__WEBPACK_IMPORTED_MODULE_0__.createContext(null);\n\n/**\n * Returns the parent node id for nested floating elements, if available.\n * Returns `null` for top-level floating elements.\n */\nconst useFloatingParentNodeId = () => {\n  var _React$useContext;\n  return ((_React$useContext = react__WEBPACK_IMPORTED_MODULE_0__.useContext(FloatingNodeContext)) == null ? void 0 : _React$useContext.id) || null;\n};\n\n/**\n * Returns the nearest floating tree context, if available.\n */\nconst useFloatingTree = () => react__WEBPACK_IMPORTED_MODULE_0__.useContext(FloatingTreeContext);\n\n/**\n * Registers a node into the `FloatingTree`, returning its id.\n * @see https://floating-ui.com/docs/FloatingTree\n */\nfunction useFloatingNodeId(customParentId) {\n  const id = useId();\n  const tree = useFloatingTree();\n  const reactParentId = useFloatingParentNodeId();\n  const parentId = customParentId || reactParentId;\n  (0,_floating_ui_react_utils__WEBPACK_IMPORTED_MODULE_6__.useModernLayoutEffect)(() => {\n    if (!id) return;\n    const node = {\n      id,\n      parentId\n    };\n    tree == null || tree.addNode(node);\n    return () => {\n      tree == null || tree.removeNode(node);\n    };\n  }, [tree, id, parentId]);\n  return id;\n}\n/**\n * Provides parent node context for nested floating elements.\n * @see https://floating-ui.com/docs/FloatingTree\n */\nfunction FloatingNode(props) {\n  const {\n    children,\n    id\n  } = props;\n  const parentId = useFloatingParentNodeId();\n  return /*#__PURE__*/(0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_1__.jsx)(FloatingNodeContext.Provider, {\n    value: react__WEBPACK_IMPORTED_MODULE_0__.useMemo(() => ({\n      id,\n      parentId\n    }), [id, parentId]),\n    children: children\n  });\n}\n/**\n * Provides context for nested floating elements when they are not children of\n * each other on the DOM.\n * This is not necessary in all cases, except when there must be explicit communication between parent and child floating elements. It is necessary for:\n * - The `bubbles` option in the `useDismiss()` Hook\n * - Nested virtual list navigation\n * - Nested floating elements that each open on hover\n * - Custom communication between parent and child floating elements\n * @see https://floating-ui.com/docs/FloatingTree\n */\nfunction FloatingTree(props) {\n  const {\n    children\n  } = props;\n  const nodesRef = react__WEBPACK_IMPORTED_MODULE_0__.useRef([]);\n  const addNode = react__WEBPACK_IMPORTED_MODULE_0__.useCallback(node => {\n    nodesRef.current = [...nodesRef.current, node];\n  }, []);\n  const removeNode = react__WEBPACK_IMPORTED_MODULE_0__.useCallback(node => {\n    nodesRef.current = nodesRef.current.filter(n => n !== node);\n  }, []);\n  const [events] = react__WEBPACK_IMPORTED_MODULE_0__.useState(() => createEventEmitter());\n  return /*#__PURE__*/(0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_1__.jsx)(FloatingTreeContext.Provider, {\n    value: react__WEBPACK_IMPORTED_MODULE_0__.useMemo(() => ({\n      nodesRef,\n      addNode,\n      removeNode,\n      events\n    }), [addNode, removeNode, events]),\n    children: children\n  });\n}\n\nfunction createAttribute(name) {\n  return \"data-floating-ui-\" + name;\n}\n\nfunction clearTimeoutIfSet(timeoutRef) {\n  if (timeoutRef.current !== -1) {\n    clearTimeout(timeoutRef.current);\n    timeoutRef.current = -1;\n  }\n}\n\nconst safePolygonIdentifier = /*#__PURE__*/createAttribute('safe-polygon');\nfunction getDelay(value, prop, pointerType) {\n  if (pointerType && !(0,_floating_ui_react_utils__WEBPACK_IMPORTED_MODULE_6__.isMouseLikePointerType)(pointerType)) {\n    return 0;\n  }\n  if (typeof value === 'number') {\n    return value;\n  }\n  if (typeof value === 'function') {\n    const result = value();\n    if (typeof result === 'number') {\n      return result;\n    }\n    return result == null ? void 0 : result[prop];\n  }\n  return value == null ? void 0 : value[prop];\n}\nfunction getRestMs(value) {\n  if (typeof value === 'function') {\n    return value();\n  }\n  return value;\n}\n/**\n * Opens the floating element while hovering over the reference element, like\n * CSS `:hover`.\n * @see https://floating-ui.com/docs/useHover\n */\nfunction useHover(context, props) {\n  if (props === void 0) {\n    props = {};\n  }\n  const {\n    open,\n    onOpenChange,\n    dataRef,\n    events,\n    elements\n  } = context;\n  const {\n    enabled = true,\n    delay = 0,\n    handleClose = null,\n    mouseOnly = false,\n    restMs = 0,\n    move = true\n  } = props;\n  const tree = useFloatingTree();\n  const parentId = useFloatingParentNodeId();\n  const handleCloseRef = (0,_floating_ui_react_utils__WEBPACK_IMPORTED_MODULE_6__.useLatestRef)(handleClose);\n  const delayRef = (0,_floating_ui_react_utils__WEBPACK_IMPORTED_MODULE_6__.useLatestRef)(delay);\n  const openRef = (0,_floating_ui_react_utils__WEBPACK_IMPORTED_MODULE_6__.useLatestRef)(open);\n  const restMsRef = (0,_floating_ui_react_utils__WEBPACK_IMPORTED_MODULE_6__.useLatestRef)(restMs);\n  const pointerTypeRef = react__WEBPACK_IMPORTED_MODULE_0__.useRef();\n  const timeoutRef = react__WEBPACK_IMPORTED_MODULE_0__.useRef(-1);\n  const handlerRef = react__WEBPACK_IMPORTED_MODULE_0__.useRef();\n  const restTimeoutRef = react__WEBPACK_IMPORTED_MODULE_0__.useRef(-1);\n  const blockMouseMoveRef = react__WEBPACK_IMPORTED_MODULE_0__.useRef(true);\n  const performedPointerEventsMutationRef = react__WEBPACK_IMPORTED_MODULE_0__.useRef(false);\n  const unbindMouseMoveRef = react__WEBPACK_IMPORTED_MODULE_0__.useRef(() => {});\n  const restTimeoutPendingRef = react__WEBPACK_IMPORTED_MODULE_0__.useRef(false);\n  const isHoverOpen = (0,_floating_ui_react_utils__WEBPACK_IMPORTED_MODULE_6__.useEffectEvent)(() => {\n    var _dataRef$current$open;\n    const type = (_dataRef$current$open = dataRef.current.openEvent) == null ? void 0 : _dataRef$current$open.type;\n    return (type == null ? void 0 : type.includes('mouse')) && type !== 'mousedown';\n  });\n\n  // When closing before opening, clear the delay timeouts to cancel it\n  // from showing.\n  react__WEBPACK_IMPORTED_MODULE_0__.useEffect(() => {\n    if (!enabled) return;\n    function onOpenChange(_ref) {\n      let {\n        open\n      } = _ref;\n      if (!open) {\n        clearTimeoutIfSet(timeoutRef);\n        clearTimeoutIfSet(restTimeoutRef);\n        blockMouseMoveRef.current = true;\n        restTimeoutPendingRef.current = false;\n      }\n    }\n    events.on('openchange', onOpenChange);\n    return () => {\n      events.off('openchange', onOpenChange);\n    };\n  }, [enabled, events]);\n  react__WEBPACK_IMPORTED_MODULE_0__.useEffect(() => {\n    if (!enabled) return;\n    if (!handleCloseRef.current) return;\n    if (!open) return;\n    function onLeave(event) {\n      if (isHoverOpen()) {\n        onOpenChange(false, event, 'hover');\n      }\n    }\n    const html = (0,_floating_ui_react_utils__WEBPACK_IMPORTED_MODULE_6__.getDocument)(elements.floating).documentElement;\n    html.addEventListener('mouseleave', onLeave);\n    return () => {\n      html.removeEventListener('mouseleave', onLeave);\n    };\n  }, [elements.floating, open, onOpenChange, enabled, handleCloseRef, isHoverOpen]);\n  const closeWithDelay = react__WEBPACK_IMPORTED_MODULE_0__.useCallback(function (event, runElseBranch, reason) {\n    if (runElseBranch === void 0) {\n      runElseBranch = true;\n    }\n    if (reason === void 0) {\n      reason = 'hover';\n    }\n    const closeDelay = getDelay(delayRef.current, 'close', pointerTypeRef.current);\n    if (closeDelay && !handlerRef.current) {\n      clearTimeoutIfSet(timeoutRef);\n      timeoutRef.current = window.setTimeout(() => onOpenChange(false, event, reason), closeDelay);\n    } else if (runElseBranch) {\n      clearTimeoutIfSet(timeoutRef);\n      onOpenChange(false, event, reason);\n    }\n  }, [delayRef, onOpenChange]);\n  const cleanupMouseMoveHandler = (0,_floating_ui_react_utils__WEBPACK_IMPORTED_MODULE_6__.useEffectEvent)(() => {\n    unbindMouseMoveRef.current();\n    handlerRef.current = undefined;\n  });\n  const clearPointerEvents = (0,_floating_ui_react_utils__WEBPACK_IMPORTED_MODULE_6__.useEffectEvent)(() => {\n    if (performedPointerEventsMutationRef.current) {\n      const body = (0,_floating_ui_react_utils__WEBPACK_IMPORTED_MODULE_6__.getDocument)(elements.floating).body;\n      body.style.pointerEvents = '';\n      body.removeAttribute(safePolygonIdentifier);\n      performedPointerEventsMutationRef.current = false;\n    }\n  });\n  const isClickLikeOpenEvent = (0,_floating_ui_react_utils__WEBPACK_IMPORTED_MODULE_6__.useEffectEvent)(() => {\n    return dataRef.current.openEvent ? ['click', 'mousedown'].includes(dataRef.current.openEvent.type) : false;\n  });\n\n  // Registering the mouse events on the reference directly to bypass React's\n  // delegation system. If the cursor was on a disabled element and then entered\n  // the reference (no gap), `mouseenter` doesn't fire in the delegation system.\n  react__WEBPACK_IMPORTED_MODULE_0__.useEffect(() => {\n    if (!enabled) return;\n    function onReferenceMouseEnter(event) {\n      clearTimeoutIfSet(timeoutRef);\n      blockMouseMoveRef.current = false;\n      if (mouseOnly && !(0,_floating_ui_react_utils__WEBPACK_IMPORTED_MODULE_6__.isMouseLikePointerType)(pointerTypeRef.current) || getRestMs(restMsRef.current) > 0 && !getDelay(delayRef.current, 'open')) {\n        return;\n      }\n      const openDelay = getDelay(delayRef.current, 'open', pointerTypeRef.current);\n      if (openDelay) {\n        timeoutRef.current = window.setTimeout(() => {\n          if (!openRef.current) {\n            onOpenChange(true, event, 'hover');\n          }\n        }, openDelay);\n      } else if (!open) {\n        onOpenChange(true, event, 'hover');\n      }\n    }\n    function onReferenceMouseLeave(event) {\n      if (isClickLikeOpenEvent()) {\n        clearPointerEvents();\n        return;\n      }\n      unbindMouseMoveRef.current();\n      const doc = (0,_floating_ui_react_utils__WEBPACK_IMPORTED_MODULE_6__.getDocument)(elements.floating);\n      clearTimeoutIfSet(restTimeoutRef);\n      restTimeoutPendingRef.current = false;\n      if (handleCloseRef.current && dataRef.current.floatingContext) {\n        // Prevent clearing `onScrollMouseLeave` timeout.\n        if (!open) {\n          clearTimeoutIfSet(timeoutRef);\n        }\n        handlerRef.current = handleCloseRef.current({\n          ...dataRef.current.floatingContext,\n          tree,\n          x: event.clientX,\n          y: event.clientY,\n          onClose() {\n            clearPointerEvents();\n            cleanupMouseMoveHandler();\n            if (!isClickLikeOpenEvent()) {\n              closeWithDelay(event, true, 'safe-polygon');\n            }\n          }\n        });\n        const handler = handlerRef.current;\n        doc.addEventListener('mousemove', handler);\n        unbindMouseMoveRef.current = () => {\n          doc.removeEventListener('mousemove', handler);\n        };\n        return;\n      }\n\n      // Allow interactivity without `safePolygon` on touch devices. With a\n      // pointer, a short close delay is an alternative, so it should work\n      // consistently.\n      const shouldClose = pointerTypeRef.current === 'touch' ? !(0,_floating_ui_react_utils__WEBPACK_IMPORTED_MODULE_6__.contains)(elements.floating, event.relatedTarget) : true;\n      if (shouldClose) {\n        closeWithDelay(event);\n      }\n    }\n\n    // Ensure the floating element closes after scrolling even if the pointer\n    // did not move.\n    // https://github.com/floating-ui/floating-ui/discussions/1692\n    function onScrollMouseLeave(event) {\n      if (isClickLikeOpenEvent()) return;\n      if (!dataRef.current.floatingContext) return;\n      handleCloseRef.current == null || handleCloseRef.current({\n        ...dataRef.current.floatingContext,\n        tree,\n        x: event.clientX,\n        y: event.clientY,\n        onClose() {\n          clearPointerEvents();\n          cleanupMouseMoveHandler();\n          if (!isClickLikeOpenEvent()) {\n            closeWithDelay(event);\n          }\n        }\n      })(event);\n    }\n    function onFloatingMouseEnter() {\n      clearTimeoutIfSet(timeoutRef);\n    }\n    function onFloatingMouseLeave(event) {\n      if (!isClickLikeOpenEvent()) {\n        closeWithDelay(event, false);\n      }\n    }\n    if ((0,_floating_ui_react_dom__WEBPACK_IMPORTED_MODULE_5__.isElement)(elements.domReference)) {\n      const reference = elements.domReference;\n      const floating = elements.floating;\n      if (open) {\n        reference.addEventListener('mouseleave', onScrollMouseLeave);\n      }\n      if (move) {\n        reference.addEventListener('mousemove', onReferenceMouseEnter, {\n          once: true\n        });\n      }\n      reference.addEventListener('mouseenter', onReferenceMouseEnter);\n      reference.addEventListener('mouseleave', onReferenceMouseLeave);\n      if (floating) {\n        floating.addEventListener('mouseleave', onScrollMouseLeave);\n        floating.addEventListener('mouseenter', onFloatingMouseEnter);\n        floating.addEventListener('mouseleave', onFloatingMouseLeave);\n      }\n      return () => {\n        if (open) {\n          reference.removeEventListener('mouseleave', onScrollMouseLeave);\n        }\n        if (move) {\n          reference.removeEventListener('mousemove', onReferenceMouseEnter);\n        }\n        reference.removeEventListener('mouseenter', onReferenceMouseEnter);\n        reference.removeEventListener('mouseleave', onReferenceMouseLeave);\n        if (floating) {\n          floating.removeEventListener('mouseleave', onScrollMouseLeave);\n          floating.removeEventListener('mouseenter', onFloatingMouseEnter);\n          floating.removeEventListener('mouseleave', onFloatingMouseLeave);\n        }\n      };\n    }\n  }, [elements, enabled, context, mouseOnly, move, closeWithDelay, cleanupMouseMoveHandler, clearPointerEvents, onOpenChange, open, openRef, tree, delayRef, handleCloseRef, dataRef, isClickLikeOpenEvent, restMsRef]);\n\n  // Block pointer-events of every element other than the reference and floating\n  // while the floating element is open and has a `handleClose` handler. Also\n  // handles nested floating elements.\n  // https://github.com/floating-ui/floating-ui/issues/1722\n  (0,_floating_ui_react_utils__WEBPACK_IMPORTED_MODULE_6__.useModernLayoutEffect)(() => {\n    var _handleCloseRef$curre;\n    if (!enabled) return;\n    if (open && (_handleCloseRef$curre = handleCloseRef.current) != null && (_handleCloseRef$curre = _handleCloseRef$curre.__options) != null && _handleCloseRef$curre.blockPointerEvents && isHoverOpen()) {\n      performedPointerEventsMutationRef.current = true;\n      const floatingEl = elements.floating;\n      if ((0,_floating_ui_react_dom__WEBPACK_IMPORTED_MODULE_5__.isElement)(elements.domReference) && floatingEl) {\n        var _tree$nodesRef$curren;\n        const body = (0,_floating_ui_react_utils__WEBPACK_IMPORTED_MODULE_6__.getDocument)(elements.floating).body;\n        body.setAttribute(safePolygonIdentifier, '');\n        const ref = elements.domReference;\n        const parentFloating = tree == null || (_tree$nodesRef$curren = tree.nodesRef.current.find(node => node.id === parentId)) == null || (_tree$nodesRef$curren = _tree$nodesRef$curren.context) == null ? void 0 : _tree$nodesRef$curren.elements.floating;\n        if (parentFloating) {\n          parentFloating.style.pointerEvents = '';\n        }\n        body.style.pointerEvents = 'none';\n        ref.style.pointerEvents = 'auto';\n        floatingEl.style.pointerEvents = 'auto';\n        return () => {\n          body.style.pointerEvents = '';\n          ref.style.pointerEvents = '';\n          floatingEl.style.pointerEvents = '';\n        };\n      }\n    }\n  }, [enabled, open, parentId, elements, tree, handleCloseRef, isHoverOpen]);\n  (0,_floating_ui_react_utils__WEBPACK_IMPORTED_MODULE_6__.useModernLayoutEffect)(() => {\n    if (!open) {\n      pointerTypeRef.current = undefined;\n      restTimeoutPendingRef.current = false;\n      cleanupMouseMoveHandler();\n      clearPointerEvents();\n    }\n  }, [open, cleanupMouseMoveHandler, clearPointerEvents]);\n  react__WEBPACK_IMPORTED_MODULE_0__.useEffect(() => {\n    return () => {\n      cleanupMouseMoveHandler();\n      clearTimeoutIfSet(timeoutRef);\n      clearTimeoutIfSet(restTimeoutRef);\n      clearPointerEvents();\n    };\n  }, [enabled, elements.domReference, cleanupMouseMoveHandler, clearPointerEvents]);\n  const reference = react__WEBPACK_IMPORTED_MODULE_0__.useMemo(() => {\n    function setPointerRef(event) {\n      pointerTypeRef.current = event.pointerType;\n    }\n    return {\n      onPointerDown: setPointerRef,\n      onPointerEnter: setPointerRef,\n      onMouseMove(event) {\n        const {\n          nativeEvent\n        } = event;\n        function handleMouseMove() {\n          if (!blockMouseMoveRef.current && !openRef.current) {\n            onOpenChange(true, nativeEvent, 'hover');\n          }\n        }\n        if (mouseOnly && !(0,_floating_ui_react_utils__WEBPACK_IMPORTED_MODULE_6__.isMouseLikePointerType)(pointerTypeRef.current)) {\n          return;\n        }\n        if (open || getRestMs(restMsRef.current) === 0) {\n          return;\n        }\n\n        // Ignore insignificant movements to account for tremors.\n        if (restTimeoutPendingRef.current && event.movementX ** 2 + event.movementY ** 2 < 2) {\n          return;\n        }\n        clearTimeoutIfSet(restTimeoutRef);\n        if (pointerTypeRef.current === 'touch') {\n          handleMouseMove();\n        } else {\n          restTimeoutPendingRef.current = true;\n          restTimeoutRef.current = window.setTimeout(handleMouseMove, getRestMs(restMsRef.current));\n        }\n      }\n    };\n  }, [mouseOnly, onOpenChange, open, openRef, restMsRef]);\n  return react__WEBPACK_IMPORTED_MODULE_0__.useMemo(() => enabled ? {\n    reference\n  } : {}, [enabled, reference]);\n}\n\nconst NOOP = () => {};\nconst FloatingDelayGroupContext = /*#__PURE__*/react__WEBPACK_IMPORTED_MODULE_0__.createContext({\n  delay: 0,\n  initialDelay: 0,\n  timeoutMs: 0,\n  currentId: null,\n  setCurrentId: NOOP,\n  setState: NOOP,\n  isInstantPhase: false\n});\n\n/**\n * @deprecated\n * Use the return value of `useDelayGroup()` instead.\n */\nconst useDelayGroupContext = () => react__WEBPACK_IMPORTED_MODULE_0__.useContext(FloatingDelayGroupContext);\n/**\n * Provides context for a group of floating elements that should share a\n * `delay`.\n * @see https://floating-ui.com/docs/FloatingDelayGroup\n */\nfunction FloatingDelayGroup(props) {\n  const {\n    children,\n    delay,\n    timeoutMs = 0\n  } = props;\n  const [state, setState] = react__WEBPACK_IMPORTED_MODULE_0__.useReducer((prev, next) => ({\n    ...prev,\n    ...next\n  }), {\n    delay,\n    timeoutMs,\n    initialDelay: delay,\n    currentId: null,\n    isInstantPhase: false\n  });\n  const initialCurrentIdRef = react__WEBPACK_IMPORTED_MODULE_0__.useRef(null);\n  const setCurrentId = react__WEBPACK_IMPORTED_MODULE_0__.useCallback(currentId => {\n    setState({\n      currentId\n    });\n  }, []);\n  (0,_floating_ui_react_utils__WEBPACK_IMPORTED_MODULE_6__.useModernLayoutEffect)(() => {\n    if (state.currentId) {\n      if (initialCurrentIdRef.current === null) {\n        initialCurrentIdRef.current = state.currentId;\n      } else if (!state.isInstantPhase) {\n        setState({\n          isInstantPhase: true\n        });\n      }\n    } else {\n      if (state.isInstantPhase) {\n        setState({\n          isInstantPhase: false\n        });\n      }\n      initialCurrentIdRef.current = null;\n    }\n  }, [state.currentId, state.isInstantPhase]);\n  return /*#__PURE__*/(0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_1__.jsx)(FloatingDelayGroupContext.Provider, {\n    value: react__WEBPACK_IMPORTED_MODULE_0__.useMemo(() => ({\n      ...state,\n      setState,\n      setCurrentId\n    }), [state, setCurrentId]),\n    children: children\n  });\n}\n/**\n * Enables grouping when called inside a component that's a child of a\n * `FloatingDelayGroup`.\n * @see https://floating-ui.com/docs/FloatingDelayGroup\n */\nfunction useDelayGroup(context, options) {\n  if (options === void 0) {\n    options = {};\n  }\n  const {\n    open,\n    onOpenChange,\n    floatingId\n  } = context;\n  const {\n    id: optionId,\n    enabled = true\n  } = options;\n  const id = optionId != null ? optionId : floatingId;\n  const groupContext = useDelayGroupContext();\n  const {\n    currentId,\n    setCurrentId,\n    initialDelay,\n    setState,\n    timeoutMs\n  } = groupContext;\n  (0,_floating_ui_react_utils__WEBPACK_IMPORTED_MODULE_6__.useModernLayoutEffect)(() => {\n    if (!enabled) return;\n    if (!currentId) return;\n    setState({\n      delay: {\n        open: 1,\n        close: getDelay(initialDelay, 'close')\n      }\n    });\n    if (currentId !== id) {\n      onOpenChange(false);\n    }\n  }, [enabled, id, onOpenChange, setState, currentId, initialDelay]);\n  (0,_floating_ui_react_utils__WEBPACK_IMPORTED_MODULE_6__.useModernLayoutEffect)(() => {\n    function unset() {\n      onOpenChange(false);\n      setState({\n        delay: initialDelay,\n        currentId: null\n      });\n    }\n    if (!enabled) return;\n    if (!currentId) return;\n    if (!open && currentId === id) {\n      if (timeoutMs) {\n        const timeout = window.setTimeout(unset, timeoutMs);\n        return () => {\n          clearTimeout(timeout);\n        };\n      }\n      unset();\n    }\n  }, [enabled, open, setState, currentId, id, onOpenChange, initialDelay, timeoutMs]);\n  (0,_floating_ui_react_utils__WEBPACK_IMPORTED_MODULE_6__.useModernLayoutEffect)(() => {\n    if (!enabled) return;\n    if (setCurrentId === NOOP || !open) return;\n    setCurrentId(id);\n  }, [enabled, open, setCurrentId, id]);\n  return groupContext;\n}\n\nconst NextFloatingDelayGroupContext = /*#__PURE__*/react__WEBPACK_IMPORTED_MODULE_0__.createContext({\n  hasProvider: false,\n  timeoutMs: 0,\n  delayRef: {\n    current: 0\n  },\n  initialDelayRef: {\n    current: 0\n  },\n  timeoutIdRef: {\n    current: -1\n  },\n  currentIdRef: {\n    current: null\n  },\n  currentContextRef: {\n    current: null\n  }\n});\n/**\n * Experimental next version of `FloatingDelayGroup` to become the default\n * in the future. This component is not yet stable.\n * Provides context for a group of floating elements that should share a\n * `delay`. Unlike `FloatingDelayGroup`, `useNextDelayGroup` with this\n * component does not cause a re-render of unrelated consumers of the\n * context when the delay changes.\n * @see https://floating-ui.com/docs/FloatingDelayGroup\n */\nfunction NextFloatingDelayGroup(props) {\n  const {\n    children,\n    delay,\n    timeoutMs = 0\n  } = props;\n  const delayRef = react__WEBPACK_IMPORTED_MODULE_0__.useRef(delay);\n  const initialDelayRef = react__WEBPACK_IMPORTED_MODULE_0__.useRef(delay);\n  const currentIdRef = react__WEBPACK_IMPORTED_MODULE_0__.useRef(null);\n  const currentContextRef = react__WEBPACK_IMPORTED_MODULE_0__.useRef(null);\n  const timeoutIdRef = react__WEBPACK_IMPORTED_MODULE_0__.useRef(-1);\n  return /*#__PURE__*/(0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_1__.jsx)(NextFloatingDelayGroupContext.Provider, {\n    value: react__WEBPACK_IMPORTED_MODULE_0__.useMemo(() => ({\n      hasProvider: true,\n      delayRef,\n      initialDelayRef,\n      currentIdRef,\n      timeoutMs,\n      currentContextRef,\n      timeoutIdRef\n    }), [timeoutMs]),\n    children: children\n  });\n}\n/**\n * Enables grouping when called inside a component that's a child of a\n * `NextFloatingDelayGroup`.\n * @see https://floating-ui.com/docs/FloatingDelayGroup\n */\nfunction useNextDelayGroup(context, options) {\n  if (options === void 0) {\n    options = {};\n  }\n  const {\n    open,\n    onOpenChange,\n    floatingId\n  } = context;\n  const {\n    enabled = true\n  } = options;\n  const groupContext = react__WEBPACK_IMPORTED_MODULE_0__.useContext(NextFloatingDelayGroupContext);\n  const {\n    currentIdRef,\n    delayRef,\n    timeoutMs,\n    initialDelayRef,\n    currentContextRef,\n    hasProvider,\n    timeoutIdRef\n  } = groupContext;\n  const [isInstantPhase, setIsInstantPhase] = react__WEBPACK_IMPORTED_MODULE_0__.useState(false);\n  (0,_floating_ui_react_utils__WEBPACK_IMPORTED_MODULE_6__.useModernLayoutEffect)(() => {\n    function unset() {\n      var _currentContextRef$cu;\n      setIsInstantPhase(false);\n      (_currentContextRef$cu = currentContextRef.current) == null || _currentContextRef$cu.setIsInstantPhase(false);\n      currentIdRef.current = null;\n      currentContextRef.current = null;\n      delayRef.current = initialDelayRef.current;\n    }\n    if (!enabled) return;\n    if (!currentIdRef.current) return;\n    if (!open && currentIdRef.current === floatingId) {\n      setIsInstantPhase(false);\n      if (timeoutMs) {\n        timeoutIdRef.current = window.setTimeout(unset, timeoutMs);\n        return () => {\n          clearTimeout(timeoutIdRef.current);\n        };\n      }\n      unset();\n    }\n  }, [enabled, open, floatingId, currentIdRef, delayRef, timeoutMs, initialDelayRef, currentContextRef, timeoutIdRef]);\n  (0,_floating_ui_react_utils__WEBPACK_IMPORTED_MODULE_6__.useModernLayoutEffect)(() => {\n    if (!enabled) return;\n    if (!open) return;\n    const prevContext = currentContextRef.current;\n    const prevId = currentIdRef.current;\n    currentContextRef.current = {\n      onOpenChange,\n      setIsInstantPhase\n    };\n    currentIdRef.current = floatingId;\n    delayRef.current = {\n      open: 0,\n      close: getDelay(initialDelayRef.current, 'close')\n    };\n    if (prevId !== null && prevId !== floatingId) {\n      clearTimeoutIfSet(timeoutIdRef);\n      setIsInstantPhase(true);\n      prevContext == null || prevContext.setIsInstantPhase(true);\n      prevContext == null || prevContext.onOpenChange(false);\n    } else {\n      setIsInstantPhase(false);\n      prevContext == null || prevContext.setIsInstantPhase(false);\n    }\n  }, [enabled, open, floatingId, onOpenChange, currentIdRef, delayRef, timeoutMs, initialDelayRef, currentContextRef, timeoutIdRef]);\n  (0,_floating_ui_react_utils__WEBPACK_IMPORTED_MODULE_6__.useModernLayoutEffect)(() => {\n    return () => {\n      currentContextRef.current = null;\n    };\n  }, [currentContextRef]);\n  return react__WEBPACK_IMPORTED_MODULE_0__.useMemo(() => ({\n    hasProvider,\n    delayRef,\n    isInstantPhase\n  }), [hasProvider, delayRef, isInstantPhase]);\n}\n\nlet rafId = 0;\nfunction enqueueFocus(el, options) {\n  if (options === void 0) {\n    options = {};\n  }\n  const {\n    preventScroll = false,\n    cancelPrevious = true,\n    sync = false\n  } = options;\n  cancelPrevious && cancelAnimationFrame(rafId);\n  const exec = () => el == null ? void 0 : el.focus({\n    preventScroll\n  });\n  if (sync) {\n    exec();\n  } else {\n    rafId = requestAnimationFrame(exec);\n  }\n}\n\nfunction contains(parent, child) {\n  if (!parent || !child) {\n    return false;\n  }\n  const rootNode = child.getRootNode == null ? void 0 : child.getRootNode();\n\n  // First, attempt with faster native method\n  if (parent.contains(child)) {\n    return true;\n  }\n\n  // then fallback to custom implementation with Shadow DOM support\n  if (rootNode && (0,_floating_ui_react_dom__WEBPACK_IMPORTED_MODULE_5__.isShadowRoot)(rootNode)) {\n    let next = child;\n    while (next) {\n      if (parent === next) {\n        return true;\n      }\n      // @ts-ignore\n      next = next.parentNode || next.host;\n    }\n  }\n\n  // Give up, the result is false\n  return false;\n}\nfunction getTarget(event) {\n  if ('composedPath' in event) {\n    return event.composedPath()[0];\n  }\n\n  // TS thinks `event` is of type never as it assumes all browsers support\n  // `composedPath()`, but browsers without shadow DOM don't.\n  return event.target;\n}\nfunction getDocument(node) {\n  return (node == null ? void 0 : node.ownerDocument) || document;\n}\n\n// Modified to add conditional `aria-hidden` support:\n// https://github.com/theKashey/aria-hidden/blob/9220c8f4a4fd35f63bee5510a9f41a37264382d4/src/index.ts\nconst counters = {\n  inert: /*#__PURE__*/new WeakMap(),\n  'aria-hidden': /*#__PURE__*/new WeakMap(),\n  none: /*#__PURE__*/new WeakMap()\n};\nfunction getCounterMap(control) {\n  if (control === 'inert') return counters.inert;\n  if (control === 'aria-hidden') return counters['aria-hidden'];\n  return counters.none;\n}\nlet uncontrolledElementsSet = /*#__PURE__*/new WeakSet();\nlet markerMap = {};\nlet lockCount$1 = 0;\nconst supportsInert = () => typeof HTMLElement !== 'undefined' && 'inert' in HTMLElement.prototype;\nconst unwrapHost = node => node && (node.host || unwrapHost(node.parentNode));\nconst correctElements = (parent, targets) => targets.map(target => {\n  if (parent.contains(target)) {\n    return target;\n  }\n  const correctedTarget = unwrapHost(target);\n  if (parent.contains(correctedTarget)) {\n    return correctedTarget;\n  }\n  return null;\n}).filter(x => x != null);\nfunction applyAttributeToOthers(uncorrectedAvoidElements, body, ariaHidden, inert) {\n  const markerName = 'data-floating-ui-inert';\n  const controlAttribute = inert ? 'inert' : ariaHidden ? 'aria-hidden' : null;\n  const avoidElements = correctElements(body, uncorrectedAvoidElements);\n  const elementsToKeep = new Set();\n  const elementsToStop = new Set(avoidElements);\n  const hiddenElements = [];\n  if (!markerMap[markerName]) {\n    markerMap[markerName] = new WeakMap();\n  }\n  const markerCounter = markerMap[markerName];\n  avoidElements.forEach(keep);\n  deep(body);\n  elementsToKeep.clear();\n  function keep(el) {\n    if (!el || elementsToKeep.has(el)) {\n      return;\n    }\n    elementsToKeep.add(el);\n    el.parentNode && keep(el.parentNode);\n  }\n  function deep(parent) {\n    if (!parent || elementsToStop.has(parent)) {\n      return;\n    }\n    [].forEach.call(parent.children, node => {\n      if ((0,_floating_ui_react_dom__WEBPACK_IMPORTED_MODULE_5__.getNodeName)(node) === 'script') return;\n      if (elementsToKeep.has(node)) {\n        deep(node);\n      } else {\n        const attr = controlAttribute ? node.getAttribute(controlAttribute) : null;\n        const alreadyHidden = attr !== null && attr !== 'false';\n        const counterMap = getCounterMap(controlAttribute);\n        const counterValue = (counterMap.get(node) || 0) + 1;\n        const markerValue = (markerCounter.get(node) || 0) + 1;\n        counterMap.set(node, counterValue);\n        markerCounter.set(node, markerValue);\n        hiddenElements.push(node);\n        if (counterValue === 1 && alreadyHidden) {\n          uncontrolledElementsSet.add(node);\n        }\n        if (markerValue === 1) {\n          node.setAttribute(markerName, '');\n        }\n        if (!alreadyHidden && controlAttribute) {\n          node.setAttribute(controlAttribute, controlAttribute === 'inert' ? '' : 'true');\n        }\n      }\n    });\n  }\n  lockCount$1++;\n  return () => {\n    hiddenElements.forEach(element => {\n      const counterMap = getCounterMap(controlAttribute);\n      const currentCounterValue = counterMap.get(element) || 0;\n      const counterValue = currentCounterValue - 1;\n      const markerValue = (markerCounter.get(element) || 0) - 1;\n      counterMap.set(element, counterValue);\n      markerCounter.set(element, markerValue);\n      if (!counterValue) {\n        if (!uncontrolledElementsSet.has(element) && controlAttribute) {\n          element.removeAttribute(controlAttribute);\n        }\n        uncontrolledElementsSet.delete(element);\n      }\n      if (!markerValue) {\n        element.removeAttribute(markerName);\n      }\n    });\n    lockCount$1--;\n    if (!lockCount$1) {\n      counters.inert = new WeakMap();\n      counters['aria-hidden'] = new WeakMap();\n      counters.none = new WeakMap();\n      uncontrolledElementsSet = new WeakSet();\n      markerMap = {};\n    }\n  };\n}\nfunction markOthers(avoidElements, ariaHidden, inert) {\n  if (ariaHidden === void 0) {\n    ariaHidden = false;\n  }\n  if (inert === void 0) {\n    inert = false;\n  }\n  const body = getDocument(avoidElements[0]).body;\n  return applyAttributeToOthers(avoidElements.concat(Array.from(body.querySelectorAll('[aria-live],[role=\"status\"],output'))), body, ariaHidden, inert);\n}\n\nconst HIDDEN_STYLES = {\n  border: 0,\n  clip: 'rect(0 0 0 0)',\n  height: '1px',\n  margin: '-1px',\n  overflow: 'hidden',\n  padding: 0,\n  position: 'fixed',\n  whiteSpace: 'nowrap',\n  width: '1px',\n  top: 0,\n  left: 0\n};\nconst FocusGuard = /*#__PURE__*/react__WEBPACK_IMPORTED_MODULE_0__.forwardRef(function FocusGuard(props, ref) {\n  const [role, setRole] = react__WEBPACK_IMPORTED_MODULE_0__.useState();\n  (0,_floating_ui_react_utils__WEBPACK_IMPORTED_MODULE_6__.useModernLayoutEffect)(() => {\n    if ((0,_floating_ui_react_utils__WEBPACK_IMPORTED_MODULE_6__.isSafari)()) {\n      // Unlike other screen readers such as NVDA and JAWS, the virtual cursor\n      // on VoiceOver does trigger the onFocus event, so we can use the focus\n      // trap element. On Safari, only buttons trigger the onFocus event.\n      // NB: \"group\" role in the Sandbox no longer appears to work, must be a\n      // button role.\n      setRole('button');\n    }\n  }, []);\n  const restProps = {\n    ref,\n    tabIndex: 0,\n    // Role is only for VoiceOver\n    role,\n    'aria-hidden': role ? undefined : true,\n    [createAttribute('focus-guard')]: '',\n    style: HIDDEN_STYLES\n  };\n  return /*#__PURE__*/(0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_1__.jsx)(\"span\", {\n    ...props,\n    ...restProps\n  });\n});\n\nconst PortalContext = /*#__PURE__*/react__WEBPACK_IMPORTED_MODULE_0__.createContext(null);\nconst attr = /*#__PURE__*/createAttribute('portal');\n/**\n * @see https://floating-ui.com/docs/FloatingPortal#usefloatingportalnode\n */\nfunction useFloatingPortalNode(props) {\n  if (props === void 0) {\n    props = {};\n  }\n  const {\n    id,\n    root\n  } = props;\n  const uniqueId = useId();\n  const portalContext = usePortalContext();\n  const [portalNode, setPortalNode] = react__WEBPACK_IMPORTED_MODULE_0__.useState(null);\n  const portalNodeRef = react__WEBPACK_IMPORTED_MODULE_0__.useRef(null);\n  (0,_floating_ui_react_utils__WEBPACK_IMPORTED_MODULE_6__.useModernLayoutEffect)(() => {\n    return () => {\n      portalNode == null || portalNode.remove();\n      // Allow the subsequent layout effects to create a new node on updates.\n      // The portal node will still be cleaned up on unmount.\n      // https://github.com/floating-ui/floating-ui/issues/2454\n      queueMicrotask(() => {\n        portalNodeRef.current = null;\n      });\n    };\n  }, [portalNode]);\n  (0,_floating_ui_react_utils__WEBPACK_IMPORTED_MODULE_6__.useModernLayoutEffect)(() => {\n    // Wait for the uniqueId to be generated before creating the portal node in\n    // React <18 (using `useFloatingId` instead of the native `useId`).\n    // https://github.com/floating-ui/floating-ui/issues/2778\n    if (!uniqueId) return;\n    if (portalNodeRef.current) return;\n    const existingIdRoot = id ? document.getElementById(id) : null;\n    if (!existingIdRoot) return;\n    const subRoot = document.createElement('div');\n    subRoot.id = uniqueId;\n    subRoot.setAttribute(attr, '');\n    existingIdRoot.appendChild(subRoot);\n    portalNodeRef.current = subRoot;\n    setPortalNode(subRoot);\n  }, [id, uniqueId]);\n  (0,_floating_ui_react_utils__WEBPACK_IMPORTED_MODULE_6__.useModernLayoutEffect)(() => {\n    // Wait for the root to exist before creating the portal node. The root must\n    // be stored in state, not a ref, for this to work reactively.\n    if (root === null) return;\n    if (!uniqueId) return;\n    if (portalNodeRef.current) return;\n    let container = root || (portalContext == null ? void 0 : portalContext.portalNode);\n    if (container && !(0,_floating_ui_react_dom__WEBPACK_IMPORTED_MODULE_5__.isNode)(container)) container = container.current;\n    container = container || document.body;\n    let idWrapper = null;\n    if (id) {\n      idWrapper = document.createElement('div');\n      idWrapper.id = id;\n      container.appendChild(idWrapper);\n    }\n    const subRoot = document.createElement('div');\n    subRoot.id = uniqueId;\n    subRoot.setAttribute(attr, '');\n    container = idWrapper || container;\n    container.appendChild(subRoot);\n    portalNodeRef.current = subRoot;\n    setPortalNode(subRoot);\n  }, [id, root, uniqueId, portalContext]);\n  return portalNode;\n}\n/**\n * Portals the floating element into a given container element  by default,\n * outside of the app root and into the body.\n * This is necessary to ensure the floating element can appear outside any\n * potential parent containers that cause clipping (such as `overflow: hidden`),\n * while retaining its location in the React tree.\n * @see https://floating-ui.com/docs/FloatingPortal\n */\nfunction FloatingPortal(props) {\n  const {\n    children,\n    id,\n    root,\n    preserveTabOrder = true\n  } = props;\n  const portalNode = useFloatingPortalNode({\n    id,\n    root\n  });\n  const [focusManagerState, setFocusManagerState] = react__WEBPACK_IMPORTED_MODULE_0__.useState(null);\n  const beforeOutsideRef = react__WEBPACK_IMPORTED_MODULE_0__.useRef(null);\n  const afterOutsideRef = react__WEBPACK_IMPORTED_MODULE_0__.useRef(null);\n  const beforeInsideRef = react__WEBPACK_IMPORTED_MODULE_0__.useRef(null);\n  const afterInsideRef = react__WEBPACK_IMPORTED_MODULE_0__.useRef(null);\n  const modal = focusManagerState == null ? void 0 : focusManagerState.modal;\n  const open = focusManagerState == null ? void 0 : focusManagerState.open;\n  const shouldRenderGuards =\n  // The FocusManager and therefore floating element are currently open/\n  // rendered.\n  !!focusManagerState &&\n  // Guards are only for non-modal focus management.\n  !focusManagerState.modal &&\n  // Don't render if unmount is transitioning.\n  focusManagerState.open && preserveTabOrder && !!(root || portalNode);\n\n  // https://codesandbox.io/s/tabbable-portal-f4tng?file=/src/TabbablePortal.tsx\n  react__WEBPACK_IMPORTED_MODULE_0__.useEffect(() => {\n    if (!portalNode || !preserveTabOrder || modal) {\n      return;\n    }\n\n    // Make sure elements inside the portal element are tabbable only when the\n    // portal has already been focused, either by tabbing into a focus trap\n    // element outside or using the mouse.\n    function onFocus(event) {\n      if (portalNode && (0,_floating_ui_react_utils__WEBPACK_IMPORTED_MODULE_6__.isOutsideEvent)(event)) {\n        const focusing = event.type === 'focusin';\n        const manageFocus = focusing ? _floating_ui_react_utils__WEBPACK_IMPORTED_MODULE_6__.enableFocusInside : _floating_ui_react_utils__WEBPACK_IMPORTED_MODULE_6__.disableFocusInside;\n        manageFocus(portalNode);\n      }\n    }\n    // Listen to the event on the capture phase so they run before the focus\n    // trap elements onFocus prop is called.\n    portalNode.addEventListener('focusin', onFocus, true);\n    portalNode.addEventListener('focusout', onFocus, true);\n    return () => {\n      portalNode.removeEventListener('focusin', onFocus, true);\n      portalNode.removeEventListener('focusout', onFocus, true);\n    };\n  }, [portalNode, preserveTabOrder, modal]);\n  react__WEBPACK_IMPORTED_MODULE_0__.useEffect(() => {\n    if (!portalNode) return;\n    if (open) return;\n    (0,_floating_ui_react_utils__WEBPACK_IMPORTED_MODULE_6__.enableFocusInside)(portalNode);\n  }, [open, portalNode]);\n  return /*#__PURE__*/(0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_1__.jsxs)(PortalContext.Provider, {\n    value: react__WEBPACK_IMPORTED_MODULE_0__.useMemo(() => ({\n      preserveTabOrder,\n      beforeOutsideRef,\n      afterOutsideRef,\n      beforeInsideRef,\n      afterInsideRef,\n      portalNode,\n      setFocusManagerState\n    }), [preserveTabOrder, portalNode]),\n    children: [shouldRenderGuards && portalNode && /*#__PURE__*/(0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_1__.jsx)(FocusGuard, {\n      \"data-type\": \"outside\",\n      ref: beforeOutsideRef,\n      onFocus: event => {\n        if ((0,_floating_ui_react_utils__WEBPACK_IMPORTED_MODULE_6__.isOutsideEvent)(event, portalNode)) {\n          var _beforeInsideRef$curr;\n          (_beforeInsideRef$curr = beforeInsideRef.current) == null || _beforeInsideRef$curr.focus();\n        } else {\n          const domReference = focusManagerState ? focusManagerState.domReference : null;\n          const prevTabbable = (0,_floating_ui_react_utils__WEBPACK_IMPORTED_MODULE_6__.getPreviousTabbable)(domReference);\n          prevTabbable == null || prevTabbable.focus();\n        }\n      }\n    }), shouldRenderGuards && portalNode && /*#__PURE__*/(0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_1__.jsx)(\"span\", {\n      \"aria-owns\": portalNode.id,\n      style: HIDDEN_STYLES\n    }), portalNode && /*#__PURE__*/react_dom__WEBPACK_IMPORTED_MODULE_2__.createPortal(children, portalNode), shouldRenderGuards && portalNode && /*#__PURE__*/(0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_1__.jsx)(FocusGuard, {\n      \"data-type\": \"outside\",\n      ref: afterOutsideRef,\n      onFocus: event => {\n        if ((0,_floating_ui_react_utils__WEBPACK_IMPORTED_MODULE_6__.isOutsideEvent)(event, portalNode)) {\n          var _afterInsideRef$curre;\n          (_afterInsideRef$curre = afterInsideRef.current) == null || _afterInsideRef$curre.focus();\n        } else {\n          const domReference = focusManagerState ? focusManagerState.domReference : null;\n          const nextTabbable = (0,_floating_ui_react_utils__WEBPACK_IMPORTED_MODULE_6__.getNextTabbable)(domReference);\n          nextTabbable == null || nextTabbable.focus();\n          (focusManagerState == null ? void 0 : focusManagerState.closeOnFocusOut) && (focusManagerState == null ? void 0 : focusManagerState.onOpenChange(false, event.nativeEvent, 'focus-out'));\n        }\n      }\n    })]\n  });\n}\nconst usePortalContext = () => react__WEBPACK_IMPORTED_MODULE_0__.useContext(PortalContext);\n\nfunction useLiteMergeRefs(refs) {\n  return react__WEBPACK_IMPORTED_MODULE_0__.useMemo(() => {\n    return value => {\n      refs.forEach(ref => {\n        if (ref) {\n          ref.current = value;\n        }\n      });\n    };\n    // eslint-disable-next-line react-hooks/exhaustive-deps\n  }, refs);\n}\n\nconst LIST_LIMIT = 20;\nlet previouslyFocusedElements = [];\nfunction clearDisconnectedPreviouslyFocusedElements() {\n  previouslyFocusedElements = previouslyFocusedElements.filter(el => el.isConnected);\n}\nfunction addPreviouslyFocusedElement(element) {\n  clearDisconnectedPreviouslyFocusedElements();\n  if (element && (0,_floating_ui_react_dom__WEBPACK_IMPORTED_MODULE_5__.getNodeName)(element) !== 'body') {\n    previouslyFocusedElements.push(element);\n    if (previouslyFocusedElements.length > LIST_LIMIT) {\n      previouslyFocusedElements = previouslyFocusedElements.slice(-20);\n    }\n  }\n}\nfunction getPreviouslyFocusedElement() {\n  clearDisconnectedPreviouslyFocusedElements();\n  return previouslyFocusedElements[previouslyFocusedElements.length - 1];\n}\nfunction getFirstTabbableElement(container) {\n  const tabbableOptions = (0,_floating_ui_react_utils__WEBPACK_IMPORTED_MODULE_6__.getTabbableOptions)();\n  if ((0,tabbable__WEBPACK_IMPORTED_MODULE_7__.isTabbable)(container, tabbableOptions)) {\n    return container;\n  }\n  return (0,tabbable__WEBPACK_IMPORTED_MODULE_7__.tabbable)(container, tabbableOptions)[0] || container;\n}\nfunction handleTabIndex(floatingFocusElement, orderRef) {\n  var _floatingFocusElement;\n  if (!orderRef.current.includes('floating') && !((_floatingFocusElement = floatingFocusElement.getAttribute('role')) != null && _floatingFocusElement.includes('dialog'))) {\n    return;\n  }\n  const options = (0,_floating_ui_react_utils__WEBPACK_IMPORTED_MODULE_6__.getTabbableOptions)();\n  const focusableElements = (0,tabbable__WEBPACK_IMPORTED_MODULE_7__.focusable)(floatingFocusElement, options);\n  const tabbableContent = focusableElements.filter(element => {\n    const dataTabIndex = element.getAttribute('data-tabindex') || '';\n    return (0,tabbable__WEBPACK_IMPORTED_MODULE_7__.isTabbable)(element, options) || element.hasAttribute('data-tabindex') && !dataTabIndex.startsWith('-');\n  });\n  const tabIndex = floatingFocusElement.getAttribute('tabindex');\n  if (orderRef.current.includes('floating') || tabbableContent.length === 0) {\n    if (tabIndex !== '0') {\n      floatingFocusElement.setAttribute('tabindex', '0');\n    }\n  } else if (tabIndex !== '-1' || floatingFocusElement.hasAttribute('data-tabindex') && floatingFocusElement.getAttribute('data-tabindex') !== '-1') {\n    floatingFocusElement.setAttribute('tabindex', '-1');\n    floatingFocusElement.setAttribute('data-tabindex', '-1');\n  }\n}\nconst VisuallyHiddenDismiss = /*#__PURE__*/react__WEBPACK_IMPORTED_MODULE_0__.forwardRef(function VisuallyHiddenDismiss(props, ref) {\n  return /*#__PURE__*/(0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_1__.jsx)(\"button\", {\n    ...props,\n    type: \"button\",\n    ref: ref,\n    tabIndex: -1,\n    style: HIDDEN_STYLES\n  });\n});\n/**\n * Provides focus management for the floating element.\n * @see https://floating-ui.com/docs/FloatingFocusManager\n */\nfunction FloatingFocusManager(props) {\n  const {\n    context,\n    children,\n    disabled = false,\n    order = ['content'],\n    guards: _guards = true,\n    initialFocus = 0,\n    returnFocus = true,\n    restoreFocus = false,\n    modal = true,\n    visuallyHiddenDismiss = false,\n    closeOnFocusOut = true,\n    outsideElementsInert = false,\n    getInsideElements: _getInsideElements = () => []\n  } = props;\n  const {\n    open,\n    onOpenChange,\n    events,\n    dataRef,\n    elements: {\n      domReference,\n      floating\n    }\n  } = context;\n  const getNodeId = (0,_floating_ui_react_utils__WEBPACK_IMPORTED_MODULE_6__.useEffectEvent)(() => {\n    var _dataRef$current$floa;\n    return (_dataRef$current$floa = dataRef.current.floatingContext) == null ? void 0 : _dataRef$current$floa.nodeId;\n  });\n  const getInsideElements = (0,_floating_ui_react_utils__WEBPACK_IMPORTED_MODULE_6__.useEffectEvent)(_getInsideElements);\n  const ignoreInitialFocus = typeof initialFocus === 'number' && initialFocus < 0;\n  // If the reference is a combobox and is typeable (e.g. input/textarea),\n  // there are different focus semantics. The guards should not be rendered, but\n  // aria-hidden should be applied to all nodes still. Further, the visually\n  // hidden dismiss button should only appear at the end of the list, not the\n  // start.\n  const isUntrappedTypeableCombobox = (0,_floating_ui_react_utils__WEBPACK_IMPORTED_MODULE_6__.isTypeableCombobox)(domReference) && ignoreInitialFocus;\n\n  // Force the guards to be rendered if the `inert` attribute is not supported.\n  const inertSupported = supportsInert();\n  const guards = inertSupported ? _guards : true;\n  const useInert = !guards || inertSupported && outsideElementsInert;\n  const orderRef = (0,_floating_ui_react_utils__WEBPACK_IMPORTED_MODULE_6__.useLatestRef)(order);\n  const initialFocusRef = (0,_floating_ui_react_utils__WEBPACK_IMPORTED_MODULE_6__.useLatestRef)(initialFocus);\n  const returnFocusRef = (0,_floating_ui_react_utils__WEBPACK_IMPORTED_MODULE_6__.useLatestRef)(returnFocus);\n  const tree = useFloatingTree();\n  const portalContext = usePortalContext();\n  const startDismissButtonRef = react__WEBPACK_IMPORTED_MODULE_0__.useRef(null);\n  const endDismissButtonRef = react__WEBPACK_IMPORTED_MODULE_0__.useRef(null);\n  const preventReturnFocusRef = react__WEBPACK_IMPORTED_MODULE_0__.useRef(false);\n  const isPointerDownRef = react__WEBPACK_IMPORTED_MODULE_0__.useRef(false);\n  const tabbableIndexRef = react__WEBPACK_IMPORTED_MODULE_0__.useRef(-1);\n  const blurTimeoutRef = react__WEBPACK_IMPORTED_MODULE_0__.useRef(-1);\n  const isInsidePortal = portalContext != null;\n  const floatingFocusElement = (0,_floating_ui_react_utils__WEBPACK_IMPORTED_MODULE_6__.getFloatingFocusElement)(floating);\n  const getTabbableContent = (0,_floating_ui_react_utils__WEBPACK_IMPORTED_MODULE_6__.useEffectEvent)(function (container) {\n    if (container === void 0) {\n      container = floatingFocusElement;\n    }\n    return container ? (0,tabbable__WEBPACK_IMPORTED_MODULE_7__.tabbable)(container, (0,_floating_ui_react_utils__WEBPACK_IMPORTED_MODULE_6__.getTabbableOptions)()) : [];\n  });\n  const getTabbableElements = (0,_floating_ui_react_utils__WEBPACK_IMPORTED_MODULE_6__.useEffectEvent)(container => {\n    const content = getTabbableContent(container);\n    return orderRef.current.map(type => {\n      if (domReference && type === 'reference') {\n        return domReference;\n      }\n      if (floatingFocusElement && type === 'floating') {\n        return floatingFocusElement;\n      }\n      return content;\n    }).filter(Boolean).flat();\n  });\n  react__WEBPACK_IMPORTED_MODULE_0__.useEffect(() => {\n    if (disabled) return;\n    if (!modal) return;\n    function onKeyDown(event) {\n      if (event.key === 'Tab') {\n        // The focus guards have nothing to focus, so we need to stop the event.\n        if ((0,_floating_ui_react_utils__WEBPACK_IMPORTED_MODULE_6__.contains)(floatingFocusElement, (0,_floating_ui_react_utils__WEBPACK_IMPORTED_MODULE_6__.activeElement)((0,_floating_ui_react_utils__WEBPACK_IMPORTED_MODULE_6__.getDocument)(floatingFocusElement))) && getTabbableContent().length === 0 && !isUntrappedTypeableCombobox) {\n          (0,_floating_ui_react_utils__WEBPACK_IMPORTED_MODULE_6__.stopEvent)(event);\n        }\n        const els = getTabbableElements();\n        const target = (0,_floating_ui_react_utils__WEBPACK_IMPORTED_MODULE_6__.getTarget)(event);\n        if (orderRef.current[0] === 'reference' && target === domReference) {\n          (0,_floating_ui_react_utils__WEBPACK_IMPORTED_MODULE_6__.stopEvent)(event);\n          if (event.shiftKey) {\n            enqueueFocus(els[els.length - 1]);\n          } else {\n            enqueueFocus(els[1]);\n          }\n        }\n        if (orderRef.current[1] === 'floating' && target === floatingFocusElement && event.shiftKey) {\n          (0,_floating_ui_react_utils__WEBPACK_IMPORTED_MODULE_6__.stopEvent)(event);\n          enqueueFocus(els[0]);\n        }\n      }\n    }\n    const doc = (0,_floating_ui_react_utils__WEBPACK_IMPORTED_MODULE_6__.getDocument)(floatingFocusElement);\n    doc.addEventListener('keydown', onKeyDown);\n    return () => {\n      doc.removeEventListener('keydown', onKeyDown);\n    };\n  }, [disabled, domReference, floatingFocusElement, modal, orderRef, isUntrappedTypeableCombobox, getTabbableContent, getTabbableElements]);\n  react__WEBPACK_IMPORTED_MODULE_0__.useEffect(() => {\n    if (disabled) return;\n    if (!floating) return;\n    function handleFocusIn(event) {\n      const target = (0,_floating_ui_react_utils__WEBPACK_IMPORTED_MODULE_6__.getTarget)(event);\n      const tabbableContent = getTabbableContent();\n      const tabbableIndex = tabbableContent.indexOf(target);\n      if (tabbableIndex !== -1) {\n        tabbableIndexRef.current = tabbableIndex;\n      }\n    }\n    floating.addEventListener('focusin', handleFocusIn);\n    return () => {\n      floating.removeEventListener('focusin', handleFocusIn);\n    };\n  }, [disabled, floating, getTabbableContent]);\n  react__WEBPACK_IMPORTED_MODULE_0__.useEffect(() => {\n    if (disabled) return;\n    if (!closeOnFocusOut) return;\n\n    // In Safari, buttons lose focus when pressing them.\n    function handlePointerDown() {\n      isPointerDownRef.current = true;\n      setTimeout(() => {\n        isPointerDownRef.current = false;\n      });\n    }\n    function handleFocusOutside(event) {\n      const relatedTarget = event.relatedTarget;\n      const currentTarget = event.currentTarget;\n      const target = (0,_floating_ui_react_utils__WEBPACK_IMPORTED_MODULE_6__.getTarget)(event);\n      queueMicrotask(() => {\n        const nodeId = getNodeId();\n        const movedToUnrelatedNode = !((0,_floating_ui_react_utils__WEBPACK_IMPORTED_MODULE_6__.contains)(domReference, relatedTarget) || (0,_floating_ui_react_utils__WEBPACK_IMPORTED_MODULE_6__.contains)(floating, relatedTarget) || (0,_floating_ui_react_utils__WEBPACK_IMPORTED_MODULE_6__.contains)(relatedTarget, floating) || (0,_floating_ui_react_utils__WEBPACK_IMPORTED_MODULE_6__.contains)(portalContext == null ? void 0 : portalContext.portalNode, relatedTarget) || relatedTarget != null && relatedTarget.hasAttribute(createAttribute('focus-guard')) || tree && ((0,_floating_ui_react_utils__WEBPACK_IMPORTED_MODULE_6__.getNodeChildren)(tree.nodesRef.current, nodeId).find(node => {\n          var _node$context, _node$context2;\n          return (0,_floating_ui_react_utils__WEBPACK_IMPORTED_MODULE_6__.contains)((_node$context = node.context) == null ? void 0 : _node$context.elements.floating, relatedTarget) || (0,_floating_ui_react_utils__WEBPACK_IMPORTED_MODULE_6__.contains)((_node$context2 = node.context) == null ? void 0 : _node$context2.elements.domReference, relatedTarget);\n        }) || (0,_floating_ui_react_utils__WEBPACK_IMPORTED_MODULE_6__.getNodeAncestors)(tree.nodesRef.current, nodeId).find(node => {\n          var _node$context3, _node$context4, _node$context5;\n          return [(_node$context3 = node.context) == null ? void 0 : _node$context3.elements.floating, (0,_floating_ui_react_utils__WEBPACK_IMPORTED_MODULE_6__.getFloatingFocusElement)((_node$context4 = node.context) == null ? void 0 : _node$context4.elements.floating)].includes(relatedTarget) || ((_node$context5 = node.context) == null ? void 0 : _node$context5.elements.domReference) === relatedTarget;\n        })));\n        if (currentTarget === domReference && floatingFocusElement) {\n          handleTabIndex(floatingFocusElement, orderRef);\n        }\n\n        // Restore focus to the previous tabbable element index to prevent\n        // focus from being lost outside the floating tree.\n        if (restoreFocus && currentTarget !== domReference && !(target != null && target.isConnected) && (0,_floating_ui_react_utils__WEBPACK_IMPORTED_MODULE_6__.activeElement)((0,_floating_ui_react_utils__WEBPACK_IMPORTED_MODULE_6__.getDocument)(floatingFocusElement)) === (0,_floating_ui_react_utils__WEBPACK_IMPORTED_MODULE_6__.getDocument)(floatingFocusElement).body) {\n          // Let `FloatingPortal` effect knows that focus is still inside the\n          // floating tree.\n          if ((0,_floating_ui_react_dom__WEBPACK_IMPORTED_MODULE_5__.isHTMLElement)(floatingFocusElement)) {\n            floatingFocusElement.focus();\n          }\n          const prevTabbableIndex = tabbableIndexRef.current;\n          const tabbableContent = getTabbableContent();\n          const nodeToFocus = tabbableContent[prevTabbableIndex] || tabbableContent[tabbableContent.length - 1] || floatingFocusElement;\n          if ((0,_floating_ui_react_dom__WEBPACK_IMPORTED_MODULE_5__.isHTMLElement)(nodeToFocus)) {\n            nodeToFocus.focus();\n          }\n        }\n\n        // https://github.com/floating-ui/floating-ui/issues/3060\n        if (dataRef.current.insideReactTree) {\n          dataRef.current.insideReactTree = false;\n          return;\n        }\n\n        // Focus did not move inside the floating tree, and there are no tabbable\n        // portal guards to handle closing.\n        if ((isUntrappedTypeableCombobox ? true : !modal) && relatedTarget && movedToUnrelatedNode && !isPointerDownRef.current &&\n        // Fix React 18 Strict Mode returnFocus due to double rendering.\n        relatedTarget !== getPreviouslyFocusedElement()) {\n          preventReturnFocusRef.current = true;\n          onOpenChange(false, event, 'focus-out');\n        }\n      });\n    }\n    const shouldHandleBlurCapture = Boolean(!tree && portalContext);\n    function markInsideReactTree() {\n      clearTimeoutIfSet(blurTimeoutRef);\n      dataRef.current.insideReactTree = true;\n      blurTimeoutRef.current = window.setTimeout(() => {\n        dataRef.current.insideReactTree = false;\n      });\n    }\n    if (floating && (0,_floating_ui_react_dom__WEBPACK_IMPORTED_MODULE_5__.isHTMLElement)(domReference)) {\n      domReference.addEventListener('focusout', handleFocusOutside);\n      domReference.addEventListener('pointerdown', handlePointerDown);\n      floating.addEventListener('focusout', handleFocusOutside);\n      if (shouldHandleBlurCapture) {\n        floating.addEventListener('focusout', markInsideReactTree, true);\n      }\n      return () => {\n        domReference.removeEventListener('focusout', handleFocusOutside);\n        domReference.removeEventListener('pointerdown', handlePointerDown);\n        floating.removeEventListener('focusout', handleFocusOutside);\n        if (shouldHandleBlurCapture) {\n          floating.removeEventListener('focusout', markInsideReactTree, true);\n        }\n      };\n    }\n  }, [disabled, domReference, floating, floatingFocusElement, modal, tree, portalContext, onOpenChange, closeOnFocusOut, restoreFocus, getTabbableContent, isUntrappedTypeableCombobox, getNodeId, orderRef, dataRef]);\n  const beforeGuardRef = react__WEBPACK_IMPORTED_MODULE_0__.useRef(null);\n  const afterGuardRef = react__WEBPACK_IMPORTED_MODULE_0__.useRef(null);\n  const mergedBeforeGuardRef = useLiteMergeRefs([beforeGuardRef, portalContext == null ? void 0 : portalContext.beforeInsideRef]);\n  const mergedAfterGuardRef = useLiteMergeRefs([afterGuardRef, portalContext == null ? void 0 : portalContext.afterInsideRef]);\n  react__WEBPACK_IMPORTED_MODULE_0__.useEffect(() => {\n    var _portalContext$portal, _ancestors$find;\n    if (disabled) return;\n    if (!floating) return;\n\n    // Don't hide portals nested within the parent portal.\n    const portalNodes = Array.from((portalContext == null || (_portalContext$portal = portalContext.portalNode) == null ? void 0 : _portalContext$portal.querySelectorAll(\"[\" + createAttribute('portal') + \"]\")) || []);\n    const ancestors = tree ? (0,_floating_ui_react_utils__WEBPACK_IMPORTED_MODULE_6__.getNodeAncestors)(tree.nodesRef.current, getNodeId()) : [];\n    const rootAncestorComboboxDomReference = (_ancestors$find = ancestors.find(node => {\n      var _node$context6;\n      return (0,_floating_ui_react_utils__WEBPACK_IMPORTED_MODULE_6__.isTypeableCombobox)(((_node$context6 = node.context) == null ? void 0 : _node$context6.elements.domReference) || null);\n    })) == null || (_ancestors$find = _ancestors$find.context) == null ? void 0 : _ancestors$find.elements.domReference;\n    const insideElements = [floating, rootAncestorComboboxDomReference, ...portalNodes, ...getInsideElements(), startDismissButtonRef.current, endDismissButtonRef.current, beforeGuardRef.current, afterGuardRef.current, portalContext == null ? void 0 : portalContext.beforeOutsideRef.current, portalContext == null ? void 0 : portalContext.afterOutsideRef.current, orderRef.current.includes('reference') || isUntrappedTypeableCombobox ? domReference : null].filter(x => x != null);\n    const cleanup = modal || isUntrappedTypeableCombobox ? markOthers(insideElements, !useInert, useInert) : markOthers(insideElements);\n    return () => {\n      cleanup();\n    };\n  }, [disabled, domReference, floating, modal, orderRef, portalContext, isUntrappedTypeableCombobox, guards, useInert, tree, getNodeId, getInsideElements]);\n  (0,_floating_ui_react_utils__WEBPACK_IMPORTED_MODULE_6__.useModernLayoutEffect)(() => {\n    if (disabled || !(0,_floating_ui_react_dom__WEBPACK_IMPORTED_MODULE_5__.isHTMLElement)(floatingFocusElement)) return;\n    const doc = (0,_floating_ui_react_utils__WEBPACK_IMPORTED_MODULE_6__.getDocument)(floatingFocusElement);\n    const previouslyFocusedElement = (0,_floating_ui_react_utils__WEBPACK_IMPORTED_MODULE_6__.activeElement)(doc);\n\n    // Wait for any layout effect state setters to execute to set `tabIndex`.\n    queueMicrotask(() => {\n      const focusableElements = getTabbableElements(floatingFocusElement);\n      const initialFocusValue = initialFocusRef.current;\n      const elToFocus = (typeof initialFocusValue === 'number' ? focusableElements[initialFocusValue] : initialFocusValue.current) || floatingFocusElement;\n      const focusAlreadyInsideFloatingEl = (0,_floating_ui_react_utils__WEBPACK_IMPORTED_MODULE_6__.contains)(floatingFocusElement, previouslyFocusedElement);\n      if (!ignoreInitialFocus && !focusAlreadyInsideFloatingEl && open) {\n        enqueueFocus(elToFocus, {\n          preventScroll: elToFocus === floatingFocusElement\n        });\n      }\n    });\n  }, [disabled, open, floatingFocusElement, ignoreInitialFocus, getTabbableElements, initialFocusRef]);\n  (0,_floating_ui_react_utils__WEBPACK_IMPORTED_MODULE_6__.useModernLayoutEffect)(() => {\n    if (disabled || !floatingFocusElement) return;\n    const doc = (0,_floating_ui_react_utils__WEBPACK_IMPORTED_MODULE_6__.getDocument)(floatingFocusElement);\n    const previouslyFocusedElement = (0,_floating_ui_react_utils__WEBPACK_IMPORTED_MODULE_6__.activeElement)(doc);\n    addPreviouslyFocusedElement(previouslyFocusedElement);\n\n    // Dismissing via outside press should always ignore `returnFocus` to\n    // prevent unwanted scrolling.\n    function onOpenChange(_ref) {\n      let {\n        reason,\n        event,\n        nested\n      } = _ref;\n      if (['hover', 'safe-polygon'].includes(reason) && event.type === 'mouseleave') {\n        preventReturnFocusRef.current = true;\n      }\n      if (reason !== 'outside-press') return;\n      if (nested) {\n        preventReturnFocusRef.current = false;\n      } else if ((0,_floating_ui_react_utils__WEBPACK_IMPORTED_MODULE_6__.isVirtualClick)(event) || (0,_floating_ui_react_utils__WEBPACK_IMPORTED_MODULE_6__.isVirtualPointerEvent)(event)) {\n        preventReturnFocusRef.current = false;\n      } else {\n        let isPreventScrollSupported = false;\n        document.createElement('div').focus({\n          get preventScroll() {\n            isPreventScrollSupported = true;\n            return false;\n          }\n        });\n        if (isPreventScrollSupported) {\n          preventReturnFocusRef.current = false;\n        } else {\n          preventReturnFocusRef.current = true;\n        }\n      }\n    }\n    events.on('openchange', onOpenChange);\n    const fallbackEl = doc.createElement('span');\n    fallbackEl.setAttribute('tabindex', '-1');\n    fallbackEl.setAttribute('aria-hidden', 'true');\n    Object.assign(fallbackEl.style, HIDDEN_STYLES);\n    if (isInsidePortal && domReference) {\n      domReference.insertAdjacentElement('afterend', fallbackEl);\n    }\n    function getReturnElement() {\n      if (typeof returnFocusRef.current === 'boolean') {\n        const el = domReference || getPreviouslyFocusedElement();\n        return el && el.isConnected ? el : fallbackEl;\n      }\n      return returnFocusRef.current.current || fallbackEl;\n    }\n    return () => {\n      events.off('openchange', onOpenChange);\n      const activeEl = (0,_floating_ui_react_utils__WEBPACK_IMPORTED_MODULE_6__.activeElement)(doc);\n      const isFocusInsideFloatingTree = (0,_floating_ui_react_utils__WEBPACK_IMPORTED_MODULE_6__.contains)(floating, activeEl) || tree && (0,_floating_ui_react_utils__WEBPACK_IMPORTED_MODULE_6__.getNodeChildren)(tree.nodesRef.current, getNodeId(), false).some(node => {\n        var _node$context7;\n        return (0,_floating_ui_react_utils__WEBPACK_IMPORTED_MODULE_6__.contains)((_node$context7 = node.context) == null ? void 0 : _node$context7.elements.floating, activeEl);\n      });\n      const returnElement = getReturnElement();\n      queueMicrotask(() => {\n        // This is `returnElement`, if it's tabbable, or its first tabbable child.\n        const tabbableReturnElement = getFirstTabbableElement(returnElement);\n        if (\n        // eslint-disable-next-line react-hooks/exhaustive-deps\n        returnFocusRef.current && !preventReturnFocusRef.current && (0,_floating_ui_react_dom__WEBPACK_IMPORTED_MODULE_5__.isHTMLElement)(tabbableReturnElement) && (\n        // If the focus moved somewhere else after mount, avoid returning focus\n        // since it likely entered a different element which should be\n        // respected: https://github.com/floating-ui/floating-ui/issues/2607\n        tabbableReturnElement !== activeEl && activeEl !== doc.body ? isFocusInsideFloatingTree : true)) {\n          tabbableReturnElement.focus({\n            preventScroll: true\n          });\n        }\n        fallbackEl.remove();\n      });\n    };\n  }, [disabled, floating, floatingFocusElement, returnFocusRef, dataRef, events, tree, isInsidePortal, domReference, getNodeId]);\n  react__WEBPACK_IMPORTED_MODULE_0__.useEffect(() => {\n    // The `returnFocus` cleanup behavior is inside a microtask; ensure we\n    // wait for it to complete before resetting the flag.\n    queueMicrotask(() => {\n      preventReturnFocusRef.current = false;\n    });\n    return () => {\n      queueMicrotask(clearDisconnectedPreviouslyFocusedElements);\n    };\n  }, [disabled]);\n\n  // Synchronize the `context` & `modal` value to the FloatingPortal context.\n  // It will decide whether or not it needs to render its own guards.\n  (0,_floating_ui_react_utils__WEBPACK_IMPORTED_MODULE_6__.useModernLayoutEffect)(() => {\n    if (disabled) return;\n    if (!portalContext) return;\n    portalContext.setFocusManagerState({\n      modal,\n      closeOnFocusOut,\n      open,\n      onOpenChange,\n      domReference\n    });\n    return () => {\n      portalContext.setFocusManagerState(null);\n    };\n  }, [disabled, portalContext, modal, open, onOpenChange, closeOnFocusOut, domReference]);\n  (0,_floating_ui_react_utils__WEBPACK_IMPORTED_MODULE_6__.useModernLayoutEffect)(() => {\n    if (disabled) return;\n    if (!floatingFocusElement) return;\n    handleTabIndex(floatingFocusElement, orderRef);\n  }, [disabled, floatingFocusElement, orderRef]);\n  function renderDismissButton(location) {\n    if (disabled || !visuallyHiddenDismiss || !modal) {\n      return null;\n    }\n    return /*#__PURE__*/(0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_1__.jsx)(VisuallyHiddenDismiss, {\n      ref: location === 'start' ? startDismissButtonRef : endDismissButtonRef,\n      onClick: event => onOpenChange(false, event.nativeEvent),\n      children: typeof visuallyHiddenDismiss === 'string' ? visuallyHiddenDismiss : 'Dismiss'\n    });\n  }\n  const shouldRenderGuards = !disabled && guards && (modal ? !isUntrappedTypeableCombobox : true) && (isInsidePortal || modal);\n  return /*#__PURE__*/(0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_1__.jsxs)(react_jsx_runtime__WEBPACK_IMPORTED_MODULE_1__.Fragment, {\n    children: [shouldRenderGuards && /*#__PURE__*/(0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_1__.jsx)(FocusGuard, {\n      \"data-type\": \"inside\",\n      ref: mergedBeforeGuardRef,\n      onFocus: event => {\n        if (modal) {\n          const els = getTabbableElements();\n          enqueueFocus(order[0] === 'reference' ? els[0] : els[els.length - 1]);\n        } else if (portalContext != null && portalContext.preserveTabOrder && portalContext.portalNode) {\n          preventReturnFocusRef.current = false;\n          if ((0,_floating_ui_react_utils__WEBPACK_IMPORTED_MODULE_6__.isOutsideEvent)(event, portalContext.portalNode)) {\n            const nextTabbable = (0,_floating_ui_react_utils__WEBPACK_IMPORTED_MODULE_6__.getNextTabbable)(domReference);\n            nextTabbable == null || nextTabbable.focus();\n          } else {\n            var _portalContext$before;\n            (_portalContext$before = portalContext.beforeOutsideRef.current) == null || _portalContext$before.focus();\n          }\n        }\n      }\n    }), !isUntrappedTypeableCombobox && renderDismissButton('start'), children, renderDismissButton('end'), shouldRenderGuards && /*#__PURE__*/(0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_1__.jsx)(FocusGuard, {\n      \"data-type\": \"inside\",\n      ref: mergedAfterGuardRef,\n      onFocus: event => {\n        if (modal) {\n          enqueueFocus(getTabbableElements()[0]);\n        } else if (portalContext != null && portalContext.preserveTabOrder && portalContext.portalNode) {\n          if (closeOnFocusOut) {\n            preventReturnFocusRef.current = true;\n          }\n          if ((0,_floating_ui_react_utils__WEBPACK_IMPORTED_MODULE_6__.isOutsideEvent)(event, portalContext.portalNode)) {\n            const prevTabbable = (0,_floating_ui_react_utils__WEBPACK_IMPORTED_MODULE_6__.getPreviousTabbable)(domReference);\n            prevTabbable == null || prevTabbable.focus();\n          } else {\n            var _portalContext$afterO;\n            (_portalContext$afterO = portalContext.afterOutsideRef.current) == null || _portalContext$afterO.focus();\n          }\n        }\n      }\n    })]\n  });\n}\n\nlet lockCount = 0;\nconst scrollbarProperty = '--floating-ui-scrollbar-width';\nfunction enableScrollLock() {\n  const platform = (0,_floating_ui_react_utils__WEBPACK_IMPORTED_MODULE_6__.getPlatform)();\n  const isIOS = /iP(hone|ad|od)|iOS/.test(platform) ||\n  // iPads can claim to be MacIntel\n  platform === 'MacIntel' && navigator.maxTouchPoints > 1;\n  const bodyStyle = document.body.style;\n  // RTL <body> scrollbar\n  const scrollbarX = Math.round(document.documentElement.getBoundingClientRect().left) + document.documentElement.scrollLeft;\n  const paddingProp = scrollbarX ? 'paddingLeft' : 'paddingRight';\n  const scrollbarWidth = window.innerWidth - document.documentElement.clientWidth;\n  const scrollX = bodyStyle.left ? parseFloat(bodyStyle.left) : window.scrollX;\n  const scrollY = bodyStyle.top ? parseFloat(bodyStyle.top) : window.scrollY;\n  bodyStyle.overflow = 'hidden';\n  bodyStyle.setProperty(scrollbarProperty, scrollbarWidth + \"px\");\n  if (scrollbarWidth) {\n    bodyStyle[paddingProp] = scrollbarWidth + \"px\";\n  }\n\n  // Only iOS doesn't respect `overflow: hidden` on document.body, and this\n  // technique has fewer side effects.\n  if (isIOS) {\n    var _window$visualViewpor, _window$visualViewpor2;\n    // iOS 12 does not support `visualViewport`.\n    const offsetLeft = ((_window$visualViewpor = window.visualViewport) == null ? void 0 : _window$visualViewpor.offsetLeft) || 0;\n    const offsetTop = ((_window$visualViewpor2 = window.visualViewport) == null ? void 0 : _window$visualViewpor2.offsetTop) || 0;\n    Object.assign(bodyStyle, {\n      position: 'fixed',\n      top: -(scrollY - Math.floor(offsetTop)) + \"px\",\n      left: -(scrollX - Math.floor(offsetLeft)) + \"px\",\n      right: '0'\n    });\n  }\n  return () => {\n    Object.assign(bodyStyle, {\n      overflow: '',\n      [paddingProp]: ''\n    });\n    bodyStyle.removeProperty(scrollbarProperty);\n    if (isIOS) {\n      Object.assign(bodyStyle, {\n        position: '',\n        top: '',\n        left: '',\n        right: ''\n      });\n      window.scrollTo(scrollX, scrollY);\n    }\n  };\n}\nlet cleanup = () => {};\n\n/**\n * Provides base styling for a fixed overlay element to dim content or block\n * pointer events behind a floating element.\n * It's a regular `<div>`, so it can be styled via any CSS solution you prefer.\n * @see https://floating-ui.com/docs/FloatingOverlay\n */\nconst FloatingOverlay = /*#__PURE__*/react__WEBPACK_IMPORTED_MODULE_0__.forwardRef(function FloatingOverlay(props, ref) {\n  const {\n    lockScroll = false,\n    ...rest\n  } = props;\n  (0,_floating_ui_react_utils__WEBPACK_IMPORTED_MODULE_6__.useModernLayoutEffect)(() => {\n    if (!lockScroll) return;\n    lockCount++;\n    if (lockCount === 1) {\n      cleanup = enableScrollLock();\n    }\n    return () => {\n      lockCount--;\n      if (lockCount === 0) {\n        cleanup();\n      }\n    };\n  }, [lockScroll]);\n  return /*#__PURE__*/(0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_1__.jsx)(\"div\", {\n    ref: ref,\n    ...rest,\n    style: {\n      position: 'fixed',\n      overflow: 'auto',\n      top: 0,\n      right: 0,\n      bottom: 0,\n      left: 0,\n      ...rest.style\n    }\n  });\n});\n\nfunction isButtonTarget(event) {\n  return (0,_floating_ui_react_dom__WEBPACK_IMPORTED_MODULE_5__.isHTMLElement)(event.target) && event.target.tagName === 'BUTTON';\n}\nfunction isAnchorTarget(event) {\n  return (0,_floating_ui_react_dom__WEBPACK_IMPORTED_MODULE_5__.isHTMLElement)(event.target) && event.target.tagName === 'A';\n}\nfunction isSpaceIgnored(element) {\n  return (0,_floating_ui_react_utils__WEBPACK_IMPORTED_MODULE_6__.isTypeableElement)(element);\n}\n/**\n * Opens or closes the floating element when clicking the reference element.\n * @see https://floating-ui.com/docs/useClick\n */\nfunction useClick(context, props) {\n  if (props === void 0) {\n    props = {};\n  }\n  const {\n    open,\n    onOpenChange,\n    dataRef,\n    elements: {\n      domReference\n    }\n  } = context;\n  const {\n    enabled = true,\n    event: eventOption = 'click',\n    toggle = true,\n    ignoreMouse = false,\n    keyboardHandlers = true,\n    stickIfOpen = true\n  } = props;\n  const pointerTypeRef = react__WEBPACK_IMPORTED_MODULE_0__.useRef();\n  const didKeyDownRef = react__WEBPACK_IMPORTED_MODULE_0__.useRef(false);\n  const reference = react__WEBPACK_IMPORTED_MODULE_0__.useMemo(() => ({\n    onPointerDown(event) {\n      pointerTypeRef.current = event.pointerType;\n    },\n    onMouseDown(event) {\n      const pointerType = pointerTypeRef.current;\n\n      // Ignore all buttons except for the \"main\" button.\n      // https://developer.mozilla.org/en-US/docs/Web/API/MouseEvent/button\n      if (event.button !== 0) return;\n      if (eventOption === 'click') return;\n      if ((0,_floating_ui_react_utils__WEBPACK_IMPORTED_MODULE_6__.isMouseLikePointerType)(pointerType, true) && ignoreMouse) return;\n      if (open && toggle && (dataRef.current.openEvent && stickIfOpen ? dataRef.current.openEvent.type === 'mousedown' : true)) {\n        onOpenChange(false, event.nativeEvent, 'click');\n      } else {\n        // Prevent stealing focus from the floating element\n        event.preventDefault();\n        onOpenChange(true, event.nativeEvent, 'click');\n      }\n    },\n    onClick(event) {\n      const pointerType = pointerTypeRef.current;\n      if (eventOption === 'mousedown' && pointerTypeRef.current) {\n        pointerTypeRef.current = undefined;\n        return;\n      }\n      if ((0,_floating_ui_react_utils__WEBPACK_IMPORTED_MODULE_6__.isMouseLikePointerType)(pointerType, true) && ignoreMouse) return;\n      if (open && toggle && (dataRef.current.openEvent && stickIfOpen ? dataRef.current.openEvent.type === 'click' : true)) {\n        onOpenChange(false, event.nativeEvent, 'click');\n      } else {\n        onOpenChange(true, event.nativeEvent, 'click');\n      }\n    },\n    onKeyDown(event) {\n      pointerTypeRef.current = undefined;\n      if (event.defaultPrevented || !keyboardHandlers || isButtonTarget(event)) {\n        return;\n      }\n      if (event.key === ' ' && !isSpaceIgnored(domReference)) {\n        // Prevent scrolling\n        event.preventDefault();\n        didKeyDownRef.current = true;\n      }\n      if (isAnchorTarget(event)) {\n        return;\n      }\n      if (event.key === 'Enter') {\n        if (open && toggle) {\n          onOpenChange(false, event.nativeEvent, 'click');\n        } else {\n          onOpenChange(true, event.nativeEvent, 'click');\n        }\n      }\n    },\n    onKeyUp(event) {\n      if (event.defaultPrevented || !keyboardHandlers || isButtonTarget(event) || isSpaceIgnored(domReference)) {\n        return;\n      }\n      if (event.key === ' ' && didKeyDownRef.current) {\n        didKeyDownRef.current = false;\n        if (open && toggle) {\n          onOpenChange(false, event.nativeEvent, 'click');\n        } else {\n          onOpenChange(true, event.nativeEvent, 'click');\n        }\n      }\n    }\n  }), [dataRef, domReference, eventOption, ignoreMouse, keyboardHandlers, onOpenChange, open, stickIfOpen, toggle]);\n  return react__WEBPACK_IMPORTED_MODULE_0__.useMemo(() => enabled ? {\n    reference\n  } : {}, [enabled, reference]);\n}\n\nfunction createVirtualElement(domElement, data) {\n  let offsetX = null;\n  let offsetY = null;\n  let isAutoUpdateEvent = false;\n  return {\n    contextElement: domElement || undefined,\n    getBoundingClientRect() {\n      var _data$dataRef$current;\n      const domRect = (domElement == null ? void 0 : domElement.getBoundingClientRect()) || {\n        width: 0,\n        height: 0,\n        x: 0,\n        y: 0\n      };\n      const isXAxis = data.axis === 'x' || data.axis === 'both';\n      const isYAxis = data.axis === 'y' || data.axis === 'both';\n      const canTrackCursorOnAutoUpdate = ['mouseenter', 'mousemove'].includes(((_data$dataRef$current = data.dataRef.current.openEvent) == null ? void 0 : _data$dataRef$current.type) || '') && data.pointerType !== 'touch';\n      let width = domRect.width;\n      let height = domRect.height;\n      let x = domRect.x;\n      let y = domRect.y;\n      if (offsetX == null && data.x && isXAxis) {\n        offsetX = domRect.x - data.x;\n      }\n      if (offsetY == null && data.y && isYAxis) {\n        offsetY = domRect.y - data.y;\n      }\n      x -= offsetX || 0;\n      y -= offsetY || 0;\n      width = 0;\n      height = 0;\n      if (!isAutoUpdateEvent || canTrackCursorOnAutoUpdate) {\n        width = data.axis === 'y' ? domRect.width : 0;\n        height = data.axis === 'x' ? domRect.height : 0;\n        x = isXAxis && data.x != null ? data.x : x;\n        y = isYAxis && data.y != null ? data.y : y;\n      } else if (isAutoUpdateEvent && !canTrackCursorOnAutoUpdate) {\n        height = data.axis === 'x' ? domRect.height : height;\n        width = data.axis === 'y' ? domRect.width : width;\n      }\n      isAutoUpdateEvent = true;\n      return {\n        width,\n        height,\n        x,\n        y,\n        top: y,\n        right: x + width,\n        bottom: y + height,\n        left: x\n      };\n    }\n  };\n}\nfunction isMouseBasedEvent(event) {\n  return event != null && event.clientX != null;\n}\n/**\n * Positions the floating element relative to a client point (in the viewport),\n * such as the mouse position. By default, it follows the mouse cursor.\n * @see https://floating-ui.com/docs/useClientPoint\n */\nfunction useClientPoint(context, props) {\n  if (props === void 0) {\n    props = {};\n  }\n  const {\n    open,\n    dataRef,\n    elements: {\n      floating,\n      domReference\n    },\n    refs\n  } = context;\n  const {\n    enabled = true,\n    axis = 'both',\n    x = null,\n    y = null\n  } = props;\n  const initialRef = react__WEBPACK_IMPORTED_MODULE_0__.useRef(false);\n  const cleanupListenerRef = react__WEBPACK_IMPORTED_MODULE_0__.useRef(null);\n  const [pointerType, setPointerType] = react__WEBPACK_IMPORTED_MODULE_0__.useState();\n  const [reactive, setReactive] = react__WEBPACK_IMPORTED_MODULE_0__.useState([]);\n  const setReference = (0,_floating_ui_react_utils__WEBPACK_IMPORTED_MODULE_6__.useEffectEvent)((x, y) => {\n    if (initialRef.current) return;\n\n    // Prevent setting if the open event was not a mouse-like one\n    // (e.g. focus to open, then hover over the reference element).\n    // Only apply if the event exists.\n    if (dataRef.current.openEvent && !isMouseBasedEvent(dataRef.current.openEvent)) {\n      return;\n    }\n    refs.setPositionReference(createVirtualElement(domReference, {\n      x,\n      y,\n      axis,\n      dataRef,\n      pointerType\n    }));\n  });\n  const handleReferenceEnterOrMove = (0,_floating_ui_react_utils__WEBPACK_IMPORTED_MODULE_6__.useEffectEvent)(event => {\n    if (x != null || y != null) return;\n    if (!open) {\n      setReference(event.clientX, event.clientY);\n    } else if (!cleanupListenerRef.current) {\n      // If there's no cleanup, there's no listener, but we want to ensure\n      // we add the listener if the cursor landed on the floating element and\n      // then back on the reference (i.e. it's interactive).\n      setReactive([]);\n    }\n  });\n\n  // If the pointer is a mouse-like pointer, we want to continue following the\n  // mouse even if the floating element is transitioning out. On touch\n  // devices, this is undesirable because the floating element will move to\n  // the dismissal touch point.\n  const openCheck = (0,_floating_ui_react_utils__WEBPACK_IMPORTED_MODULE_6__.isMouseLikePointerType)(pointerType) ? floating : open;\n  const addListener = react__WEBPACK_IMPORTED_MODULE_0__.useCallback(() => {\n    // Explicitly specified `x`/`y` coordinates shouldn't add a listener.\n    if (!openCheck || !enabled || x != null || y != null) return;\n    const win = (0,_floating_ui_react_dom__WEBPACK_IMPORTED_MODULE_5__.getWindow)(floating);\n    function handleMouseMove(event) {\n      const target = (0,_floating_ui_react_utils__WEBPACK_IMPORTED_MODULE_6__.getTarget)(event);\n      if (!(0,_floating_ui_react_utils__WEBPACK_IMPORTED_MODULE_6__.contains)(floating, target)) {\n        setReference(event.clientX, event.clientY);\n      } else {\n        win.removeEventListener('mousemove', handleMouseMove);\n        cleanupListenerRef.current = null;\n      }\n    }\n    if (!dataRef.current.openEvent || isMouseBasedEvent(dataRef.current.openEvent)) {\n      win.addEventListener('mousemove', handleMouseMove);\n      const cleanup = () => {\n        win.removeEventListener('mousemove', handleMouseMove);\n        cleanupListenerRef.current = null;\n      };\n      cleanupListenerRef.current = cleanup;\n      return cleanup;\n    }\n    refs.setPositionReference(domReference);\n  }, [openCheck, enabled, x, y, floating, dataRef, refs, domReference, setReference]);\n  react__WEBPACK_IMPORTED_MODULE_0__.useEffect(() => {\n    return addListener();\n  }, [addListener, reactive]);\n  react__WEBPACK_IMPORTED_MODULE_0__.useEffect(() => {\n    if (enabled && !floating) {\n      initialRef.current = false;\n    }\n  }, [enabled, floating]);\n  react__WEBPACK_IMPORTED_MODULE_0__.useEffect(() => {\n    if (!enabled && open) {\n      initialRef.current = true;\n    }\n  }, [enabled, open]);\n  (0,_floating_ui_react_utils__WEBPACK_IMPORTED_MODULE_6__.useModernLayoutEffect)(() => {\n    if (enabled && (x != null || y != null)) {\n      initialRef.current = false;\n      setReference(x, y);\n    }\n  }, [enabled, x, y, setReference]);\n  const reference = react__WEBPACK_IMPORTED_MODULE_0__.useMemo(() => {\n    function setPointerTypeRef(_ref) {\n      let {\n        pointerType\n      } = _ref;\n      setPointerType(pointerType);\n    }\n    return {\n      onPointerDown: setPointerTypeRef,\n      onPointerEnter: setPointerTypeRef,\n      onMouseMove: handleReferenceEnterOrMove,\n      onMouseEnter: handleReferenceEnterOrMove\n    };\n  }, [handleReferenceEnterOrMove]);\n  return react__WEBPACK_IMPORTED_MODULE_0__.useMemo(() => enabled ? {\n    reference\n  } : {}, [enabled, reference]);\n}\n\nconst bubbleHandlerKeys = {\n  pointerdown: 'onPointerDown',\n  mousedown: 'onMouseDown',\n  click: 'onClick'\n};\nconst captureHandlerKeys = {\n  pointerdown: 'onPointerDownCapture',\n  mousedown: 'onMouseDownCapture',\n  click: 'onClickCapture'\n};\nconst normalizeProp = normalizable => {\n  var _normalizable$escapeK, _normalizable$outside;\n  return {\n    escapeKey: typeof normalizable === 'boolean' ? normalizable : (_normalizable$escapeK = normalizable == null ? void 0 : normalizable.escapeKey) != null ? _normalizable$escapeK : false,\n    outsidePress: typeof normalizable === 'boolean' ? normalizable : (_normalizable$outside = normalizable == null ? void 0 : normalizable.outsidePress) != null ? _normalizable$outside : true\n  };\n};\n/**\n * Closes the floating element when a dismissal is requested  by default, when\n * the user presses the `escape` key or outside of the floating element.\n * @see https://floating-ui.com/docs/useDismiss\n */\nfunction useDismiss(context, props) {\n  if (props === void 0) {\n    props = {};\n  }\n  const {\n    open,\n    onOpenChange,\n    elements,\n    dataRef\n  } = context;\n  const {\n    enabled = true,\n    escapeKey = true,\n    outsidePress: unstable_outsidePress = true,\n    outsidePressEvent = 'pointerdown',\n    referencePress = false,\n    referencePressEvent = 'pointerdown',\n    ancestorScroll = false,\n    bubbles,\n    capture\n  } = props;\n  const tree = useFloatingTree();\n  const outsidePressFn = (0,_floating_ui_react_utils__WEBPACK_IMPORTED_MODULE_6__.useEffectEvent)(typeof unstable_outsidePress === 'function' ? unstable_outsidePress : () => false);\n  const outsidePress = typeof unstable_outsidePress === 'function' ? outsidePressFn : unstable_outsidePress;\n  const endedOrStartedInsideRef = react__WEBPACK_IMPORTED_MODULE_0__.useRef(false);\n  const {\n    escapeKey: escapeKeyBubbles,\n    outsidePress: outsidePressBubbles\n  } = normalizeProp(bubbles);\n  const {\n    escapeKey: escapeKeyCapture,\n    outsidePress: outsidePressCapture\n  } = normalizeProp(capture);\n  const isComposingRef = react__WEBPACK_IMPORTED_MODULE_0__.useRef(false);\n  const closeOnEscapeKeyDown = (0,_floating_ui_react_utils__WEBPACK_IMPORTED_MODULE_6__.useEffectEvent)(event => {\n    var _dataRef$current$floa;\n    if (!open || !enabled || !escapeKey || event.key !== 'Escape') {\n      return;\n    }\n\n    // Wait until IME is settled. Pressing `Escape` while composing should\n    // close the compose menu, but not the floating element.\n    if (isComposingRef.current) {\n      return;\n    }\n    const nodeId = (_dataRef$current$floa = dataRef.current.floatingContext) == null ? void 0 : _dataRef$current$floa.nodeId;\n    const children = tree ? (0,_floating_ui_react_utils__WEBPACK_IMPORTED_MODULE_6__.getNodeChildren)(tree.nodesRef.current, nodeId) : [];\n    if (!escapeKeyBubbles) {\n      event.stopPropagation();\n      if (children.length > 0) {\n        let shouldDismiss = true;\n        children.forEach(child => {\n          var _child$context;\n          if ((_child$context = child.context) != null && _child$context.open && !child.context.dataRef.current.__escapeKeyBubbles) {\n            shouldDismiss = false;\n            return;\n          }\n        });\n        if (!shouldDismiss) {\n          return;\n        }\n      }\n    }\n    onOpenChange(false, (0,_floating_ui_react_utils__WEBPACK_IMPORTED_MODULE_6__.isReactEvent)(event) ? event.nativeEvent : event, 'escape-key');\n  });\n  const closeOnEscapeKeyDownCapture = (0,_floating_ui_react_utils__WEBPACK_IMPORTED_MODULE_6__.useEffectEvent)(event => {\n    var _getTarget2;\n    const callback = () => {\n      var _getTarget;\n      closeOnEscapeKeyDown(event);\n      (_getTarget = (0,_floating_ui_react_utils__WEBPACK_IMPORTED_MODULE_6__.getTarget)(event)) == null || _getTarget.removeEventListener('keydown', callback);\n    };\n    (_getTarget2 = (0,_floating_ui_react_utils__WEBPACK_IMPORTED_MODULE_6__.getTarget)(event)) == null || _getTarget2.addEventListener('keydown', callback);\n  });\n  const closeOnPressOutside = (0,_floating_ui_react_utils__WEBPACK_IMPORTED_MODULE_6__.useEffectEvent)(event => {\n    var _dataRef$current$floa2;\n    // Given developers can stop the propagation of the synthetic event,\n    // we can only be confident with a positive value.\n    const insideReactTree = dataRef.current.insideReactTree;\n    dataRef.current.insideReactTree = false;\n\n    // When click outside is lazy (`click` event), handle dragging.\n    // Don't close if:\n    // - The click started inside the floating element.\n    // - The click ended inside the floating element.\n    const endedOrStartedInside = endedOrStartedInsideRef.current;\n    endedOrStartedInsideRef.current = false;\n    if (outsidePressEvent === 'click' && endedOrStartedInside) {\n      return;\n    }\n    if (insideReactTree) {\n      return;\n    }\n    if (typeof outsidePress === 'function' && !outsidePress(event)) {\n      return;\n    }\n    const target = (0,_floating_ui_react_utils__WEBPACK_IMPORTED_MODULE_6__.getTarget)(event);\n    const inertSelector = \"[\" + createAttribute('inert') + \"]\";\n    const markers = (0,_floating_ui_react_utils__WEBPACK_IMPORTED_MODULE_6__.getDocument)(elements.floating).querySelectorAll(inertSelector);\n    let targetRootAncestor = (0,_floating_ui_react_dom__WEBPACK_IMPORTED_MODULE_5__.isElement)(target) ? target : null;\n    while (targetRootAncestor && !(0,_floating_ui_react_dom__WEBPACK_IMPORTED_MODULE_5__.isLastTraversableNode)(targetRootAncestor)) {\n      const nextParent = (0,_floating_ui_react_dom__WEBPACK_IMPORTED_MODULE_5__.getParentNode)(targetRootAncestor);\n      if ((0,_floating_ui_react_dom__WEBPACK_IMPORTED_MODULE_5__.isLastTraversableNode)(nextParent) || !(0,_floating_ui_react_dom__WEBPACK_IMPORTED_MODULE_5__.isElement)(nextParent)) {\n        break;\n      }\n      targetRootAncestor = nextParent;\n    }\n\n    // Check if the click occurred on a third-party element injected after the\n    // floating element rendered.\n    if (markers.length && (0,_floating_ui_react_dom__WEBPACK_IMPORTED_MODULE_5__.isElement)(target) && !(0,_floating_ui_react_utils__WEBPACK_IMPORTED_MODULE_6__.isRootElement)(target) &&\n    // Clicked on a direct ancestor (e.g. FloatingOverlay).\n    !(0,_floating_ui_react_utils__WEBPACK_IMPORTED_MODULE_6__.contains)(target, elements.floating) &&\n    // If the target root element contains none of the markers, then the\n    // element was injected after the floating element rendered.\n    Array.from(markers).every(marker => !(0,_floating_ui_react_utils__WEBPACK_IMPORTED_MODULE_6__.contains)(targetRootAncestor, marker))) {\n      return;\n    }\n\n    // Check if the click occurred on the scrollbar\n    if ((0,_floating_ui_react_dom__WEBPACK_IMPORTED_MODULE_5__.isHTMLElement)(target) && floating) {\n      const lastTraversableNode = (0,_floating_ui_react_dom__WEBPACK_IMPORTED_MODULE_5__.isLastTraversableNode)(target);\n      const style = (0,_floating_ui_react_dom__WEBPACK_IMPORTED_MODULE_5__.getComputedStyle)(target);\n      const scrollRe = /auto|scroll/;\n      const isScrollableX = lastTraversableNode || scrollRe.test(style.overflowX);\n      const isScrollableY = lastTraversableNode || scrollRe.test(style.overflowY);\n      const canScrollX = isScrollableX && target.clientWidth > 0 && target.scrollWidth > target.clientWidth;\n      const canScrollY = isScrollableY && target.clientHeight > 0 && target.scrollHeight > target.clientHeight;\n      const isRTL = style.direction === 'rtl';\n\n      // Check click position relative to scrollbar.\n      // In some browsers it is possible to change the <body> (or window)\n      // scrollbar to the left side, but is very rare and is difficult to\n      // check for. Plus, for modal dialogs with backdrops, it is more\n      // important that the backdrop is checked but not so much the window.\n      const pressedVerticalScrollbar = canScrollY && (isRTL ? event.offsetX <= target.offsetWidth - target.clientWidth : event.offsetX > target.clientWidth);\n      const pressedHorizontalScrollbar = canScrollX && event.offsetY > target.clientHeight;\n      if (pressedVerticalScrollbar || pressedHorizontalScrollbar) {\n        return;\n      }\n    }\n    const nodeId = (_dataRef$current$floa2 = dataRef.current.floatingContext) == null ? void 0 : _dataRef$current$floa2.nodeId;\n    const targetIsInsideChildren = tree && (0,_floating_ui_react_utils__WEBPACK_IMPORTED_MODULE_6__.getNodeChildren)(tree.nodesRef.current, nodeId).some(node => {\n      var _node$context;\n      return (0,_floating_ui_react_utils__WEBPACK_IMPORTED_MODULE_6__.isEventTargetWithin)(event, (_node$context = node.context) == null ? void 0 : _node$context.elements.floating);\n    });\n    if ((0,_floating_ui_react_utils__WEBPACK_IMPORTED_MODULE_6__.isEventTargetWithin)(event, elements.floating) || (0,_floating_ui_react_utils__WEBPACK_IMPORTED_MODULE_6__.isEventTargetWithin)(event, elements.domReference) || targetIsInsideChildren) {\n      return;\n    }\n    const children = tree ? (0,_floating_ui_react_utils__WEBPACK_IMPORTED_MODULE_6__.getNodeChildren)(tree.nodesRef.current, nodeId) : [];\n    if (children.length > 0) {\n      let shouldDismiss = true;\n      children.forEach(child => {\n        var _child$context2;\n        if ((_child$context2 = child.context) != null && _child$context2.open && !child.context.dataRef.current.__outsidePressBubbles) {\n          shouldDismiss = false;\n          return;\n        }\n      });\n      if (!shouldDismiss) {\n        return;\n      }\n    }\n    onOpenChange(false, event, 'outside-press');\n  });\n  const closeOnPressOutsideCapture = (0,_floating_ui_react_utils__WEBPACK_IMPORTED_MODULE_6__.useEffectEvent)(event => {\n    var _getTarget4;\n    const callback = () => {\n      var _getTarget3;\n      closeOnPressOutside(event);\n      (_getTarget3 = (0,_floating_ui_react_utils__WEBPACK_IMPORTED_MODULE_6__.getTarget)(event)) == null || _getTarget3.removeEventListener(outsidePressEvent, callback);\n    };\n    (_getTarget4 = (0,_floating_ui_react_utils__WEBPACK_IMPORTED_MODULE_6__.getTarget)(event)) == null || _getTarget4.addEventListener(outsidePressEvent, callback);\n  });\n  react__WEBPACK_IMPORTED_MODULE_0__.useEffect(() => {\n    if (!open || !enabled) {\n      return;\n    }\n    dataRef.current.__escapeKeyBubbles = escapeKeyBubbles;\n    dataRef.current.__outsidePressBubbles = outsidePressBubbles;\n    let compositionTimeout = -1;\n    function onScroll(event) {\n      onOpenChange(false, event, 'ancestor-scroll');\n    }\n    function handleCompositionStart() {\n      window.clearTimeout(compositionTimeout);\n      isComposingRef.current = true;\n    }\n    function handleCompositionEnd() {\n      // Safari fires `compositionend` before `keydown`, so we need to wait\n      // until the next tick to set `isComposing` to `false`.\n      // https://bugs.webkit.org/show_bug.cgi?id=165004\n      compositionTimeout = window.setTimeout(() => {\n        isComposingRef.current = false;\n      },\n      // 0ms or 1ms don't work in Safari. 5ms appears to consistently work.\n      // Only apply to WebKit for the test to remain 0ms.\n      (0,_floating_ui_react_dom__WEBPACK_IMPORTED_MODULE_5__.isWebKit)() ? 5 : 0);\n    }\n    const doc = (0,_floating_ui_react_utils__WEBPACK_IMPORTED_MODULE_6__.getDocument)(elements.floating);\n    if (escapeKey) {\n      doc.addEventListener('keydown', escapeKeyCapture ? closeOnEscapeKeyDownCapture : closeOnEscapeKeyDown, escapeKeyCapture);\n      doc.addEventListener('compositionstart', handleCompositionStart);\n      doc.addEventListener('compositionend', handleCompositionEnd);\n    }\n    outsidePress && doc.addEventListener(outsidePressEvent, outsidePressCapture ? closeOnPressOutsideCapture : closeOnPressOutside, outsidePressCapture);\n    let ancestors = [];\n    if (ancestorScroll) {\n      if ((0,_floating_ui_react_dom__WEBPACK_IMPORTED_MODULE_5__.isElement)(elements.domReference)) {\n        ancestors = (0,_floating_ui_react_dom__WEBPACK_IMPORTED_MODULE_5__.getOverflowAncestors)(elements.domReference);\n      }\n      if ((0,_floating_ui_react_dom__WEBPACK_IMPORTED_MODULE_5__.isElement)(elements.floating)) {\n        ancestors = ancestors.concat((0,_floating_ui_react_dom__WEBPACK_IMPORTED_MODULE_5__.getOverflowAncestors)(elements.floating));\n      }\n      if (!(0,_floating_ui_react_dom__WEBPACK_IMPORTED_MODULE_5__.isElement)(elements.reference) && elements.reference && elements.reference.contextElement) {\n        ancestors = ancestors.concat((0,_floating_ui_react_dom__WEBPACK_IMPORTED_MODULE_5__.getOverflowAncestors)(elements.reference.contextElement));\n      }\n    }\n\n    // Ignore the visual viewport for scrolling dismissal (allow pinch-zoom)\n    ancestors = ancestors.filter(ancestor => {\n      var _doc$defaultView;\n      return ancestor !== ((_doc$defaultView = doc.defaultView) == null ? void 0 : _doc$defaultView.visualViewport);\n    });\n    ancestors.forEach(ancestor => {\n      ancestor.addEventListener('scroll', onScroll, {\n        passive: true\n      });\n    });\n    return () => {\n      if (escapeKey) {\n        doc.removeEventListener('keydown', escapeKeyCapture ? closeOnEscapeKeyDownCapture : closeOnEscapeKeyDown, escapeKeyCapture);\n        doc.removeEventListener('compositionstart', handleCompositionStart);\n        doc.removeEventListener('compositionend', handleCompositionEnd);\n      }\n      outsidePress && doc.removeEventListener(outsidePressEvent, outsidePressCapture ? closeOnPressOutsideCapture : closeOnPressOutside, outsidePressCapture);\n      ancestors.forEach(ancestor => {\n        ancestor.removeEventListener('scroll', onScroll);\n      });\n      window.clearTimeout(compositionTimeout);\n    };\n  }, [dataRef, elements, escapeKey, outsidePress, outsidePressEvent, open, onOpenChange, ancestorScroll, enabled, escapeKeyBubbles, outsidePressBubbles, closeOnEscapeKeyDown, escapeKeyCapture, closeOnEscapeKeyDownCapture, closeOnPressOutside, outsidePressCapture, closeOnPressOutsideCapture]);\n  react__WEBPACK_IMPORTED_MODULE_0__.useEffect(() => {\n    dataRef.current.insideReactTree = false;\n  }, [dataRef, outsidePress, outsidePressEvent]);\n  const reference = react__WEBPACK_IMPORTED_MODULE_0__.useMemo(() => ({\n    onKeyDown: closeOnEscapeKeyDown,\n    ...(referencePress && {\n      [bubbleHandlerKeys[referencePressEvent]]: event => {\n        onOpenChange(false, event.nativeEvent, 'reference-press');\n      },\n      ...(referencePressEvent !== 'click' && {\n        onClick(event) {\n          onOpenChange(false, event.nativeEvent, 'reference-press');\n        }\n      })\n    })\n  }), [closeOnEscapeKeyDown, onOpenChange, referencePress, referencePressEvent]);\n  const floating = react__WEBPACK_IMPORTED_MODULE_0__.useMemo(() => ({\n    onKeyDown: closeOnEscapeKeyDown,\n    onMouseDown() {\n      endedOrStartedInsideRef.current = true;\n    },\n    onMouseUp() {\n      endedOrStartedInsideRef.current = true;\n    },\n    [captureHandlerKeys[outsidePressEvent]]: () => {\n      dataRef.current.insideReactTree = true;\n    }\n  }), [closeOnEscapeKeyDown, outsidePressEvent, dataRef]);\n  return react__WEBPACK_IMPORTED_MODULE_0__.useMemo(() => enabled ? {\n    reference,\n    floating\n  } : {}, [enabled, reference, floating]);\n}\n\nfunction useFloatingRootContext(options) {\n  const {\n    open = false,\n    onOpenChange: onOpenChangeProp,\n    elements: elementsProp\n  } = options;\n  const floatingId = useId();\n  const dataRef = react__WEBPACK_IMPORTED_MODULE_0__.useRef({});\n  const [events] = react__WEBPACK_IMPORTED_MODULE_0__.useState(() => createEventEmitter());\n  const nested = useFloatingParentNodeId() != null;\n  if (true) {\n    const optionDomReference = elementsProp.reference;\n    if (optionDomReference && !(0,_floating_ui_react_dom__WEBPACK_IMPORTED_MODULE_5__.isElement)(optionDomReference)) {\n      error('Cannot pass a virtual element to the `elements.reference` option,', 'as it must be a real DOM element. Use `refs.setPositionReference()`', 'instead.');\n    }\n  }\n  const [positionReference, setPositionReference] = react__WEBPACK_IMPORTED_MODULE_0__.useState(elementsProp.reference);\n  const onOpenChange = (0,_floating_ui_react_utils__WEBPACK_IMPORTED_MODULE_6__.useEffectEvent)((open, event, reason) => {\n    dataRef.current.openEvent = open ? event : undefined;\n    events.emit('openchange', {\n      open,\n      event,\n      reason,\n      nested\n    });\n    onOpenChangeProp == null || onOpenChangeProp(open, event, reason);\n  });\n  const refs = react__WEBPACK_IMPORTED_MODULE_0__.useMemo(() => ({\n    setPositionReference\n  }), []);\n  const elements = react__WEBPACK_IMPORTED_MODULE_0__.useMemo(() => ({\n    reference: positionReference || elementsProp.reference || null,\n    floating: elementsProp.floating || null,\n    domReference: elementsProp.reference\n  }), [positionReference, elementsProp.reference, elementsProp.floating]);\n  return react__WEBPACK_IMPORTED_MODULE_0__.useMemo(() => ({\n    dataRef,\n    open,\n    onOpenChange,\n    elements,\n    events,\n    floatingId,\n    refs\n  }), [open, onOpenChange, elements, events, floatingId, refs]);\n}\n\n/**\n * Provides data to position a floating element and context to add interactions.\n * @see https://floating-ui.com/docs/useFloating\n */\nfunction useFloating(options) {\n  if (options === void 0) {\n    options = {};\n  }\n  const {\n    nodeId\n  } = options;\n  const internalRootContext = useFloatingRootContext({\n    ...options,\n    elements: {\n      reference: null,\n      floating: null,\n      ...options.elements\n    }\n  });\n  const rootContext = options.rootContext || internalRootContext;\n  const computedElements = rootContext.elements;\n  const [_domReference, setDomReference] = react__WEBPACK_IMPORTED_MODULE_0__.useState(null);\n  const [positionReference, _setPositionReference] = react__WEBPACK_IMPORTED_MODULE_0__.useState(null);\n  const optionDomReference = computedElements == null ? void 0 : computedElements.domReference;\n  const domReference = optionDomReference || _domReference;\n  const domReferenceRef = react__WEBPACK_IMPORTED_MODULE_0__.useRef(null);\n  const tree = useFloatingTree();\n  (0,_floating_ui_react_utils__WEBPACK_IMPORTED_MODULE_6__.useModernLayoutEffect)(() => {\n    if (domReference) {\n      domReferenceRef.current = domReference;\n    }\n  }, [domReference]);\n  const position = (0,_floating_ui_react_dom__WEBPACK_IMPORTED_MODULE_3__.useFloating)({\n    ...options,\n    elements: {\n      ...computedElements,\n      ...(positionReference && {\n        reference: positionReference\n      })\n    }\n  });\n  const setPositionReference = react__WEBPACK_IMPORTED_MODULE_0__.useCallback(node => {\n    const computedPositionReference = (0,_floating_ui_react_dom__WEBPACK_IMPORTED_MODULE_5__.isElement)(node) ? {\n      getBoundingClientRect: () => node.getBoundingClientRect(),\n      getClientRects: () => node.getClientRects(),\n      contextElement: node\n    } : node;\n    // Store the positionReference in state if the DOM reference is specified externally via the\n    // `elements.reference` option. This ensures that it won't be overridden on future renders.\n    _setPositionReference(computedPositionReference);\n    position.refs.setReference(computedPositionReference);\n  }, [position.refs]);\n  const setReference = react__WEBPACK_IMPORTED_MODULE_0__.useCallback(node => {\n    if ((0,_floating_ui_react_dom__WEBPACK_IMPORTED_MODULE_5__.isElement)(node) || node === null) {\n      domReferenceRef.current = node;\n      setDomReference(node);\n    }\n\n    // Backwards-compatibility for passing a virtual element to `reference`\n    // after it has set the DOM reference.\n    if ((0,_floating_ui_react_dom__WEBPACK_IMPORTED_MODULE_5__.isElement)(position.refs.reference.current) || position.refs.reference.current === null ||\n    // Don't allow setting virtual elements using the old technique back to\n    // `null` to support `positionReference` + an unstable `reference`\n    // callback ref.\n    node !== null && !(0,_floating_ui_react_dom__WEBPACK_IMPORTED_MODULE_5__.isElement)(node)) {\n      position.refs.setReference(node);\n    }\n  }, [position.refs]);\n  const refs = react__WEBPACK_IMPORTED_MODULE_0__.useMemo(() => ({\n    ...position.refs,\n    setReference,\n    setPositionReference,\n    domReference: domReferenceRef\n  }), [position.refs, setReference, setPositionReference]);\n  const elements = react__WEBPACK_IMPORTED_MODULE_0__.useMemo(() => ({\n    ...position.elements,\n    domReference: domReference\n  }), [position.elements, domReference]);\n  const context = react__WEBPACK_IMPORTED_MODULE_0__.useMemo(() => ({\n    ...position,\n    ...rootContext,\n    refs,\n    elements,\n    nodeId\n  }), [position, refs, elements, nodeId, rootContext]);\n  (0,_floating_ui_react_utils__WEBPACK_IMPORTED_MODULE_6__.useModernLayoutEffect)(() => {\n    rootContext.dataRef.current.floatingContext = context;\n    const node = tree == null ? void 0 : tree.nodesRef.current.find(node => node.id === nodeId);\n    if (node) {\n      node.context = context;\n    }\n  });\n  return react__WEBPACK_IMPORTED_MODULE_0__.useMemo(() => ({\n    ...position,\n    context,\n    refs,\n    elements\n  }), [position, refs, elements, context]);\n}\n\nfunction isMacSafari() {\n  return (0,_floating_ui_react_utils__WEBPACK_IMPORTED_MODULE_6__.isMac)() && (0,_floating_ui_react_utils__WEBPACK_IMPORTED_MODULE_6__.isSafari)();\n}\n/**\n * Opens the floating element while the reference element has focus, like CSS\n * `:focus`.\n * @see https://floating-ui.com/docs/useFocus\n */\nfunction useFocus(context, props) {\n  if (props === void 0) {\n    props = {};\n  }\n  const {\n    open,\n    onOpenChange,\n    events,\n    dataRef,\n    elements\n  } = context;\n  const {\n    enabled = true,\n    visibleOnly = true\n  } = props;\n  const blockFocusRef = react__WEBPACK_IMPORTED_MODULE_0__.useRef(false);\n  const timeoutRef = react__WEBPACK_IMPORTED_MODULE_0__.useRef(-1);\n  const keyboardModalityRef = react__WEBPACK_IMPORTED_MODULE_0__.useRef(true);\n  react__WEBPACK_IMPORTED_MODULE_0__.useEffect(() => {\n    if (!enabled) return;\n    const win = (0,_floating_ui_react_dom__WEBPACK_IMPORTED_MODULE_5__.getWindow)(elements.domReference);\n\n    // If the reference was focused and the user left the tab/window, and the\n    // floating element was not open, the focus should be blocked when they\n    // return to the tab/window.\n    function onBlur() {\n      if (!open && (0,_floating_ui_react_dom__WEBPACK_IMPORTED_MODULE_5__.isHTMLElement)(elements.domReference) && elements.domReference === (0,_floating_ui_react_utils__WEBPACK_IMPORTED_MODULE_6__.activeElement)((0,_floating_ui_react_utils__WEBPACK_IMPORTED_MODULE_6__.getDocument)(elements.domReference))) {\n        blockFocusRef.current = true;\n      }\n    }\n    function onKeyDown() {\n      keyboardModalityRef.current = true;\n    }\n    function onPointerDown() {\n      keyboardModalityRef.current = false;\n    }\n    win.addEventListener('blur', onBlur);\n    if (isMacSafari()) {\n      win.addEventListener('keydown', onKeyDown, true);\n      win.addEventListener('pointerdown', onPointerDown, true);\n    }\n    return () => {\n      win.removeEventListener('blur', onBlur);\n      if (isMacSafari()) {\n        win.removeEventListener('keydown', onKeyDown, true);\n        win.removeEventListener('pointerdown', onPointerDown, true);\n      }\n    };\n  }, [elements.domReference, open, enabled]);\n  react__WEBPACK_IMPORTED_MODULE_0__.useEffect(() => {\n    if (!enabled) return;\n    function onOpenChange(_ref) {\n      let {\n        reason\n      } = _ref;\n      if (reason === 'reference-press' || reason === 'escape-key') {\n        blockFocusRef.current = true;\n      }\n    }\n    events.on('openchange', onOpenChange);\n    return () => {\n      events.off('openchange', onOpenChange);\n    };\n  }, [events, enabled]);\n  react__WEBPACK_IMPORTED_MODULE_0__.useEffect(() => {\n    return () => {\n      clearTimeoutIfSet(timeoutRef);\n    };\n  }, []);\n  const reference = react__WEBPACK_IMPORTED_MODULE_0__.useMemo(() => ({\n    onMouseLeave() {\n      blockFocusRef.current = false;\n    },\n    onFocus(event) {\n      if (blockFocusRef.current) return;\n      const target = (0,_floating_ui_react_utils__WEBPACK_IMPORTED_MODULE_6__.getTarget)(event.nativeEvent);\n      if (visibleOnly && (0,_floating_ui_react_dom__WEBPACK_IMPORTED_MODULE_5__.isElement)(target)) {\n        // Safari fails to match `:focus-visible` if focus was initially\n        // outside the document.\n        if (isMacSafari() && !event.relatedTarget) {\n          if (!keyboardModalityRef.current && !(0,_floating_ui_react_utils__WEBPACK_IMPORTED_MODULE_6__.isTypeableElement)(target)) {\n            return;\n          }\n        } else if (!(0,_floating_ui_react_utils__WEBPACK_IMPORTED_MODULE_6__.matchesFocusVisible)(target)) {\n          return;\n        }\n      }\n      onOpenChange(true, event.nativeEvent, 'focus');\n    },\n    onBlur(event) {\n      blockFocusRef.current = false;\n      const relatedTarget = event.relatedTarget;\n      const nativeEvent = event.nativeEvent;\n\n      // Hit the non-modal focus management portal guard. Focus will be\n      // moved into the floating element immediately after.\n      const movedToFocusGuard = (0,_floating_ui_react_dom__WEBPACK_IMPORTED_MODULE_5__.isElement)(relatedTarget) && relatedTarget.hasAttribute(createAttribute('focus-guard')) && relatedTarget.getAttribute('data-type') === 'outside';\n\n      // Wait for the window blur listener to fire.\n      timeoutRef.current = window.setTimeout(() => {\n        var _dataRef$current$floa;\n        const activeEl = (0,_floating_ui_react_utils__WEBPACK_IMPORTED_MODULE_6__.activeElement)(elements.domReference ? elements.domReference.ownerDocument : document);\n\n        // Focus left the page, keep it open.\n        if (!relatedTarget && activeEl === elements.domReference) return;\n\n        // When focusing the reference element (e.g. regular click), then\n        // clicking into the floating element, prevent it from hiding.\n        // Note: it must be focusable, e.g. `tabindex=\"-1\"`.\n        // We can not rely on relatedTarget to point to the correct element\n        // as it will only point to the shadow host of the newly focused element\n        // and not the element that actually has received focus if it is located\n        // inside a shadow root.\n        if ((0,_floating_ui_react_utils__WEBPACK_IMPORTED_MODULE_6__.contains)((_dataRef$current$floa = dataRef.current.floatingContext) == null ? void 0 : _dataRef$current$floa.refs.floating.current, activeEl) || (0,_floating_ui_react_utils__WEBPACK_IMPORTED_MODULE_6__.contains)(elements.domReference, activeEl) || movedToFocusGuard) {\n          return;\n        }\n        onOpenChange(false, nativeEvent, 'focus');\n      });\n    }\n  }), [dataRef, elements.domReference, onOpenChange, visibleOnly]);\n  return react__WEBPACK_IMPORTED_MODULE_0__.useMemo(() => enabled ? {\n    reference\n  } : {}, [enabled, reference]);\n}\n\nfunction mergeProps(userProps, propsList, elementKey) {\n  const map = new Map();\n  const isItem = elementKey === 'item';\n  let domUserProps = userProps;\n  if (isItem && userProps) {\n    const {\n      [ACTIVE_KEY]: _,\n      [SELECTED_KEY]: __,\n      ...validProps\n    } = userProps;\n    domUserProps = validProps;\n  }\n  return {\n    ...(elementKey === 'floating' && {\n      tabIndex: -1,\n      [FOCUSABLE_ATTRIBUTE]: ''\n    }),\n    ...domUserProps,\n    ...propsList.map(value => {\n      const propsOrGetProps = value ? value[elementKey] : null;\n      if (typeof propsOrGetProps === 'function') {\n        return userProps ? propsOrGetProps(userProps) : null;\n      }\n      return propsOrGetProps;\n    }).concat(userProps).reduce((acc, props) => {\n      if (!props) {\n        return acc;\n      }\n      Object.entries(props).forEach(_ref => {\n        let [key, value] = _ref;\n        if (isItem && [ACTIVE_KEY, SELECTED_KEY].includes(key)) {\n          return;\n        }\n        if (key.indexOf('on') === 0) {\n          if (!map.has(key)) {\n            map.set(key, []);\n          }\n          if (typeof value === 'function') {\n            var _map$get;\n            (_map$get = map.get(key)) == null || _map$get.push(value);\n            acc[key] = function () {\n              var _map$get2;\n              for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {\n                args[_key] = arguments[_key];\n              }\n              return (_map$get2 = map.get(key)) == null ? void 0 : _map$get2.map(fn => fn(...args)).find(val => val !== undefined);\n            };\n          }\n        } else {\n          acc[key] = value;\n        }\n      });\n      return acc;\n    }, {})\n  };\n}\n/**\n * Merges an array of interaction hooks' props into prop getters, allowing\n * event handler functions to be composed together without overwriting one\n * another.\n * @see https://floating-ui.com/docs/useInteractions\n */\nfunction useInteractions(propsList) {\n  if (propsList === void 0) {\n    propsList = [];\n  }\n  const referenceDeps = propsList.map(key => key == null ? void 0 : key.reference);\n  const floatingDeps = propsList.map(key => key == null ? void 0 : key.floating);\n  const itemDeps = propsList.map(key => key == null ? void 0 : key.item);\n  const getReferenceProps = react__WEBPACK_IMPORTED_MODULE_0__.useCallback(userProps => mergeProps(userProps, propsList, 'reference'),\n  // eslint-disable-next-line react-hooks/exhaustive-deps\n  referenceDeps);\n  const getFloatingProps = react__WEBPACK_IMPORTED_MODULE_0__.useCallback(userProps => mergeProps(userProps, propsList, 'floating'),\n  // eslint-disable-next-line react-hooks/exhaustive-deps\n  floatingDeps);\n  const getItemProps = react__WEBPACK_IMPORTED_MODULE_0__.useCallback(userProps => mergeProps(userProps, propsList, 'item'),\n  // eslint-disable-next-line react-hooks/exhaustive-deps\n  itemDeps);\n  return react__WEBPACK_IMPORTED_MODULE_0__.useMemo(() => ({\n    getReferenceProps,\n    getFloatingProps,\n    getItemProps\n  }), [getReferenceProps, getFloatingProps, getItemProps]);\n}\n\nconst ESCAPE = 'Escape';\nfunction doSwitch(orientation, vertical, horizontal) {\n  switch (orientation) {\n    case 'vertical':\n      return vertical;\n    case 'horizontal':\n      return horizontal;\n    default:\n      return vertical || horizontal;\n  }\n}\nfunction isMainOrientationKey(key, orientation) {\n  const vertical = key === ARROW_UP || key === ARROW_DOWN;\n  const horizontal = key === ARROW_LEFT || key === ARROW_RIGHT;\n  return doSwitch(orientation, vertical, horizontal);\n}\nfunction isMainOrientationToEndKey(key, orientation, rtl) {\n  const vertical = key === ARROW_DOWN;\n  const horizontal = rtl ? key === ARROW_LEFT : key === ARROW_RIGHT;\n  return doSwitch(orientation, vertical, horizontal) || key === 'Enter' || key === ' ' || key === '';\n}\nfunction isCrossOrientationOpenKey(key, orientation, rtl) {\n  const vertical = rtl ? key === ARROW_LEFT : key === ARROW_RIGHT;\n  const horizontal = key === ARROW_DOWN;\n  return doSwitch(orientation, vertical, horizontal);\n}\nfunction isCrossOrientationCloseKey(key, orientation, rtl, cols) {\n  const vertical = rtl ? key === ARROW_RIGHT : key === ARROW_LEFT;\n  const horizontal = key === ARROW_UP;\n  if (orientation === 'both' || orientation === 'horizontal' && cols && cols > 1) {\n    return key === ESCAPE;\n  }\n  return doSwitch(orientation, vertical, horizontal);\n}\n/**\n * Adds arrow key-based navigation of a list of items, either using real DOM\n * focus or virtual focus.\n * @see https://floating-ui.com/docs/useListNavigation\n */\nfunction useListNavigation(context, props) {\n  const {\n    open,\n    onOpenChange,\n    elements,\n    floatingId\n  } = context;\n  const {\n    listRef,\n    activeIndex,\n    onNavigate: unstable_onNavigate = () => {},\n    enabled = true,\n    selectedIndex = null,\n    allowEscape = false,\n    loop = false,\n    nested = false,\n    rtl = false,\n    virtual = false,\n    focusItemOnOpen = 'auto',\n    focusItemOnHover = true,\n    openOnArrowKeyDown = true,\n    disabledIndices = undefined,\n    orientation = 'vertical',\n    parentOrientation,\n    cols = 1,\n    scrollItemIntoView = true,\n    virtualItemRef,\n    itemSizes,\n    dense = false\n  } = props;\n  if (true) {\n    if (allowEscape) {\n      if (!loop) {\n        warn('`useListNavigation` looping must be enabled to allow escaping.');\n      }\n      if (!virtual) {\n        warn('`useListNavigation` must be virtual to allow escaping.');\n      }\n    }\n    if (orientation === 'vertical' && cols > 1) {\n      warn('In grid list navigation mode (`cols` > 1), the `orientation` should', 'be either \"horizontal\" or \"both\".');\n    }\n  }\n  const floatingFocusElement = (0,_floating_ui_react_utils__WEBPACK_IMPORTED_MODULE_6__.getFloatingFocusElement)(elements.floating);\n  const floatingFocusElementRef = (0,_floating_ui_react_utils__WEBPACK_IMPORTED_MODULE_6__.useLatestRef)(floatingFocusElement);\n  const parentId = useFloatingParentNodeId();\n  const tree = useFloatingTree();\n  (0,_floating_ui_react_utils__WEBPACK_IMPORTED_MODULE_6__.useModernLayoutEffect)(() => {\n    context.dataRef.current.orientation = orientation;\n  }, [context, orientation]);\n  const onNavigate = (0,_floating_ui_react_utils__WEBPACK_IMPORTED_MODULE_6__.useEffectEvent)(() => {\n    unstable_onNavigate(indexRef.current === -1 ? null : indexRef.current);\n  });\n  const typeableComboboxReference = (0,_floating_ui_react_utils__WEBPACK_IMPORTED_MODULE_6__.isTypeableCombobox)(elements.domReference);\n  const focusItemOnOpenRef = react__WEBPACK_IMPORTED_MODULE_0__.useRef(focusItemOnOpen);\n  const indexRef = react__WEBPACK_IMPORTED_MODULE_0__.useRef(selectedIndex != null ? selectedIndex : -1);\n  const keyRef = react__WEBPACK_IMPORTED_MODULE_0__.useRef(null);\n  const isPointerModalityRef = react__WEBPACK_IMPORTED_MODULE_0__.useRef(true);\n  const previousOnNavigateRef = react__WEBPACK_IMPORTED_MODULE_0__.useRef(onNavigate);\n  const previousMountedRef = react__WEBPACK_IMPORTED_MODULE_0__.useRef(!!elements.floating);\n  const previousOpenRef = react__WEBPACK_IMPORTED_MODULE_0__.useRef(open);\n  const forceSyncFocusRef = react__WEBPACK_IMPORTED_MODULE_0__.useRef(false);\n  const forceScrollIntoViewRef = react__WEBPACK_IMPORTED_MODULE_0__.useRef(false);\n  const disabledIndicesRef = (0,_floating_ui_react_utils__WEBPACK_IMPORTED_MODULE_6__.useLatestRef)(disabledIndices);\n  const latestOpenRef = (0,_floating_ui_react_utils__WEBPACK_IMPORTED_MODULE_6__.useLatestRef)(open);\n  const scrollItemIntoViewRef = (0,_floating_ui_react_utils__WEBPACK_IMPORTED_MODULE_6__.useLatestRef)(scrollItemIntoView);\n  const selectedIndexRef = (0,_floating_ui_react_utils__WEBPACK_IMPORTED_MODULE_6__.useLatestRef)(selectedIndex);\n  const [activeId, setActiveId] = react__WEBPACK_IMPORTED_MODULE_0__.useState();\n  const [virtualId, setVirtualId] = react__WEBPACK_IMPORTED_MODULE_0__.useState();\n  const focusItem = (0,_floating_ui_react_utils__WEBPACK_IMPORTED_MODULE_6__.useEffectEvent)(() => {\n    function runFocus(item) {\n      if (virtual) {\n        var _item$id;\n        if ((_item$id = item.id) != null && _item$id.endsWith('-fui-option')) {\n          item.id = floatingId + \"-\" + Math.random().toString(16).slice(2, 10);\n        }\n        setActiveId(item.id);\n        tree == null || tree.events.emit('virtualfocus', item);\n        if (virtualItemRef) {\n          virtualItemRef.current = item;\n        }\n      } else {\n        enqueueFocus(item, {\n          sync: forceSyncFocusRef.current,\n          preventScroll: true\n        });\n      }\n    }\n    const initialItem = listRef.current[indexRef.current];\n    const forceScrollIntoView = forceScrollIntoViewRef.current;\n    if (initialItem) {\n      runFocus(initialItem);\n    }\n    const scheduler = forceSyncFocusRef.current ? v => v() : requestAnimationFrame;\n    scheduler(() => {\n      const waitedItem = listRef.current[indexRef.current] || initialItem;\n      if (!waitedItem) return;\n      if (!initialItem) {\n        runFocus(waitedItem);\n      }\n      const scrollIntoViewOptions = scrollItemIntoViewRef.current;\n      const shouldScrollIntoView = scrollIntoViewOptions && item && (forceScrollIntoView || !isPointerModalityRef.current);\n      if (shouldScrollIntoView) {\n        // JSDOM doesn't support `.scrollIntoView()` but it's widely supported\n        // by all browsers.\n        waitedItem.scrollIntoView == null || waitedItem.scrollIntoView(typeof scrollIntoViewOptions === 'boolean' ? {\n          block: 'nearest',\n          inline: 'nearest'\n        } : scrollIntoViewOptions);\n      }\n    });\n  });\n\n  // Sync `selectedIndex` to be the `activeIndex` upon opening the floating\n  // element. Also, reset `activeIndex` upon closing the floating element.\n  (0,_floating_ui_react_utils__WEBPACK_IMPORTED_MODULE_6__.useModernLayoutEffect)(() => {\n    if (!enabled) return;\n    if (open && elements.floating) {\n      if (focusItemOnOpenRef.current && selectedIndex != null) {\n        // Regardless of the pointer modality, we want to ensure the selected\n        // item comes into view when the floating element is opened.\n        forceScrollIntoViewRef.current = true;\n        indexRef.current = selectedIndex;\n        onNavigate();\n      }\n    } else if (previousMountedRef.current) {\n      // Since the user can specify `onNavigate` conditionally\n      // (onNavigate: open ? setActiveIndex : setSelectedIndex),\n      // we store and call the previous function.\n      indexRef.current = -1;\n      previousOnNavigateRef.current();\n    }\n  }, [enabled, open, elements.floating, selectedIndex, onNavigate]);\n\n  // Sync `activeIndex` to be the focused item while the floating element is\n  // open.\n  (0,_floating_ui_react_utils__WEBPACK_IMPORTED_MODULE_6__.useModernLayoutEffect)(() => {\n    if (!enabled) return;\n    if (!open) return;\n    if (!elements.floating) return;\n    if (activeIndex == null) {\n      forceSyncFocusRef.current = false;\n      if (selectedIndexRef.current != null) {\n        return;\n      }\n\n      // Reset while the floating element was open (e.g. the list changed).\n      if (previousMountedRef.current) {\n        indexRef.current = -1;\n        focusItem();\n      }\n\n      // Initial sync.\n      if ((!previousOpenRef.current || !previousMountedRef.current) && focusItemOnOpenRef.current && (keyRef.current != null || focusItemOnOpenRef.current === true && keyRef.current == null)) {\n        let runs = 0;\n        const waitForListPopulated = () => {\n          if (listRef.current[0] == null) {\n            // Avoid letting the browser paint if possible on the first try,\n            // otherwise use rAF. Don't try more than twice, since something\n            // is wrong otherwise.\n            if (runs < 2) {\n              const scheduler = runs ? requestAnimationFrame : queueMicrotask;\n              scheduler(waitForListPopulated);\n            }\n            runs++;\n          } else {\n            indexRef.current = keyRef.current == null || isMainOrientationToEndKey(keyRef.current, orientation, rtl) || nested ? (0,_floating_ui_react_utils__WEBPACK_IMPORTED_MODULE_6__.getMinListIndex)(listRef, disabledIndicesRef.current) : (0,_floating_ui_react_utils__WEBPACK_IMPORTED_MODULE_6__.getMaxListIndex)(listRef, disabledIndicesRef.current);\n            keyRef.current = null;\n            onNavigate();\n          }\n        };\n        waitForListPopulated();\n      }\n    } else if (!(0,_floating_ui_react_utils__WEBPACK_IMPORTED_MODULE_6__.isIndexOutOfListBounds)(listRef, activeIndex)) {\n      indexRef.current = activeIndex;\n      focusItem();\n      forceScrollIntoViewRef.current = false;\n    }\n  }, [enabled, open, elements.floating, activeIndex, selectedIndexRef, nested, listRef, orientation, rtl, onNavigate, focusItem, disabledIndicesRef]);\n\n  // Ensure the parent floating element has focus when a nested child closes\n  // to allow arrow key navigation to work after the pointer leaves the child.\n  (0,_floating_ui_react_utils__WEBPACK_IMPORTED_MODULE_6__.useModernLayoutEffect)(() => {\n    var _nodes$find;\n    if (!enabled || elements.floating || !tree || virtual || !previousMountedRef.current) {\n      return;\n    }\n    const nodes = tree.nodesRef.current;\n    const parent = (_nodes$find = nodes.find(node => node.id === parentId)) == null || (_nodes$find = _nodes$find.context) == null ? void 0 : _nodes$find.elements.floating;\n    const activeEl = (0,_floating_ui_react_utils__WEBPACK_IMPORTED_MODULE_6__.activeElement)((0,_floating_ui_react_utils__WEBPACK_IMPORTED_MODULE_6__.getDocument)(elements.floating));\n    const treeContainsActiveEl = nodes.some(node => node.context && (0,_floating_ui_react_utils__WEBPACK_IMPORTED_MODULE_6__.contains)(node.context.elements.floating, activeEl));\n    if (parent && !treeContainsActiveEl && isPointerModalityRef.current) {\n      parent.focus({\n        preventScroll: true\n      });\n    }\n  }, [enabled, elements.floating, tree, parentId, virtual]);\n  (0,_floating_ui_react_utils__WEBPACK_IMPORTED_MODULE_6__.useModernLayoutEffect)(() => {\n    if (!enabled) return;\n    if (!tree) return;\n    if (!virtual) return;\n    if (parentId) return;\n    function handleVirtualFocus(item) {\n      setVirtualId(item.id);\n      if (virtualItemRef) {\n        virtualItemRef.current = item;\n      }\n    }\n    tree.events.on('virtualfocus', handleVirtualFocus);\n    return () => {\n      tree.events.off('virtualfocus', handleVirtualFocus);\n    };\n  }, [enabled, tree, virtual, parentId, virtualItemRef]);\n  (0,_floating_ui_react_utils__WEBPACK_IMPORTED_MODULE_6__.useModernLayoutEffect)(() => {\n    previousOnNavigateRef.current = onNavigate;\n    previousOpenRef.current = open;\n    previousMountedRef.current = !!elements.floating;\n  });\n  (0,_floating_ui_react_utils__WEBPACK_IMPORTED_MODULE_6__.useModernLayoutEffect)(() => {\n    if (!open) {\n      keyRef.current = null;\n      focusItemOnOpenRef.current = focusItemOnOpen;\n    }\n  }, [open, focusItemOnOpen]);\n  const hasActiveIndex = activeIndex != null;\n  const item = react__WEBPACK_IMPORTED_MODULE_0__.useMemo(() => {\n    function syncCurrentTarget(currentTarget) {\n      if (!latestOpenRef.current) return;\n      const index = listRef.current.indexOf(currentTarget);\n      if (index !== -1 && indexRef.current !== index) {\n        indexRef.current = index;\n        onNavigate();\n      }\n    }\n    const props = {\n      onFocus(_ref) {\n        let {\n          currentTarget\n        } = _ref;\n        forceSyncFocusRef.current = true;\n        syncCurrentTarget(currentTarget);\n      },\n      onClick: _ref2 => {\n        let {\n          currentTarget\n        } = _ref2;\n        return currentTarget.focus({\n          preventScroll: true\n        });\n      },\n      // Safari\n      onMouseMove(_ref3) {\n        let {\n          currentTarget\n        } = _ref3;\n        forceSyncFocusRef.current = true;\n        forceScrollIntoViewRef.current = false;\n        if (focusItemOnHover) {\n          syncCurrentTarget(currentTarget);\n        }\n      },\n      onPointerLeave(_ref4) {\n        let {\n          pointerType\n        } = _ref4;\n        if (!isPointerModalityRef.current || pointerType === 'touch') {\n          return;\n        }\n        forceSyncFocusRef.current = true;\n        if (!focusItemOnHover) {\n          return;\n        }\n        indexRef.current = -1;\n        onNavigate();\n        if (!virtual) {\n          var _floatingFocusElement;\n          (_floatingFocusElement = floatingFocusElementRef.current) == null || _floatingFocusElement.focus({\n            preventScroll: true\n          });\n        }\n      }\n    };\n    return props;\n  }, [latestOpenRef, floatingFocusElementRef, focusItemOnHover, listRef, onNavigate, virtual]);\n  const getParentOrientation = react__WEBPACK_IMPORTED_MODULE_0__.useCallback(() => {\n    var _tree$nodesRef$curren;\n    return parentOrientation != null ? parentOrientation : tree == null || (_tree$nodesRef$curren = tree.nodesRef.current.find(node => node.id === parentId)) == null || (_tree$nodesRef$curren = _tree$nodesRef$curren.context) == null || (_tree$nodesRef$curren = _tree$nodesRef$curren.dataRef) == null ? void 0 : _tree$nodesRef$curren.current.orientation;\n  }, [parentId, tree, parentOrientation]);\n  const commonOnKeyDown = (0,_floating_ui_react_utils__WEBPACK_IMPORTED_MODULE_6__.useEffectEvent)(event => {\n    isPointerModalityRef.current = false;\n    forceSyncFocusRef.current = true;\n\n    // When composing a character, Chrome fires ArrowDown twice. Firefox/Safari\n    // don't appear to suffer from this. `event.isComposing` is avoided due to\n    // Safari not supporting it properly (although it's not needed in the first\n    // place for Safari, just avoiding any possible issues).\n    if (event.which === 229) {\n      return;\n    }\n\n    // If the floating element is animating out, ignore navigation. Otherwise,\n    // the `activeIndex` gets set to 0 despite not being open so the next time\n    // the user ArrowDowns, the first item won't be focused.\n    if (!latestOpenRef.current && event.currentTarget === floatingFocusElementRef.current) {\n      return;\n    }\n    if (nested && isCrossOrientationCloseKey(event.key, orientation, rtl, cols)) {\n      // If the nested list's close key is also the parent navigation key,\n      // let the parent navigate. Otherwise, stop propagating the event.\n      if (!isMainOrientationKey(event.key, getParentOrientation())) {\n        (0,_floating_ui_react_utils__WEBPACK_IMPORTED_MODULE_6__.stopEvent)(event);\n      }\n      onOpenChange(false, event.nativeEvent, 'list-navigation');\n      if ((0,_floating_ui_react_dom__WEBPACK_IMPORTED_MODULE_5__.isHTMLElement)(elements.domReference)) {\n        if (virtual) {\n          tree == null || tree.events.emit('virtualfocus', elements.domReference);\n        } else {\n          elements.domReference.focus();\n        }\n      }\n      return;\n    }\n    const currentIndex = indexRef.current;\n    const minIndex = (0,_floating_ui_react_utils__WEBPACK_IMPORTED_MODULE_6__.getMinListIndex)(listRef, disabledIndices);\n    const maxIndex = (0,_floating_ui_react_utils__WEBPACK_IMPORTED_MODULE_6__.getMaxListIndex)(listRef, disabledIndices);\n    if (!typeableComboboxReference) {\n      if (event.key === 'Home') {\n        (0,_floating_ui_react_utils__WEBPACK_IMPORTED_MODULE_6__.stopEvent)(event);\n        indexRef.current = minIndex;\n        onNavigate();\n      }\n      if (event.key === 'End') {\n        (0,_floating_ui_react_utils__WEBPACK_IMPORTED_MODULE_6__.stopEvent)(event);\n        indexRef.current = maxIndex;\n        onNavigate();\n      }\n    }\n\n    // Grid navigation.\n    if (cols > 1) {\n      const sizes = itemSizes || Array.from({\n        length: listRef.current.length\n      }, () => ({\n        width: 1,\n        height: 1\n      }));\n      // To calculate movements on the grid, we use hypothetical cell indices\n      // as if every item was 1x1, then convert back to real indices.\n      const cellMap = (0,_floating_ui_react_utils__WEBPACK_IMPORTED_MODULE_6__.createGridCellMap)(sizes, cols, dense);\n      const minGridIndex = cellMap.findIndex(index => index != null && !(0,_floating_ui_react_utils__WEBPACK_IMPORTED_MODULE_6__.isListIndexDisabled)(listRef, index, disabledIndices));\n      // last enabled index\n      const maxGridIndex = cellMap.reduce((foundIndex, index, cellIndex) => index != null && !(0,_floating_ui_react_utils__WEBPACK_IMPORTED_MODULE_6__.isListIndexDisabled)(listRef, index, disabledIndices) ? cellIndex : foundIndex, -1);\n      const index = cellMap[(0,_floating_ui_react_utils__WEBPACK_IMPORTED_MODULE_6__.getGridNavigatedIndex)({\n        current: cellMap.map(itemIndex => itemIndex != null ? listRef.current[itemIndex] : null)\n      }, {\n        event,\n        orientation,\n        loop,\n        rtl,\n        cols,\n        // treat undefined (empty grid spaces) as disabled indices so we\n        // don't end up in them\n        disabledIndices: (0,_floating_ui_react_utils__WEBPACK_IMPORTED_MODULE_6__.getGridCellIndices)([...((typeof disabledIndices !== 'function' ? disabledIndices : null) || listRef.current.map((_, index) => (0,_floating_ui_react_utils__WEBPACK_IMPORTED_MODULE_6__.isListIndexDisabled)(listRef, index, disabledIndices) ? index : undefined)), undefined], cellMap),\n        minIndex: minGridIndex,\n        maxIndex: maxGridIndex,\n        prevIndex: (0,_floating_ui_react_utils__WEBPACK_IMPORTED_MODULE_6__.getGridCellIndexOfCorner)(indexRef.current > maxIndex ? minIndex : indexRef.current, sizes, cellMap, cols,\n        // use a corner matching the edge closest to the direction\n        // we're moving in so we don't end up in the same item. Prefer\n        // top/left over bottom/right.\n        event.key === ARROW_DOWN ? 'bl' : event.key === (rtl ? ARROW_LEFT : ARROW_RIGHT) ? 'tr' : 'tl'),\n        stopEvent: true\n      })];\n      if (index != null) {\n        indexRef.current = index;\n        onNavigate();\n      }\n      if (orientation === 'both') {\n        return;\n      }\n    }\n    if (isMainOrientationKey(event.key, orientation)) {\n      (0,_floating_ui_react_utils__WEBPACK_IMPORTED_MODULE_6__.stopEvent)(event);\n\n      // Reset the index if no item is focused.\n      if (open && !virtual && (0,_floating_ui_react_utils__WEBPACK_IMPORTED_MODULE_6__.activeElement)(event.currentTarget.ownerDocument) === event.currentTarget) {\n        indexRef.current = isMainOrientationToEndKey(event.key, orientation, rtl) ? minIndex : maxIndex;\n        onNavigate();\n        return;\n      }\n      if (isMainOrientationToEndKey(event.key, orientation, rtl)) {\n        if (loop) {\n          indexRef.current = currentIndex >= maxIndex ? allowEscape && currentIndex !== listRef.current.length ? -1 : minIndex : (0,_floating_ui_react_utils__WEBPACK_IMPORTED_MODULE_6__.findNonDisabledListIndex)(listRef, {\n            startingIndex: currentIndex,\n            disabledIndices\n          });\n        } else {\n          indexRef.current = Math.min(maxIndex, (0,_floating_ui_react_utils__WEBPACK_IMPORTED_MODULE_6__.findNonDisabledListIndex)(listRef, {\n            startingIndex: currentIndex,\n            disabledIndices\n          }));\n        }\n      } else {\n        if (loop) {\n          indexRef.current = currentIndex <= minIndex ? allowEscape && currentIndex !== -1 ? listRef.current.length : maxIndex : (0,_floating_ui_react_utils__WEBPACK_IMPORTED_MODULE_6__.findNonDisabledListIndex)(listRef, {\n            startingIndex: currentIndex,\n            decrement: true,\n            disabledIndices\n          });\n        } else {\n          indexRef.current = Math.max(minIndex, (0,_floating_ui_react_utils__WEBPACK_IMPORTED_MODULE_6__.findNonDisabledListIndex)(listRef, {\n            startingIndex: currentIndex,\n            decrement: true,\n            disabledIndices\n          }));\n        }\n      }\n      if ((0,_floating_ui_react_utils__WEBPACK_IMPORTED_MODULE_6__.isIndexOutOfListBounds)(listRef, indexRef.current)) {\n        indexRef.current = -1;\n      }\n      onNavigate();\n    }\n  });\n  const ariaActiveDescendantProp = react__WEBPACK_IMPORTED_MODULE_0__.useMemo(() => {\n    return virtual && open && hasActiveIndex && {\n      'aria-activedescendant': virtualId || activeId\n    };\n  }, [virtual, open, hasActiveIndex, virtualId, activeId]);\n  const floating = react__WEBPACK_IMPORTED_MODULE_0__.useMemo(() => {\n    return {\n      'aria-orientation': orientation === 'both' ? undefined : orientation,\n      ...(!typeableComboboxReference ? ariaActiveDescendantProp : {}),\n      onKeyDown: commonOnKeyDown,\n      onPointerMove() {\n        isPointerModalityRef.current = true;\n      }\n    };\n  }, [ariaActiveDescendantProp, commonOnKeyDown, orientation, typeableComboboxReference]);\n  const reference = react__WEBPACK_IMPORTED_MODULE_0__.useMemo(() => {\n    function checkVirtualMouse(event) {\n      if (focusItemOnOpen === 'auto' && (0,_floating_ui_react_utils__WEBPACK_IMPORTED_MODULE_6__.isVirtualClick)(event.nativeEvent)) {\n        focusItemOnOpenRef.current = true;\n      }\n    }\n    function checkVirtualPointer(event) {\n      // `pointerdown` fires first, reset the state then perform the checks.\n      focusItemOnOpenRef.current = focusItemOnOpen;\n      if (focusItemOnOpen === 'auto' && (0,_floating_ui_react_utils__WEBPACK_IMPORTED_MODULE_6__.isVirtualPointerEvent)(event.nativeEvent)) {\n        focusItemOnOpenRef.current = true;\n      }\n    }\n    return {\n      ...ariaActiveDescendantProp,\n      onKeyDown(event) {\n        isPointerModalityRef.current = false;\n        const isArrowKey = event.key.startsWith('Arrow');\n        const isHomeOrEndKey = ['Home', 'End'].includes(event.key);\n        const isMoveKey = isArrowKey || isHomeOrEndKey;\n        const isCrossOpenKey = isCrossOrientationOpenKey(event.key, orientation, rtl);\n        const isCrossCloseKey = isCrossOrientationCloseKey(event.key, orientation, rtl, cols);\n        const isParentCrossOpenKey = isCrossOrientationOpenKey(event.key, getParentOrientation(), rtl);\n        const isMainKey = isMainOrientationKey(event.key, orientation);\n        const isNavigationKey = (nested ? isParentCrossOpenKey : isMainKey) || event.key === 'Enter' || event.key.trim() === '';\n        if (virtual && open) {\n          const rootNode = tree == null ? void 0 : tree.nodesRef.current.find(node => node.parentId == null);\n          const deepestNode = tree && rootNode ? (0,_floating_ui_react_utils__WEBPACK_IMPORTED_MODULE_6__.getDeepestNode)(tree.nodesRef.current, rootNode.id) : null;\n          if (isMoveKey && deepestNode && virtualItemRef) {\n            const eventObject = new KeyboardEvent('keydown', {\n              key: event.key,\n              bubbles: true\n            });\n            if (isCrossOpenKey || isCrossCloseKey) {\n              var _deepestNode$context, _deepestNode$context2;\n              const isCurrentTarget = ((_deepestNode$context = deepestNode.context) == null ? void 0 : _deepestNode$context.elements.domReference) === event.currentTarget;\n              const dispatchItem = isCrossCloseKey && !isCurrentTarget ? (_deepestNode$context2 = deepestNode.context) == null ? void 0 : _deepestNode$context2.elements.domReference : isCrossOpenKey ? listRef.current.find(item => (item == null ? void 0 : item.id) === activeId) : null;\n              if (dispatchItem) {\n                (0,_floating_ui_react_utils__WEBPACK_IMPORTED_MODULE_6__.stopEvent)(event);\n                dispatchItem.dispatchEvent(eventObject);\n                setVirtualId(undefined);\n              }\n            }\n            if ((isMainKey || isHomeOrEndKey) && deepestNode.context) {\n              if (deepestNode.context.open && deepestNode.parentId && event.currentTarget !== deepestNode.context.elements.domReference) {\n                var _deepestNode$context$;\n                (0,_floating_ui_react_utils__WEBPACK_IMPORTED_MODULE_6__.stopEvent)(event);\n                (_deepestNode$context$ = deepestNode.context.elements.domReference) == null || _deepestNode$context$.dispatchEvent(eventObject);\n                return;\n              }\n            }\n          }\n          return commonOnKeyDown(event);\n        }\n        // If a floating element should not open on arrow key down, avoid\n        // setting `activeIndex` while it's closed.\n        if (!open && !openOnArrowKeyDown && isArrowKey) {\n          return;\n        }\n        if (isNavigationKey) {\n          const isParentMainKey = isMainOrientationKey(event.key, getParentOrientation());\n          keyRef.current = nested && isParentMainKey ? null : event.key;\n        }\n        if (nested) {\n          if (isParentCrossOpenKey) {\n            (0,_floating_ui_react_utils__WEBPACK_IMPORTED_MODULE_6__.stopEvent)(event);\n            if (open) {\n              indexRef.current = (0,_floating_ui_react_utils__WEBPACK_IMPORTED_MODULE_6__.getMinListIndex)(listRef, disabledIndicesRef.current);\n              onNavigate();\n            } else {\n              onOpenChange(true, event.nativeEvent, 'list-navigation');\n            }\n          }\n          return;\n        }\n        if (isMainKey) {\n          if (selectedIndex != null) {\n            indexRef.current = selectedIndex;\n          }\n          (0,_floating_ui_react_utils__WEBPACK_IMPORTED_MODULE_6__.stopEvent)(event);\n          if (!open && openOnArrowKeyDown) {\n            onOpenChange(true, event.nativeEvent, 'list-navigation');\n          } else {\n            commonOnKeyDown(event);\n          }\n          if (open) {\n            onNavigate();\n          }\n        }\n      },\n      onFocus() {\n        if (open && !virtual) {\n          indexRef.current = -1;\n          onNavigate();\n        }\n      },\n      onPointerDown: checkVirtualPointer,\n      onPointerEnter: checkVirtualPointer,\n      onMouseDown: checkVirtualMouse,\n      onClick: checkVirtualMouse\n    };\n  }, [activeId, ariaActiveDescendantProp, cols, commonOnKeyDown, disabledIndicesRef, focusItemOnOpen, listRef, nested, onNavigate, onOpenChange, open, openOnArrowKeyDown, orientation, getParentOrientation, rtl, selectedIndex, tree, virtual, virtualItemRef]);\n  return react__WEBPACK_IMPORTED_MODULE_0__.useMemo(() => enabled ? {\n    reference,\n    floating,\n    item\n  } : {}, [enabled, reference, floating, item]);\n}\n\nconst componentRoleToAriaRoleMap = /*#__PURE__*/new Map([['select', 'listbox'], ['combobox', 'listbox'], ['label', false]]);\n\n/**\n * Adds base screen reader props to the reference and floating elements for a\n * given floating element `role`.\n * @see https://floating-ui.com/docs/useRole\n */\nfunction useRole(context, props) {\n  var _elements$domReferenc, _componentRoleToAriaR;\n  if (props === void 0) {\n    props = {};\n  }\n  const {\n    open,\n    elements,\n    floatingId: defaultFloatingId\n  } = context;\n  const {\n    enabled = true,\n    role = 'dialog'\n  } = props;\n  const defaultReferenceId = useId();\n  const referenceId = ((_elements$domReferenc = elements.domReference) == null ? void 0 : _elements$domReferenc.id) || defaultReferenceId;\n  const floatingId = react__WEBPACK_IMPORTED_MODULE_0__.useMemo(() => {\n    var _getFloatingFocusElem;\n    return ((_getFloatingFocusElem = (0,_floating_ui_react_utils__WEBPACK_IMPORTED_MODULE_6__.getFloatingFocusElement)(elements.floating)) == null ? void 0 : _getFloatingFocusElem.id) || defaultFloatingId;\n  }, [elements.floating, defaultFloatingId]);\n  const ariaRole = (_componentRoleToAriaR = componentRoleToAriaRoleMap.get(role)) != null ? _componentRoleToAriaR : role;\n  const parentId = useFloatingParentNodeId();\n  const isNested = parentId != null;\n  const reference = react__WEBPACK_IMPORTED_MODULE_0__.useMemo(() => {\n    if (ariaRole === 'tooltip' || role === 'label') {\n      return {\n        [\"aria-\" + (role === 'label' ? 'labelledby' : 'describedby')]: open ? floatingId : undefined\n      };\n    }\n    return {\n      'aria-expanded': open ? 'true' : 'false',\n      'aria-haspopup': ariaRole === 'alertdialog' ? 'dialog' : ariaRole,\n      'aria-controls': open ? floatingId : undefined,\n      ...(ariaRole === 'listbox' && {\n        role: 'combobox'\n      }),\n      ...(ariaRole === 'menu' && {\n        id: referenceId\n      }),\n      ...(ariaRole === 'menu' && isNested && {\n        role: 'menuitem'\n      }),\n      ...(role === 'select' && {\n        'aria-autocomplete': 'none'\n      }),\n      ...(role === 'combobox' && {\n        'aria-autocomplete': 'list'\n      })\n    };\n  }, [ariaRole, floatingId, isNested, open, referenceId, role]);\n  const floating = react__WEBPACK_IMPORTED_MODULE_0__.useMemo(() => {\n    const floatingProps = {\n      id: floatingId,\n      ...(ariaRole && {\n        role: ariaRole\n      })\n    };\n    if (ariaRole === 'tooltip' || role === 'label') {\n      return floatingProps;\n    }\n    return {\n      ...floatingProps,\n      ...(ariaRole === 'menu' && {\n        'aria-labelledby': referenceId\n      })\n    };\n  }, [ariaRole, floatingId, referenceId, role]);\n  const item = react__WEBPACK_IMPORTED_MODULE_0__.useCallback(_ref => {\n    let {\n      active,\n      selected\n    } = _ref;\n    const commonProps = {\n      role: 'option',\n      ...(active && {\n        id: floatingId + \"-fui-option\"\n      })\n    };\n\n    // For `menu`, we are unable to tell if the item is a `menuitemradio`\n    // or `menuitemcheckbox`. For backwards-compatibility reasons, also\n    // avoid defaulting to `menuitem` as it may overwrite custom role props.\n    switch (role) {\n      case 'select':\n      case 'combobox':\n        return {\n          ...commonProps,\n          'aria-selected': selected\n        };\n    }\n    return {};\n  }, [floatingId, role]);\n  return react__WEBPACK_IMPORTED_MODULE_0__.useMemo(() => enabled ? {\n    reference,\n    floating,\n    item\n  } : {}, [enabled, reference, floating, item]);\n}\n\n// Converts a JS style key like `backgroundColor` to a CSS transition-property\n// like `background-color`.\nconst camelCaseToKebabCase = str => str.replace(/[A-Z]+(?![a-z])|[A-Z]/g, ($, ofs) => (ofs ? '-' : '') + $.toLowerCase());\nfunction execWithArgsOrReturn(valueOrFn, args) {\n  return typeof valueOrFn === 'function' ? valueOrFn(args) : valueOrFn;\n}\nfunction useDelayUnmount(open, durationMs) {\n  const [isMounted, setIsMounted] = react__WEBPACK_IMPORTED_MODULE_0__.useState(open);\n  if (open && !isMounted) {\n    setIsMounted(true);\n  }\n  react__WEBPACK_IMPORTED_MODULE_0__.useEffect(() => {\n    if (!open && isMounted) {\n      const timeout = setTimeout(() => setIsMounted(false), durationMs);\n      return () => clearTimeout(timeout);\n    }\n  }, [open, isMounted, durationMs]);\n  return isMounted;\n}\n/**\n * Provides a status string to apply CSS transitions to a floating element,\n * correctly handling placement-aware transitions.\n * @see https://floating-ui.com/docs/useTransition#usetransitionstatus\n */\nfunction useTransitionStatus(context, props) {\n  if (props === void 0) {\n    props = {};\n  }\n  const {\n    open,\n    elements: {\n      floating\n    }\n  } = context;\n  const {\n    duration = 250\n  } = props;\n  const isNumberDuration = typeof duration === 'number';\n  const closeDuration = (isNumberDuration ? duration : duration.close) || 0;\n  const [status, setStatus] = react__WEBPACK_IMPORTED_MODULE_0__.useState('unmounted');\n  const isMounted = useDelayUnmount(open, closeDuration);\n  if (!isMounted && status === 'close') {\n    setStatus('unmounted');\n  }\n  (0,_floating_ui_react_utils__WEBPACK_IMPORTED_MODULE_6__.useModernLayoutEffect)(() => {\n    if (!floating) return;\n    if (open) {\n      setStatus('initial');\n      const frame = requestAnimationFrame(() => {\n        // Ensure it opens before paint. With `FloatingDelayGroup`,\n        // this avoids a flicker when moving between floating elements\n        // to ensure one is always open with no missing frames.\n        react_dom__WEBPACK_IMPORTED_MODULE_2__.flushSync(() => {\n          setStatus('open');\n        });\n      });\n      return () => {\n        cancelAnimationFrame(frame);\n      };\n    }\n    setStatus('close');\n  }, [open, floating]);\n  return {\n    isMounted,\n    status\n  };\n}\n/**\n * Provides styles to apply CSS transitions to a floating element, correctly\n * handling placement-aware transitions. Wrapper around `useTransitionStatus`.\n * @see https://floating-ui.com/docs/useTransition#usetransitionstyles\n */\nfunction useTransitionStyles(context, props) {\n  if (props === void 0) {\n    props = {};\n  }\n  const {\n    initial: unstable_initial = {\n      opacity: 0\n    },\n    open: unstable_open,\n    close: unstable_close,\n    common: unstable_common,\n    duration = 250\n  } = props;\n  const placement = context.placement;\n  const side = placement.split('-')[0];\n  const fnArgs = react__WEBPACK_IMPORTED_MODULE_0__.useMemo(() => ({\n    side,\n    placement\n  }), [side, placement]);\n  const isNumberDuration = typeof duration === 'number';\n  const openDuration = (isNumberDuration ? duration : duration.open) || 0;\n  const closeDuration = (isNumberDuration ? duration : duration.close) || 0;\n  const [styles, setStyles] = react__WEBPACK_IMPORTED_MODULE_0__.useState(() => ({\n    ...execWithArgsOrReturn(unstable_common, fnArgs),\n    ...execWithArgsOrReturn(unstable_initial, fnArgs)\n  }));\n  const {\n    isMounted,\n    status\n  } = useTransitionStatus(context, {\n    duration\n  });\n  const initialRef = (0,_floating_ui_react_utils__WEBPACK_IMPORTED_MODULE_6__.useLatestRef)(unstable_initial);\n  const openRef = (0,_floating_ui_react_utils__WEBPACK_IMPORTED_MODULE_6__.useLatestRef)(unstable_open);\n  const closeRef = (0,_floating_ui_react_utils__WEBPACK_IMPORTED_MODULE_6__.useLatestRef)(unstable_close);\n  const commonRef = (0,_floating_ui_react_utils__WEBPACK_IMPORTED_MODULE_6__.useLatestRef)(unstable_common);\n  (0,_floating_ui_react_utils__WEBPACK_IMPORTED_MODULE_6__.useModernLayoutEffect)(() => {\n    const initialStyles = execWithArgsOrReturn(initialRef.current, fnArgs);\n    const closeStyles = execWithArgsOrReturn(closeRef.current, fnArgs);\n    const commonStyles = execWithArgsOrReturn(commonRef.current, fnArgs);\n    const openStyles = execWithArgsOrReturn(openRef.current, fnArgs) || Object.keys(initialStyles).reduce((acc, key) => {\n      acc[key] = '';\n      return acc;\n    }, {});\n    if (status === 'initial') {\n      setStyles(styles => ({\n        transitionProperty: styles.transitionProperty,\n        ...commonStyles,\n        ...initialStyles\n      }));\n    }\n    if (status === 'open') {\n      setStyles({\n        transitionProperty: Object.keys(openStyles).map(camelCaseToKebabCase).join(','),\n        transitionDuration: openDuration + \"ms\",\n        ...commonStyles,\n        ...openStyles\n      });\n    }\n    if (status === 'close') {\n      const styles = closeStyles || initialStyles;\n      setStyles({\n        transitionProperty: Object.keys(styles).map(camelCaseToKebabCase).join(','),\n        transitionDuration: closeDuration + \"ms\",\n        ...commonStyles,\n        ...styles\n      });\n    }\n  }, [closeDuration, closeRef, initialRef, openRef, commonRef, openDuration, status, fnArgs]);\n  return {\n    isMounted,\n    styles\n  };\n}\n\n/**\n * Provides a matching callback that can be used to focus an item as the user\n * types, often used in tandem with `useListNavigation()`.\n * @see https://floating-ui.com/docs/useTypeahead\n */\nfunction useTypeahead(context, props) {\n  var _ref;\n  const {\n    open,\n    dataRef\n  } = context;\n  const {\n    listRef,\n    activeIndex,\n    onMatch: unstable_onMatch,\n    onTypingChange: unstable_onTypingChange,\n    enabled = true,\n    findMatch = null,\n    resetMs = 750,\n    ignoreKeys = [],\n    selectedIndex = null\n  } = props;\n  const timeoutIdRef = react__WEBPACK_IMPORTED_MODULE_0__.useRef(-1);\n  const stringRef = react__WEBPACK_IMPORTED_MODULE_0__.useRef('');\n  const prevIndexRef = react__WEBPACK_IMPORTED_MODULE_0__.useRef((_ref = selectedIndex != null ? selectedIndex : activeIndex) != null ? _ref : -1);\n  const matchIndexRef = react__WEBPACK_IMPORTED_MODULE_0__.useRef(null);\n  const onMatch = (0,_floating_ui_react_utils__WEBPACK_IMPORTED_MODULE_6__.useEffectEvent)(unstable_onMatch);\n  const onTypingChange = (0,_floating_ui_react_utils__WEBPACK_IMPORTED_MODULE_6__.useEffectEvent)(unstable_onTypingChange);\n  const findMatchRef = (0,_floating_ui_react_utils__WEBPACK_IMPORTED_MODULE_6__.useLatestRef)(findMatch);\n  const ignoreKeysRef = (0,_floating_ui_react_utils__WEBPACK_IMPORTED_MODULE_6__.useLatestRef)(ignoreKeys);\n  (0,_floating_ui_react_utils__WEBPACK_IMPORTED_MODULE_6__.useModernLayoutEffect)(() => {\n    if (open) {\n      clearTimeoutIfSet(timeoutIdRef);\n      matchIndexRef.current = null;\n      stringRef.current = '';\n    }\n  }, [open]);\n  (0,_floating_ui_react_utils__WEBPACK_IMPORTED_MODULE_6__.useModernLayoutEffect)(() => {\n    // Sync arrow key navigation but not typeahead navigation.\n    if (open && stringRef.current === '') {\n      var _ref2;\n      prevIndexRef.current = (_ref2 = selectedIndex != null ? selectedIndex : activeIndex) != null ? _ref2 : -1;\n    }\n  }, [open, selectedIndex, activeIndex]);\n  const setTypingChange = (0,_floating_ui_react_utils__WEBPACK_IMPORTED_MODULE_6__.useEffectEvent)(value => {\n    if (value) {\n      if (!dataRef.current.typing) {\n        dataRef.current.typing = value;\n        onTypingChange(value);\n      }\n    } else {\n      if (dataRef.current.typing) {\n        dataRef.current.typing = value;\n        onTypingChange(value);\n      }\n    }\n  });\n  const onKeyDown = (0,_floating_ui_react_utils__WEBPACK_IMPORTED_MODULE_6__.useEffectEvent)(event => {\n    function getMatchingIndex(list, orderedList, string) {\n      const str = findMatchRef.current ? findMatchRef.current(orderedList, string) : orderedList.find(text => (text == null ? void 0 : text.toLocaleLowerCase().indexOf(string.toLocaleLowerCase())) === 0);\n      return str ? list.indexOf(str) : -1;\n    }\n    const listContent = listRef.current;\n    if (stringRef.current.length > 0 && stringRef.current[0] !== ' ') {\n      if (getMatchingIndex(listContent, listContent, stringRef.current) === -1) {\n        setTypingChange(false);\n      } else if (event.key === ' ') {\n        (0,_floating_ui_react_utils__WEBPACK_IMPORTED_MODULE_6__.stopEvent)(event);\n      }\n    }\n    if (listContent == null || ignoreKeysRef.current.includes(event.key) ||\n    // Character key.\n    event.key.length !== 1 ||\n    // Modifier key.\n    event.ctrlKey || event.metaKey || event.altKey) {\n      return;\n    }\n    if (open && event.key !== ' ') {\n      (0,_floating_ui_react_utils__WEBPACK_IMPORTED_MODULE_6__.stopEvent)(event);\n      setTypingChange(true);\n    }\n\n    // Bail out if the list contains a word like \"llama\" or \"aaron\". TODO:\n    // allow it in this case, too.\n    const allowRapidSuccessionOfFirstLetter = listContent.every(text => {\n      var _text$, _text$2;\n      return text ? ((_text$ = text[0]) == null ? void 0 : _text$.toLocaleLowerCase()) !== ((_text$2 = text[1]) == null ? void 0 : _text$2.toLocaleLowerCase()) : true;\n    });\n\n    // Allows the user to cycle through items that start with the same letter\n    // in rapid succession.\n    if (allowRapidSuccessionOfFirstLetter && stringRef.current === event.key) {\n      stringRef.current = '';\n      prevIndexRef.current = matchIndexRef.current;\n    }\n    stringRef.current += event.key;\n    clearTimeoutIfSet(timeoutIdRef);\n    timeoutIdRef.current = window.setTimeout(() => {\n      stringRef.current = '';\n      prevIndexRef.current = matchIndexRef.current;\n      setTypingChange(false);\n    }, resetMs);\n    const prevIndex = prevIndexRef.current;\n    const index = getMatchingIndex(listContent, [...listContent.slice((prevIndex || 0) + 1), ...listContent.slice(0, (prevIndex || 0) + 1)], stringRef.current);\n    if (index !== -1) {\n      onMatch(index);\n      matchIndexRef.current = index;\n    } else if (event.key !== ' ') {\n      stringRef.current = '';\n      setTypingChange(false);\n    }\n  });\n  const reference = react__WEBPACK_IMPORTED_MODULE_0__.useMemo(() => ({\n    onKeyDown\n  }), [onKeyDown]);\n  const floating = react__WEBPACK_IMPORTED_MODULE_0__.useMemo(() => {\n    return {\n      onKeyDown,\n      onKeyUp(event) {\n        if (event.key === ' ') {\n          setTypingChange(false);\n        }\n      }\n    };\n  }, [onKeyDown, setTypingChange]);\n  return react__WEBPACK_IMPORTED_MODULE_0__.useMemo(() => enabled ? {\n    reference,\n    floating\n  } : {}, [enabled, reference, floating]);\n}\n\nfunction getArgsWithCustomFloatingHeight(state, height) {\n  return {\n    ...state,\n    rects: {\n      ...state.rects,\n      floating: {\n        ...state.rects.floating,\n        height\n      }\n    }\n  };\n}\n/**\n * Positions the floating element such that an inner element inside of it is\n * anchored to the reference element.\n * @see https://floating-ui.com/docs/inner\n * @deprecated\n */\nconst inner = props => ({\n  name: 'inner',\n  options: props,\n  async fn(state) {\n    const {\n      listRef,\n      overflowRef,\n      onFallbackChange,\n      offset: innerOffset = 0,\n      index = 0,\n      minItemsVisible = 4,\n      referenceOverflowThreshold = 0,\n      scrollRef,\n      ...detectOverflowOptions\n    } = (0,_floating_ui_utils__WEBPACK_IMPORTED_MODULE_8__.evaluate)(props, state);\n    const {\n      rects,\n      elements: {\n        floating\n      }\n    } = state;\n    const item = listRef.current[index];\n    const scrollEl = (scrollRef == null ? void 0 : scrollRef.current) || floating;\n\n    // Valid combinations:\n    // 1. Floating element is the scrollRef and has a border (default)\n    // 2. Floating element is not the scrollRef, floating element has a border\n    // 3. Floating element is not the scrollRef, scrollRef has a border\n    // Floating > {...getFloatingProps()} wrapper > scrollRef > items is not\n    // allowed as VoiceOver doesn't work.\n    const clientTop = floating.clientTop || scrollEl.clientTop;\n    const floatingIsBordered = floating.clientTop !== 0;\n    const scrollElIsBordered = scrollEl.clientTop !== 0;\n    const floatingIsScrollEl = floating === scrollEl;\n    if (true) {\n      if (!state.placement.startsWith('bottom')) {\n        warn('`placement` side must be \"bottom\" when using the `inner`', 'middleware.');\n      }\n    }\n    if (!item) {\n      return {};\n    }\n    const nextArgs = {\n      ...state,\n      ...(await (0,_floating_ui_react_dom__WEBPACK_IMPORTED_MODULE_3__.offset)(-item.offsetTop - floating.clientTop - rects.reference.height / 2 - item.offsetHeight / 2 - innerOffset).fn(state))\n    };\n    const overflow = await (0,_floating_ui_react_dom__WEBPACK_IMPORTED_MODULE_4__.detectOverflow)(getArgsWithCustomFloatingHeight(nextArgs, scrollEl.scrollHeight + clientTop + floating.clientTop), detectOverflowOptions);\n    const refOverflow = await (0,_floating_ui_react_dom__WEBPACK_IMPORTED_MODULE_4__.detectOverflow)(nextArgs, {\n      ...detectOverflowOptions,\n      elementContext: 'reference'\n    });\n    const diffY = (0,_floating_ui_utils__WEBPACK_IMPORTED_MODULE_8__.max)(0, overflow.top);\n    const nextY = nextArgs.y + diffY;\n    const isScrollable = scrollEl.scrollHeight > scrollEl.clientHeight;\n    const rounder = isScrollable ? v => v : _floating_ui_utils__WEBPACK_IMPORTED_MODULE_8__.round;\n    const maxHeight = rounder((0,_floating_ui_utils__WEBPACK_IMPORTED_MODULE_8__.max)(0, scrollEl.scrollHeight + (floatingIsBordered && floatingIsScrollEl || scrollElIsBordered ? clientTop * 2 : 0) - diffY - (0,_floating_ui_utils__WEBPACK_IMPORTED_MODULE_8__.max)(0, overflow.bottom)));\n    scrollEl.style.maxHeight = maxHeight + \"px\";\n    scrollEl.scrollTop = diffY;\n\n    // There is not enough space, fallback to standard anchored positioning\n    if (onFallbackChange) {\n      const shouldFallback = scrollEl.offsetHeight < item.offsetHeight * (0,_floating_ui_utils__WEBPACK_IMPORTED_MODULE_8__.min)(minItemsVisible, listRef.current.length) - 1 || refOverflow.top >= -referenceOverflowThreshold || refOverflow.bottom >= -referenceOverflowThreshold;\n      react_dom__WEBPACK_IMPORTED_MODULE_2__.flushSync(() => onFallbackChange(shouldFallback));\n    }\n    if (overflowRef) {\n      overflowRef.current = await (0,_floating_ui_react_dom__WEBPACK_IMPORTED_MODULE_4__.detectOverflow)(getArgsWithCustomFloatingHeight({\n        ...nextArgs,\n        y: nextY\n      }, scrollEl.offsetHeight + clientTop + floating.clientTop), detectOverflowOptions);\n    }\n    return {\n      y: nextY\n    };\n  }\n});\n/**\n * Changes the `inner` middleware's `offset` upon a `wheel` event to\n * expand the floating element's height, revealing more list items.\n * @see https://floating-ui.com/docs/inner\n * @deprecated\n */\nfunction useInnerOffset(context, props) {\n  const {\n    open,\n    elements\n  } = context;\n  const {\n    enabled = true,\n    overflowRef,\n    scrollRef,\n    onChange: unstable_onChange\n  } = props;\n  const onChange = (0,_floating_ui_react_utils__WEBPACK_IMPORTED_MODULE_6__.useEffectEvent)(unstable_onChange);\n  const controlledScrollingRef = react__WEBPACK_IMPORTED_MODULE_0__.useRef(false);\n  const prevScrollTopRef = react__WEBPACK_IMPORTED_MODULE_0__.useRef(null);\n  const initialOverflowRef = react__WEBPACK_IMPORTED_MODULE_0__.useRef(null);\n  react__WEBPACK_IMPORTED_MODULE_0__.useEffect(() => {\n    if (!enabled) return;\n    function onWheel(e) {\n      if (e.ctrlKey || !el || overflowRef.current == null) {\n        return;\n      }\n      const dY = e.deltaY;\n      const isAtTop = overflowRef.current.top >= -0.5;\n      const isAtBottom = overflowRef.current.bottom >= -0.5;\n      const remainingScroll = el.scrollHeight - el.clientHeight;\n      const sign = dY < 0 ? -1 : 1;\n      const method = dY < 0 ? 'max' : 'min';\n      if (el.scrollHeight <= el.clientHeight) {\n        return;\n      }\n      if (!isAtTop && dY > 0 || !isAtBottom && dY < 0) {\n        e.preventDefault();\n        react_dom__WEBPACK_IMPORTED_MODULE_2__.flushSync(() => {\n          onChange(d => d + Math[method](dY, remainingScroll * sign));\n        });\n      } else if (/firefox/i.test((0,_floating_ui_react_utils__WEBPACK_IMPORTED_MODULE_6__.getUserAgent)())) {\n        // Needed to propagate scrolling during momentum scrolling phase once\n        // it gets limited by the boundary. UX improvement, not critical.\n        el.scrollTop += dY;\n      }\n    }\n    const el = (scrollRef == null ? void 0 : scrollRef.current) || elements.floating;\n    if (open && el) {\n      el.addEventListener('wheel', onWheel);\n\n      // Wait for the position to be ready.\n      requestAnimationFrame(() => {\n        prevScrollTopRef.current = el.scrollTop;\n        if (overflowRef.current != null) {\n          initialOverflowRef.current = {\n            ...overflowRef.current\n          };\n        }\n      });\n      return () => {\n        prevScrollTopRef.current = null;\n        initialOverflowRef.current = null;\n        el.removeEventListener('wheel', onWheel);\n      };\n    }\n  }, [enabled, open, elements.floating, overflowRef, scrollRef, onChange]);\n  const floating = react__WEBPACK_IMPORTED_MODULE_0__.useMemo(() => ({\n    onKeyDown() {\n      controlledScrollingRef.current = true;\n    },\n    onWheel() {\n      controlledScrollingRef.current = false;\n    },\n    onPointerMove() {\n      controlledScrollingRef.current = false;\n    },\n    onScroll() {\n      const el = (scrollRef == null ? void 0 : scrollRef.current) || elements.floating;\n      if (!overflowRef.current || !el || !controlledScrollingRef.current) {\n        return;\n      }\n      if (prevScrollTopRef.current !== null) {\n        const scrollDiff = el.scrollTop - prevScrollTopRef.current;\n        if (overflowRef.current.bottom < -0.5 && scrollDiff < -1 || overflowRef.current.top < -0.5 && scrollDiff > 1) {\n          react_dom__WEBPACK_IMPORTED_MODULE_2__.flushSync(() => onChange(d => d + scrollDiff));\n        }\n      }\n\n      // [Firefox] Wait for the height change to have been applied.\n      requestAnimationFrame(() => {\n        prevScrollTopRef.current = el.scrollTop;\n      });\n    }\n  }), [elements.floating, onChange, overflowRef, scrollRef]);\n  return react__WEBPACK_IMPORTED_MODULE_0__.useMemo(() => enabled ? {\n    floating\n  } : {}, [enabled, floating]);\n}\n\nfunction getNodeChildren(nodes, id, onlyOpenChildren) {\n  if (onlyOpenChildren === void 0) {\n    onlyOpenChildren = true;\n  }\n  const directChildren = nodes.filter(node => {\n    var _node$context;\n    return node.parentId === id && (!onlyOpenChildren || ((_node$context = node.context) == null ? void 0 : _node$context.open));\n  });\n  return directChildren.flatMap(child => [child, ...getNodeChildren(nodes, child.id, onlyOpenChildren)]);\n}\n\nfunction isPointInPolygon(point, polygon) {\n  const [x, y] = point;\n  let isInside = false;\n  const length = polygon.length;\n  for (let i = 0, j = length - 1; i < length; j = i++) {\n    const [xi, yi] = polygon[i] || [0, 0];\n    const [xj, yj] = polygon[j] || [0, 0];\n    const intersect = yi >= y !== yj >= y && x <= (xj - xi) * (y - yi) / (yj - yi) + xi;\n    if (intersect) {\n      isInside = !isInside;\n    }\n  }\n  return isInside;\n}\nfunction isInside(point, rect) {\n  return point[0] >= rect.x && point[0] <= rect.x + rect.width && point[1] >= rect.y && point[1] <= rect.y + rect.height;\n}\n/**\n * Generates a safe polygon area that the user can traverse without closing the\n * floating element once leaving the reference element.\n * @see https://floating-ui.com/docs/useHover#safepolygon\n */\nfunction safePolygon(options) {\n  if (options === void 0) {\n    options = {};\n  }\n  const {\n    buffer = 0.5,\n    blockPointerEvents = false,\n    requireIntent = true\n  } = options;\n  const timeoutRef = {\n    current: -1\n  };\n  let hasLanded = false;\n  let lastX = null;\n  let lastY = null;\n  let lastCursorTime = typeof performance !== 'undefined' ? performance.now() : 0;\n  function getCursorSpeed(x, y) {\n    const currentTime = performance.now();\n    const elapsedTime = currentTime - lastCursorTime;\n    if (lastX === null || lastY === null || elapsedTime === 0) {\n      lastX = x;\n      lastY = y;\n      lastCursorTime = currentTime;\n      return null;\n    }\n    const deltaX = x - lastX;\n    const deltaY = y - lastY;\n    const distance = Math.sqrt(deltaX * deltaX + deltaY * deltaY);\n    const speed = distance / elapsedTime; // px / ms\n\n    lastX = x;\n    lastY = y;\n    lastCursorTime = currentTime;\n    return speed;\n  }\n  const fn = _ref => {\n    let {\n      x,\n      y,\n      placement,\n      elements,\n      onClose,\n      nodeId,\n      tree\n    } = _ref;\n    return function onMouseMove(event) {\n      function close() {\n        clearTimeoutIfSet(timeoutRef);\n        onClose();\n      }\n      clearTimeoutIfSet(timeoutRef);\n      if (!elements.domReference || !elements.floating || placement == null || x == null || y == null) {\n        return;\n      }\n      const {\n        clientX,\n        clientY\n      } = event;\n      const clientPoint = [clientX, clientY];\n      const target = getTarget(event);\n      const isLeave = event.type === 'mouseleave';\n      const isOverFloatingEl = contains(elements.floating, target);\n      const isOverReferenceEl = contains(elements.domReference, target);\n      const refRect = elements.domReference.getBoundingClientRect();\n      const rect = elements.floating.getBoundingClientRect();\n      const side = placement.split('-')[0];\n      const cursorLeaveFromRight = x > rect.right - rect.width / 2;\n      const cursorLeaveFromBottom = y > rect.bottom - rect.height / 2;\n      const isOverReferenceRect = isInside(clientPoint, refRect);\n      const isFloatingWider = rect.width > refRect.width;\n      const isFloatingTaller = rect.height > refRect.height;\n      const left = (isFloatingWider ? refRect : rect).left;\n      const right = (isFloatingWider ? refRect : rect).right;\n      const top = (isFloatingTaller ? refRect : rect).top;\n      const bottom = (isFloatingTaller ? refRect : rect).bottom;\n      if (isOverFloatingEl) {\n        hasLanded = true;\n        if (!isLeave) {\n          return;\n        }\n      }\n      if (isOverReferenceEl) {\n        hasLanded = false;\n      }\n      if (isOverReferenceEl && !isLeave) {\n        hasLanded = true;\n        return;\n      }\n\n      // Prevent overlapping floating element from being stuck in an open-close\n      // loop: https://github.com/floating-ui/floating-ui/issues/1910\n      if (isLeave && (0,_floating_ui_react_dom__WEBPACK_IMPORTED_MODULE_5__.isElement)(event.relatedTarget) && contains(elements.floating, event.relatedTarget)) {\n        return;\n      }\n\n      // If any nested child is open, abort.\n      if (tree && getNodeChildren(tree.nodesRef.current, nodeId).length) {\n        return;\n      }\n\n      // If the pointer is leaving from the opposite side, the \"buffer\" logic\n      // creates a point where the floating element remains open, but should be\n      // ignored.\n      // A constant of 1 handles floating point rounding errors.\n      if (side === 'top' && y >= refRect.bottom - 1 || side === 'bottom' && y <= refRect.top + 1 || side === 'left' && x >= refRect.right - 1 || side === 'right' && x <= refRect.left + 1) {\n        return close();\n      }\n\n      // Ignore when the cursor is within the rectangular trough between the\n      // two elements. Since the triangle is created from the cursor point,\n      // which can start beyond the ref element's edge, traversing back and\n      // forth from the ref to the floating element can cause it to close. This\n      // ensures it always remains open in that case.\n      let rectPoly = [];\n      switch (side) {\n        case 'top':\n          rectPoly = [[left, refRect.top + 1], [left, rect.bottom - 1], [right, rect.bottom - 1], [right, refRect.top + 1]];\n          break;\n        case 'bottom':\n          rectPoly = [[left, rect.top + 1], [left, refRect.bottom - 1], [right, refRect.bottom - 1], [right, rect.top + 1]];\n          break;\n        case 'left':\n          rectPoly = [[rect.right - 1, bottom], [rect.right - 1, top], [refRect.left + 1, top], [refRect.left + 1, bottom]];\n          break;\n        case 'right':\n          rectPoly = [[refRect.right - 1, bottom], [refRect.right - 1, top], [rect.left + 1, top], [rect.left + 1, bottom]];\n          break;\n      }\n      function getPolygon(_ref2) {\n        let [x, y] = _ref2;\n        switch (side) {\n          case 'top':\n            {\n              const cursorPointOne = [isFloatingWider ? x + buffer / 2 : cursorLeaveFromRight ? x + buffer * 4 : x - buffer * 4, y + buffer + 1];\n              const cursorPointTwo = [isFloatingWider ? x - buffer / 2 : cursorLeaveFromRight ? x + buffer * 4 : x - buffer * 4, y + buffer + 1];\n              const commonPoints = [[rect.left, cursorLeaveFromRight ? rect.bottom - buffer : isFloatingWider ? rect.bottom - buffer : rect.top], [rect.right, cursorLeaveFromRight ? isFloatingWider ? rect.bottom - buffer : rect.top : rect.bottom - buffer]];\n              return [cursorPointOne, cursorPointTwo, ...commonPoints];\n            }\n          case 'bottom':\n            {\n              const cursorPointOne = [isFloatingWider ? x + buffer / 2 : cursorLeaveFromRight ? x + buffer * 4 : x - buffer * 4, y - buffer];\n              const cursorPointTwo = [isFloatingWider ? x - buffer / 2 : cursorLeaveFromRight ? x + buffer * 4 : x - buffer * 4, y - buffer];\n              const commonPoints = [[rect.left, cursorLeaveFromRight ? rect.top + buffer : isFloatingWider ? rect.top + buffer : rect.bottom], [rect.right, cursorLeaveFromRight ? isFloatingWider ? rect.top + buffer : rect.bottom : rect.top + buffer]];\n              return [cursorPointOne, cursorPointTwo, ...commonPoints];\n            }\n          case 'left':\n            {\n              const cursorPointOne = [x + buffer + 1, isFloatingTaller ? y + buffer / 2 : cursorLeaveFromBottom ? y + buffer * 4 : y - buffer * 4];\n              const cursorPointTwo = [x + buffer + 1, isFloatingTaller ? y - buffer / 2 : cursorLeaveFromBottom ? y + buffer * 4 : y - buffer * 4];\n              const commonPoints = [[cursorLeaveFromBottom ? rect.right - buffer : isFloatingTaller ? rect.right - buffer : rect.left, rect.top], [cursorLeaveFromBottom ? isFloatingTaller ? rect.right - buffer : rect.left : rect.right - buffer, rect.bottom]];\n              return [...commonPoints, cursorPointOne, cursorPointTwo];\n            }\n          case 'right':\n            {\n              const cursorPointOne = [x - buffer, isFloatingTaller ? y + buffer / 2 : cursorLeaveFromBottom ? y + buffer * 4 : y - buffer * 4];\n              const cursorPointTwo = [x - buffer, isFloatingTaller ? y - buffer / 2 : cursorLeaveFromBottom ? y + buffer * 4 : y - buffer * 4];\n              const commonPoints = [[cursorLeaveFromBottom ? rect.left + buffer : isFloatingTaller ? rect.left + buffer : rect.right, rect.top], [cursorLeaveFromBottom ? isFloatingTaller ? rect.left + buffer : rect.right : rect.left + buffer, rect.bottom]];\n              return [cursorPointOne, cursorPointTwo, ...commonPoints];\n            }\n        }\n      }\n      if (isPointInPolygon([clientX, clientY], rectPoly)) {\n        return;\n      }\n      if (hasLanded && !isOverReferenceRect) {\n        return close();\n      }\n      if (!isLeave && requireIntent) {\n        const cursorSpeed = getCursorSpeed(event.clientX, event.clientY);\n        const cursorSpeedThreshold = 0.1;\n        if (cursorSpeed !== null && cursorSpeed < cursorSpeedThreshold) {\n          return close();\n        }\n      }\n      if (!isPointInPolygon([clientX, clientY], getPolygon([x, y]))) {\n        close();\n      } else if (!hasLanded && requireIntent) {\n        timeoutRef.current = window.setTimeout(close, 40);\n      }\n    };\n  };\n  fn.__options = {\n    blockPointerEvents\n  };\n  return fn;\n}\n\n\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvcmVhY3QtZGF0ZXBpY2tlci9ub2RlX21vZHVsZXMvQGZsb2F0aW5nLXVpL3JlYWN0L2Rpc3QvZmxvYXRpbmctdWkucmVhY3QubWpzIiwibWFwcGluZ3MiOiI7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7QUFBK0I7QUFDc3hCO0FBQzd2QjtBQUMwSDtBQUN2SDtBQUNyQjtBQUM4RTtBQUM0RTtBQUNqSTs7QUFFL0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHFCQUFxQix5Q0FBWTtBQUNqQyxvQkFBb0IsOENBQWlCO0FBQ3JDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSCxTQUFTLDBDQUFhO0FBQ3RCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EseUNBQXlDLGdEQUFtQjtBQUM1RCxvQkFBb0I7QUFDcEIsc0JBQXNCO0FBQ3RCO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQztBQUNEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSiw0QkFBNEIsMkNBQWM7QUFDMUMsbUJBQW1CLDhDQUFpQjtBQUNwQztBQUNBLEdBQUc7QUFDSCxxQkFBcUIsOENBQWlCO0FBQ3RDO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMLEdBQUc7QUFDSCxjQUFjLDBDQUFhO0FBQzNCO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0EsR0FBRztBQUNILHNCQUFzQixz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QTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLGtCQUFrQixvRUFBWTtBQUM5QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7QUFDRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBVSxtRUFBVztBQUNyQjtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7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Q0E7QUFDQTtBQUNBLFVBQVUsZ0RBQWtCO0FBQzVCO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0EsR0FBRztBQUNILFNBQVMsMENBQWE7QUFDdEI7QUFDQSxJQUFJLElBQUk7QUFDUjs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esa0NBQWtDLFlBQVk7QUFDOUM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwwQ0FBMEM7O0FBRTFDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EscUJBQXFCLGlFQUFTO0FBQzlCO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRXNsQiIsInNvdXJjZXMiOlsid2VicGFjazovL2ludm9pY2UtYXBwLy4vbm9kZV9tb2R1bGVzL3JlYWN0LWRhdGVwaWNrZXIvbm9kZV9tb2R1bGVzL0BmbG9hdGluZy11aS9yZWFjdC9kaXN0L2Zsb2F0aW5nLXVpLnJlYWN0Lm1qcz85NDZiIl0sInNvdXJjZXNDb250ZW50IjpbImltcG9ydCAqIGFzIFJlYWN0IGZyb20gJ3JlYWN0JztcbmltcG9ydCB7IHVzZU1vZGVybkxheW91dEVmZmVjdCwgdXNlRWZmZWN0RXZlbnQsIGdldE1pbkxpc3RJbmRleCwgZ2V0TWF4TGlzdEluZGV4LCBjcmVhdGVHcmlkQ2VsbE1hcCwgaXNMaXN0SW5kZXhEaXNhYmxlZCwgZ2V0R3JpZE5hdmlnYXRlZEluZGV4LCBnZXRHcmlkQ2VsbEluZGV4T2ZDb3JuZXIsIGdldEdyaWRDZWxsSW5kaWNlcywgZmluZE5vbkRpc2FibGVkTGlzdEluZGV4LCBpc0luZGV4T3V0T2ZMaXN0Qm91bmRzLCB1c2VMYXRlc3RSZWYsIGdldERvY3VtZW50IGFzIGdldERvY3VtZW50JDEsIGlzTW91c2VMaWtlUG9pbnRlclR5cGUsIGNvbnRhaW5zIGFzIGNvbnRhaW5zJDEsIGlzU2FmYXJpLCBlbmFibGVGb2N1c0luc2lkZSwgaXNPdXRzaWRlRXZlbnQsIGdldFByZXZpb3VzVGFiYmFibGUsIGdldE5leHRUYWJiYWJsZSwgZGlzYWJsZUZvY3VzSW5zaWRlLCBpc1R5cGVhYmxlQ29tYm9ib3gsIGdldEZsb2F0aW5nRm9jdXNFbGVtZW50LCBnZXRUYWJiYWJsZU9wdGlvbnMsIGdldE5vZGVBbmNlc3RvcnMsIGFjdGl2ZUVsZW1lbnQsIGdldE5vZGVDaGlsZHJlbiBhcyBnZXROb2RlQ2hpbGRyZW4kMSwgc3RvcEV2ZW50LCBnZXRUYXJnZXQgYXMgZ2V0VGFyZ2V0JDEsIGlzVmlydHVhbENsaWNrLCBpc1ZpcnR1YWxQb2ludGVyRXZlbnQsIGdldFBsYXRmb3JtLCBpc1R5cGVhYmxlRWxlbWVudCwgaXNSZWFjdEV2ZW50LCBpc1Jvb3RFbGVtZW50LCBpc0V2ZW50VGFyZ2V0V2l0aGluLCBtYXRjaGVzRm9jdXNWaXNpYmxlLCBpc01hYywgZ2V0RGVlcGVzdE5vZGUsIGdldFVzZXJBZ2VudCB9IGZyb20gJ0BmbG9hdGluZy11aS9yZWFjdC91dGlscyc7XG5pbXBvcnQgeyBqc3gsIGpzeHMsIEZyYWdtZW50IH0gZnJvbSAncmVhY3QvanN4LXJ1bnRpbWUnO1xuaW1wb3J0IHsgZ2V0Q29tcHV0ZWRTdHlsZSwgaXNFbGVtZW50LCBpc1NoYWRvd1Jvb3QsIGdldE5vZGVOYW1lLCBpc05vZGUsIGlzSFRNTEVsZW1lbnQsIGdldFdpbmRvdywgaXNMYXN0VHJhdmVyc2FibGVOb2RlLCBnZXRQYXJlbnROb2RlLCBpc1dlYktpdCB9IGZyb20gJ0BmbG9hdGluZy11aS91dGlscy9kb20nO1xuaW1wb3J0IHsgdGFiYmFibGUsIGlzVGFiYmFibGUsIGZvY3VzYWJsZSB9IGZyb20gJ3RhYmJhYmxlJztcbmltcG9ydCAqIGFzIFJlYWN0RE9NIGZyb20gJ3JlYWN0LWRvbSc7XG5pbXBvcnQgeyBnZXRPdmVyZmxvd0FuY2VzdG9ycywgdXNlRmxvYXRpbmcgYXMgdXNlRmxvYXRpbmckMSwgb2Zmc2V0LCBkZXRlY3RPdmVyZmxvdyB9IGZyb20gJ0BmbG9hdGluZy11aS9yZWFjdC1kb20nO1xuZXhwb3J0IHsgYXJyb3csIGF1dG9QbGFjZW1lbnQsIGF1dG9VcGRhdGUsIGNvbXB1dGVQb3NpdGlvbiwgZGV0ZWN0T3ZlcmZsb3csIGZsaXAsIGdldE92ZXJmbG93QW5jZXN0b3JzLCBoaWRlLCBpbmxpbmUsIGxpbWl0U2hpZnQsIG9mZnNldCwgcGxhdGZvcm0sIHNoaWZ0LCBzaXplIH0gZnJvbSAnQGZsb2F0aW5nLXVpL3JlYWN0LWRvbSc7XG5pbXBvcnQgeyBldmFsdWF0ZSwgbWF4LCByb3VuZCwgbWluIH0gZnJvbSAnQGZsb2F0aW5nLXVpL3V0aWxzJztcblxuLyoqXG4gKiBNZXJnZXMgYW4gYXJyYXkgb2YgcmVmcyBpbnRvIGEgc2luZ2xlIG1lbW9pemVkIGNhbGxiYWNrIHJlZiBvciBgbnVsbGAuXG4gKiBAc2VlIGh0dHBzOi8vZmxvYXRpbmctdWkuY29tL2RvY3MvcmVhY3QtdXRpbHMjdXNlbWVyZ2VyZWZzXG4gKi9cbmZ1bmN0aW9uIHVzZU1lcmdlUmVmcyhyZWZzKSB7XG4gIGNvbnN0IGNsZWFudXBSZWYgPSBSZWFjdC51c2VSZWYodW5kZWZpbmVkKTtcbiAgY29uc3QgcmVmRWZmZWN0ID0gUmVhY3QudXNlQ2FsbGJhY2soaW5zdGFuY2UgPT4ge1xuICAgIGNvbnN0IGNsZWFudXBzID0gcmVmcy5tYXAocmVmID0+IHtcbiAgICAgIGlmIChyZWYgPT0gbnVsbCkge1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG4gICAgICBpZiAodHlwZW9mIHJlZiA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICBjb25zdCByZWZDYWxsYmFjayA9IHJlZjtcbiAgICAgICAgY29uc3QgcmVmQ2xlYW51cCA9IHJlZkNhbGxiYWNrKGluc3RhbmNlKTtcbiAgICAgICAgcmV0dXJuIHR5cGVvZiByZWZDbGVhbnVwID09PSAnZnVuY3Rpb24nID8gcmVmQ2xlYW51cCA6ICgpID0+IHtcbiAgICAgICAgICByZWZDYWxsYmFjayhudWxsKTtcbiAgICAgICAgfTtcbiAgICAgIH1cbiAgICAgIHJlZi5jdXJyZW50ID0gaW5zdGFuY2U7XG4gICAgICByZXR1cm4gKCkgPT4ge1xuICAgICAgICByZWYuY3VycmVudCA9IG51bGw7XG4gICAgICB9O1xuICAgIH0pO1xuICAgIHJldHVybiAoKSA9PiB7XG4gICAgICBjbGVhbnVwcy5mb3JFYWNoKHJlZkNsZWFudXAgPT4gcmVmQ2xlYW51cCA9PSBudWxsID8gdm9pZCAwIDogcmVmQ2xlYW51cCgpKTtcbiAgICB9O1xuICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSByZWFjdC1ob29rcy9leGhhdXN0aXZlLWRlcHNcbiAgfSwgcmVmcyk7XG4gIHJldHVybiBSZWFjdC51c2VNZW1vKCgpID0+IHtcbiAgICBpZiAocmVmcy5ldmVyeShyZWYgPT4gcmVmID09IG51bGwpKSB7XG4gICAgICByZXR1cm4gbnVsbDtcbiAgICB9XG4gICAgcmV0dXJuIHZhbHVlID0+IHtcbiAgICAgIGlmIChjbGVhbnVwUmVmLmN1cnJlbnQpIHtcbiAgICAgICAgY2xlYW51cFJlZi5jdXJyZW50KCk7XG4gICAgICAgIGNsZWFudXBSZWYuY3VycmVudCA9IHVuZGVmaW5lZDtcbiAgICAgIH1cbiAgICAgIGlmICh2YWx1ZSAhPSBudWxsKSB7XG4gICAgICAgIGNsZWFudXBSZWYuY3VycmVudCA9IHJlZkVmZmVjdCh2YWx1ZSk7XG4gICAgICB9XG4gICAgfTtcbiAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgcmVhY3QtaG9va3MvZXhoYXVzdGl2ZS1kZXBzXG4gIH0sIHJlZnMpO1xufVxuXG5mdW5jdGlvbiBzb3J0QnlEb2N1bWVudFBvc2l0aW9uKGEsIGIpIHtcbiAgY29uc3QgcG9zaXRpb24gPSBhLmNvbXBhcmVEb2N1bWVudFBvc2l0aW9uKGIpO1xuICBpZiAocG9zaXRpb24gJiBOb2RlLkRPQ1VNRU5UX1BPU0lUSU9OX0ZPTExPV0lORyB8fCBwb3NpdGlvbiAmIE5vZGUuRE9DVU1FTlRfUE9TSVRJT05fQ09OVEFJTkVEX0JZKSB7XG4gICAgcmV0dXJuIC0xO1xuICB9XG4gIGlmIChwb3NpdGlvbiAmIE5vZGUuRE9DVU1FTlRfUE9TSVRJT05fUFJFQ0VESU5HIHx8IHBvc2l0aW9uICYgTm9kZS5ET0NVTUVOVF9QT1NJVElPTl9DT05UQUlOUykge1xuICAgIHJldHVybiAxO1xuICB9XG4gIHJldHVybiAwO1xufVxuY29uc3QgRmxvYXRpbmdMaXN0Q29udGV4dCA9IC8qI19fUFVSRV9fKi9SZWFjdC5jcmVhdGVDb250ZXh0KHtcbiAgcmVnaXN0ZXI6ICgpID0+IHt9LFxuICB1bnJlZ2lzdGVyOiAoKSA9PiB7fSxcbiAgbWFwOiAvKiNfX1BVUkVfXyovbmV3IE1hcCgpLFxuICBlbGVtZW50c1JlZjoge1xuICAgIGN1cnJlbnQ6IFtdXG4gIH1cbn0pO1xuLyoqXG4gKiBQcm92aWRlcyBjb250ZXh0IGZvciBhIGxpc3Qgb2YgaXRlbXMgd2l0aGluIHRoZSBmbG9hdGluZyBlbGVtZW50LlxuICogQHNlZSBodHRwczovL2Zsb2F0aW5nLXVpLmNvbS9kb2NzL0Zsb2F0aW5nTGlzdFxuICovXG5mdW5jdGlvbiBGbG9hdGluZ0xpc3QocHJvcHMpIHtcbiAgY29uc3Qge1xuICAgIGNoaWxkcmVuLFxuICAgIGVsZW1lbnRzUmVmLFxuICAgIGxhYmVsc1JlZlxuICB9ID0gcHJvcHM7XG4gIGNvbnN0IFtub2Rlcywgc2V0Tm9kZXNdID0gUmVhY3QudXNlU3RhdGUoKCkgPT4gbmV3IFNldCgpKTtcbiAgY29uc3QgcmVnaXN0ZXIgPSBSZWFjdC51c2VDYWxsYmFjayhub2RlID0+IHtcbiAgICBzZXROb2RlcyhwcmV2U2V0ID0+IG5ldyBTZXQocHJldlNldCkuYWRkKG5vZGUpKTtcbiAgfSwgW10pO1xuICBjb25zdCB1bnJlZ2lzdGVyID0gUmVhY3QudXNlQ2FsbGJhY2sobm9kZSA9PiB7XG4gICAgc2V0Tm9kZXMocHJldlNldCA9PiB7XG4gICAgICBjb25zdCBzZXQgPSBuZXcgU2V0KHByZXZTZXQpO1xuICAgICAgc2V0LmRlbGV0ZShub2RlKTtcbiAgICAgIHJldHVybiBzZXQ7XG4gICAgfSk7XG4gIH0sIFtdKTtcbiAgY29uc3QgbWFwID0gUmVhY3QudXNlTWVtbygoKSA9PiB7XG4gICAgY29uc3QgbmV3TWFwID0gbmV3IE1hcCgpO1xuICAgIGNvbnN0IHNvcnRlZE5vZGVzID0gQXJyYXkuZnJvbShub2Rlcy5rZXlzKCkpLnNvcnQoc29ydEJ5RG9jdW1lbnRQb3NpdGlvbik7XG4gICAgc29ydGVkTm9kZXMuZm9yRWFjaCgobm9kZSwgaW5kZXgpID0+IHtcbiAgICAgIG5ld01hcC5zZXQobm9kZSwgaW5kZXgpO1xuICAgIH0pO1xuICAgIHJldHVybiBuZXdNYXA7XG4gIH0sIFtub2Rlc10pO1xuICByZXR1cm4gLyojX19QVVJFX18qL2pzeChGbG9hdGluZ0xpc3RDb250ZXh0LlByb3ZpZGVyLCB7XG4gICAgdmFsdWU6IFJlYWN0LnVzZU1lbW8oKCkgPT4gKHtcbiAgICAgIHJlZ2lzdGVyLFxuICAgICAgdW5yZWdpc3RlcixcbiAgICAgIG1hcCxcbiAgICAgIGVsZW1lbnRzUmVmLFxuICAgICAgbGFiZWxzUmVmXG4gICAgfSksIFtyZWdpc3RlciwgdW5yZWdpc3RlciwgbWFwLCBlbGVtZW50c1JlZiwgbGFiZWxzUmVmXSksXG4gICAgY2hpbGRyZW46IGNoaWxkcmVuXG4gIH0pO1xufVxuLyoqXG4gKiBVc2VkIHRvIHJlZ2lzdGVyIGEgbGlzdCBpdGVtIGFuZCBpdHMgaW5kZXggKERPTSBwb3NpdGlvbikgaW4gdGhlXG4gKiBgRmxvYXRpbmdMaXN0YC5cbiAqIEBzZWUgaHR0cHM6Ly9mbG9hdGluZy11aS5jb20vZG9jcy9GbG9hdGluZ0xpc3QjdXNlbGlzdGl0ZW1cbiAqL1xuZnVuY3Rpb24gdXNlTGlzdEl0ZW0ocHJvcHMpIHtcbiAgaWYgKHByb3BzID09PSB2b2lkIDApIHtcbiAgICBwcm9wcyA9IHt9O1xuICB9XG4gIGNvbnN0IHtcbiAgICBsYWJlbFxuICB9ID0gcHJvcHM7XG4gIGNvbnN0IHtcbiAgICByZWdpc3RlcixcbiAgICB1bnJlZ2lzdGVyLFxuICAgIG1hcCxcbiAgICBlbGVtZW50c1JlZixcbiAgICBsYWJlbHNSZWZcbiAgfSA9IFJlYWN0LnVzZUNvbnRleHQoRmxvYXRpbmdMaXN0Q29udGV4dCk7XG4gIGNvbnN0IFtpbmRleCwgc2V0SW5kZXhdID0gUmVhY3QudXNlU3RhdGUobnVsbCk7XG4gIGNvbnN0IGNvbXBvbmVudFJlZiA9IFJlYWN0LnVzZVJlZihudWxsKTtcbiAgY29uc3QgcmVmID0gUmVhY3QudXNlQ2FsbGJhY2sobm9kZSA9PiB7XG4gICAgY29tcG9uZW50UmVmLmN1cnJlbnQgPSBub2RlO1xuICAgIGlmIChpbmRleCAhPT0gbnVsbCkge1xuICAgICAgZWxlbWVudHNSZWYuY3VycmVudFtpbmRleF0gPSBub2RlO1xuICAgICAgaWYgKGxhYmVsc1JlZikge1xuICAgICAgICB2YXIgX25vZGUkdGV4dENvbnRlbnQ7XG4gICAgICAgIGNvbnN0IGlzTGFiZWxEZWZpbmVkID0gbGFiZWwgIT09IHVuZGVmaW5lZDtcbiAgICAgICAgbGFiZWxzUmVmLmN1cnJlbnRbaW5kZXhdID0gaXNMYWJlbERlZmluZWQgPyBsYWJlbCA6IChfbm9kZSR0ZXh0Q29udGVudCA9IG5vZGUgPT0gbnVsbCA/IHZvaWQgMCA6IG5vZGUudGV4dENvbnRlbnQpICE9IG51bGwgPyBfbm9kZSR0ZXh0Q29udGVudCA6IG51bGw7XG4gICAgICB9XG4gICAgfVxuICB9LCBbaW5kZXgsIGVsZW1lbnRzUmVmLCBsYWJlbHNSZWYsIGxhYmVsXSk7XG4gIHVzZU1vZGVybkxheW91dEVmZmVjdCgoKSA9PiB7XG4gICAgY29uc3Qgbm9kZSA9IGNvbXBvbmVudFJlZi5jdXJyZW50O1xuICAgIGlmIChub2RlKSB7XG4gICAgICByZWdpc3Rlcihub2RlKTtcbiAgICAgIHJldHVybiAoKSA9PiB7XG4gICAgICAgIHVucmVnaXN0ZXIobm9kZSk7XG4gICAgICB9O1xuICAgIH1cbiAgfSwgW3JlZ2lzdGVyLCB1bnJlZ2lzdGVyXSk7XG4gIHVzZU1vZGVybkxheW91dEVmZmVjdCgoKSA9PiB7XG4gICAgY29uc3QgaW5kZXggPSBjb21wb25lbnRSZWYuY3VycmVudCA/IG1hcC5nZXQoY29tcG9uZW50UmVmLmN1cnJlbnQpIDogbnVsbDtcbiAgICBpZiAoaW5kZXggIT0gbnVsbCkge1xuICAgICAgc2V0SW5kZXgoaW5kZXgpO1xuICAgIH1cbiAgfSwgW21hcF0pO1xuICByZXR1cm4gUmVhY3QudXNlTWVtbygoKSA9PiAoe1xuICAgIHJlZixcbiAgICBpbmRleDogaW5kZXggPT0gbnVsbCA/IC0xIDogaW5kZXhcbiAgfSksIFtpbmRleCwgcmVmXSk7XG59XG5cbmNvbnN0IEZPQ1VTQUJMRV9BVFRSSUJVVEUgPSAnZGF0YS1mbG9hdGluZy11aS1mb2N1c2FibGUnO1xuY29uc3QgQUNUSVZFX0tFWSA9ICdhY3RpdmUnO1xuY29uc3QgU0VMRUNURURfS0VZID0gJ3NlbGVjdGVkJztcbmNvbnN0IEFSUk9XX0xFRlQgPSAnQXJyb3dMZWZ0JztcbmNvbnN0IEFSUk9XX1JJR0hUID0gJ0Fycm93UmlnaHQnO1xuY29uc3QgQVJST1dfVVAgPSAnQXJyb3dVcCc7XG5jb25zdCBBUlJPV19ET1dOID0gJ0Fycm93RG93bic7XG5cbmZ1bmN0aW9uIHJlbmRlckpzeChyZW5kZXIsIGNvbXB1dGVkUHJvcHMpIHtcbiAgaWYgKHR5cGVvZiByZW5kZXIgPT09ICdmdW5jdGlvbicpIHtcbiAgICByZXR1cm4gcmVuZGVyKGNvbXB1dGVkUHJvcHMpO1xuICB9XG4gIGlmIChyZW5kZXIpIHtcbiAgICByZXR1cm4gLyojX19QVVJFX18qL1JlYWN0LmNsb25lRWxlbWVudChyZW5kZXIsIGNvbXB1dGVkUHJvcHMpO1xuICB9XG4gIHJldHVybiAvKiNfX1BVUkVfXyovanN4KFwiZGl2XCIsIHtcbiAgICAuLi5jb21wdXRlZFByb3BzXG4gIH0pO1xufVxuY29uc3QgQ29tcG9zaXRlQ29udGV4dCA9IC8qI19fUFVSRV9fKi9SZWFjdC5jcmVhdGVDb250ZXh0KHtcbiAgYWN0aXZlSW5kZXg6IDAsXG4gIG9uTmF2aWdhdGU6ICgpID0+IHt9XG59KTtcbmNvbnN0IGhvcml6b250YWxLZXlzID0gW0FSUk9XX0xFRlQsIEFSUk9XX1JJR0hUXTtcbmNvbnN0IHZlcnRpY2FsS2V5cyA9IFtBUlJPV19VUCwgQVJST1dfRE9XTl07XG5jb25zdCBhbGxLZXlzID0gWy4uLmhvcml6b250YWxLZXlzLCAuLi52ZXJ0aWNhbEtleXNdO1xuXG4vKipcbiAqIENyZWF0ZXMgYSBzaW5nbGUgdGFiIHN0b3Agd2hvc2UgaXRlbXMgYXJlIG5hdmlnYXRlZCBieSBhcnJvdyBrZXlzLCB3aGljaFxuICogcHJvdmlkZXMgbGlzdCBuYXZpZ2F0aW9uIG91dHNpZGUgb2YgZmxvYXRpbmcgZWxlbWVudCBjb250ZXh0cy5cbiAqXG4gKiBUaGlzIGlzIHVzZWZ1bCB0byBlbmFibGUgbmF2aWdhdGlvbiBvZiBhIGxpc3Qgb2YgaXRlbXMgdGhhdCBhcmVu4oCZdCBwYXJ0IG9mIGFcbiAqIGZsb2F0aW5nIGVsZW1lbnQuIEEgbWVudWJhciBpcyBhbiBleGFtcGxlIG9mIGEgY29tcG9zaXRlLCB3aXRoIGVhY2ggcmVmZXJlbmNlXG4gKiBlbGVtZW50IGJlaW5nIGFuIGl0ZW0uXG4gKiBAc2VlIGh0dHBzOi8vZmxvYXRpbmctdWkuY29tL2RvY3MvQ29tcG9zaXRlXG4gKi9cbmNvbnN0IENvbXBvc2l0ZSA9IC8qI19fUFVSRV9fKi9SZWFjdC5mb3J3YXJkUmVmKGZ1bmN0aW9uIENvbXBvc2l0ZShwcm9wcywgZm9yd2FyZGVkUmVmKSB7XG4gIGNvbnN0IHtcbiAgICByZW5kZXIsXG4gICAgb3JpZW50YXRpb24gPSAnYm90aCcsXG4gICAgbG9vcCA9IHRydWUsXG4gICAgcnRsID0gZmFsc2UsXG4gICAgY29scyA9IDEsXG4gICAgZGlzYWJsZWRJbmRpY2VzLFxuICAgIGFjdGl2ZUluZGV4OiBleHRlcm5hbEFjdGl2ZUluZGV4LFxuICAgIG9uTmF2aWdhdGU6IGV4dGVybmFsU2V0QWN0aXZlSW5kZXgsXG4gICAgaXRlbVNpemVzLFxuICAgIGRlbnNlID0gZmFsc2UsXG4gICAgLi4uZG9tUHJvcHNcbiAgfSA9IHByb3BzO1xuICBjb25zdCBbaW50ZXJuYWxBY3RpdmVJbmRleCwgaW50ZXJuYWxTZXRBY3RpdmVJbmRleF0gPSBSZWFjdC51c2VTdGF0ZSgwKTtcbiAgY29uc3QgYWN0aXZlSW5kZXggPSBleHRlcm5hbEFjdGl2ZUluZGV4ICE9IG51bGwgPyBleHRlcm5hbEFjdGl2ZUluZGV4IDogaW50ZXJuYWxBY3RpdmVJbmRleDtcbiAgY29uc3Qgb25OYXZpZ2F0ZSA9IHVzZUVmZmVjdEV2ZW50KGV4dGVybmFsU2V0QWN0aXZlSW5kZXggIT0gbnVsbCA/IGV4dGVybmFsU2V0QWN0aXZlSW5kZXggOiBpbnRlcm5hbFNldEFjdGl2ZUluZGV4KTtcbiAgY29uc3QgZWxlbWVudHNSZWYgPSBSZWFjdC51c2VSZWYoW10pO1xuICBjb25zdCByZW5kZXJFbGVtZW50UHJvcHMgPSByZW5kZXIgJiYgdHlwZW9mIHJlbmRlciAhPT0gJ2Z1bmN0aW9uJyA/IHJlbmRlci5wcm9wcyA6IHt9O1xuICBjb25zdCBjb250ZXh0VmFsdWUgPSBSZWFjdC51c2VNZW1vKCgpID0+ICh7XG4gICAgYWN0aXZlSW5kZXgsXG4gICAgb25OYXZpZ2F0ZVxuICB9KSwgW2FjdGl2ZUluZGV4LCBvbk5hdmlnYXRlXSk7XG4gIGNvbnN0IGlzR3JpZCA9IGNvbHMgPiAxO1xuICBmdW5jdGlvbiBoYW5kbGVLZXlEb3duKGV2ZW50KSB7XG4gICAgaWYgKCFhbGxLZXlzLmluY2x1ZGVzKGV2ZW50LmtleSkpIHJldHVybjtcbiAgICBsZXQgbmV4dEluZGV4ID0gYWN0aXZlSW5kZXg7XG4gICAgY29uc3QgbWluSW5kZXggPSBnZXRNaW5MaXN0SW5kZXgoZWxlbWVudHNSZWYsIGRpc2FibGVkSW5kaWNlcyk7XG4gICAgY29uc3QgbWF4SW5kZXggPSBnZXRNYXhMaXN0SW5kZXgoZWxlbWVudHNSZWYsIGRpc2FibGVkSW5kaWNlcyk7XG4gICAgY29uc3QgaG9yaXpvbnRhbEVuZEtleSA9IHJ0bCA/IEFSUk9XX0xFRlQgOiBBUlJPV19SSUdIVDtcbiAgICBjb25zdCBob3Jpem9udGFsU3RhcnRLZXkgPSBydGwgPyBBUlJPV19SSUdIVCA6IEFSUk9XX0xFRlQ7XG4gICAgaWYgKGlzR3JpZCkge1xuICAgICAgY29uc3Qgc2l6ZXMgPSBpdGVtU2l6ZXMgfHwgQXJyYXkuZnJvbSh7XG4gICAgICAgIGxlbmd0aDogZWxlbWVudHNSZWYuY3VycmVudC5sZW5ndGhcbiAgICAgIH0sICgpID0+ICh7XG4gICAgICAgIHdpZHRoOiAxLFxuICAgICAgICBoZWlnaHQ6IDFcbiAgICAgIH0pKTtcbiAgICAgIC8vIFRvIGNhbGN1bGF0ZSBtb3ZlbWVudHMgb24gdGhlIGdyaWQsIHdlIHVzZSBoeXBvdGhldGljYWwgY2VsbCBpbmRpY2VzXG4gICAgICAvLyBhcyBpZiBldmVyeSBpdGVtIHdhcyAxeDEsIHRoZW4gY29udmVydCBiYWNrIHRvIHJlYWwgaW5kaWNlcy5cbiAgICAgIGNvbnN0IGNlbGxNYXAgPSBjcmVhdGVHcmlkQ2VsbE1hcChzaXplcywgY29scywgZGVuc2UpO1xuICAgICAgY29uc3QgbWluR3JpZEluZGV4ID0gY2VsbE1hcC5maW5kSW5kZXgoaW5kZXggPT4gaW5kZXggIT0gbnVsbCAmJiAhaXNMaXN0SW5kZXhEaXNhYmxlZChlbGVtZW50c1JlZiwgaW5kZXgsIGRpc2FibGVkSW5kaWNlcykpO1xuICAgICAgLy8gbGFzdCBlbmFibGVkIGluZGV4XG4gICAgICBjb25zdCBtYXhHcmlkSW5kZXggPSBjZWxsTWFwLnJlZHVjZSgoZm91bmRJbmRleCwgaW5kZXgsIGNlbGxJbmRleCkgPT4gaW5kZXggIT0gbnVsbCAmJiAhaXNMaXN0SW5kZXhEaXNhYmxlZChlbGVtZW50c1JlZiwgaW5kZXgsIGRpc2FibGVkSW5kaWNlcykgPyBjZWxsSW5kZXggOiBmb3VuZEluZGV4LCAtMSk7XG4gICAgICBjb25zdCBtYXliZU5leHRJbmRleCA9IGNlbGxNYXBbZ2V0R3JpZE5hdmlnYXRlZEluZGV4KHtcbiAgICAgICAgY3VycmVudDogY2VsbE1hcC5tYXAoaXRlbUluZGV4ID0+IGl0ZW1JbmRleCA/IGVsZW1lbnRzUmVmLmN1cnJlbnRbaXRlbUluZGV4XSA6IG51bGwpXG4gICAgICB9LCB7XG4gICAgICAgIGV2ZW50LFxuICAgICAgICBvcmllbnRhdGlvbixcbiAgICAgICAgbG9vcCxcbiAgICAgICAgcnRsLFxuICAgICAgICBjb2xzLFxuICAgICAgICAvLyB0cmVhdCB1bmRlZmluZWQgKGVtcHR5IGdyaWQgc3BhY2VzKSBhcyBkaXNhYmxlZCBpbmRpY2VzIHNvIHdlXG4gICAgICAgIC8vIGRvbid0IGVuZCB1cCBpbiB0aGVtXG4gICAgICAgIGRpc2FibGVkSW5kaWNlczogZ2V0R3JpZENlbGxJbmRpY2VzKFsuLi4oKHR5cGVvZiBkaXNhYmxlZEluZGljZXMgIT09ICdmdW5jdGlvbicgPyBkaXNhYmxlZEluZGljZXMgOiBudWxsKSB8fCBlbGVtZW50c1JlZi5jdXJyZW50Lm1hcCgoXywgaW5kZXgpID0+IGlzTGlzdEluZGV4RGlzYWJsZWQoZWxlbWVudHNSZWYsIGluZGV4LCBkaXNhYmxlZEluZGljZXMpID8gaW5kZXggOiB1bmRlZmluZWQpKSwgdW5kZWZpbmVkXSwgY2VsbE1hcCksXG4gICAgICAgIG1pbkluZGV4OiBtaW5HcmlkSW5kZXgsXG4gICAgICAgIG1heEluZGV4OiBtYXhHcmlkSW5kZXgsXG4gICAgICAgIHByZXZJbmRleDogZ2V0R3JpZENlbGxJbmRleE9mQ29ybmVyKGFjdGl2ZUluZGV4ID4gbWF4SW5kZXggPyBtaW5JbmRleCA6IGFjdGl2ZUluZGV4LCBzaXplcywgY2VsbE1hcCwgY29scyxcbiAgICAgICAgLy8gdXNlIGEgY29ybmVyIG1hdGNoaW5nIHRoZSBlZGdlIGNsb3Nlc3QgdG8gdGhlIGRpcmVjdGlvbiB3ZSdyZVxuICAgICAgICAvLyBtb3ZpbmcgaW4gc28gd2UgZG9uJ3QgZW5kIHVwIGluIHRoZSBzYW1lIGl0ZW0uIFByZWZlclxuICAgICAgICAvLyB0b3AvbGVmdCBvdmVyIGJvdHRvbS9yaWdodC5cbiAgICAgICAgZXZlbnQua2V5ID09PSBBUlJPV19ET1dOID8gJ2JsJyA6IGV2ZW50LmtleSA9PT0gaG9yaXpvbnRhbEVuZEtleSA/ICd0cicgOiAndGwnKVxuICAgICAgfSldO1xuICAgICAgaWYgKG1heWJlTmV4dEluZGV4ICE9IG51bGwpIHtcbiAgICAgICAgbmV4dEluZGV4ID0gbWF5YmVOZXh0SW5kZXg7XG4gICAgICB9XG4gICAgfVxuICAgIGNvbnN0IHRvRW5kS2V5cyA9IHtcbiAgICAgIGhvcml6b250YWw6IFtob3Jpem9udGFsRW5kS2V5XSxcbiAgICAgIHZlcnRpY2FsOiBbQVJST1dfRE9XTl0sXG4gICAgICBib3RoOiBbaG9yaXpvbnRhbEVuZEtleSwgQVJST1dfRE9XTl1cbiAgICB9W29yaWVudGF0aW9uXTtcbiAgICBjb25zdCB0b1N0YXJ0S2V5cyA9IHtcbiAgICAgIGhvcml6b250YWw6IFtob3Jpem9udGFsU3RhcnRLZXldLFxuICAgICAgdmVydGljYWw6IFtBUlJPV19VUF0sXG4gICAgICBib3RoOiBbaG9yaXpvbnRhbFN0YXJ0S2V5LCBBUlJPV19VUF1cbiAgICB9W29yaWVudGF0aW9uXTtcbiAgICBjb25zdCBwcmV2ZW50ZWRLZXlzID0gaXNHcmlkID8gYWxsS2V5cyA6IHtcbiAgICAgIGhvcml6b250YWw6IGhvcml6b250YWxLZXlzLFxuICAgICAgdmVydGljYWw6IHZlcnRpY2FsS2V5cyxcbiAgICAgIGJvdGg6IGFsbEtleXNcbiAgICB9W29yaWVudGF0aW9uXTtcbiAgICBpZiAobmV4dEluZGV4ID09PSBhY3RpdmVJbmRleCAmJiBbLi4udG9FbmRLZXlzLCAuLi50b1N0YXJ0S2V5c10uaW5jbHVkZXMoZXZlbnQua2V5KSkge1xuICAgICAgaWYgKGxvb3AgJiYgbmV4dEluZGV4ID09PSBtYXhJbmRleCAmJiB0b0VuZEtleXMuaW5jbHVkZXMoZXZlbnQua2V5KSkge1xuICAgICAgICBuZXh0SW5kZXggPSBtaW5JbmRleDtcbiAgICAgIH0gZWxzZSBpZiAobG9vcCAmJiBuZXh0SW5kZXggPT09IG1pbkluZGV4ICYmIHRvU3RhcnRLZXlzLmluY2x1ZGVzKGV2ZW50LmtleSkpIHtcbiAgICAgICAgbmV4dEluZGV4ID0gbWF4SW5kZXg7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBuZXh0SW5kZXggPSBmaW5kTm9uRGlzYWJsZWRMaXN0SW5kZXgoZWxlbWVudHNSZWYsIHtcbiAgICAgICAgICBzdGFydGluZ0luZGV4OiBuZXh0SW5kZXgsXG4gICAgICAgICAgZGVjcmVtZW50OiB0b1N0YXJ0S2V5cy5pbmNsdWRlcyhldmVudC5rZXkpLFxuICAgICAgICAgIGRpc2FibGVkSW5kaWNlc1xuICAgICAgICB9KTtcbiAgICAgIH1cbiAgICB9XG4gICAgaWYgKG5leHRJbmRleCAhPT0gYWN0aXZlSW5kZXggJiYgIWlzSW5kZXhPdXRPZkxpc3RCb3VuZHMoZWxlbWVudHNSZWYsIG5leHRJbmRleCkpIHtcbiAgICAgIHZhciBfZWxlbWVudHNSZWYkY3VycmVudCQ7XG4gICAgICBldmVudC5zdG9wUHJvcGFnYXRpb24oKTtcbiAgICAgIGlmIChwcmV2ZW50ZWRLZXlzLmluY2x1ZGVzKGV2ZW50LmtleSkpIHtcbiAgICAgICAgZXZlbnQucHJldmVudERlZmF1bHQoKTtcbiAgICAgIH1cbiAgICAgIG9uTmF2aWdhdGUobmV4dEluZGV4KTtcbiAgICAgIChfZWxlbWVudHNSZWYkY3VycmVudCQgPSBlbGVtZW50c1JlZi5jdXJyZW50W25leHRJbmRleF0pID09IG51bGwgfHwgX2VsZW1lbnRzUmVmJGN1cnJlbnQkLmZvY3VzKCk7XG4gICAgfVxuICB9XG4gIGNvbnN0IGNvbXB1dGVkUHJvcHMgPSB7XG4gICAgLi4uZG9tUHJvcHMsXG4gICAgLi4ucmVuZGVyRWxlbWVudFByb3BzLFxuICAgIHJlZjogZm9yd2FyZGVkUmVmLFxuICAgICdhcmlhLW9yaWVudGF0aW9uJzogb3JpZW50YXRpb24gPT09ICdib3RoJyA/IHVuZGVmaW5lZCA6IG9yaWVudGF0aW9uLFxuICAgIG9uS2V5RG93bihlKSB7XG4gICAgICBkb21Qcm9wcy5vbktleURvd24gPT0gbnVsbCB8fCBkb21Qcm9wcy5vbktleURvd24oZSk7XG4gICAgICByZW5kZXJFbGVtZW50UHJvcHMub25LZXlEb3duID09IG51bGwgfHwgcmVuZGVyRWxlbWVudFByb3BzLm9uS2V5RG93bihlKTtcbiAgICAgIGhhbmRsZUtleURvd24oZSk7XG4gICAgfVxuICB9O1xuICByZXR1cm4gLyojX19QVVJFX18qL2pzeChDb21wb3NpdGVDb250ZXh0LlByb3ZpZGVyLCB7XG4gICAgdmFsdWU6IGNvbnRleHRWYWx1ZSxcbiAgICBjaGlsZHJlbjogLyojX19QVVJFX18qL2pzeChGbG9hdGluZ0xpc3QsIHtcbiAgICAgIGVsZW1lbnRzUmVmOiBlbGVtZW50c1JlZixcbiAgICAgIGNoaWxkcmVuOiByZW5kZXJKc3gocmVuZGVyLCBjb21wdXRlZFByb3BzKVxuICAgIH0pXG4gIH0pO1xufSk7XG4vKipcbiAqIEBzZWUgaHR0cHM6Ly9mbG9hdGluZy11aS5jb20vZG9jcy9Db21wb3NpdGVcbiAqL1xuY29uc3QgQ29tcG9zaXRlSXRlbSA9IC8qI19fUFVSRV9fKi9SZWFjdC5mb3J3YXJkUmVmKGZ1bmN0aW9uIENvbXBvc2l0ZUl0ZW0ocHJvcHMsIGZvcndhcmRlZFJlZikge1xuICBjb25zdCB7XG4gICAgcmVuZGVyLFxuICAgIC4uLmRvbVByb3BzXG4gIH0gPSBwcm9wcztcbiAgY29uc3QgcmVuZGVyRWxlbWVudFByb3BzID0gcmVuZGVyICYmIHR5cGVvZiByZW5kZXIgIT09ICdmdW5jdGlvbicgPyByZW5kZXIucHJvcHMgOiB7fTtcbiAgY29uc3Qge1xuICAgIGFjdGl2ZUluZGV4LFxuICAgIG9uTmF2aWdhdGVcbiAgfSA9IFJlYWN0LnVzZUNvbnRleHQoQ29tcG9zaXRlQ29udGV4dCk7XG4gIGNvbnN0IHtcbiAgICByZWYsXG4gICAgaW5kZXhcbiAgfSA9IHVzZUxpc3RJdGVtKCk7XG4gIGNvbnN0IG1lcmdlZFJlZiA9IHVzZU1lcmdlUmVmcyhbcmVmLCBmb3J3YXJkZWRSZWYsIHJlbmRlckVsZW1lbnRQcm9wcy5yZWZdKTtcbiAgY29uc3QgaXNBY3RpdmUgPSBhY3RpdmVJbmRleCA9PT0gaW5kZXg7XG4gIGNvbnN0IGNvbXB1dGVkUHJvcHMgPSB7XG4gICAgLi4uZG9tUHJvcHMsXG4gICAgLi4ucmVuZGVyRWxlbWVudFByb3BzLFxuICAgIHJlZjogbWVyZ2VkUmVmLFxuICAgIHRhYkluZGV4OiBpc0FjdGl2ZSA/IDAgOiAtMSxcbiAgICAnZGF0YS1hY3RpdmUnOiBpc0FjdGl2ZSA/ICcnIDogdW5kZWZpbmVkLFxuICAgIG9uRm9jdXMoZSkge1xuICAgICAgZG9tUHJvcHMub25Gb2N1cyA9PSBudWxsIHx8IGRvbVByb3BzLm9uRm9jdXMoZSk7XG4gICAgICByZW5kZXJFbGVtZW50UHJvcHMub25Gb2N1cyA9PSBudWxsIHx8IHJlbmRlckVsZW1lbnRQcm9wcy5vbkZvY3VzKGUpO1xuICAgICAgb25OYXZpZ2F0ZShpbmRleCk7XG4gICAgfVxuICB9O1xuICByZXR1cm4gcmVuZGVySnN4KHJlbmRlciwgY29tcHV0ZWRQcm9wcyk7XG59KTtcblxuLy8gaHR0cHM6Ly9naXRodWIuY29tL211aS9tYXRlcmlhbC11aS9pc3N1ZXMvNDExOTAjaXNzdWVjb21tZW50LTIwNDA4NzMzNzlcbmNvbnN0IFNhZmVSZWFjdCA9IHtcbiAgLi4uUmVhY3Rcbn07XG5cbmxldCBzZXJ2ZXJIYW5kb2ZmQ29tcGxldGUgPSBmYWxzZTtcbmxldCBjb3VudCA9IDA7XG5jb25zdCBnZW5JZCA9ICgpID0+IC8vIEVuc3VyZSB0aGUgaWQgaXMgdW5pcXVlIHdpdGggbXVsdGlwbGUgaW5kZXBlbmRlbnQgdmVyc2lvbnMgb2YgRmxvYXRpbmcgVUlcbi8vIG9uIDxSZWFjdCAxOFxuXCJmbG9hdGluZy11aS1cIiArIE1hdGgucmFuZG9tKCkudG9TdHJpbmcoMzYpLnNsaWNlKDIsIDYpICsgY291bnQrKztcbmZ1bmN0aW9uIHVzZUZsb2F0aW5nSWQoKSB7XG4gIGNvbnN0IFtpZCwgc2V0SWRdID0gUmVhY3QudXNlU3RhdGUoKCkgPT4gc2VydmVySGFuZG9mZkNvbXBsZXRlID8gZ2VuSWQoKSA6IHVuZGVmaW5lZCk7XG4gIHVzZU1vZGVybkxheW91dEVmZmVjdCgoKSA9PiB7XG4gICAgaWYgKGlkID09IG51bGwpIHtcbiAgICAgIHNldElkKGdlbklkKCkpO1xuICAgIH1cbiAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgcmVhY3QtaG9va3MvZXhoYXVzdGl2ZS1kZXBzXG4gIH0sIFtdKTtcbiAgUmVhY3QudXNlRWZmZWN0KCgpID0+IHtcbiAgICBzZXJ2ZXJIYW5kb2ZmQ29tcGxldGUgPSB0cnVlO1xuICB9LCBbXSk7XG4gIHJldHVybiBpZDtcbn1cbmNvbnN0IHVzZVJlYWN0SWQgPSBTYWZlUmVhY3QudXNlSWQ7XG5cbi8qKlxuICogVXNlcyBSZWFjdCAxOCdzIGJ1aWx0LWluIGB1c2VJZCgpYCB3aGVuIGF2YWlsYWJsZSwgb3IgZmFsbHMgYmFjayB0byBhXG4gKiBzbGlnaHRseSBsZXNzIHBlcmZvcm1hbnQgKHJlcXVpcmluZyBhIGRvdWJsZSByZW5kZXIpIGltcGxlbWVudGF0aW9uIGZvclxuICogZWFybGllciBSZWFjdCB2ZXJzaW9ucy5cbiAqIEBzZWUgaHR0cHM6Ly9mbG9hdGluZy11aS5jb20vZG9jcy9yZWFjdC11dGlscyN1c2VpZFxuICovXG5jb25zdCB1c2VJZCA9IHVzZVJlYWN0SWQgfHwgdXNlRmxvYXRpbmdJZDtcblxubGV0IGRldk1lc3NhZ2VTZXQ7XG5pZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09IFwicHJvZHVjdGlvblwiKSB7XG4gIGRldk1lc3NhZ2VTZXQgPSAvKiNfX1BVUkVfXyovbmV3IFNldCgpO1xufVxuZnVuY3Rpb24gd2FybigpIHtcbiAgdmFyIF9kZXZNZXNzYWdlU2V0O1xuICBmb3IgKHZhciBfbGVuID0gYXJndW1lbnRzLmxlbmd0aCwgbWVzc2FnZXMgPSBuZXcgQXJyYXkoX2xlbiksIF9rZXkgPSAwOyBfa2V5IDwgX2xlbjsgX2tleSsrKSB7XG4gICAgbWVzc2FnZXNbX2tleV0gPSBhcmd1bWVudHNbX2tleV07XG4gIH1cbiAgY29uc3QgbWVzc2FnZSA9IFwiRmxvYXRpbmcgVUk6IFwiICsgbWVzc2FnZXMuam9pbignICcpO1xuICBpZiAoISgoX2Rldk1lc3NhZ2VTZXQgPSBkZXZNZXNzYWdlU2V0KSAhPSBudWxsICYmIF9kZXZNZXNzYWdlU2V0LmhhcyhtZXNzYWdlKSkpIHtcbiAgICB2YXIgX2Rldk1lc3NhZ2VTZXQyO1xuICAgIChfZGV2TWVzc2FnZVNldDIgPSBkZXZNZXNzYWdlU2V0KSA9PSBudWxsIHx8IF9kZXZNZXNzYWdlU2V0Mi5hZGQobWVzc2FnZSk7XG4gICAgY29uc29sZS53YXJuKG1lc3NhZ2UpO1xuICB9XG59XG5mdW5jdGlvbiBlcnJvcigpIHtcbiAgdmFyIF9kZXZNZXNzYWdlU2V0MztcbiAgZm9yICh2YXIgX2xlbjIgPSBhcmd1bWVudHMubGVuZ3RoLCBtZXNzYWdlcyA9IG5ldyBBcnJheShfbGVuMiksIF9rZXkyID0gMDsgX2tleTIgPCBfbGVuMjsgX2tleTIrKykge1xuICAgIG1lc3NhZ2VzW19rZXkyXSA9IGFyZ3VtZW50c1tfa2V5Ml07XG4gIH1cbiAgY29uc3QgbWVzc2FnZSA9IFwiRmxvYXRpbmcgVUk6IFwiICsgbWVzc2FnZXMuam9pbignICcpO1xuICBpZiAoISgoX2Rldk1lc3NhZ2VTZXQzID0gZGV2TWVzc2FnZVNldCkgIT0gbnVsbCAmJiBfZGV2TWVzc2FnZVNldDMuaGFzKG1lc3NhZ2UpKSkge1xuICAgIHZhciBfZGV2TWVzc2FnZVNldDQ7XG4gICAgKF9kZXZNZXNzYWdlU2V0NCA9IGRldk1lc3NhZ2VTZXQpID09IG51bGwgfHwgX2Rldk1lc3NhZ2VTZXQ0LmFkZChtZXNzYWdlKTtcbiAgICBjb25zb2xlLmVycm9yKG1lc3NhZ2UpO1xuICB9XG59XG5cbi8qKlxuICogUmVuZGVycyBhIHBvaW50aW5nIGFycm93IHRyaWFuZ2xlLlxuICogQHNlZSBodHRwczovL2Zsb2F0aW5nLXVpLmNvbS9kb2NzL0Zsb2F0aW5nQXJyb3dcbiAqL1xuY29uc3QgRmxvYXRpbmdBcnJvdyA9IC8qI19fUFVSRV9fKi9SZWFjdC5mb3J3YXJkUmVmKGZ1bmN0aW9uIEZsb2F0aW5nQXJyb3cocHJvcHMsIHJlZikge1xuICBjb25zdCB7XG4gICAgY29udGV4dDoge1xuICAgICAgcGxhY2VtZW50LFxuICAgICAgZWxlbWVudHM6IHtcbiAgICAgICAgZmxvYXRpbmdcbiAgICAgIH0sXG4gICAgICBtaWRkbGV3YXJlRGF0YToge1xuICAgICAgICBhcnJvdyxcbiAgICAgICAgc2hpZnRcbiAgICAgIH1cbiAgICB9LFxuICAgIHdpZHRoID0gMTQsXG4gICAgaGVpZ2h0ID0gNyxcbiAgICB0aXBSYWRpdXMgPSAwLFxuICAgIHN0cm9rZVdpZHRoID0gMCxcbiAgICBzdGF0aWNPZmZzZXQsXG4gICAgc3Ryb2tlLFxuICAgIGQsXG4gICAgc3R5bGU6IHtcbiAgICAgIHRyYW5zZm9ybSxcbiAgICAgIC4uLnJlc3RTdHlsZVxuICAgIH0gPSB7fSxcbiAgICAuLi5yZXN0XG4gIH0gPSBwcm9wcztcbiAgaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSBcInByb2R1Y3Rpb25cIikge1xuICAgIGlmICghcmVmKSB7XG4gICAgICB3YXJuKCdUaGUgYHJlZmAgcHJvcCBpcyByZXF1aXJlZCBmb3IgYEZsb2F0aW5nQXJyb3dgLicpO1xuICAgIH1cbiAgfVxuICBjb25zdCBjbGlwUGF0aElkID0gdXNlSWQoKTtcbiAgY29uc3QgW2lzUlRMLCBzZXRJc1JUTF0gPSBSZWFjdC51c2VTdGF0ZShmYWxzZSk7XG5cbiAgLy8gaHR0cHM6Ly9naXRodWIuY29tL2Zsb2F0aW5nLXVpL2Zsb2F0aW5nLXVpL2lzc3Vlcy8yOTMyXG4gIHVzZU1vZGVybkxheW91dEVmZmVjdCgoKSA9PiB7XG4gICAgaWYgKCFmbG9hdGluZykgcmV0dXJuO1xuICAgIGNvbnN0IGlzUlRMID0gZ2V0Q29tcHV0ZWRTdHlsZShmbG9hdGluZykuZGlyZWN0aW9uID09PSAncnRsJztcbiAgICBpZiAoaXNSVEwpIHtcbiAgICAgIHNldElzUlRMKHRydWUpO1xuICAgIH1cbiAgfSwgW2Zsb2F0aW5nXSk7XG4gIGlmICghZmxvYXRpbmcpIHtcbiAgICByZXR1cm4gbnVsbDtcbiAgfVxuICBjb25zdCBbc2lkZSwgYWxpZ25tZW50XSA9IHBsYWNlbWVudC5zcGxpdCgnLScpO1xuICBjb25zdCBpc1ZlcnRpY2FsU2lkZSA9IHNpZGUgPT09ICd0b3AnIHx8IHNpZGUgPT09ICdib3R0b20nO1xuICBsZXQgY29tcHV0ZWRTdGF0aWNPZmZzZXQgPSBzdGF0aWNPZmZzZXQ7XG4gIGlmIChpc1ZlcnRpY2FsU2lkZSAmJiBzaGlmdCAhPSBudWxsICYmIHNoaWZ0LnggfHwgIWlzVmVydGljYWxTaWRlICYmIHNoaWZ0ICE9IG51bGwgJiYgc2hpZnQueSkge1xuICAgIGNvbXB1dGVkU3RhdGljT2Zmc2V0ID0gbnVsbDtcbiAgfVxuXG4gIC8vIFN0cm9rZXMgbXVzdCBiZSBkb3VibGUgdGhlIGJvcmRlciB3aWR0aCwgdGhpcyBlbnN1cmVzIHRoZSBzdHJva2UncyB3aWR0aFxuICAvLyB3b3JrcyBhcyB5b3UnZCBleHBlY3QuXG4gIGNvbnN0IGNvbXB1dGVkU3Ryb2tlV2lkdGggPSBzdHJva2VXaWR0aCAqIDI7XG4gIGNvbnN0IGhhbGZTdHJva2VXaWR0aCA9IGNvbXB1dGVkU3Ryb2tlV2lkdGggLyAyO1xuICBjb25zdCBzdmdYID0gd2lkdGggLyAyICogKHRpcFJhZGl1cyAvIC04ICsgMSk7XG4gIGNvbnN0IHN2Z1kgPSBoZWlnaHQgLyAyICogdGlwUmFkaXVzIC8gNDtcbiAgY29uc3QgaXNDdXN0b21TaGFwZSA9ICEhZDtcbiAgY29uc3QgeU9mZnNldFByb3AgPSBjb21wdXRlZFN0YXRpY09mZnNldCAmJiBhbGlnbm1lbnQgPT09ICdlbmQnID8gJ2JvdHRvbScgOiAndG9wJztcbiAgbGV0IHhPZmZzZXRQcm9wID0gY29tcHV0ZWRTdGF0aWNPZmZzZXQgJiYgYWxpZ25tZW50ID09PSAnZW5kJyA/ICdyaWdodCcgOiAnbGVmdCc7XG4gIGlmIChjb21wdXRlZFN0YXRpY09mZnNldCAmJiBpc1JUTCkge1xuICAgIHhPZmZzZXRQcm9wID0gYWxpZ25tZW50ID09PSAnZW5kJyA/ICdsZWZ0JyA6ICdyaWdodCc7XG4gIH1cbiAgY29uc3QgYXJyb3dYID0gKGFycm93ID09IG51bGwgPyB2b2lkIDAgOiBhcnJvdy54KSAhPSBudWxsID8gY29tcHV0ZWRTdGF0aWNPZmZzZXQgfHwgYXJyb3cueCA6ICcnO1xuICBjb25zdCBhcnJvd1kgPSAoYXJyb3cgPT0gbnVsbCA/IHZvaWQgMCA6IGFycm93LnkpICE9IG51bGwgPyBjb21wdXRlZFN0YXRpY09mZnNldCB8fCBhcnJvdy55IDogJyc7XG4gIGNvbnN0IGRWYWx1ZSA9IGQgfHwgJ00wLDAnICsgKFwiIEhcIiArIHdpZHRoKSArIChcIiBMXCIgKyAod2lkdGggLSBzdmdYKSArIFwiLFwiICsgKGhlaWdodCAtIHN2Z1kpKSArIChcIiBRXCIgKyB3aWR0aCAvIDIgKyBcIixcIiArIGhlaWdodCArIFwiIFwiICsgc3ZnWCArIFwiLFwiICsgKGhlaWdodCAtIHN2Z1kpKSArICcgWic7XG4gIGNvbnN0IHJvdGF0aW9uID0ge1xuICAgIHRvcDogaXNDdXN0b21TaGFwZSA/ICdyb3RhdGUoMTgwZGVnKScgOiAnJyxcbiAgICBsZWZ0OiBpc0N1c3RvbVNoYXBlID8gJ3JvdGF0ZSg5MGRlZyknIDogJ3JvdGF0ZSgtOTBkZWcpJyxcbiAgICBib3R0b206IGlzQ3VzdG9tU2hhcGUgPyAnJyA6ICdyb3RhdGUoMTgwZGVnKScsXG4gICAgcmlnaHQ6IGlzQ3VzdG9tU2hhcGUgPyAncm90YXRlKC05MGRlZyknIDogJ3JvdGF0ZSg5MGRlZyknXG4gIH1bc2lkZV07XG4gIHJldHVybiAvKiNfX1BVUkVfXyovanN4cyhcInN2Z1wiLCB7XG4gICAgLi4ucmVzdCxcbiAgICBcImFyaWEtaGlkZGVuXCI6IHRydWUsXG4gICAgcmVmOiByZWYsXG4gICAgd2lkdGg6IGlzQ3VzdG9tU2hhcGUgPyB3aWR0aCA6IHdpZHRoICsgY29tcHV0ZWRTdHJva2VXaWR0aCxcbiAgICBoZWlnaHQ6IHdpZHRoLFxuICAgIHZpZXdCb3g6IFwiMCAwIFwiICsgd2lkdGggKyBcIiBcIiArIChoZWlnaHQgPiB3aWR0aCA/IGhlaWdodCA6IHdpZHRoKSxcbiAgICBzdHlsZToge1xuICAgICAgcG9zaXRpb246ICdhYnNvbHV0ZScsXG4gICAgICBwb2ludGVyRXZlbnRzOiAnbm9uZScsXG4gICAgICBbeE9mZnNldFByb3BdOiBhcnJvd1gsXG4gICAgICBbeU9mZnNldFByb3BdOiBhcnJvd1ksXG4gICAgICBbc2lkZV06IGlzVmVydGljYWxTaWRlIHx8IGlzQ3VzdG9tU2hhcGUgPyAnMTAwJScgOiBcImNhbGMoMTAwJSAtIFwiICsgY29tcHV0ZWRTdHJva2VXaWR0aCAvIDIgKyBcInB4KVwiLFxuICAgICAgdHJhbnNmb3JtOiBbcm90YXRpb24sIHRyYW5zZm9ybV0uZmlsdGVyKHQgPT4gISF0KS5qb2luKCcgJyksXG4gICAgICAuLi5yZXN0U3R5bGVcbiAgICB9LFxuICAgIGNoaWxkcmVuOiBbY29tcHV0ZWRTdHJva2VXaWR0aCA+IDAgJiYgLyojX19QVVJFX18qL2pzeChcInBhdGhcIiwge1xuICAgICAgY2xpcFBhdGg6IFwidXJsKCNcIiArIGNsaXBQYXRoSWQgKyBcIilcIixcbiAgICAgIGZpbGw6IFwibm9uZVwiLFxuICAgICAgc3Ryb2tlOiBzdHJva2VcbiAgICAgIC8vIEFjY291bnQgZm9yIHRoZSBzdHJva2Ugb24gdGhlIGZpbGwgcGF0aCByZW5kZXJlZCBiZWxvdy5cbiAgICAgICxcbiAgICAgIHN0cm9rZVdpZHRoOiBjb21wdXRlZFN0cm9rZVdpZHRoICsgKGQgPyAwIDogMSksXG4gICAgICBkOiBkVmFsdWVcbiAgICB9KSwgLyojX19QVVJFX18qL2pzeChcInBhdGhcIiwge1xuICAgICAgc3Ryb2tlOiBjb21wdXRlZFN0cm9rZVdpZHRoICYmICFkID8gcmVzdC5maWxsIDogJ25vbmUnLFxuICAgICAgZDogZFZhbHVlXG4gICAgfSksIC8qI19fUFVSRV9fKi9qc3goXCJjbGlwUGF0aFwiLCB7XG4gICAgICBpZDogY2xpcFBhdGhJZCxcbiAgICAgIGNoaWxkcmVuOiAvKiNfX1BVUkVfXyovanN4KFwicmVjdFwiLCB7XG4gICAgICAgIHg6IC1oYWxmU3Ryb2tlV2lkdGgsXG4gICAgICAgIHk6IGhhbGZTdHJva2VXaWR0aCAqIChpc0N1c3RvbVNoYXBlID8gLTEgOiAxKSxcbiAgICAgICAgd2lkdGg6IHdpZHRoICsgY29tcHV0ZWRTdHJva2VXaWR0aCxcbiAgICAgICAgaGVpZ2h0OiB3aWR0aFxuICAgICAgfSlcbiAgICB9KV1cbiAgfSk7XG59KTtcblxuZnVuY3Rpb24gY3JlYXRlRXZlbnRFbWl0dGVyKCkge1xuICBjb25zdCBtYXAgPSBuZXcgTWFwKCk7XG4gIHJldHVybiB7XG4gICAgZW1pdChldmVudCwgZGF0YSkge1xuICAgICAgdmFyIF9tYXAkZ2V0O1xuICAgICAgKF9tYXAkZ2V0ID0gbWFwLmdldChldmVudCkpID09IG51bGwgfHwgX21hcCRnZXQuZm9yRWFjaChsaXN0ZW5lciA9PiBsaXN0ZW5lcihkYXRhKSk7XG4gICAgfSxcbiAgICBvbihldmVudCwgbGlzdGVuZXIpIHtcbiAgICAgIGlmICghbWFwLmhhcyhldmVudCkpIHtcbiAgICAgICAgbWFwLnNldChldmVudCwgbmV3IFNldCgpKTtcbiAgICAgIH1cbiAgICAgIG1hcC5nZXQoZXZlbnQpLmFkZChsaXN0ZW5lcik7XG4gICAgfSxcbiAgICBvZmYoZXZlbnQsIGxpc3RlbmVyKSB7XG4gICAgICB2YXIgX21hcCRnZXQyO1xuICAgICAgKF9tYXAkZ2V0MiA9IG1hcC5nZXQoZXZlbnQpKSA9PSBudWxsIHx8IF9tYXAkZ2V0Mi5kZWxldGUobGlzdGVuZXIpO1xuICAgIH1cbiAgfTtcbn1cblxuY29uc3QgRmxvYXRpbmdOb2RlQ29udGV4dCA9IC8qI19fUFVSRV9fKi9SZWFjdC5jcmVhdGVDb250ZXh0KG51bGwpO1xuY29uc3QgRmxvYXRpbmdUcmVlQ29udGV4dCA9IC8qI19fUFVSRV9fKi9SZWFjdC5jcmVhdGVDb250ZXh0KG51bGwpO1xuXG4vKipcbiAqIFJldHVybnMgdGhlIHBhcmVudCBub2RlIGlkIGZvciBuZXN0ZWQgZmxvYXRpbmcgZWxlbWVudHMsIGlmIGF2YWlsYWJsZS5cbiAqIFJldHVybnMgYG51bGxgIGZvciB0b3AtbGV2ZWwgZmxvYXRpbmcgZWxlbWVudHMuXG4gKi9cbmNvbnN0IHVzZUZsb2F0aW5nUGFyZW50Tm9kZUlkID0gKCkgPT4ge1xuICB2YXIgX1JlYWN0JHVzZUNvbnRleHQ7XG4gIHJldHVybiAoKF9SZWFjdCR1c2VDb250ZXh0ID0gUmVhY3QudXNlQ29udGV4dChGbG9hdGluZ05vZGVDb250ZXh0KSkgPT0gbnVsbCA/IHZvaWQgMCA6IF9SZWFjdCR1c2VDb250ZXh0LmlkKSB8fCBudWxsO1xufTtcblxuLyoqXG4gKiBSZXR1cm5zIHRoZSBuZWFyZXN0IGZsb2F0aW5nIHRyZWUgY29udGV4dCwgaWYgYXZhaWxhYmxlLlxuICovXG5jb25zdCB1c2VGbG9hdGluZ1RyZWUgPSAoKSA9PiBSZWFjdC51c2VDb250ZXh0KEZsb2F0aW5nVHJlZUNvbnRleHQpO1xuXG4vKipcbiAqIFJlZ2lzdGVycyBhIG5vZGUgaW50byB0aGUgYEZsb2F0aW5nVHJlZWAsIHJldHVybmluZyBpdHMgaWQuXG4gKiBAc2VlIGh0dHBzOi8vZmxvYXRpbmctdWkuY29tL2RvY3MvRmxvYXRpbmdUcmVlXG4gKi9cbmZ1bmN0aW9uIHVzZUZsb2F0aW5nTm9kZUlkKGN1c3RvbVBhcmVudElkKSB7XG4gIGNvbnN0IGlkID0gdXNlSWQoKTtcbiAgY29uc3QgdHJlZSA9IHVzZUZsb2F0aW5nVHJlZSgpO1xuICBjb25zdCByZWFjdFBhcmVudElkID0gdXNlRmxvYXRpbmdQYXJlbnROb2RlSWQoKTtcbiAgY29uc3QgcGFyZW50SWQgPSBjdXN0b21QYXJlbnRJZCB8fCByZWFjdFBhcmVudElkO1xuICB1c2VNb2Rlcm5MYXlvdXRFZmZlY3QoKCkgPT4ge1xuICAgIGlmICghaWQpIHJldHVybjtcbiAgICBjb25zdCBub2RlID0ge1xuICAgICAgaWQsXG4gICAgICBwYXJlbnRJZFxuICAgIH07XG4gICAgdHJlZSA9PSBudWxsIHx8IHRyZWUuYWRkTm9kZShub2RlKTtcbiAgICByZXR1cm4gKCkgPT4ge1xuICAgICAgdHJlZSA9PSBudWxsIHx8IHRyZWUucmVtb3ZlTm9kZShub2RlKTtcbiAgICB9O1xuICB9LCBbdHJlZSwgaWQsIHBhcmVudElkXSk7XG4gIHJldHVybiBpZDtcbn1cbi8qKlxuICogUHJvdmlkZXMgcGFyZW50IG5vZGUgY29udGV4dCBmb3IgbmVzdGVkIGZsb2F0aW5nIGVsZW1lbnRzLlxuICogQHNlZSBodHRwczovL2Zsb2F0aW5nLXVpLmNvbS9kb2NzL0Zsb2F0aW5nVHJlZVxuICovXG5mdW5jdGlvbiBGbG9hdGluZ05vZGUocHJvcHMpIHtcbiAgY29uc3Qge1xuICAgIGNoaWxkcmVuLFxuICAgIGlkXG4gIH0gPSBwcm9wcztcbiAgY29uc3QgcGFyZW50SWQgPSB1c2VGbG9hdGluZ1BhcmVudE5vZGVJZCgpO1xuICByZXR1cm4gLyojX19QVVJFX18qL2pzeChGbG9hdGluZ05vZGVDb250ZXh0LlByb3ZpZGVyLCB7XG4gICAgdmFsdWU6IFJlYWN0LnVzZU1lbW8oKCkgPT4gKHtcbiAgICAgIGlkLFxuICAgICAgcGFyZW50SWRcbiAgICB9KSwgW2lkLCBwYXJlbnRJZF0pLFxuICAgIGNoaWxkcmVuOiBjaGlsZHJlblxuICB9KTtcbn1cbi8qKlxuICogUHJvdmlkZXMgY29udGV4dCBmb3IgbmVzdGVkIGZsb2F0aW5nIGVsZW1lbnRzIHdoZW4gdGhleSBhcmUgbm90IGNoaWxkcmVuIG9mXG4gKiBlYWNoIG90aGVyIG9uIHRoZSBET00uXG4gKiBUaGlzIGlzIG5vdCBuZWNlc3NhcnkgaW4gYWxsIGNhc2VzLCBleGNlcHQgd2hlbiB0aGVyZSBtdXN0IGJlIGV4cGxpY2l0IGNvbW11bmljYXRpb24gYmV0d2VlbiBwYXJlbnQgYW5kIGNoaWxkIGZsb2F0aW5nIGVsZW1lbnRzLiBJdCBpcyBuZWNlc3NhcnkgZm9yOlxuICogLSBUaGUgYGJ1YmJsZXNgIG9wdGlvbiBpbiB0aGUgYHVzZURpc21pc3MoKWAgSG9va1xuICogLSBOZXN0ZWQgdmlydHVhbCBsaXN0IG5hdmlnYXRpb25cbiAqIC0gTmVzdGVkIGZsb2F0aW5nIGVsZW1lbnRzIHRoYXQgZWFjaCBvcGVuIG9uIGhvdmVyXG4gKiAtIEN1c3RvbSBjb21tdW5pY2F0aW9uIGJldHdlZW4gcGFyZW50IGFuZCBjaGlsZCBmbG9hdGluZyBlbGVtZW50c1xuICogQHNlZSBodHRwczovL2Zsb2F0aW5nLXVpLmNvbS9kb2NzL0Zsb2F0aW5nVHJlZVxuICovXG5mdW5jdGlvbiBGbG9hdGluZ1RyZWUocHJvcHMpIHtcbiAgY29uc3Qge1xuICAgIGNoaWxkcmVuXG4gIH0gPSBwcm9wcztcbiAgY29uc3Qgbm9kZXNSZWYgPSBSZWFjdC51c2VSZWYoW10pO1xuICBjb25zdCBhZGROb2RlID0gUmVhY3QudXNlQ2FsbGJhY2sobm9kZSA9PiB7XG4gICAgbm9kZXNSZWYuY3VycmVudCA9IFsuLi5ub2Rlc1JlZi5jdXJyZW50LCBub2RlXTtcbiAgfSwgW10pO1xuICBjb25zdCByZW1vdmVOb2RlID0gUmVhY3QudXNlQ2FsbGJhY2sobm9kZSA9PiB7XG4gICAgbm9kZXNSZWYuY3VycmVudCA9IG5vZGVzUmVmLmN1cnJlbnQuZmlsdGVyKG4gPT4gbiAhPT0gbm9kZSk7XG4gIH0sIFtdKTtcbiAgY29uc3QgW2V2ZW50c10gPSBSZWFjdC51c2VTdGF0ZSgoKSA9PiBjcmVhdGVFdmVudEVtaXR0ZXIoKSk7XG4gIHJldHVybiAvKiNfX1BVUkVfXyovanN4KEZsb2F0aW5nVHJlZUNvbnRleHQuUHJvdmlkZXIsIHtcbiAgICB2YWx1ZTogUmVhY3QudXNlTWVtbygoKSA9PiAoe1xuICAgICAgbm9kZXNSZWYsXG4gICAgICBhZGROb2RlLFxuICAgICAgcmVtb3ZlTm9kZSxcbiAgICAgIGV2ZW50c1xuICAgIH0pLCBbYWRkTm9kZSwgcmVtb3ZlTm9kZSwgZXZlbnRzXSksXG4gICAgY2hpbGRyZW46IGNoaWxkcmVuXG4gIH0pO1xufVxuXG5mdW5jdGlvbiBjcmVhdGVBdHRyaWJ1dGUobmFtZSkge1xuICByZXR1cm4gXCJkYXRhLWZsb2F0aW5nLXVpLVwiICsgbmFtZTtcbn1cblxuZnVuY3Rpb24gY2xlYXJUaW1lb3V0SWZTZXQodGltZW91dFJlZikge1xuICBpZiAodGltZW91dFJlZi5jdXJyZW50ICE9PSAtMSkge1xuICAgIGNsZWFyVGltZW91dCh0aW1lb3V0UmVmLmN1cnJlbnQpO1xuICAgIHRpbWVvdXRSZWYuY3VycmVudCA9IC0xO1xuICB9XG59XG5cbmNvbnN0IHNhZmVQb2x5Z29uSWRlbnRpZmllciA9IC8qI19fUFVSRV9fKi9jcmVhdGVBdHRyaWJ1dGUoJ3NhZmUtcG9seWdvbicpO1xuZnVuY3Rpb24gZ2V0RGVsYXkodmFsdWUsIHByb3AsIHBvaW50ZXJUeXBlKSB7XG4gIGlmIChwb2ludGVyVHlwZSAmJiAhaXNNb3VzZUxpa2VQb2ludGVyVHlwZShwb2ludGVyVHlwZSkpIHtcbiAgICByZXR1cm4gMDtcbiAgfVxuICBpZiAodHlwZW9mIHZhbHVlID09PSAnbnVtYmVyJykge1xuICAgIHJldHVybiB2YWx1ZTtcbiAgfVxuICBpZiAodHlwZW9mIHZhbHVlID09PSAnZnVuY3Rpb24nKSB7XG4gICAgY29uc3QgcmVzdWx0ID0gdmFsdWUoKTtcbiAgICBpZiAodHlwZW9mIHJlc3VsdCA9PT0gJ251bWJlcicpIHtcbiAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgfVxuICAgIHJldHVybiByZXN1bHQgPT0gbnVsbCA/IHZvaWQgMCA6IHJlc3VsdFtwcm9wXTtcbiAgfVxuICByZXR1cm4gdmFsdWUgPT0gbnVsbCA/IHZvaWQgMCA6IHZhbHVlW3Byb3BdO1xufVxuZnVuY3Rpb24gZ2V0UmVzdE1zKHZhbHVlKSB7XG4gIGlmICh0eXBlb2YgdmFsdWUgPT09ICdmdW5jdGlvbicpIHtcbiAgICByZXR1cm4gdmFsdWUoKTtcbiAgfVxuICByZXR1cm4gdmFsdWU7XG59XG4vKipcbiAqIE9wZW5zIHRoZSBmbG9hdGluZyBlbGVtZW50IHdoaWxlIGhvdmVyaW5nIG92ZXIgdGhlIHJlZmVyZW5jZSBlbGVtZW50LCBsaWtlXG4gKiBDU1MgYDpob3ZlcmAuXG4gKiBAc2VlIGh0dHBzOi8vZmxvYXRpbmctdWkuY29tL2RvY3MvdXNlSG92ZXJcbiAqL1xuZnVuY3Rpb24gdXNlSG92ZXIoY29udGV4dCwgcHJvcHMpIHtcbiAgaWYgKHByb3BzID09PSB2b2lkIDApIHtcbiAgICBwcm9wcyA9IHt9O1xuICB9XG4gIGNvbnN0IHtcbiAgICBvcGVuLFxuICAgIG9uT3BlbkNoYW5nZSxcbiAgICBkYXRhUmVmLFxuICAgIGV2ZW50cyxcbiAgICBlbGVtZW50c1xuICB9ID0gY29udGV4dDtcbiAgY29uc3Qge1xuICAgIGVuYWJsZWQgPSB0cnVlLFxuICAgIGRlbGF5ID0gMCxcbiAgICBoYW5kbGVDbG9zZSA9IG51bGwsXG4gICAgbW91c2VPbmx5ID0gZmFsc2UsXG4gICAgcmVzdE1zID0gMCxcbiAgICBtb3ZlID0gdHJ1ZVxuICB9ID0gcHJvcHM7XG4gIGNvbnN0IHRyZWUgPSB1c2VGbG9hdGluZ1RyZWUoKTtcbiAgY29uc3QgcGFyZW50SWQgPSB1c2VGbG9hdGluZ1BhcmVudE5vZGVJZCgpO1xuICBjb25zdCBoYW5kbGVDbG9zZVJlZiA9IHVzZUxhdGVzdFJlZihoYW5kbGVDbG9zZSk7XG4gIGNvbnN0IGRlbGF5UmVmID0gdXNlTGF0ZXN0UmVmKGRlbGF5KTtcbiAgY29uc3Qgb3BlblJlZiA9IHVzZUxhdGVzdFJlZihvcGVuKTtcbiAgY29uc3QgcmVzdE1zUmVmID0gdXNlTGF0ZXN0UmVmKHJlc3RNcyk7XG4gIGNvbnN0IHBvaW50ZXJUeXBlUmVmID0gUmVhY3QudXNlUmVmKCk7XG4gIGNvbnN0IHRpbWVvdXRSZWYgPSBSZWFjdC51c2VSZWYoLTEpO1xuICBjb25zdCBoYW5kbGVyUmVmID0gUmVhY3QudXNlUmVmKCk7XG4gIGNvbnN0IHJlc3RUaW1lb3V0UmVmID0gUmVhY3QudXNlUmVmKC0xKTtcbiAgY29uc3QgYmxvY2tNb3VzZU1vdmVSZWYgPSBSZWFjdC51c2VSZWYodHJ1ZSk7XG4gIGNvbnN0IHBlcmZvcm1lZFBvaW50ZXJFdmVudHNNdXRhdGlvblJlZiA9IFJlYWN0LnVzZVJlZihmYWxzZSk7XG4gIGNvbnN0IHVuYmluZE1vdXNlTW92ZVJlZiA9IFJlYWN0LnVzZVJlZigoKSA9PiB7fSk7XG4gIGNvbnN0IHJlc3RUaW1lb3V0UGVuZGluZ1JlZiA9IFJlYWN0LnVzZVJlZihmYWxzZSk7XG4gIGNvbnN0IGlzSG92ZXJPcGVuID0gdXNlRWZmZWN0RXZlbnQoKCkgPT4ge1xuICAgIHZhciBfZGF0YVJlZiRjdXJyZW50JG9wZW47XG4gICAgY29uc3QgdHlwZSA9IChfZGF0YVJlZiRjdXJyZW50JG9wZW4gPSBkYXRhUmVmLmN1cnJlbnQub3BlbkV2ZW50KSA9PSBudWxsID8gdm9pZCAwIDogX2RhdGFSZWYkY3VycmVudCRvcGVuLnR5cGU7XG4gICAgcmV0dXJuICh0eXBlID09IG51bGwgPyB2b2lkIDAgOiB0eXBlLmluY2x1ZGVzKCdtb3VzZScpKSAmJiB0eXBlICE9PSAnbW91c2Vkb3duJztcbiAgfSk7XG5cbiAgLy8gV2hlbiBjbG9zaW5nIGJlZm9yZSBvcGVuaW5nLCBjbGVhciB0aGUgZGVsYXkgdGltZW91dHMgdG8gY2FuY2VsIGl0XG4gIC8vIGZyb20gc2hvd2luZy5cbiAgUmVhY3QudXNlRWZmZWN0KCgpID0+IHtcbiAgICBpZiAoIWVuYWJsZWQpIHJldHVybjtcbiAgICBmdW5jdGlvbiBvbk9wZW5DaGFuZ2UoX3JlZikge1xuICAgICAgbGV0IHtcbiAgICAgICAgb3BlblxuICAgICAgfSA9IF9yZWY7XG4gICAgICBpZiAoIW9wZW4pIHtcbiAgICAgICAgY2xlYXJUaW1lb3V0SWZTZXQodGltZW91dFJlZik7XG4gICAgICAgIGNsZWFyVGltZW91dElmU2V0KHJlc3RUaW1lb3V0UmVmKTtcbiAgICAgICAgYmxvY2tNb3VzZU1vdmVSZWYuY3VycmVudCA9IHRydWU7XG4gICAgICAgIHJlc3RUaW1lb3V0UGVuZGluZ1JlZi5jdXJyZW50ID0gZmFsc2U7XG4gICAgICB9XG4gICAgfVxuICAgIGV2ZW50cy5vbignb3BlbmNoYW5nZScsIG9uT3BlbkNoYW5nZSk7XG4gICAgcmV0dXJuICgpID0+IHtcbiAgICAgIGV2ZW50cy5vZmYoJ29wZW5jaGFuZ2UnLCBvbk9wZW5DaGFuZ2UpO1xuICAgIH07XG4gIH0sIFtlbmFibGVkLCBldmVudHNdKTtcbiAgUmVhY3QudXNlRWZmZWN0KCgpID0+IHtcbiAgICBpZiAoIWVuYWJsZWQpIHJldHVybjtcbiAgICBpZiAoIWhhbmRsZUNsb3NlUmVmLmN1cnJlbnQpIHJldHVybjtcbiAgICBpZiAoIW9wZW4pIHJldHVybjtcbiAgICBmdW5jdGlvbiBvbkxlYXZlKGV2ZW50KSB7XG4gICAgICBpZiAoaXNIb3Zlck9wZW4oKSkge1xuICAgICAgICBvbk9wZW5DaGFuZ2UoZmFsc2UsIGV2ZW50LCAnaG92ZXInKTtcbiAgICAgIH1cbiAgICB9XG4gICAgY29uc3QgaHRtbCA9IGdldERvY3VtZW50JDEoZWxlbWVudHMuZmxvYXRpbmcpLmRvY3VtZW50RWxlbWVudDtcbiAgICBodG1sLmFkZEV2ZW50TGlzdGVuZXIoJ21vdXNlbGVhdmUnLCBvbkxlYXZlKTtcbiAgICByZXR1cm4gKCkgPT4ge1xuICAgICAgaHRtbC5yZW1vdmVFdmVudExpc3RlbmVyKCdtb3VzZWxlYXZlJywgb25MZWF2ZSk7XG4gICAgfTtcbiAgfSwgW2VsZW1lbnRzLmZsb2F0aW5nLCBvcGVuLCBvbk9wZW5DaGFuZ2UsIGVuYWJsZWQsIGhhbmRsZUNsb3NlUmVmLCBpc0hvdmVyT3Blbl0pO1xuICBjb25zdCBjbG9zZVdpdGhEZWxheSA9IFJlYWN0LnVzZUNhbGxiYWNrKGZ1bmN0aW9uIChldmVudCwgcnVuRWxzZUJyYW5jaCwgcmVhc29uKSB7XG4gICAgaWYgKHJ1bkVsc2VCcmFuY2ggPT09IHZvaWQgMCkge1xuICAgICAgcnVuRWxzZUJyYW5jaCA9IHRydWU7XG4gICAgfVxuICAgIGlmIChyZWFzb24gPT09IHZvaWQgMCkge1xuICAgICAgcmVhc29uID0gJ2hvdmVyJztcbiAgICB9XG4gICAgY29uc3QgY2xvc2VEZWxheSA9IGdldERlbGF5KGRlbGF5UmVmLmN1cnJlbnQsICdjbG9zZScsIHBvaW50ZXJUeXBlUmVmLmN1cnJlbnQpO1xuICAgIGlmIChjbG9zZURlbGF5ICYmICFoYW5kbGVyUmVmLmN1cnJlbnQpIHtcbiAgICAgIGNsZWFyVGltZW91dElmU2V0KHRpbWVvdXRSZWYpO1xuICAgICAgdGltZW91dFJlZi5jdXJyZW50ID0gd2luZG93LnNldFRpbWVvdXQoKCkgPT4gb25PcGVuQ2hhbmdlKGZhbHNlLCBldmVudCwgcmVhc29uKSwgY2xvc2VEZWxheSk7XG4gICAgfSBlbHNlIGlmIChydW5FbHNlQnJhbmNoKSB7XG4gICAgICBjbGVhclRpbWVvdXRJZlNldCh0aW1lb3V0UmVmKTtcbiAgICAgIG9uT3BlbkNoYW5nZShmYWxzZSwgZXZlbnQsIHJlYXNvbik7XG4gICAgfVxuICB9LCBbZGVsYXlSZWYsIG9uT3BlbkNoYW5nZV0pO1xuICBjb25zdCBjbGVhbnVwTW91c2VNb3ZlSGFuZGxlciA9IHVzZUVmZmVjdEV2ZW50KCgpID0+IHtcbiAgICB1bmJpbmRNb3VzZU1vdmVSZWYuY3VycmVudCgpO1xuICAgIGhhbmRsZXJSZWYuY3VycmVudCA9IHVuZGVmaW5lZDtcbiAgfSk7XG4gIGNvbnN0IGNsZWFyUG9pbnRlckV2ZW50cyA9IHVzZUVmZmVjdEV2ZW50KCgpID0+IHtcbiAgICBpZiAocGVyZm9ybWVkUG9pbnRlckV2ZW50c011dGF0aW9uUmVmLmN1cnJlbnQpIHtcbiAgICAgIGNvbnN0IGJvZHkgPSBnZXREb2N1bWVudCQxKGVsZW1lbnRzLmZsb2F0aW5nKS5ib2R5O1xuICAgICAgYm9keS5zdHlsZS5wb2ludGVyRXZlbnRzID0gJyc7XG4gICAgICBib2R5LnJlbW92ZUF0dHJpYnV0ZShzYWZlUG9seWdvbklkZW50aWZpZXIpO1xuICAgICAgcGVyZm9ybWVkUG9pbnRlckV2ZW50c011dGF0aW9uUmVmLmN1cnJlbnQgPSBmYWxzZTtcbiAgICB9XG4gIH0pO1xuICBjb25zdCBpc0NsaWNrTGlrZU9wZW5FdmVudCA9IHVzZUVmZmVjdEV2ZW50KCgpID0+IHtcbiAgICByZXR1cm4gZGF0YVJlZi5jdXJyZW50Lm9wZW5FdmVudCA/IFsnY2xpY2snLCAnbW91c2Vkb3duJ10uaW5jbHVkZXMoZGF0YVJlZi5jdXJyZW50Lm9wZW5FdmVudC50eXBlKSA6IGZhbHNlO1xuICB9KTtcblxuICAvLyBSZWdpc3RlcmluZyB0aGUgbW91c2UgZXZlbnRzIG9uIHRoZSByZWZlcmVuY2UgZGlyZWN0bHkgdG8gYnlwYXNzIFJlYWN0J3NcbiAgLy8gZGVsZWdhdGlvbiBzeXN0ZW0uIElmIHRoZSBjdXJzb3Igd2FzIG9uIGEgZGlzYWJsZWQgZWxlbWVudCBhbmQgdGhlbiBlbnRlcmVkXG4gIC8vIHRoZSByZWZlcmVuY2UgKG5vIGdhcCksIGBtb3VzZWVudGVyYCBkb2Vzbid0IGZpcmUgaW4gdGhlIGRlbGVnYXRpb24gc3lzdGVtLlxuICBSZWFjdC51c2VFZmZlY3QoKCkgPT4ge1xuICAgIGlmICghZW5hYmxlZCkgcmV0dXJuO1xuICAgIGZ1bmN0aW9uIG9uUmVmZXJlbmNlTW91c2VFbnRlcihldmVudCkge1xuICAgICAgY2xlYXJUaW1lb3V0SWZTZXQodGltZW91dFJlZik7XG4gICAgICBibG9ja01vdXNlTW92ZVJlZi5jdXJyZW50ID0gZmFsc2U7XG4gICAgICBpZiAobW91c2VPbmx5ICYmICFpc01vdXNlTGlrZVBvaW50ZXJUeXBlKHBvaW50ZXJUeXBlUmVmLmN1cnJlbnQpIHx8IGdldFJlc3RNcyhyZXN0TXNSZWYuY3VycmVudCkgPiAwICYmICFnZXREZWxheShkZWxheVJlZi5jdXJyZW50LCAnb3BlbicpKSB7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cbiAgICAgIGNvbnN0IG9wZW5EZWxheSA9IGdldERlbGF5KGRlbGF5UmVmLmN1cnJlbnQsICdvcGVuJywgcG9pbnRlclR5cGVSZWYuY3VycmVudCk7XG4gICAgICBpZiAob3BlbkRlbGF5KSB7XG4gICAgICAgIHRpbWVvdXRSZWYuY3VycmVudCA9IHdpbmRvdy5zZXRUaW1lb3V0KCgpID0+IHtcbiAgICAgICAgICBpZiAoIW9wZW5SZWYuY3VycmVudCkge1xuICAgICAgICAgICAgb25PcGVuQ2hhbmdlKHRydWUsIGV2ZW50LCAnaG92ZXInKTtcbiAgICAgICAgICB9XG4gICAgICAgIH0sIG9wZW5EZWxheSk7XG4gICAgICB9IGVsc2UgaWYgKCFvcGVuKSB7XG4gICAgICAgIG9uT3BlbkNoYW5nZSh0cnVlLCBldmVudCwgJ2hvdmVyJyk7XG4gICAgICB9XG4gICAgfVxuICAgIGZ1bmN0aW9uIG9uUmVmZXJlbmNlTW91c2VMZWF2ZShldmVudCkge1xuICAgICAgaWYgKGlzQ2xpY2tMaWtlT3BlbkV2ZW50KCkpIHtcbiAgICAgICAgY2xlYXJQb2ludGVyRXZlbnRzKCk7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cbiAgICAgIHVuYmluZE1vdXNlTW92ZVJlZi5jdXJyZW50KCk7XG4gICAgICBjb25zdCBkb2MgPSBnZXREb2N1bWVudCQxKGVsZW1lbnRzLmZsb2F0aW5nKTtcbiAgICAgIGNsZWFyVGltZW91dElmU2V0KHJlc3RUaW1lb3V0UmVmKTtcbiAgICAgIHJlc3RUaW1lb3V0UGVuZGluZ1JlZi5jdXJyZW50ID0gZmFsc2U7XG4gICAgICBpZiAoaGFuZGxlQ2xvc2VSZWYuY3VycmVudCAmJiBkYXRhUmVmLmN1cnJlbnQuZmxvYXRpbmdDb250ZXh0KSB7XG4gICAgICAgIC8vIFByZXZlbnQgY2xlYXJpbmcgYG9uU2Nyb2xsTW91c2VMZWF2ZWAgdGltZW91dC5cbiAgICAgICAgaWYgKCFvcGVuKSB7XG4gICAgICAgICAgY2xlYXJUaW1lb3V0SWZTZXQodGltZW91dFJlZik7XG4gICAgICAgIH1cbiAgICAgICAgaGFuZGxlclJlZi5jdXJyZW50ID0gaGFuZGxlQ2xvc2VSZWYuY3VycmVudCh7XG4gICAgICAgICAgLi4uZGF0YVJlZi5jdXJyZW50LmZsb2F0aW5nQ29udGV4dCxcbiAgICAgICAgICB0cmVlLFxuICAgICAgICAgIHg6IGV2ZW50LmNsaWVudFgsXG4gICAgICAgICAgeTogZXZlbnQuY2xpZW50WSxcbiAgICAgICAgICBvbkNsb3NlKCkge1xuICAgICAgICAgICAgY2xlYXJQb2ludGVyRXZlbnRzKCk7XG4gICAgICAgICAgICBjbGVhbnVwTW91c2VNb3ZlSGFuZGxlcigpO1xuICAgICAgICAgICAgaWYgKCFpc0NsaWNrTGlrZU9wZW5FdmVudCgpKSB7XG4gICAgICAgICAgICAgIGNsb3NlV2l0aERlbGF5KGV2ZW50LCB0cnVlLCAnc2FmZS1wb2x5Z29uJyk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICAgICAgY29uc3QgaGFuZGxlciA9IGhhbmRsZXJSZWYuY3VycmVudDtcbiAgICAgICAgZG9jLmFkZEV2ZW50TGlzdGVuZXIoJ21vdXNlbW92ZScsIGhhbmRsZXIpO1xuICAgICAgICB1bmJpbmRNb3VzZU1vdmVSZWYuY3VycmVudCA9ICgpID0+IHtcbiAgICAgICAgICBkb2MucmVtb3ZlRXZlbnRMaXN0ZW5lcignbW91c2Vtb3ZlJywgaGFuZGxlcik7XG4gICAgICAgIH07XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cblxuICAgICAgLy8gQWxsb3cgaW50ZXJhY3Rpdml0eSB3aXRob3V0IGBzYWZlUG9seWdvbmAgb24gdG91Y2ggZGV2aWNlcy4gV2l0aCBhXG4gICAgICAvLyBwb2ludGVyLCBhIHNob3J0IGNsb3NlIGRlbGF5IGlzIGFuIGFsdGVybmF0aXZlLCBzbyBpdCBzaG91bGQgd29ya1xuICAgICAgLy8gY29uc2lzdGVudGx5LlxuICAgICAgY29uc3Qgc2hvdWxkQ2xvc2UgPSBwb2ludGVyVHlwZVJlZi5jdXJyZW50ID09PSAndG91Y2gnID8gIWNvbnRhaW5zJDEoZWxlbWVudHMuZmxvYXRpbmcsIGV2ZW50LnJlbGF0ZWRUYXJnZXQpIDogdHJ1ZTtcbiAgICAgIGlmIChzaG91bGRDbG9zZSkge1xuICAgICAgICBjbG9zZVdpdGhEZWxheShldmVudCk7XG4gICAgICB9XG4gICAgfVxuXG4gICAgLy8gRW5zdXJlIHRoZSBmbG9hdGluZyBlbGVtZW50IGNsb3NlcyBhZnRlciBzY3JvbGxpbmcgZXZlbiBpZiB0aGUgcG9pbnRlclxuICAgIC8vIGRpZCBub3QgbW92ZS5cbiAgICAvLyBodHRwczovL2dpdGh1Yi5jb20vZmxvYXRpbmctdWkvZmxvYXRpbmctdWkvZGlzY3Vzc2lvbnMvMTY5MlxuICAgIGZ1bmN0aW9uIG9uU2Nyb2xsTW91c2VMZWF2ZShldmVudCkge1xuICAgICAgaWYgKGlzQ2xpY2tMaWtlT3BlbkV2ZW50KCkpIHJldHVybjtcbiAgICAgIGlmICghZGF0YVJlZi5jdXJyZW50LmZsb2F0aW5nQ29udGV4dCkgcmV0dXJuO1xuICAgICAgaGFuZGxlQ2xvc2VSZWYuY3VycmVudCA9PSBudWxsIHx8IGhhbmRsZUNsb3NlUmVmLmN1cnJlbnQoe1xuICAgICAgICAuLi5kYXRhUmVmLmN1cnJlbnQuZmxvYXRpbmdDb250ZXh0LFxuICAgICAgICB0cmVlLFxuICAgICAgICB4OiBldmVudC5jbGllbnRYLFxuICAgICAgICB5OiBldmVudC5jbGllbnRZLFxuICAgICAgICBvbkNsb3NlKCkge1xuICAgICAgICAgIGNsZWFyUG9pbnRlckV2ZW50cygpO1xuICAgICAgICAgIGNsZWFudXBNb3VzZU1vdmVIYW5kbGVyKCk7XG4gICAgICAgICAgaWYgKCFpc0NsaWNrTGlrZU9wZW5FdmVudCgpKSB7XG4gICAgICAgICAgICBjbG9zZVdpdGhEZWxheShldmVudCk7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9KShldmVudCk7XG4gICAgfVxuICAgIGZ1bmN0aW9uIG9uRmxvYXRpbmdNb3VzZUVudGVyKCkge1xuICAgICAgY2xlYXJUaW1lb3V0SWZTZXQodGltZW91dFJlZik7XG4gICAgfVxuICAgIGZ1bmN0aW9uIG9uRmxvYXRpbmdNb3VzZUxlYXZlKGV2ZW50KSB7XG4gICAgICBpZiAoIWlzQ2xpY2tMaWtlT3BlbkV2ZW50KCkpIHtcbiAgICAgICAgY2xvc2VXaXRoRGVsYXkoZXZlbnQsIGZhbHNlKTtcbiAgICAgIH1cbiAgICB9XG4gICAgaWYgKGlzRWxlbWVudChlbGVtZW50cy5kb21SZWZlcmVuY2UpKSB7XG4gICAgICBjb25zdCByZWZlcmVuY2UgPSBlbGVtZW50cy5kb21SZWZlcmVuY2U7XG4gICAgICBjb25zdCBmbG9hdGluZyA9IGVsZW1lbnRzLmZsb2F0aW5nO1xuICAgICAgaWYgKG9wZW4pIHtcbiAgICAgICAgcmVmZXJlbmNlLmFkZEV2ZW50TGlzdGVuZXIoJ21vdXNlbGVhdmUnLCBvblNjcm9sbE1vdXNlTGVhdmUpO1xuICAgICAgfVxuICAgICAgaWYgKG1vdmUpIHtcbiAgICAgICAgcmVmZXJlbmNlLmFkZEV2ZW50TGlzdGVuZXIoJ21vdXNlbW92ZScsIG9uUmVmZXJlbmNlTW91c2VFbnRlciwge1xuICAgICAgICAgIG9uY2U6IHRydWVcbiAgICAgICAgfSk7XG4gICAgICB9XG4gICAgICByZWZlcmVuY2UuYWRkRXZlbnRMaXN0ZW5lcignbW91c2VlbnRlcicsIG9uUmVmZXJlbmNlTW91c2VFbnRlcik7XG4gICAgICByZWZlcmVuY2UuYWRkRXZlbnRMaXN0ZW5lcignbW91c2VsZWF2ZScsIG9uUmVmZXJlbmNlTW91c2VMZWF2ZSk7XG4gICAgICBpZiAoZmxvYXRpbmcpIHtcbiAgICAgICAgZmxvYXRpbmcuYWRkRXZlbnRMaXN0ZW5lcignbW91c2VsZWF2ZScsIG9uU2Nyb2xsTW91c2VMZWF2ZSk7XG4gICAgICAgIGZsb2F0aW5nLmFkZEV2ZW50TGlzdGVuZXIoJ21vdXNlZW50ZXInLCBvbkZsb2F0aW5nTW91c2VFbnRlcik7XG4gICAgICAgIGZsb2F0aW5nLmFkZEV2ZW50TGlzdGVuZXIoJ21vdXNlbGVhdmUnLCBvbkZsb2F0aW5nTW91c2VMZWF2ZSk7XG4gICAgICB9XG4gICAgICByZXR1cm4gKCkgPT4ge1xuICAgICAgICBpZiAob3Blbikge1xuICAgICAgICAgIHJlZmVyZW5jZS5yZW1vdmVFdmVudExpc3RlbmVyKCdtb3VzZWxlYXZlJywgb25TY3JvbGxNb3VzZUxlYXZlKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAobW92ZSkge1xuICAgICAgICAgIHJlZmVyZW5jZS5yZW1vdmVFdmVudExpc3RlbmVyKCdtb3VzZW1vdmUnLCBvblJlZmVyZW5jZU1vdXNlRW50ZXIpO1xuICAgICAgICB9XG4gICAgICAgIHJlZmVyZW5jZS5yZW1vdmVFdmVudExpc3RlbmVyKCdtb3VzZWVudGVyJywgb25SZWZlcmVuY2VNb3VzZUVudGVyKTtcbiAgICAgICAgcmVmZXJlbmNlLnJlbW92ZUV2ZW50TGlzdGVuZXIoJ21vdXNlbGVhdmUnLCBvblJlZmVyZW5jZU1vdXNlTGVhdmUpO1xuICAgICAgICBpZiAoZmxvYXRpbmcpIHtcbiAgICAgICAgICBmbG9hdGluZy5yZW1vdmVFdmVudExpc3RlbmVyKCdtb3VzZWxlYXZlJywgb25TY3JvbGxNb3VzZUxlYXZlKTtcbiAgICAgICAgICBmbG9hdGluZy5yZW1vdmVFdmVudExpc3RlbmVyKCdtb3VzZWVudGVyJywgb25GbG9hdGluZ01vdXNlRW50ZXIpO1xuICAgICAgICAgIGZsb2F0aW5nLnJlbW92ZUV2ZW50TGlzdGVuZXIoJ21vdXNlbGVhdmUnLCBvbkZsb2F0aW5nTW91c2VMZWF2ZSk7XG4gICAgICAgIH1cbiAgICAgIH07XG4gICAgfVxuICB9LCBbZWxlbWVudHMsIGVuYWJsZWQsIGNvbnRleHQsIG1vdXNlT25seSwgbW92ZSwgY2xvc2VXaXRoRGVsYXksIGNsZWFudXBNb3VzZU1vdmVIYW5kbGVyLCBjbGVhclBvaW50ZXJFdmVudHMsIG9uT3BlbkNoYW5nZSwgb3Blbiwgb3BlblJlZiwgdHJlZSwgZGVsYXlSZWYsIGhhbmRsZUNsb3NlUmVmLCBkYXRhUmVmLCBpc0NsaWNrTGlrZU9wZW5FdmVudCwgcmVzdE1zUmVmXSk7XG5cbiAgLy8gQmxvY2sgcG9pbnRlci1ldmVudHMgb2YgZXZlcnkgZWxlbWVudCBvdGhlciB0aGFuIHRoZSByZWZlcmVuY2UgYW5kIGZsb2F0aW5nXG4gIC8vIHdoaWxlIHRoZSBmbG9hdGluZyBlbGVtZW50IGlzIG9wZW4gYW5kIGhhcyBhIGBoYW5kbGVDbG9zZWAgaGFuZGxlci4gQWxzb1xuICAvLyBoYW5kbGVzIG5lc3RlZCBmbG9hdGluZyBlbGVtZW50cy5cbiAgLy8gaHR0cHM6Ly9naXRodWIuY29tL2Zsb2F0aW5nLXVpL2Zsb2F0aW5nLXVpL2lzc3Vlcy8xNzIyXG4gIHVzZU1vZGVybkxheW91dEVmZmVjdCgoKSA9PiB7XG4gICAgdmFyIF9oYW5kbGVDbG9zZVJlZiRjdXJyZTtcbiAgICBpZiAoIWVuYWJsZWQpIHJldHVybjtcbiAgICBpZiAob3BlbiAmJiAoX2hhbmRsZUNsb3NlUmVmJGN1cnJlID0gaGFuZGxlQ2xvc2VSZWYuY3VycmVudCkgIT0gbnVsbCAmJiAoX2hhbmRsZUNsb3NlUmVmJGN1cnJlID0gX2hhbmRsZUNsb3NlUmVmJGN1cnJlLl9fb3B0aW9ucykgIT0gbnVsbCAmJiBfaGFuZGxlQ2xvc2VSZWYkY3VycmUuYmxvY2tQb2ludGVyRXZlbnRzICYmIGlzSG92ZXJPcGVuKCkpIHtcbiAgICAgIHBlcmZvcm1lZFBvaW50ZXJFdmVudHNNdXRhdGlvblJlZi5jdXJyZW50ID0gdHJ1ZTtcbiAgICAgIGNvbnN0IGZsb2F0aW5nRWwgPSBlbGVtZW50cy5mbG9hdGluZztcbiAgICAgIGlmIChpc0VsZW1lbnQoZWxlbWVudHMuZG9tUmVmZXJlbmNlKSAmJiBmbG9hdGluZ0VsKSB7XG4gICAgICAgIHZhciBfdHJlZSRub2Rlc1JlZiRjdXJyZW47XG4gICAgICAgIGNvbnN0IGJvZHkgPSBnZXREb2N1bWVudCQxKGVsZW1lbnRzLmZsb2F0aW5nKS5ib2R5O1xuICAgICAgICBib2R5LnNldEF0dHJpYnV0ZShzYWZlUG9seWdvbklkZW50aWZpZXIsICcnKTtcbiAgICAgICAgY29uc3QgcmVmID0gZWxlbWVudHMuZG9tUmVmZXJlbmNlO1xuICAgICAgICBjb25zdCBwYXJlbnRGbG9hdGluZyA9IHRyZWUgPT0gbnVsbCB8fCAoX3RyZWUkbm9kZXNSZWYkY3VycmVuID0gdHJlZS5ub2Rlc1JlZi5jdXJyZW50LmZpbmQobm9kZSA9PiBub2RlLmlkID09PSBwYXJlbnRJZCkpID09IG51bGwgfHwgKF90cmVlJG5vZGVzUmVmJGN1cnJlbiA9IF90cmVlJG5vZGVzUmVmJGN1cnJlbi5jb250ZXh0KSA9PSBudWxsID8gdm9pZCAwIDogX3RyZWUkbm9kZXNSZWYkY3VycmVuLmVsZW1lbnRzLmZsb2F0aW5nO1xuICAgICAgICBpZiAocGFyZW50RmxvYXRpbmcpIHtcbiAgICAgICAgICBwYXJlbnRGbG9hdGluZy5zdHlsZS5wb2ludGVyRXZlbnRzID0gJyc7XG4gICAgICAgIH1cbiAgICAgICAgYm9keS5zdHlsZS5wb2ludGVyRXZlbnRzID0gJ25vbmUnO1xuICAgICAgICByZWYuc3R5bGUucG9pbnRlckV2ZW50cyA9ICdhdXRvJztcbiAgICAgICAgZmxvYXRpbmdFbC5zdHlsZS5wb2ludGVyRXZlbnRzID0gJ2F1dG8nO1xuICAgICAgICByZXR1cm4gKCkgPT4ge1xuICAgICAgICAgIGJvZHkuc3R5bGUucG9pbnRlckV2ZW50cyA9ICcnO1xuICAgICAgICAgIHJlZi5zdHlsZS5wb2ludGVyRXZlbnRzID0gJyc7XG4gICAgICAgICAgZmxvYXRpbmdFbC5zdHlsZS5wb2ludGVyRXZlbnRzID0gJyc7XG4gICAgICAgIH07XG4gICAgICB9XG4gICAgfVxuICB9LCBbZW5hYmxlZCwgb3BlbiwgcGFyZW50SWQsIGVsZW1lbnRzLCB0cmVlLCBoYW5kbGVDbG9zZVJlZiwgaXNIb3Zlck9wZW5dKTtcbiAgdXNlTW9kZXJuTGF5b3V0RWZmZWN0KCgpID0+IHtcbiAgICBpZiAoIW9wZW4pIHtcbiAgICAgIHBvaW50ZXJUeXBlUmVmLmN1cnJlbnQgPSB1bmRlZmluZWQ7XG4gICAgICByZXN0VGltZW91dFBlbmRpbmdSZWYuY3VycmVudCA9IGZhbHNlO1xuICAgICAgY2xlYW51cE1vdXNlTW92ZUhhbmRsZXIoKTtcbiAgICAgIGNsZWFyUG9pbnRlckV2ZW50cygpO1xuICAgIH1cbiAgfSwgW29wZW4sIGNsZWFudXBNb3VzZU1vdmVIYW5kbGVyLCBjbGVhclBvaW50ZXJFdmVudHNdKTtcbiAgUmVhY3QudXNlRWZmZWN0KCgpID0+IHtcbiAgICByZXR1cm4gKCkgPT4ge1xuICAgICAgY2xlYW51cE1vdXNlTW92ZUhhbmRsZXIoKTtcbiAgICAgIGNsZWFyVGltZW91dElmU2V0KHRpbWVvdXRSZWYpO1xuICAgICAgY2xlYXJUaW1lb3V0SWZTZXQocmVzdFRpbWVvdXRSZWYpO1xuICAgICAgY2xlYXJQb2ludGVyRXZlbnRzKCk7XG4gICAgfTtcbiAgfSwgW2VuYWJsZWQsIGVsZW1lbnRzLmRvbVJlZmVyZW5jZSwgY2xlYW51cE1vdXNlTW92ZUhhbmRsZXIsIGNsZWFyUG9pbnRlckV2ZW50c10pO1xuICBjb25zdCByZWZlcmVuY2UgPSBSZWFjdC51c2VNZW1vKCgpID0+IHtcbiAgICBmdW5jdGlvbiBzZXRQb2ludGVyUmVmKGV2ZW50KSB7XG4gICAgICBwb2ludGVyVHlwZVJlZi5jdXJyZW50ID0gZXZlbnQucG9pbnRlclR5cGU7XG4gICAgfVxuICAgIHJldHVybiB7XG4gICAgICBvblBvaW50ZXJEb3duOiBzZXRQb2ludGVyUmVmLFxuICAgICAgb25Qb2ludGVyRW50ZXI6IHNldFBvaW50ZXJSZWYsXG4gICAgICBvbk1vdXNlTW92ZShldmVudCkge1xuICAgICAgICBjb25zdCB7XG4gICAgICAgICAgbmF0aXZlRXZlbnRcbiAgICAgICAgfSA9IGV2ZW50O1xuICAgICAgICBmdW5jdGlvbiBoYW5kbGVNb3VzZU1vdmUoKSB7XG4gICAgICAgICAgaWYgKCFibG9ja01vdXNlTW92ZVJlZi5jdXJyZW50ICYmICFvcGVuUmVmLmN1cnJlbnQpIHtcbiAgICAgICAgICAgIG9uT3BlbkNoYW5nZSh0cnVlLCBuYXRpdmVFdmVudCwgJ2hvdmVyJyk7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGlmIChtb3VzZU9ubHkgJiYgIWlzTW91c2VMaWtlUG9pbnRlclR5cGUocG9pbnRlclR5cGVSZWYuY3VycmVudCkpIHtcbiAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgaWYgKG9wZW4gfHwgZ2V0UmVzdE1zKHJlc3RNc1JlZi5jdXJyZW50KSA9PT0gMCkge1xuICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuXG4gICAgICAgIC8vIElnbm9yZSBpbnNpZ25pZmljYW50IG1vdmVtZW50cyB0byBhY2NvdW50IGZvciB0cmVtb3JzLlxuICAgICAgICBpZiAocmVzdFRpbWVvdXRQZW5kaW5nUmVmLmN1cnJlbnQgJiYgZXZlbnQubW92ZW1lbnRYICoqIDIgKyBldmVudC5tb3ZlbWVudFkgKiogMiA8IDIpIHtcbiAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgY2xlYXJUaW1lb3V0SWZTZXQocmVzdFRpbWVvdXRSZWYpO1xuICAgICAgICBpZiAocG9pbnRlclR5cGVSZWYuY3VycmVudCA9PT0gJ3RvdWNoJykge1xuICAgICAgICAgIGhhbmRsZU1vdXNlTW92ZSgpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHJlc3RUaW1lb3V0UGVuZGluZ1JlZi5jdXJyZW50ID0gdHJ1ZTtcbiAgICAgICAgICByZXN0VGltZW91dFJlZi5jdXJyZW50ID0gd2luZG93LnNldFRpbWVvdXQoaGFuZGxlTW91c2VNb3ZlLCBnZXRSZXN0TXMocmVzdE1zUmVmLmN1cnJlbnQpKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH07XG4gIH0sIFttb3VzZU9ubHksIG9uT3BlbkNoYW5nZSwgb3Blbiwgb3BlblJlZiwgcmVzdE1zUmVmXSk7XG4gIHJldHVybiBSZWFjdC51c2VNZW1vKCgpID0+IGVuYWJsZWQgPyB7XG4gICAgcmVmZXJlbmNlXG4gIH0gOiB7fSwgW2VuYWJsZWQsIHJlZmVyZW5jZV0pO1xufVxuXG5jb25zdCBOT09QID0gKCkgPT4ge307XG5jb25zdCBGbG9hdGluZ0RlbGF5R3JvdXBDb250ZXh0ID0gLyojX19QVVJFX18qL1JlYWN0LmNyZWF0ZUNvbnRleHQoe1xuICBkZWxheTogMCxcbiAgaW5pdGlhbERlbGF5OiAwLFxuICB0aW1lb3V0TXM6IDAsXG4gIGN1cnJlbnRJZDogbnVsbCxcbiAgc2V0Q3VycmVudElkOiBOT09QLFxuICBzZXRTdGF0ZTogTk9PUCxcbiAgaXNJbnN0YW50UGhhc2U6IGZhbHNlXG59KTtcblxuLyoqXG4gKiBAZGVwcmVjYXRlZFxuICogVXNlIHRoZSByZXR1cm4gdmFsdWUgb2YgYHVzZURlbGF5R3JvdXAoKWAgaW5zdGVhZC5cbiAqL1xuY29uc3QgdXNlRGVsYXlHcm91cENvbnRleHQgPSAoKSA9PiBSZWFjdC51c2VDb250ZXh0KEZsb2F0aW5nRGVsYXlHcm91cENvbnRleHQpO1xuLyoqXG4gKiBQcm92aWRlcyBjb250ZXh0IGZvciBhIGdyb3VwIG9mIGZsb2F0aW5nIGVsZW1lbnRzIHRoYXQgc2hvdWxkIHNoYXJlIGFcbiAqIGBkZWxheWAuXG4gKiBAc2VlIGh0dHBzOi8vZmxvYXRpbmctdWkuY29tL2RvY3MvRmxvYXRpbmdEZWxheUdyb3VwXG4gKi9cbmZ1bmN0aW9uIEZsb2F0aW5nRGVsYXlHcm91cChwcm9wcykge1xuICBjb25zdCB7XG4gICAgY2hpbGRyZW4sXG4gICAgZGVsYXksXG4gICAgdGltZW91dE1zID0gMFxuICB9ID0gcHJvcHM7XG4gIGNvbnN0IFtzdGF0ZSwgc2V0U3RhdGVdID0gUmVhY3QudXNlUmVkdWNlcigocHJldiwgbmV4dCkgPT4gKHtcbiAgICAuLi5wcmV2LFxuICAgIC4uLm5leHRcbiAgfSksIHtcbiAgICBkZWxheSxcbiAgICB0aW1lb3V0TXMsXG4gICAgaW5pdGlhbERlbGF5OiBkZWxheSxcbiAgICBjdXJyZW50SWQ6IG51bGwsXG4gICAgaXNJbnN0YW50UGhhc2U6IGZhbHNlXG4gIH0pO1xuICBjb25zdCBpbml0aWFsQ3VycmVudElkUmVmID0gUmVhY3QudXNlUmVmKG51bGwpO1xuICBjb25zdCBzZXRDdXJyZW50SWQgPSBSZWFjdC51c2VDYWxsYmFjayhjdXJyZW50SWQgPT4ge1xuICAgIHNldFN0YXRlKHtcbiAgICAgIGN1cnJlbnRJZFxuICAgIH0pO1xuICB9LCBbXSk7XG4gIHVzZU1vZGVybkxheW91dEVmZmVjdCgoKSA9PiB7XG4gICAgaWYgKHN0YXRlLmN1cnJlbnRJZCkge1xuICAgICAgaWYgKGluaXRpYWxDdXJyZW50SWRSZWYuY3VycmVudCA9PT0gbnVsbCkge1xuICAgICAgICBpbml0aWFsQ3VycmVudElkUmVmLmN1cnJlbnQgPSBzdGF0ZS5jdXJyZW50SWQ7XG4gICAgICB9IGVsc2UgaWYgKCFzdGF0ZS5pc0luc3RhbnRQaGFzZSkge1xuICAgICAgICBzZXRTdGF0ZSh7XG4gICAgICAgICAgaXNJbnN0YW50UGhhc2U6IHRydWVcbiAgICAgICAgfSk7XG4gICAgICB9XG4gICAgfSBlbHNlIHtcbiAgICAgIGlmIChzdGF0ZS5pc0luc3RhbnRQaGFzZSkge1xuICAgICAgICBzZXRTdGF0ZSh7XG4gICAgICAgICAgaXNJbnN0YW50UGhhc2U6IGZhbHNlXG4gICAgICAgIH0pO1xuICAgICAgfVxuICAgICAgaW5pdGlhbEN1cnJlbnRJZFJlZi5jdXJyZW50ID0gbnVsbDtcbiAgICB9XG4gIH0sIFtzdGF0ZS5jdXJyZW50SWQsIHN0YXRlLmlzSW5zdGFudFBoYXNlXSk7XG4gIHJldHVybiAvKiNfX1BVUkVfXyovanN4KEZsb2F0aW5nRGVsYXlHcm91cENvbnRleHQuUHJvdmlkZXIsIHtcbiAgICB2YWx1ZTogUmVhY3QudXNlTWVtbygoKSA9PiAoe1xuICAgICAgLi4uc3RhdGUsXG4gICAgICBzZXRTdGF0ZSxcbiAgICAgIHNldEN1cnJlbnRJZFxuICAgIH0pLCBbc3RhdGUsIHNldEN1cnJlbnRJZF0pLFxuICAgIGNoaWxkcmVuOiBjaGlsZHJlblxuICB9KTtcbn1cbi8qKlxuICogRW5hYmxlcyBncm91cGluZyB3aGVuIGNhbGxlZCBpbnNpZGUgYSBjb21wb25lbnQgdGhhdCdzIGEgY2hpbGQgb2YgYVxuICogYEZsb2F0aW5nRGVsYXlHcm91cGAuXG4gKiBAc2VlIGh0dHBzOi8vZmxvYXRpbmctdWkuY29tL2RvY3MvRmxvYXRpbmdEZWxheUdyb3VwXG4gKi9cbmZ1bmN0aW9uIHVzZURlbGF5R3JvdXAoY29udGV4dCwgb3B0aW9ucykge1xuICBpZiAob3B0aW9ucyA9PT0gdm9pZCAwKSB7XG4gICAgb3B0aW9ucyA9IHt9O1xuICB9XG4gIGNvbnN0IHtcbiAgICBvcGVuLFxuICAgIG9uT3BlbkNoYW5nZSxcbiAgICBmbG9hdGluZ0lkXG4gIH0gPSBjb250ZXh0O1xuICBjb25zdCB7XG4gICAgaWQ6IG9wdGlvbklkLFxuICAgIGVuYWJsZWQgPSB0cnVlXG4gIH0gPSBvcHRpb25zO1xuICBjb25zdCBpZCA9IG9wdGlvbklkICE9IG51bGwgPyBvcHRpb25JZCA6IGZsb2F0aW5nSWQ7XG4gIGNvbnN0IGdyb3VwQ29udGV4dCA9IHVzZURlbGF5R3JvdXBDb250ZXh0KCk7XG4gIGNvbnN0IHtcbiAgICBjdXJyZW50SWQsXG4gICAgc2V0Q3VycmVudElkLFxuICAgIGluaXRpYWxEZWxheSxcbiAgICBzZXRTdGF0ZSxcbiAgICB0aW1lb3V0TXNcbiAgfSA9IGdyb3VwQ29udGV4dDtcbiAgdXNlTW9kZXJuTGF5b3V0RWZmZWN0KCgpID0+IHtcbiAgICBpZiAoIWVuYWJsZWQpIHJldHVybjtcbiAgICBpZiAoIWN1cnJlbnRJZCkgcmV0dXJuO1xuICAgIHNldFN0YXRlKHtcbiAgICAgIGRlbGF5OiB7XG4gICAgICAgIG9wZW46IDEsXG4gICAgICAgIGNsb3NlOiBnZXREZWxheShpbml0aWFsRGVsYXksICdjbG9zZScpXG4gICAgICB9XG4gICAgfSk7XG4gICAgaWYgKGN1cnJlbnRJZCAhPT0gaWQpIHtcbiAgICAgIG9uT3BlbkNoYW5nZShmYWxzZSk7XG4gICAgfVxuICB9LCBbZW5hYmxlZCwgaWQsIG9uT3BlbkNoYW5nZSwgc2V0U3RhdGUsIGN1cnJlbnRJZCwgaW5pdGlhbERlbGF5XSk7XG4gIHVzZU1vZGVybkxheW91dEVmZmVjdCgoKSA9PiB7XG4gICAgZnVuY3Rpb24gdW5zZXQoKSB7XG4gICAgICBvbk9wZW5DaGFuZ2UoZmFsc2UpO1xuICAgICAgc2V0U3RhdGUoe1xuICAgICAgICBkZWxheTogaW5pdGlhbERlbGF5LFxuICAgICAgICBjdXJyZW50SWQ6IG51bGxcbiAgICAgIH0pO1xuICAgIH1cbiAgICBpZiAoIWVuYWJsZWQpIHJldHVybjtcbiAgICBpZiAoIWN1cnJlbnRJZCkgcmV0dXJuO1xuICAgIGlmICghb3BlbiAmJiBjdXJyZW50SWQgPT09IGlkKSB7XG4gICAgICBpZiAodGltZW91dE1zKSB7XG4gICAgICAgIGNvbnN0IHRpbWVvdXQgPSB3aW5kb3cuc2V0VGltZW91dCh1bnNldCwgdGltZW91dE1zKTtcbiAgICAgICAgcmV0dXJuICgpID0+IHtcbiAgICAgICAgICBjbGVhclRpbWVvdXQodGltZW91dCk7XG4gICAgICAgIH07XG4gICAgICB9XG4gICAgICB1bnNldCgpO1xuICAgIH1cbiAgfSwgW2VuYWJsZWQsIG9wZW4sIHNldFN0YXRlLCBjdXJyZW50SWQsIGlkLCBvbk9wZW5DaGFuZ2UsIGluaXRpYWxEZWxheSwgdGltZW91dE1zXSk7XG4gIHVzZU1vZGVybkxheW91dEVmZmVjdCgoKSA9PiB7XG4gICAgaWYgKCFlbmFibGVkKSByZXR1cm47XG4gICAgaWYgKHNldEN1cnJlbnRJZCA9PT0gTk9PUCB8fCAhb3BlbikgcmV0dXJuO1xuICAgIHNldEN1cnJlbnRJZChpZCk7XG4gIH0sIFtlbmFibGVkLCBvcGVuLCBzZXRDdXJyZW50SWQsIGlkXSk7XG4gIHJldHVybiBncm91cENvbnRleHQ7XG59XG5cbmNvbnN0IE5leHRGbG9hdGluZ0RlbGF5R3JvdXBDb250ZXh0ID0gLyojX19QVVJFX18qL1JlYWN0LmNyZWF0ZUNvbnRleHQoe1xuICBoYXNQcm92aWRlcjogZmFsc2UsXG4gIHRpbWVvdXRNczogMCxcbiAgZGVsYXlSZWY6IHtcbiAgICBjdXJyZW50OiAwXG4gIH0sXG4gIGluaXRpYWxEZWxheVJlZjoge1xuICAgIGN1cnJlbnQ6IDBcbiAgfSxcbiAgdGltZW91dElkUmVmOiB7XG4gICAgY3VycmVudDogLTFcbiAgfSxcbiAgY3VycmVudElkUmVmOiB7XG4gICAgY3VycmVudDogbnVsbFxuICB9LFxuICBjdXJyZW50Q29udGV4dFJlZjoge1xuICAgIGN1cnJlbnQ6IG51bGxcbiAgfVxufSk7XG4vKipcbiAqIEV4cGVyaW1lbnRhbCBuZXh0IHZlcnNpb24gb2YgYEZsb2F0aW5nRGVsYXlHcm91cGAgdG8gYmVjb21lIHRoZSBkZWZhdWx0XG4gKiBpbiB0aGUgZnV0dXJlLiBUaGlzIGNvbXBvbmVudCBpcyBub3QgeWV0IHN0YWJsZS5cbiAqIFByb3ZpZGVzIGNvbnRleHQgZm9yIGEgZ3JvdXAgb2YgZmxvYXRpbmcgZWxlbWVudHMgdGhhdCBzaG91bGQgc2hhcmUgYVxuICogYGRlbGF5YC4gVW5saWtlIGBGbG9hdGluZ0RlbGF5R3JvdXBgLCBgdXNlTmV4dERlbGF5R3JvdXBgIHdpdGggdGhpc1xuICogY29tcG9uZW50IGRvZXMgbm90IGNhdXNlIGEgcmUtcmVuZGVyIG9mIHVucmVsYXRlZCBjb25zdW1lcnMgb2YgdGhlXG4gKiBjb250ZXh0IHdoZW4gdGhlIGRlbGF5IGNoYW5nZXMuXG4gKiBAc2VlIGh0dHBzOi8vZmxvYXRpbmctdWkuY29tL2RvY3MvRmxvYXRpbmdEZWxheUdyb3VwXG4gKi9cbmZ1bmN0aW9uIE5leHRGbG9hdGluZ0RlbGF5R3JvdXAocHJvcHMpIHtcbiAgY29uc3Qge1xuICAgIGNoaWxkcmVuLFxuICAgIGRlbGF5LFxuICAgIHRpbWVvdXRNcyA9IDBcbiAgfSA9IHByb3BzO1xuICBjb25zdCBkZWxheVJlZiA9IFJlYWN0LnVzZVJlZihkZWxheSk7XG4gIGNvbnN0IGluaXRpYWxEZWxheVJlZiA9IFJlYWN0LnVzZVJlZihkZWxheSk7XG4gIGNvbnN0IGN1cnJlbnRJZFJlZiA9IFJlYWN0LnVzZVJlZihudWxsKTtcbiAgY29uc3QgY3VycmVudENvbnRleHRSZWYgPSBSZWFjdC51c2VSZWYobnVsbCk7XG4gIGNvbnN0IHRpbWVvdXRJZFJlZiA9IFJlYWN0LnVzZVJlZigtMSk7XG4gIHJldHVybiAvKiNfX1BVUkVfXyovanN4KE5leHRGbG9hdGluZ0RlbGF5R3JvdXBDb250ZXh0LlByb3ZpZGVyLCB7XG4gICAgdmFsdWU6IFJlYWN0LnVzZU1lbW8oKCkgPT4gKHtcbiAgICAgIGhhc1Byb3ZpZGVyOiB0cnVlLFxuICAgICAgZGVsYXlSZWYsXG4gICAgICBpbml0aWFsRGVsYXlSZWYsXG4gICAgICBjdXJyZW50SWRSZWYsXG4gICAgICB0aW1lb3V0TXMsXG4gICAgICBjdXJyZW50Q29udGV4dFJlZixcbiAgICAgIHRpbWVvdXRJZFJlZlxuICAgIH0pLCBbdGltZW91dE1zXSksXG4gICAgY2hpbGRyZW46IGNoaWxkcmVuXG4gIH0pO1xufVxuLyoqXG4gKiBFbmFibGVzIGdyb3VwaW5nIHdoZW4gY2FsbGVkIGluc2lkZSBhIGNvbXBvbmVudCB0aGF0J3MgYSBjaGlsZCBvZiBhXG4gKiBgTmV4dEZsb2F0aW5nRGVsYXlHcm91cGAuXG4gKiBAc2VlIGh0dHBzOi8vZmxvYXRpbmctdWkuY29tL2RvY3MvRmxvYXRpbmdEZWxheUdyb3VwXG4gKi9cbmZ1bmN0aW9uIHVzZU5leHREZWxheUdyb3VwKGNvbnRleHQsIG9wdGlvbnMpIHtcbiAgaWYgKG9wdGlvbnMgPT09IHZvaWQgMCkge1xuICAgIG9wdGlvbnMgPSB7fTtcbiAgfVxuICBjb25zdCB7XG4gICAgb3BlbixcbiAgICBvbk9wZW5DaGFuZ2UsXG4gICAgZmxvYXRpbmdJZFxuICB9ID0gY29udGV4dDtcbiAgY29uc3Qge1xuICAgIGVuYWJsZWQgPSB0cnVlXG4gIH0gPSBvcHRpb25zO1xuICBjb25zdCBncm91cENvbnRleHQgPSBSZWFjdC51c2VDb250ZXh0KE5leHRGbG9hdGluZ0RlbGF5R3JvdXBDb250ZXh0KTtcbiAgY29uc3Qge1xuICAgIGN1cnJlbnRJZFJlZixcbiAgICBkZWxheVJlZixcbiAgICB0aW1lb3V0TXMsXG4gICAgaW5pdGlhbERlbGF5UmVmLFxuICAgIGN1cnJlbnRDb250ZXh0UmVmLFxuICAgIGhhc1Byb3ZpZGVyLFxuICAgIHRpbWVvdXRJZFJlZlxuICB9ID0gZ3JvdXBDb250ZXh0O1xuICBjb25zdCBbaXNJbnN0YW50UGhhc2UsIHNldElzSW5zdGFudFBoYXNlXSA9IFJlYWN0LnVzZVN0YXRlKGZhbHNlKTtcbiAgdXNlTW9kZXJuTGF5b3V0RWZmZWN0KCgpID0+IHtcbiAgICBmdW5jdGlvbiB1bnNldCgpIHtcbiAgICAgIHZhciBfY3VycmVudENvbnRleHRSZWYkY3U7XG4gICAgICBzZXRJc0luc3RhbnRQaGFzZShmYWxzZSk7XG4gICAgICAoX2N1cnJlbnRDb250ZXh0UmVmJGN1ID0gY3VycmVudENvbnRleHRSZWYuY3VycmVudCkgPT0gbnVsbCB8fCBfY3VycmVudENvbnRleHRSZWYkY3Uuc2V0SXNJbnN0YW50UGhhc2UoZmFsc2UpO1xuICAgICAgY3VycmVudElkUmVmLmN1cnJlbnQgPSBudWxsO1xuICAgICAgY3VycmVudENvbnRleHRSZWYuY3VycmVudCA9IG51bGw7XG4gICAgICBkZWxheVJlZi5jdXJyZW50ID0gaW5pdGlhbERlbGF5UmVmLmN1cnJlbnQ7XG4gICAgfVxuICAgIGlmICghZW5hYmxlZCkgcmV0dXJuO1xuICAgIGlmICghY3VycmVudElkUmVmLmN1cnJlbnQpIHJldHVybjtcbiAgICBpZiAoIW9wZW4gJiYgY3VycmVudElkUmVmLmN1cnJlbnQgPT09IGZsb2F0aW5nSWQpIHtcbiAgICAgIHNldElzSW5zdGFudFBoYXNlKGZhbHNlKTtcbiAgICAgIGlmICh0aW1lb3V0TXMpIHtcbiAgICAgICAgdGltZW91dElkUmVmLmN1cnJlbnQgPSB3aW5kb3cuc2V0VGltZW91dCh1bnNldCwgdGltZW91dE1zKTtcbiAgICAgICAgcmV0dXJuICgpID0+IHtcbiAgICAgICAgICBjbGVhclRpbWVvdXQodGltZW91dElkUmVmLmN1cnJlbnQpO1xuICAgICAgICB9O1xuICAgICAgfVxuICAgICAgdW5zZXQoKTtcbiAgICB9XG4gIH0sIFtlbmFibGVkLCBvcGVuLCBmbG9hdGluZ0lkLCBjdXJyZW50SWRSZWYsIGRlbGF5UmVmLCB0aW1lb3V0TXMsIGluaXRpYWxEZWxheVJlZiwgY3VycmVudENvbnRleHRSZWYsIHRpbWVvdXRJZFJlZl0pO1xuICB1c2VNb2Rlcm5MYXlvdXRFZmZlY3QoKCkgPT4ge1xuICAgIGlmICghZW5hYmxlZCkgcmV0dXJuO1xuICAgIGlmICghb3BlbikgcmV0dXJuO1xuICAgIGNvbnN0IHByZXZDb250ZXh0ID0gY3VycmVudENvbnRleHRSZWYuY3VycmVudDtcbiAgICBjb25zdCBwcmV2SWQgPSBjdXJyZW50SWRSZWYuY3VycmVudDtcbiAgICBjdXJyZW50Q29udGV4dFJlZi5jdXJyZW50ID0ge1xuICAgICAgb25PcGVuQ2hhbmdlLFxuICAgICAgc2V0SXNJbnN0YW50UGhhc2VcbiAgICB9O1xuICAgIGN1cnJlbnRJZFJlZi5jdXJyZW50ID0gZmxvYXRpbmdJZDtcbiAgICBkZWxheVJlZi5jdXJyZW50ID0ge1xuICAgICAgb3BlbjogMCxcbiAgICAgIGNsb3NlOiBnZXREZWxheShpbml0aWFsRGVsYXlSZWYuY3VycmVudCwgJ2Nsb3NlJylcbiAgICB9O1xuICAgIGlmIChwcmV2SWQgIT09IG51bGwgJiYgcHJldklkICE9PSBmbG9hdGluZ0lkKSB7XG4gICAgICBjbGVhclRpbWVvdXRJZlNldCh0aW1lb3V0SWRSZWYpO1xuICAgICAgc2V0SXNJbnN0YW50UGhhc2UodHJ1ZSk7XG4gICAgICBwcmV2Q29udGV4dCA9PSBudWxsIHx8IHByZXZDb250ZXh0LnNldElzSW5zdGFudFBoYXNlKHRydWUpO1xuICAgICAgcHJldkNvbnRleHQgPT0gbnVsbCB8fCBwcmV2Q29udGV4dC5vbk9wZW5DaGFuZ2UoZmFsc2UpO1xuICAgIH0gZWxzZSB7XG4gICAgICBzZXRJc0luc3RhbnRQaGFzZShmYWxzZSk7XG4gICAgICBwcmV2Q29udGV4dCA9PSBudWxsIHx8IHByZXZDb250ZXh0LnNldElzSW5zdGFudFBoYXNlKGZhbHNlKTtcbiAgICB9XG4gIH0sIFtlbmFibGVkLCBvcGVuLCBmbG9hdGluZ0lkLCBvbk9wZW5DaGFuZ2UsIGN1cnJlbnRJZFJlZiwgZGVsYXlSZWYsIHRpbWVvdXRNcywgaW5pdGlhbERlbGF5UmVmLCBjdXJyZW50Q29udGV4dFJlZiwgdGltZW91dElkUmVmXSk7XG4gIHVzZU1vZGVybkxheW91dEVmZmVjdCgoKSA9PiB7XG4gICAgcmV0dXJuICgpID0+IHtcbiAgICAgIGN1cnJlbnRDb250ZXh0UmVmLmN1cnJlbnQgPSBudWxsO1xuICAgIH07XG4gIH0sIFtjdXJyZW50Q29udGV4dFJlZl0pO1xuICByZXR1cm4gUmVhY3QudXNlTWVtbygoKSA9PiAoe1xuICAgIGhhc1Byb3ZpZGVyLFxuICAgIGRlbGF5UmVmLFxuICAgIGlzSW5zdGFudFBoYXNlXG4gIH0pLCBbaGFzUHJvdmlkZXIsIGRlbGF5UmVmLCBpc0luc3RhbnRQaGFzZV0pO1xufVxuXG5sZXQgcmFmSWQgPSAwO1xuZnVuY3Rpb24gZW5xdWV1ZUZvY3VzKGVsLCBvcHRpb25zKSB7XG4gIGlmIChvcHRpb25zID09PSB2b2lkIDApIHtcbiAgICBvcHRpb25zID0ge307XG4gIH1cbiAgY29uc3Qge1xuICAgIHByZXZlbnRTY3JvbGwgPSBmYWxzZSxcbiAgICBjYW5jZWxQcmV2aW91cyA9IHRydWUsXG4gICAgc3luYyA9IGZhbHNlXG4gIH0gPSBvcHRpb25zO1xuICBjYW5jZWxQcmV2aW91cyAmJiBjYW5jZWxBbmltYXRpb25GcmFtZShyYWZJZCk7XG4gIGNvbnN0IGV4ZWMgPSAoKSA9PiBlbCA9PSBudWxsID8gdm9pZCAwIDogZWwuZm9jdXMoe1xuICAgIHByZXZlbnRTY3JvbGxcbiAgfSk7XG4gIGlmIChzeW5jKSB7XG4gICAgZXhlYygpO1xuICB9IGVsc2Uge1xuICAgIHJhZklkID0gcmVxdWVzdEFuaW1hdGlvbkZyYW1lKGV4ZWMpO1xuICB9XG59XG5cbmZ1bmN0aW9uIGNvbnRhaW5zKHBhcmVudCwgY2hpbGQpIHtcbiAgaWYgKCFwYXJlbnQgfHwgIWNoaWxkKSB7XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG4gIGNvbnN0IHJvb3ROb2RlID0gY2hpbGQuZ2V0Um9vdE5vZGUgPT0gbnVsbCA/IHZvaWQgMCA6IGNoaWxkLmdldFJvb3ROb2RlKCk7XG5cbiAgLy8gRmlyc3QsIGF0dGVtcHQgd2l0aCBmYXN0ZXIgbmF0aXZlIG1ldGhvZFxuICBpZiAocGFyZW50LmNvbnRhaW5zKGNoaWxkKSkge1xuICAgIHJldHVybiB0cnVlO1xuICB9XG5cbiAgLy8gdGhlbiBmYWxsYmFjayB0byBjdXN0b20gaW1wbGVtZW50YXRpb24gd2l0aCBTaGFkb3cgRE9NIHN1cHBvcnRcbiAgaWYgKHJvb3ROb2RlICYmIGlzU2hhZG93Um9vdChyb290Tm9kZSkpIHtcbiAgICBsZXQgbmV4dCA9IGNoaWxkO1xuICAgIHdoaWxlIChuZXh0KSB7XG4gICAgICBpZiAocGFyZW50ID09PSBuZXh0KSB7XG4gICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgfVxuICAgICAgLy8gQHRzLWlnbm9yZVxuICAgICAgbmV4dCA9IG5leHQucGFyZW50Tm9kZSB8fCBuZXh0Lmhvc3Q7XG4gICAgfVxuICB9XG5cbiAgLy8gR2l2ZSB1cCwgdGhlIHJlc3VsdCBpcyBmYWxzZVxuICByZXR1cm4gZmFsc2U7XG59XG5mdW5jdGlvbiBnZXRUYXJnZXQoZXZlbnQpIHtcbiAgaWYgKCdjb21wb3NlZFBhdGgnIGluIGV2ZW50KSB7XG4gICAgcmV0dXJuIGV2ZW50LmNvbXBvc2VkUGF0aCgpWzBdO1xuICB9XG5cbiAgLy8gVFMgdGhpbmtzIGBldmVudGAgaXMgb2YgdHlwZSBuZXZlciBhcyBpdCBhc3N1bWVzIGFsbCBicm93c2VycyBzdXBwb3J0XG4gIC8vIGBjb21wb3NlZFBhdGgoKWAsIGJ1dCBicm93c2VycyB3aXRob3V0IHNoYWRvdyBET00gZG9uJ3QuXG4gIHJldHVybiBldmVudC50YXJnZXQ7XG59XG5mdW5jdGlvbiBnZXREb2N1bWVudChub2RlKSB7XG4gIHJldHVybiAobm9kZSA9PSBudWxsID8gdm9pZCAwIDogbm9kZS5vd25lckRvY3VtZW50KSB8fCBkb2N1bWVudDtcbn1cblxuLy8gTW9kaWZpZWQgdG8gYWRkIGNvbmRpdGlvbmFsIGBhcmlhLWhpZGRlbmAgc3VwcG9ydDpcbi8vIGh0dHBzOi8vZ2l0aHViLmNvbS90aGVLYXNoZXkvYXJpYS1oaWRkZW4vYmxvYi85MjIwYzhmNGE0ZmQzNWY2M2JlZTU1MTBhOWY0MWEzNzI2NDM4MmQ0L3NyYy9pbmRleC50c1xuY29uc3QgY291bnRlcnMgPSB7XG4gIGluZXJ0OiAvKiNfX1BVUkVfXyovbmV3IFdlYWtNYXAoKSxcbiAgJ2FyaWEtaGlkZGVuJzogLyojX19QVVJFX18qL25ldyBXZWFrTWFwKCksXG4gIG5vbmU6IC8qI19fUFVSRV9fKi9uZXcgV2Vha01hcCgpXG59O1xuZnVuY3Rpb24gZ2V0Q291bnRlck1hcChjb250cm9sKSB7XG4gIGlmIChjb250cm9sID09PSAnaW5lcnQnKSByZXR1cm4gY291bnRlcnMuaW5lcnQ7XG4gIGlmIChjb250cm9sID09PSAnYXJpYS1oaWRkZW4nKSByZXR1cm4gY291bnRlcnNbJ2FyaWEtaGlkZGVuJ107XG4gIHJldHVybiBjb3VudGVycy5ub25lO1xufVxubGV0IHVuY29udHJvbGxlZEVsZW1lbnRzU2V0ID0gLyojX19QVVJFX18qL25ldyBXZWFrU2V0KCk7XG5sZXQgbWFya2VyTWFwID0ge307XG5sZXQgbG9ja0NvdW50JDEgPSAwO1xuY29uc3Qgc3VwcG9ydHNJbmVydCA9ICgpID0+IHR5cGVvZiBIVE1MRWxlbWVudCAhPT0gJ3VuZGVmaW5lZCcgJiYgJ2luZXJ0JyBpbiBIVE1MRWxlbWVudC5wcm90b3R5cGU7XG5jb25zdCB1bndyYXBIb3N0ID0gbm9kZSA9PiBub2RlICYmIChub2RlLmhvc3QgfHwgdW53cmFwSG9zdChub2RlLnBhcmVudE5vZGUpKTtcbmNvbnN0IGNvcnJlY3RFbGVtZW50cyA9IChwYXJlbnQsIHRhcmdldHMpID0+IHRhcmdldHMubWFwKHRhcmdldCA9PiB7XG4gIGlmIChwYXJlbnQuY29udGFpbnModGFyZ2V0KSkge1xuICAgIHJldHVybiB0YXJnZXQ7XG4gIH1cbiAgY29uc3QgY29ycmVjdGVkVGFyZ2V0ID0gdW53cmFwSG9zdCh0YXJnZXQpO1xuICBpZiAocGFyZW50LmNvbnRhaW5zKGNvcnJlY3RlZFRhcmdldCkpIHtcbiAgICByZXR1cm4gY29ycmVjdGVkVGFyZ2V0O1xuICB9XG4gIHJldHVybiBudWxsO1xufSkuZmlsdGVyKHggPT4geCAhPSBudWxsKTtcbmZ1bmN0aW9uIGFwcGx5QXR0cmlidXRlVG9PdGhlcnModW5jb3JyZWN0ZWRBdm9pZEVsZW1lbnRzLCBib2R5LCBhcmlhSGlkZGVuLCBpbmVydCkge1xuICBjb25zdCBtYXJrZXJOYW1lID0gJ2RhdGEtZmxvYXRpbmctdWktaW5lcnQnO1xuICBjb25zdCBjb250cm9sQXR0cmlidXRlID0gaW5lcnQgPyAnaW5lcnQnIDogYXJpYUhpZGRlbiA/ICdhcmlhLWhpZGRlbicgOiBudWxsO1xuICBjb25zdCBhdm9pZEVsZW1lbnRzID0gY29ycmVjdEVsZW1lbnRzKGJvZHksIHVuY29ycmVjdGVkQXZvaWRFbGVtZW50cyk7XG4gIGNvbnN0IGVsZW1lbnRzVG9LZWVwID0gbmV3IFNldCgpO1xuICBjb25zdCBlbGVtZW50c1RvU3RvcCA9IG5ldyBTZXQoYXZvaWRFbGVtZW50cyk7XG4gIGNvbnN0IGhpZGRlbkVsZW1lbnRzID0gW107XG4gIGlmICghbWFya2VyTWFwW21hcmtlck5hbWVdKSB7XG4gICAgbWFya2VyTWFwW21hcmtlck5hbWVdID0gbmV3IFdlYWtNYXAoKTtcbiAgfVxuICBjb25zdCBtYXJrZXJDb3VudGVyID0gbWFya2VyTWFwW21hcmtlck5hbWVdO1xuICBhdm9pZEVsZW1lbnRzLmZvckVhY2goa2VlcCk7XG4gIGRlZXAoYm9keSk7XG4gIGVsZW1lbnRzVG9LZWVwLmNsZWFyKCk7XG4gIGZ1bmN0aW9uIGtlZXAoZWwpIHtcbiAgICBpZiAoIWVsIHx8IGVsZW1lbnRzVG9LZWVwLmhhcyhlbCkpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgZWxlbWVudHNUb0tlZXAuYWRkKGVsKTtcbiAgICBlbC5wYXJlbnROb2RlICYmIGtlZXAoZWwucGFyZW50Tm9kZSk7XG4gIH1cbiAgZnVuY3Rpb24gZGVlcChwYXJlbnQpIHtcbiAgICBpZiAoIXBhcmVudCB8fCBlbGVtZW50c1RvU3RvcC5oYXMocGFyZW50KSkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBbXS5mb3JFYWNoLmNhbGwocGFyZW50LmNoaWxkcmVuLCBub2RlID0+IHtcbiAgICAgIGlmIChnZXROb2RlTmFtZShub2RlKSA9PT0gJ3NjcmlwdCcpIHJldHVybjtcbiAgICAgIGlmIChlbGVtZW50c1RvS2VlcC5oYXMobm9kZSkpIHtcbiAgICAgICAgZGVlcChub2RlKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGNvbnN0IGF0dHIgPSBjb250cm9sQXR0cmlidXRlID8gbm9kZS5nZXRBdHRyaWJ1dGUoY29udHJvbEF0dHJpYnV0ZSkgOiBudWxsO1xuICAgICAgICBjb25zdCBhbHJlYWR5SGlkZGVuID0gYXR0ciAhPT0gbnVsbCAmJiBhdHRyICE9PSAnZmFsc2UnO1xuICAgICAgICBjb25zdCBjb3VudGVyTWFwID0gZ2V0Q291bnRlck1hcChjb250cm9sQXR0cmlidXRlKTtcbiAgICAgICAgY29uc3QgY291bnRlclZhbHVlID0gKGNvdW50ZXJNYXAuZ2V0KG5vZGUpIHx8IDApICsgMTtcbiAgICAgICAgY29uc3QgbWFya2VyVmFsdWUgPSAobWFya2VyQ291bnRlci5nZXQobm9kZSkgfHwgMCkgKyAxO1xuICAgICAgICBjb3VudGVyTWFwLnNldChub2RlLCBjb3VudGVyVmFsdWUpO1xuICAgICAgICBtYXJrZXJDb3VudGVyLnNldChub2RlLCBtYXJrZXJWYWx1ZSk7XG4gICAgICAgIGhpZGRlbkVsZW1lbnRzLnB1c2gobm9kZSk7XG4gICAgICAgIGlmIChjb3VudGVyVmFsdWUgPT09IDEgJiYgYWxyZWFkeUhpZGRlbikge1xuICAgICAgICAgIHVuY29udHJvbGxlZEVsZW1lbnRzU2V0LmFkZChub2RlKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAobWFya2VyVmFsdWUgPT09IDEpIHtcbiAgICAgICAgICBub2RlLnNldEF0dHJpYnV0ZShtYXJrZXJOYW1lLCAnJyk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKCFhbHJlYWR5SGlkZGVuICYmIGNvbnRyb2xBdHRyaWJ1dGUpIHtcbiAgICAgICAgICBub2RlLnNldEF0dHJpYnV0ZShjb250cm9sQXR0cmlidXRlLCBjb250cm9sQXR0cmlidXRlID09PSAnaW5lcnQnID8gJycgOiAndHJ1ZScpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfSk7XG4gIH1cbiAgbG9ja0NvdW50JDErKztcbiAgcmV0dXJuICgpID0+IHtcbiAgICBoaWRkZW5FbGVtZW50cy5mb3JFYWNoKGVsZW1lbnQgPT4ge1xuICAgICAgY29uc3QgY291bnRlck1hcCA9IGdldENvdW50ZXJNYXAoY29udHJvbEF0dHJpYnV0ZSk7XG4gICAgICBjb25zdCBjdXJyZW50Q291bnRlclZhbHVlID0gY291bnRlck1hcC5nZXQoZWxlbWVudCkgfHwgMDtcbiAgICAgIGNvbnN0IGNvdW50ZXJWYWx1ZSA9IGN1cnJlbnRDb3VudGVyVmFsdWUgLSAxO1xuICAgICAgY29uc3QgbWFya2VyVmFsdWUgPSAobWFya2VyQ291bnRlci5nZXQoZWxlbWVudCkgfHwgMCkgLSAxO1xuICAgICAgY291bnRlck1hcC5zZXQoZWxlbWVudCwgY291bnRlclZhbHVlKTtcbiAgICAgIG1hcmtlckNvdW50ZXIuc2V0KGVsZW1lbnQsIG1hcmtlclZhbHVlKTtcbiAgICAgIGlmICghY291bnRlclZhbHVlKSB7XG4gICAgICAgIGlmICghdW5jb250cm9sbGVkRWxlbWVudHNTZXQuaGFzKGVsZW1lbnQpICYmIGNvbnRyb2xBdHRyaWJ1dGUpIHtcbiAgICAgICAgICBlbGVtZW50LnJlbW92ZUF0dHJpYnV0ZShjb250cm9sQXR0cmlidXRlKTtcbiAgICAgICAgfVxuICAgICAgICB1bmNvbnRyb2xsZWRFbGVtZW50c1NldC5kZWxldGUoZWxlbWVudCk7XG4gICAgICB9XG4gICAgICBpZiAoIW1hcmtlclZhbHVlKSB7XG4gICAgICAgIGVsZW1lbnQucmVtb3ZlQXR0cmlidXRlKG1hcmtlck5hbWUpO1xuICAgICAgfVxuICAgIH0pO1xuICAgIGxvY2tDb3VudCQxLS07XG4gICAgaWYgKCFsb2NrQ291bnQkMSkge1xuICAgICAgY291bnRlcnMuaW5lcnQgPSBuZXcgV2Vha01hcCgpO1xuICAgICAgY291bnRlcnNbJ2FyaWEtaGlkZGVuJ10gPSBuZXcgV2Vha01hcCgpO1xuICAgICAgY291bnRlcnMubm9uZSA9IG5ldyBXZWFrTWFwKCk7XG4gICAgICB1bmNvbnRyb2xsZWRFbGVtZW50c1NldCA9IG5ldyBXZWFrU2V0KCk7XG4gICAgICBtYXJrZXJNYXAgPSB7fTtcbiAgICB9XG4gIH07XG59XG5mdW5jdGlvbiBtYXJrT3RoZXJzKGF2b2lkRWxlbWVudHMsIGFyaWFIaWRkZW4sIGluZXJ0KSB7XG4gIGlmIChhcmlhSGlkZGVuID09PSB2b2lkIDApIHtcbiAgICBhcmlhSGlkZGVuID0gZmFsc2U7XG4gIH1cbiAgaWYgKGluZXJ0ID09PSB2b2lkIDApIHtcbiAgICBpbmVydCA9IGZhbHNlO1xuICB9XG4gIGNvbnN0IGJvZHkgPSBnZXREb2N1bWVudChhdm9pZEVsZW1lbnRzWzBdKS5ib2R5O1xuICByZXR1cm4gYXBwbHlBdHRyaWJ1dGVUb090aGVycyhhdm9pZEVsZW1lbnRzLmNvbmNhdChBcnJheS5mcm9tKGJvZHkucXVlcnlTZWxlY3RvckFsbCgnW2FyaWEtbGl2ZV0sW3JvbGU9XCJzdGF0dXNcIl0sb3V0cHV0JykpKSwgYm9keSwgYXJpYUhpZGRlbiwgaW5lcnQpO1xufVxuXG5jb25zdCBISURERU5fU1RZTEVTID0ge1xuICBib3JkZXI6IDAsXG4gIGNsaXA6ICdyZWN0KDAgMCAwIDApJyxcbiAgaGVpZ2h0OiAnMXB4JyxcbiAgbWFyZ2luOiAnLTFweCcsXG4gIG92ZXJmbG93OiAnaGlkZGVuJyxcbiAgcGFkZGluZzogMCxcbiAgcG9zaXRpb246ICdmaXhlZCcsXG4gIHdoaXRlU3BhY2U6ICdub3dyYXAnLFxuICB3aWR0aDogJzFweCcsXG4gIHRvcDogMCxcbiAgbGVmdDogMFxufTtcbmNvbnN0IEZvY3VzR3VhcmQgPSAvKiNfX1BVUkVfXyovUmVhY3QuZm9yd2FyZFJlZihmdW5jdGlvbiBGb2N1c0d1YXJkKHByb3BzLCByZWYpIHtcbiAgY29uc3QgW3JvbGUsIHNldFJvbGVdID0gUmVhY3QudXNlU3RhdGUoKTtcbiAgdXNlTW9kZXJuTGF5b3V0RWZmZWN0KCgpID0+IHtcbiAgICBpZiAoaXNTYWZhcmkoKSkge1xuICAgICAgLy8gVW5saWtlIG90aGVyIHNjcmVlbiByZWFkZXJzIHN1Y2ggYXMgTlZEQSBhbmQgSkFXUywgdGhlIHZpcnR1YWwgY3Vyc29yXG4gICAgICAvLyBvbiBWb2ljZU92ZXIgZG9lcyB0cmlnZ2VyIHRoZSBvbkZvY3VzIGV2ZW50LCBzbyB3ZSBjYW4gdXNlIHRoZSBmb2N1c1xuICAgICAgLy8gdHJhcCBlbGVtZW50LiBPbiBTYWZhcmksIG9ubHkgYnV0dG9ucyB0cmlnZ2VyIHRoZSBvbkZvY3VzIGV2ZW50LlxuICAgICAgLy8gTkI6IFwiZ3JvdXBcIiByb2xlIGluIHRoZSBTYW5kYm94IG5vIGxvbmdlciBhcHBlYXJzIHRvIHdvcmssIG11c3QgYmUgYVxuICAgICAgLy8gYnV0dG9uIHJvbGUuXG4gICAgICBzZXRSb2xlKCdidXR0b24nKTtcbiAgICB9XG4gIH0sIFtdKTtcbiAgY29uc3QgcmVzdFByb3BzID0ge1xuICAgIHJlZixcbiAgICB0YWJJbmRleDogMCxcbiAgICAvLyBSb2xlIGlzIG9ubHkgZm9yIFZvaWNlT3ZlclxuICAgIHJvbGUsXG4gICAgJ2FyaWEtaGlkZGVuJzogcm9sZSA/IHVuZGVmaW5lZCA6IHRydWUsXG4gICAgW2NyZWF0ZUF0dHJpYnV0ZSgnZm9jdXMtZ3VhcmQnKV06ICcnLFxuICAgIHN0eWxlOiBISURERU5fU1RZTEVTXG4gIH07XG4gIHJldHVybiAvKiNfX1BVUkVfXyovanN4KFwic3BhblwiLCB7XG4gICAgLi4ucHJvcHMsXG4gICAgLi4ucmVzdFByb3BzXG4gIH0pO1xufSk7XG5cbmNvbnN0IFBvcnRhbENvbnRleHQgPSAvKiNfX1BVUkVfXyovUmVhY3QuY3JlYXRlQ29udGV4dChudWxsKTtcbmNvbnN0IGF0dHIgPSAvKiNfX1BVUkVfXyovY3JlYXRlQXR0cmlidXRlKCdwb3J0YWwnKTtcbi8qKlxuICogQHNlZSBodHRwczovL2Zsb2F0aW5nLXVpLmNvbS9kb2NzL0Zsb2F0aW5nUG9ydGFsI3VzZWZsb2F0aW5ncG9ydGFsbm9kZVxuICovXG5mdW5jdGlvbiB1c2VGbG9hdGluZ1BvcnRhbE5vZGUocHJvcHMpIHtcbiAgaWYgKHByb3BzID09PSB2b2lkIDApIHtcbiAgICBwcm9wcyA9IHt9O1xuICB9XG4gIGNvbnN0IHtcbiAgICBpZCxcbiAgICByb290XG4gIH0gPSBwcm9wcztcbiAgY29uc3QgdW5pcXVlSWQgPSB1c2VJZCgpO1xuICBjb25zdCBwb3J0YWxDb250ZXh0ID0gdXNlUG9ydGFsQ29udGV4dCgpO1xuICBjb25zdCBbcG9ydGFsTm9kZSwgc2V0UG9ydGFsTm9kZV0gPSBSZWFjdC51c2VTdGF0ZShudWxsKTtcbiAgY29uc3QgcG9ydGFsTm9kZVJlZiA9IFJlYWN0LnVzZVJlZihudWxsKTtcbiAgdXNlTW9kZXJuTGF5b3V0RWZmZWN0KCgpID0+IHtcbiAgICByZXR1cm4gKCkgPT4ge1xuICAgICAgcG9ydGFsTm9kZSA9PSBudWxsIHx8IHBvcnRhbE5vZGUucmVtb3ZlKCk7XG4gICAgICAvLyBBbGxvdyB0aGUgc3Vic2VxdWVudCBsYXlvdXQgZWZmZWN0cyB0byBjcmVhdGUgYSBuZXcgbm9kZSBvbiB1cGRhdGVzLlxuICAgICAgLy8gVGhlIHBvcnRhbCBub2RlIHdpbGwgc3RpbGwgYmUgY2xlYW5lZCB1cCBvbiB1bm1vdW50LlxuICAgICAgLy8gaHR0cHM6Ly9naXRodWIuY29tL2Zsb2F0aW5nLXVpL2Zsb2F0aW5nLXVpL2lzc3Vlcy8yNDU0XG4gICAgICBxdWV1ZU1pY3JvdGFzaygoKSA9PiB7XG4gICAgICAgIHBvcnRhbE5vZGVSZWYuY3VycmVudCA9IG51bGw7XG4gICAgICB9KTtcbiAgICB9O1xuICB9LCBbcG9ydGFsTm9kZV0pO1xuICB1c2VNb2Rlcm5MYXlvdXRFZmZlY3QoKCkgPT4ge1xuICAgIC8vIFdhaXQgZm9yIHRoZSB1bmlxdWVJZCB0byBiZSBnZW5lcmF0ZWQgYmVmb3JlIGNyZWF0aW5nIHRoZSBwb3J0YWwgbm9kZSBpblxuICAgIC8vIFJlYWN0IDwxOCAodXNpbmcgYHVzZUZsb2F0aW5nSWRgIGluc3RlYWQgb2YgdGhlIG5hdGl2ZSBgdXNlSWRgKS5cbiAgICAvLyBodHRwczovL2dpdGh1Yi5jb20vZmxvYXRpbmctdWkvZmxvYXRpbmctdWkvaXNzdWVzLzI3NzhcbiAgICBpZiAoIXVuaXF1ZUlkKSByZXR1cm47XG4gICAgaWYgKHBvcnRhbE5vZGVSZWYuY3VycmVudCkgcmV0dXJuO1xuICAgIGNvbnN0IGV4aXN0aW5nSWRSb290ID0gaWQgPyBkb2N1bWVudC5nZXRFbGVtZW50QnlJZChpZCkgOiBudWxsO1xuICAgIGlmICghZXhpc3RpbmdJZFJvb3QpIHJldHVybjtcbiAgICBjb25zdCBzdWJSb290ID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnZGl2Jyk7XG4gICAgc3ViUm9vdC5pZCA9IHVuaXF1ZUlkO1xuICAgIHN1YlJvb3Quc2V0QXR0cmlidXRlKGF0dHIsICcnKTtcbiAgICBleGlzdGluZ0lkUm9vdC5hcHBlbmRDaGlsZChzdWJSb290KTtcbiAgICBwb3J0YWxOb2RlUmVmLmN1cnJlbnQgPSBzdWJSb290O1xuICAgIHNldFBvcnRhbE5vZGUoc3ViUm9vdCk7XG4gIH0sIFtpZCwgdW5pcXVlSWRdKTtcbiAgdXNlTW9kZXJuTGF5b3V0RWZmZWN0KCgpID0+IHtcbiAgICAvLyBXYWl0IGZvciB0aGUgcm9vdCB0byBleGlzdCBiZWZvcmUgY3JlYXRpbmcgdGhlIHBvcnRhbCBub2RlLiBUaGUgcm9vdCBtdXN0XG4gICAgLy8gYmUgc3RvcmVkIGluIHN0YXRlLCBub3QgYSByZWYsIGZvciB0aGlzIHRvIHdvcmsgcmVhY3RpdmVseS5cbiAgICBpZiAocm9vdCA9PT0gbnVsbCkgcmV0dXJuO1xuICAgIGlmICghdW5pcXVlSWQpIHJldHVybjtcbiAgICBpZiAocG9ydGFsTm9kZVJlZi5jdXJyZW50KSByZXR1cm47XG4gICAgbGV0IGNvbnRhaW5lciA9IHJvb3QgfHwgKHBvcnRhbENvbnRleHQgPT0gbnVsbCA/IHZvaWQgMCA6IHBvcnRhbENvbnRleHQucG9ydGFsTm9kZSk7XG4gICAgaWYgKGNvbnRhaW5lciAmJiAhaXNOb2RlKGNvbnRhaW5lcikpIGNvbnRhaW5lciA9IGNvbnRhaW5lci5jdXJyZW50O1xuICAgIGNvbnRhaW5lciA9IGNvbnRhaW5lciB8fCBkb2N1bWVudC5ib2R5O1xuICAgIGxldCBpZFdyYXBwZXIgPSBudWxsO1xuICAgIGlmIChpZCkge1xuICAgICAgaWRXcmFwcGVyID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnZGl2Jyk7XG4gICAgICBpZFdyYXBwZXIuaWQgPSBpZDtcbiAgICAgIGNvbnRhaW5lci5hcHBlbmRDaGlsZChpZFdyYXBwZXIpO1xuICAgIH1cbiAgICBjb25zdCBzdWJSb290ID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnZGl2Jyk7XG4gICAgc3ViUm9vdC5pZCA9IHVuaXF1ZUlkO1xuICAgIHN1YlJvb3Quc2V0QXR0cmlidXRlKGF0dHIsICcnKTtcbiAgICBjb250YWluZXIgPSBpZFdyYXBwZXIgfHwgY29udGFpbmVyO1xuICAgIGNvbnRhaW5lci5hcHBlbmRDaGlsZChzdWJSb290KTtcbiAgICBwb3J0YWxOb2RlUmVmLmN1cnJlbnQgPSBzdWJSb290O1xuICAgIHNldFBvcnRhbE5vZGUoc3ViUm9vdCk7XG4gIH0sIFtpZCwgcm9vdCwgdW5pcXVlSWQsIHBvcnRhbENvbnRleHRdKTtcbiAgcmV0dXJuIHBvcnRhbE5vZGU7XG59XG4vKipcbiAqIFBvcnRhbHMgdGhlIGZsb2F0aW5nIGVsZW1lbnQgaW50byBhIGdpdmVuIGNvbnRhaW5lciBlbGVtZW50IOKAlCBieSBkZWZhdWx0LFxuICogb3V0c2lkZSBvZiB0aGUgYXBwIHJvb3QgYW5kIGludG8gdGhlIGJvZHkuXG4gKiBUaGlzIGlzIG5lY2Vzc2FyeSB0byBlbnN1cmUgdGhlIGZsb2F0aW5nIGVsZW1lbnQgY2FuIGFwcGVhciBvdXRzaWRlIGFueVxuICogcG90ZW50aWFsIHBhcmVudCBjb250YWluZXJzIHRoYXQgY2F1c2UgY2xpcHBpbmcgKHN1Y2ggYXMgYG92ZXJmbG93OiBoaWRkZW5gKSxcbiAqIHdoaWxlIHJldGFpbmluZyBpdHMgbG9jYXRpb24gaW4gdGhlIFJlYWN0IHRyZWUuXG4gKiBAc2VlIGh0dHBzOi8vZmxvYXRpbmctdWkuY29tL2RvY3MvRmxvYXRpbmdQb3J0YWxcbiAqL1xuZnVuY3Rpb24gRmxvYXRpbmdQb3J0YWwocHJvcHMpIHtcbiAgY29uc3Qge1xuICAgIGNoaWxkcmVuLFxuICAgIGlkLFxuICAgIHJvb3QsXG4gICAgcHJlc2VydmVUYWJPcmRlciA9IHRydWVcbiAgfSA9IHByb3BzO1xuICBjb25zdCBwb3J0YWxOb2RlID0gdXNlRmxvYXRpbmdQb3J0YWxOb2RlKHtcbiAgICBpZCxcbiAgICByb290XG4gIH0pO1xuICBjb25zdCBbZm9jdXNNYW5hZ2VyU3RhdGUsIHNldEZvY3VzTWFuYWdlclN0YXRlXSA9IFJlYWN0LnVzZVN0YXRlKG51bGwpO1xuICBjb25zdCBiZWZvcmVPdXRzaWRlUmVmID0gUmVhY3QudXNlUmVmKG51bGwpO1xuICBjb25zdCBhZnRlck91dHNpZGVSZWYgPSBSZWFjdC51c2VSZWYobnVsbCk7XG4gIGNvbnN0IGJlZm9yZUluc2lkZVJlZiA9IFJlYWN0LnVzZVJlZihudWxsKTtcbiAgY29uc3QgYWZ0ZXJJbnNpZGVSZWYgPSBSZWFjdC51c2VSZWYobnVsbCk7XG4gIGNvbnN0IG1vZGFsID0gZm9jdXNNYW5hZ2VyU3RhdGUgPT0gbnVsbCA/IHZvaWQgMCA6IGZvY3VzTWFuYWdlclN0YXRlLm1vZGFsO1xuICBjb25zdCBvcGVuID0gZm9jdXNNYW5hZ2VyU3RhdGUgPT0gbnVsbCA/IHZvaWQgMCA6IGZvY3VzTWFuYWdlclN0YXRlLm9wZW47XG4gIGNvbnN0IHNob3VsZFJlbmRlckd1YXJkcyA9XG4gIC8vIFRoZSBGb2N1c01hbmFnZXIgYW5kIHRoZXJlZm9yZSBmbG9hdGluZyBlbGVtZW50IGFyZSBjdXJyZW50bHkgb3Blbi9cbiAgLy8gcmVuZGVyZWQuXG4gICEhZm9jdXNNYW5hZ2VyU3RhdGUgJiZcbiAgLy8gR3VhcmRzIGFyZSBvbmx5IGZvciBub24tbW9kYWwgZm9jdXMgbWFuYWdlbWVudC5cbiAgIWZvY3VzTWFuYWdlclN0YXRlLm1vZGFsICYmXG4gIC8vIERvbid0IHJlbmRlciBpZiB1bm1vdW50IGlzIHRyYW5zaXRpb25pbmcuXG4gIGZvY3VzTWFuYWdlclN0YXRlLm9wZW4gJiYgcHJlc2VydmVUYWJPcmRlciAmJiAhIShyb290IHx8IHBvcnRhbE5vZGUpO1xuXG4gIC8vIGh0dHBzOi8vY29kZXNhbmRib3guaW8vcy90YWJiYWJsZS1wb3J0YWwtZjR0bmc/ZmlsZT0vc3JjL1RhYmJhYmxlUG9ydGFsLnRzeFxuICBSZWFjdC51c2VFZmZlY3QoKCkgPT4ge1xuICAgIGlmICghcG9ydGFsTm9kZSB8fCAhcHJlc2VydmVUYWJPcmRlciB8fCBtb2RhbCkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIC8vIE1ha2Ugc3VyZSBlbGVtZW50cyBpbnNpZGUgdGhlIHBvcnRhbCBlbGVtZW50IGFyZSB0YWJiYWJsZSBvbmx5IHdoZW4gdGhlXG4gICAgLy8gcG9ydGFsIGhhcyBhbHJlYWR5IGJlZW4gZm9jdXNlZCwgZWl0aGVyIGJ5IHRhYmJpbmcgaW50byBhIGZvY3VzIHRyYXBcbiAgICAvLyBlbGVtZW50IG91dHNpZGUgb3IgdXNpbmcgdGhlIG1vdXNlLlxuICAgIGZ1bmN0aW9uIG9uRm9jdXMoZXZlbnQpIHtcbiAgICAgIGlmIChwb3J0YWxOb2RlICYmIGlzT3V0c2lkZUV2ZW50KGV2ZW50KSkge1xuICAgICAgICBjb25zdCBmb2N1c2luZyA9IGV2ZW50LnR5cGUgPT09ICdmb2N1c2luJztcbiAgICAgICAgY29uc3QgbWFuYWdlRm9jdXMgPSBmb2N1c2luZyA/IGVuYWJsZUZvY3VzSW5zaWRlIDogZGlzYWJsZUZvY3VzSW5zaWRlO1xuICAgICAgICBtYW5hZ2VGb2N1cyhwb3J0YWxOb2RlKTtcbiAgICAgIH1cbiAgICB9XG4gICAgLy8gTGlzdGVuIHRvIHRoZSBldmVudCBvbiB0aGUgY2FwdHVyZSBwaGFzZSBzbyB0aGV5IHJ1biBiZWZvcmUgdGhlIGZvY3VzXG4gICAgLy8gdHJhcCBlbGVtZW50cyBvbkZvY3VzIHByb3AgaXMgY2FsbGVkLlxuICAgIHBvcnRhbE5vZGUuYWRkRXZlbnRMaXN0ZW5lcignZm9jdXNpbicsIG9uRm9jdXMsIHRydWUpO1xuICAgIHBvcnRhbE5vZGUuYWRkRXZlbnRMaXN0ZW5lcignZm9jdXNvdXQnLCBvbkZvY3VzLCB0cnVlKTtcbiAgICByZXR1cm4gKCkgPT4ge1xuICAgICAgcG9ydGFsTm9kZS5yZW1vdmVFdmVudExpc3RlbmVyKCdmb2N1c2luJywgb25Gb2N1cywgdHJ1ZSk7XG4gICAgICBwb3J0YWxOb2RlLnJlbW92ZUV2ZW50TGlzdGVuZXIoJ2ZvY3Vzb3V0Jywgb25Gb2N1cywgdHJ1ZSk7XG4gICAgfTtcbiAgfSwgW3BvcnRhbE5vZGUsIHByZXNlcnZlVGFiT3JkZXIsIG1vZGFsXSk7XG4gIFJlYWN0LnVzZUVmZmVjdCgoKSA9PiB7XG4gICAgaWYgKCFwb3J0YWxOb2RlKSByZXR1cm47XG4gICAgaWYgKG9wZW4pIHJldHVybjtcbiAgICBlbmFibGVGb2N1c0luc2lkZShwb3J0YWxOb2RlKTtcbiAgfSwgW29wZW4sIHBvcnRhbE5vZGVdKTtcbiAgcmV0dXJuIC8qI19fUFVSRV9fKi9qc3hzKFBvcnRhbENvbnRleHQuUHJvdmlkZXIsIHtcbiAgICB2YWx1ZTogUmVhY3QudXNlTWVtbygoKSA9PiAoe1xuICAgICAgcHJlc2VydmVUYWJPcmRlcixcbiAgICAgIGJlZm9yZU91dHNpZGVSZWYsXG4gICAgICBhZnRlck91dHNpZGVSZWYsXG4gICAgICBiZWZvcmVJbnNpZGVSZWYsXG4gICAgICBhZnRlckluc2lkZVJlZixcbiAgICAgIHBvcnRhbE5vZGUsXG4gICAgICBzZXRGb2N1c01hbmFnZXJTdGF0ZVxuICAgIH0pLCBbcHJlc2VydmVUYWJPcmRlciwgcG9ydGFsTm9kZV0pLFxuICAgIGNoaWxkcmVuOiBbc2hvdWxkUmVuZGVyR3VhcmRzICYmIHBvcnRhbE5vZGUgJiYgLyojX19QVVJFX18qL2pzeChGb2N1c0d1YXJkLCB7XG4gICAgICBcImRhdGEtdHlwZVwiOiBcIm91dHNpZGVcIixcbiAgICAgIHJlZjogYmVmb3JlT3V0c2lkZVJlZixcbiAgICAgIG9uRm9jdXM6IGV2ZW50ID0+IHtcbiAgICAgICAgaWYgKGlzT3V0c2lkZUV2ZW50KGV2ZW50LCBwb3J0YWxOb2RlKSkge1xuICAgICAgICAgIHZhciBfYmVmb3JlSW5zaWRlUmVmJGN1cnI7XG4gICAgICAgICAgKF9iZWZvcmVJbnNpZGVSZWYkY3VyciA9IGJlZm9yZUluc2lkZVJlZi5jdXJyZW50KSA9PSBudWxsIHx8IF9iZWZvcmVJbnNpZGVSZWYkY3Vyci5mb2N1cygpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIGNvbnN0IGRvbVJlZmVyZW5jZSA9IGZvY3VzTWFuYWdlclN0YXRlID8gZm9jdXNNYW5hZ2VyU3RhdGUuZG9tUmVmZXJlbmNlIDogbnVsbDtcbiAgICAgICAgICBjb25zdCBwcmV2VGFiYmFibGUgPSBnZXRQcmV2aW91c1RhYmJhYmxlKGRvbVJlZmVyZW5jZSk7XG4gICAgICAgICAgcHJldlRhYmJhYmxlID09IG51bGwgfHwgcHJldlRhYmJhYmxlLmZvY3VzKCk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9KSwgc2hvdWxkUmVuZGVyR3VhcmRzICYmIHBvcnRhbE5vZGUgJiYgLyojX19QVVJFX18qL2pzeChcInNwYW5cIiwge1xuICAgICAgXCJhcmlhLW93bnNcIjogcG9ydGFsTm9kZS5pZCxcbiAgICAgIHN0eWxlOiBISURERU5fU1RZTEVTXG4gICAgfSksIHBvcnRhbE5vZGUgJiYgLyojX19QVVJFX18qL1JlYWN0RE9NLmNyZWF0ZVBvcnRhbChjaGlsZHJlbiwgcG9ydGFsTm9kZSksIHNob3VsZFJlbmRlckd1YXJkcyAmJiBwb3J0YWxOb2RlICYmIC8qI19fUFVSRV9fKi9qc3goRm9jdXNHdWFyZCwge1xuICAgICAgXCJkYXRhLXR5cGVcIjogXCJvdXRzaWRlXCIsXG4gICAgICByZWY6IGFmdGVyT3V0c2lkZVJlZixcbiAgICAgIG9uRm9jdXM6IGV2ZW50ID0+IHtcbiAgICAgICAgaWYgKGlzT3V0c2lkZUV2ZW50KGV2ZW50LCBwb3J0YWxOb2RlKSkge1xuICAgICAgICAgIHZhciBfYWZ0ZXJJbnNpZGVSZWYkY3VycmU7XG4gICAgICAgICAgKF9hZnRlckluc2lkZVJlZiRjdXJyZSA9IGFmdGVySW5zaWRlUmVmLmN1cnJlbnQpID09IG51bGwgfHwgX2FmdGVySW5zaWRlUmVmJGN1cnJlLmZvY3VzKCk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgY29uc3QgZG9tUmVmZXJlbmNlID0gZm9jdXNNYW5hZ2VyU3RhdGUgPyBmb2N1c01hbmFnZXJTdGF0ZS5kb21SZWZlcmVuY2UgOiBudWxsO1xuICAgICAgICAgIGNvbnN0IG5leHRUYWJiYWJsZSA9IGdldE5leHRUYWJiYWJsZShkb21SZWZlcmVuY2UpO1xuICAgICAgICAgIG5leHRUYWJiYWJsZSA9PSBudWxsIHx8IG5leHRUYWJiYWJsZS5mb2N1cygpO1xuICAgICAgICAgIChmb2N1c01hbmFnZXJTdGF0ZSA9PSBudWxsID8gdm9pZCAwIDogZm9jdXNNYW5hZ2VyU3RhdGUuY2xvc2VPbkZvY3VzT3V0KSAmJiAoZm9jdXNNYW5hZ2VyU3RhdGUgPT0gbnVsbCA/IHZvaWQgMCA6IGZvY3VzTWFuYWdlclN0YXRlLm9uT3BlbkNoYW5nZShmYWxzZSwgZXZlbnQubmF0aXZlRXZlbnQsICdmb2N1cy1vdXQnKSk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9KV1cbiAgfSk7XG59XG5jb25zdCB1c2VQb3J0YWxDb250ZXh0ID0gKCkgPT4gUmVhY3QudXNlQ29udGV4dChQb3J0YWxDb250ZXh0KTtcblxuZnVuY3Rpb24gdXNlTGl0ZU1lcmdlUmVmcyhyZWZzKSB7XG4gIHJldHVybiBSZWFjdC51c2VNZW1vKCgpID0+IHtcbiAgICByZXR1cm4gdmFsdWUgPT4ge1xuICAgICAgcmVmcy5mb3JFYWNoKHJlZiA9PiB7XG4gICAgICAgIGlmIChyZWYpIHtcbiAgICAgICAgICByZWYuY3VycmVudCA9IHZhbHVlO1xuICAgICAgICB9XG4gICAgICB9KTtcbiAgICB9O1xuICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSByZWFjdC1ob29rcy9leGhhdXN0aXZlLWRlcHNcbiAgfSwgcmVmcyk7XG59XG5cbmNvbnN0IExJU1RfTElNSVQgPSAyMDtcbmxldCBwcmV2aW91c2x5Rm9jdXNlZEVsZW1lbnRzID0gW107XG5mdW5jdGlvbiBjbGVhckRpc2Nvbm5lY3RlZFByZXZpb3VzbHlGb2N1c2VkRWxlbWVudHMoKSB7XG4gIHByZXZpb3VzbHlGb2N1c2VkRWxlbWVudHMgPSBwcmV2aW91c2x5Rm9jdXNlZEVsZW1lbnRzLmZpbHRlcihlbCA9PiBlbC5pc0Nvbm5lY3RlZCk7XG59XG5mdW5jdGlvbiBhZGRQcmV2aW91c2x5Rm9jdXNlZEVsZW1lbnQoZWxlbWVudCkge1xuICBjbGVhckRpc2Nvbm5lY3RlZFByZXZpb3VzbHlGb2N1c2VkRWxlbWVudHMoKTtcbiAgaWYgKGVsZW1lbnQgJiYgZ2V0Tm9kZU5hbWUoZWxlbWVudCkgIT09ICdib2R5Jykge1xuICAgIHByZXZpb3VzbHlGb2N1c2VkRWxlbWVudHMucHVzaChlbGVtZW50KTtcbiAgICBpZiAocHJldmlvdXNseUZvY3VzZWRFbGVtZW50cy5sZW5ndGggPiBMSVNUX0xJTUlUKSB7XG4gICAgICBwcmV2aW91c2x5Rm9jdXNlZEVsZW1lbnRzID0gcHJldmlvdXNseUZvY3VzZWRFbGVtZW50cy5zbGljZSgtMjApO1xuICAgIH1cbiAgfVxufVxuZnVuY3Rpb24gZ2V0UHJldmlvdXNseUZvY3VzZWRFbGVtZW50KCkge1xuICBjbGVhckRpc2Nvbm5lY3RlZFByZXZpb3VzbHlGb2N1c2VkRWxlbWVudHMoKTtcbiAgcmV0dXJuIHByZXZpb3VzbHlGb2N1c2VkRWxlbWVudHNbcHJldmlvdXNseUZvY3VzZWRFbGVtZW50cy5sZW5ndGggLSAxXTtcbn1cbmZ1bmN0aW9uIGdldEZpcnN0VGFiYmFibGVFbGVtZW50KGNvbnRhaW5lcikge1xuICBjb25zdCB0YWJiYWJsZU9wdGlvbnMgPSBnZXRUYWJiYWJsZU9wdGlvbnMoKTtcbiAgaWYgKGlzVGFiYmFibGUoY29udGFpbmVyLCB0YWJiYWJsZU9wdGlvbnMpKSB7XG4gICAgcmV0dXJuIGNvbnRhaW5lcjtcbiAgfVxuICByZXR1cm4gdGFiYmFibGUoY29udGFpbmVyLCB0YWJiYWJsZU9wdGlvbnMpWzBdIHx8IGNvbnRhaW5lcjtcbn1cbmZ1bmN0aW9uIGhhbmRsZVRhYkluZGV4KGZsb2F0aW5nRm9jdXNFbGVtZW50LCBvcmRlclJlZikge1xuICB2YXIgX2Zsb2F0aW5nRm9jdXNFbGVtZW50O1xuICBpZiAoIW9yZGVyUmVmLmN1cnJlbnQuaW5jbHVkZXMoJ2Zsb2F0aW5nJykgJiYgISgoX2Zsb2F0aW5nRm9jdXNFbGVtZW50ID0gZmxvYXRpbmdGb2N1c0VsZW1lbnQuZ2V0QXR0cmlidXRlKCdyb2xlJykpICE9IG51bGwgJiYgX2Zsb2F0aW5nRm9jdXNFbGVtZW50LmluY2x1ZGVzKCdkaWFsb2cnKSkpIHtcbiAgICByZXR1cm47XG4gIH1cbiAgY29uc3Qgb3B0aW9ucyA9IGdldFRhYmJhYmxlT3B0aW9ucygpO1xuICBjb25zdCBmb2N1c2FibGVFbGVtZW50cyA9IGZvY3VzYWJsZShmbG9hdGluZ0ZvY3VzRWxlbWVudCwgb3B0aW9ucyk7XG4gIGNvbnN0IHRhYmJhYmxlQ29udGVudCA9IGZvY3VzYWJsZUVsZW1lbnRzLmZpbHRlcihlbGVtZW50ID0+IHtcbiAgICBjb25zdCBkYXRhVGFiSW5kZXggPSBlbGVtZW50LmdldEF0dHJpYnV0ZSgnZGF0YS10YWJpbmRleCcpIHx8ICcnO1xuICAgIHJldHVybiBpc1RhYmJhYmxlKGVsZW1lbnQsIG9wdGlvbnMpIHx8IGVsZW1lbnQuaGFzQXR0cmlidXRlKCdkYXRhLXRhYmluZGV4JykgJiYgIWRhdGFUYWJJbmRleC5zdGFydHNXaXRoKCctJyk7XG4gIH0pO1xuICBjb25zdCB0YWJJbmRleCA9IGZsb2F0aW5nRm9jdXNFbGVtZW50LmdldEF0dHJpYnV0ZSgndGFiaW5kZXgnKTtcbiAgaWYgKG9yZGVyUmVmLmN1cnJlbnQuaW5jbHVkZXMoJ2Zsb2F0aW5nJykgfHwgdGFiYmFibGVDb250ZW50Lmxlbmd0aCA9PT0gMCkge1xuICAgIGlmICh0YWJJbmRleCAhPT0gJzAnKSB7XG4gICAgICBmbG9hdGluZ0ZvY3VzRWxlbWVudC5zZXRBdHRyaWJ1dGUoJ3RhYmluZGV4JywgJzAnKTtcbiAgICB9XG4gIH0gZWxzZSBpZiAodGFiSW5kZXggIT09ICctMScgfHwgZmxvYXRpbmdGb2N1c0VsZW1lbnQuaGFzQXR0cmlidXRlKCdkYXRhLXRhYmluZGV4JykgJiYgZmxvYXRpbmdGb2N1c0VsZW1lbnQuZ2V0QXR0cmlidXRlKCdkYXRhLXRhYmluZGV4JykgIT09ICctMScpIHtcbiAgICBmbG9hdGluZ0ZvY3VzRWxlbWVudC5zZXRBdHRyaWJ1dGUoJ3RhYmluZGV4JywgJy0xJyk7XG4gICAgZmxvYXRpbmdGb2N1c0VsZW1lbnQuc2V0QXR0cmlidXRlKCdkYXRhLXRhYmluZGV4JywgJy0xJyk7XG4gIH1cbn1cbmNvbnN0IFZpc3VhbGx5SGlkZGVuRGlzbWlzcyA9IC8qI19fUFVSRV9fKi9SZWFjdC5mb3J3YXJkUmVmKGZ1bmN0aW9uIFZpc3VhbGx5SGlkZGVuRGlzbWlzcyhwcm9wcywgcmVmKSB7XG4gIHJldHVybiAvKiNfX1BVUkVfXyovanN4KFwiYnV0dG9uXCIsIHtcbiAgICAuLi5wcm9wcyxcbiAgICB0eXBlOiBcImJ1dHRvblwiLFxuICAgIHJlZjogcmVmLFxuICAgIHRhYkluZGV4OiAtMSxcbiAgICBzdHlsZTogSElEREVOX1NUWUxFU1xuICB9KTtcbn0pO1xuLyoqXG4gKiBQcm92aWRlcyBmb2N1cyBtYW5hZ2VtZW50IGZvciB0aGUgZmxvYXRpbmcgZWxlbWVudC5cbiAqIEBzZWUgaHR0cHM6Ly9mbG9hdGluZy11aS5jb20vZG9jcy9GbG9hdGluZ0ZvY3VzTWFuYWdlclxuICovXG5mdW5jdGlvbiBGbG9hdGluZ0ZvY3VzTWFuYWdlcihwcm9wcykge1xuICBjb25zdCB7XG4gICAgY29udGV4dCxcbiAgICBjaGlsZHJlbixcbiAgICBkaXNhYmxlZCA9IGZhbHNlLFxuICAgIG9yZGVyID0gWydjb250ZW50J10sXG4gICAgZ3VhcmRzOiBfZ3VhcmRzID0gdHJ1ZSxcbiAgICBpbml0aWFsRm9jdXMgPSAwLFxuICAgIHJldHVybkZvY3VzID0gdHJ1ZSxcbiAgICByZXN0b3JlRm9jdXMgPSBmYWxzZSxcbiAgICBtb2RhbCA9IHRydWUsXG4gICAgdmlzdWFsbHlIaWRkZW5EaXNtaXNzID0gZmFsc2UsXG4gICAgY2xvc2VPbkZvY3VzT3V0ID0gdHJ1ZSxcbiAgICBvdXRzaWRlRWxlbWVudHNJbmVydCA9IGZhbHNlLFxuICAgIGdldEluc2lkZUVsZW1lbnRzOiBfZ2V0SW5zaWRlRWxlbWVudHMgPSAoKSA9PiBbXVxuICB9ID0gcHJvcHM7XG4gIGNvbnN0IHtcbiAgICBvcGVuLFxuICAgIG9uT3BlbkNoYW5nZSxcbiAgICBldmVudHMsXG4gICAgZGF0YVJlZixcbiAgICBlbGVtZW50czoge1xuICAgICAgZG9tUmVmZXJlbmNlLFxuICAgICAgZmxvYXRpbmdcbiAgICB9XG4gIH0gPSBjb250ZXh0O1xuICBjb25zdCBnZXROb2RlSWQgPSB1c2VFZmZlY3RFdmVudCgoKSA9PiB7XG4gICAgdmFyIF9kYXRhUmVmJGN1cnJlbnQkZmxvYTtcbiAgICByZXR1cm4gKF9kYXRhUmVmJGN1cnJlbnQkZmxvYSA9IGRhdGFSZWYuY3VycmVudC5mbG9hdGluZ0NvbnRleHQpID09IG51bGwgPyB2b2lkIDAgOiBfZGF0YVJlZiRjdXJyZW50JGZsb2Eubm9kZUlkO1xuICB9KTtcbiAgY29uc3QgZ2V0SW5zaWRlRWxlbWVudHMgPSB1c2VFZmZlY3RFdmVudChfZ2V0SW5zaWRlRWxlbWVudHMpO1xuICBjb25zdCBpZ25vcmVJbml0aWFsRm9jdXMgPSB0eXBlb2YgaW5pdGlhbEZvY3VzID09PSAnbnVtYmVyJyAmJiBpbml0aWFsRm9jdXMgPCAwO1xuICAvLyBJZiB0aGUgcmVmZXJlbmNlIGlzIGEgY29tYm9ib3ggYW5kIGlzIHR5cGVhYmxlIChlLmcuIGlucHV0L3RleHRhcmVhKSxcbiAgLy8gdGhlcmUgYXJlIGRpZmZlcmVudCBmb2N1cyBzZW1hbnRpY3MuIFRoZSBndWFyZHMgc2hvdWxkIG5vdCBiZSByZW5kZXJlZCwgYnV0XG4gIC8vIGFyaWEtaGlkZGVuIHNob3VsZCBiZSBhcHBsaWVkIHRvIGFsbCBub2RlcyBzdGlsbC4gRnVydGhlciwgdGhlIHZpc3VhbGx5XG4gIC8vIGhpZGRlbiBkaXNtaXNzIGJ1dHRvbiBzaG91bGQgb25seSBhcHBlYXIgYXQgdGhlIGVuZCBvZiB0aGUgbGlzdCwgbm90IHRoZVxuICAvLyBzdGFydC5cbiAgY29uc3QgaXNVbnRyYXBwZWRUeXBlYWJsZUNvbWJvYm94ID0gaXNUeXBlYWJsZUNvbWJvYm94KGRvbVJlZmVyZW5jZSkgJiYgaWdub3JlSW5pdGlhbEZvY3VzO1xuXG4gIC8vIEZvcmNlIHRoZSBndWFyZHMgdG8gYmUgcmVuZGVyZWQgaWYgdGhlIGBpbmVydGAgYXR0cmlidXRlIGlzIG5vdCBzdXBwb3J0ZWQuXG4gIGNvbnN0IGluZXJ0U3VwcG9ydGVkID0gc3VwcG9ydHNJbmVydCgpO1xuICBjb25zdCBndWFyZHMgPSBpbmVydFN1cHBvcnRlZCA/IF9ndWFyZHMgOiB0cnVlO1xuICBjb25zdCB1c2VJbmVydCA9ICFndWFyZHMgfHwgaW5lcnRTdXBwb3J0ZWQgJiYgb3V0c2lkZUVsZW1lbnRzSW5lcnQ7XG4gIGNvbnN0IG9yZGVyUmVmID0gdXNlTGF0ZXN0UmVmKG9yZGVyKTtcbiAgY29uc3QgaW5pdGlhbEZvY3VzUmVmID0gdXNlTGF0ZXN0UmVmKGluaXRpYWxGb2N1cyk7XG4gIGNvbnN0IHJldHVybkZvY3VzUmVmID0gdXNlTGF0ZXN0UmVmKHJldHVybkZvY3VzKTtcbiAgY29uc3QgdHJlZSA9IHVzZUZsb2F0aW5nVHJlZSgpO1xuICBjb25zdCBwb3J0YWxDb250ZXh0ID0gdXNlUG9ydGFsQ29udGV4dCgpO1xuICBjb25zdCBzdGFydERpc21pc3NCdXR0b25SZWYgPSBSZWFjdC51c2VSZWYobnVsbCk7XG4gIGNvbnN0IGVuZERpc21pc3NCdXR0b25SZWYgPSBSZWFjdC51c2VSZWYobnVsbCk7XG4gIGNvbnN0IHByZXZlbnRSZXR1cm5Gb2N1c1JlZiA9IFJlYWN0LnVzZVJlZihmYWxzZSk7XG4gIGNvbnN0IGlzUG9pbnRlckRvd25SZWYgPSBSZWFjdC51c2VSZWYoZmFsc2UpO1xuICBjb25zdCB0YWJiYWJsZUluZGV4UmVmID0gUmVhY3QudXNlUmVmKC0xKTtcbiAgY29uc3QgYmx1clRpbWVvdXRSZWYgPSBSZWFjdC51c2VSZWYoLTEpO1xuICBjb25zdCBpc0luc2lkZVBvcnRhbCA9IHBvcnRhbENvbnRleHQgIT0gbnVsbDtcbiAgY29uc3QgZmxvYXRpbmdGb2N1c0VsZW1lbnQgPSBnZXRGbG9hdGluZ0ZvY3VzRWxlbWVudChmbG9hdGluZyk7XG4gIGNvbnN0IGdldFRhYmJhYmxlQ29udGVudCA9IHVzZUVmZmVjdEV2ZW50KGZ1bmN0aW9uIChjb250YWluZXIpIHtcbiAgICBpZiAoY29udGFpbmVyID09PSB2b2lkIDApIHtcbiAgICAgIGNvbnRhaW5lciA9IGZsb2F0aW5nRm9jdXNFbGVtZW50O1xuICAgIH1cbiAgICByZXR1cm4gY29udGFpbmVyID8gdGFiYmFibGUoY29udGFpbmVyLCBnZXRUYWJiYWJsZU9wdGlvbnMoKSkgOiBbXTtcbiAgfSk7XG4gIGNvbnN0IGdldFRhYmJhYmxlRWxlbWVudHMgPSB1c2VFZmZlY3RFdmVudChjb250YWluZXIgPT4ge1xuICAgIGNvbnN0IGNvbnRlbnQgPSBnZXRUYWJiYWJsZUNvbnRlbnQoY29udGFpbmVyKTtcbiAgICByZXR1cm4gb3JkZXJSZWYuY3VycmVudC5tYXAodHlwZSA9PiB7XG4gICAgICBpZiAoZG9tUmVmZXJlbmNlICYmIHR5cGUgPT09ICdyZWZlcmVuY2UnKSB7XG4gICAgICAgIHJldHVybiBkb21SZWZlcmVuY2U7XG4gICAgICB9XG4gICAgICBpZiAoZmxvYXRpbmdGb2N1c0VsZW1lbnQgJiYgdHlwZSA9PT0gJ2Zsb2F0aW5nJykge1xuICAgICAgICByZXR1cm4gZmxvYXRpbmdGb2N1c0VsZW1lbnQ7XG4gICAgICB9XG4gICAgICByZXR1cm4gY29udGVudDtcbiAgICB9KS5maWx0ZXIoQm9vbGVhbikuZmxhdCgpO1xuICB9KTtcbiAgUmVhY3QudXNlRWZmZWN0KCgpID0+IHtcbiAgICBpZiAoZGlzYWJsZWQpIHJldHVybjtcbiAgICBpZiAoIW1vZGFsKSByZXR1cm47XG4gICAgZnVuY3Rpb24gb25LZXlEb3duKGV2ZW50KSB7XG4gICAgICBpZiAoZXZlbnQua2V5ID09PSAnVGFiJykge1xuICAgICAgICAvLyBUaGUgZm9jdXMgZ3VhcmRzIGhhdmUgbm90aGluZyB0byBmb2N1cywgc28gd2UgbmVlZCB0byBzdG9wIHRoZSBldmVudC5cbiAgICAgICAgaWYgKGNvbnRhaW5zJDEoZmxvYXRpbmdGb2N1c0VsZW1lbnQsIGFjdGl2ZUVsZW1lbnQoZ2V0RG9jdW1lbnQkMShmbG9hdGluZ0ZvY3VzRWxlbWVudCkpKSAmJiBnZXRUYWJiYWJsZUNvbnRlbnQoKS5sZW5ndGggPT09IDAgJiYgIWlzVW50cmFwcGVkVHlwZWFibGVDb21ib2JveCkge1xuICAgICAgICAgIHN0b3BFdmVudChldmVudCk7XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgZWxzID0gZ2V0VGFiYmFibGVFbGVtZW50cygpO1xuICAgICAgICBjb25zdCB0YXJnZXQgPSBnZXRUYXJnZXQkMShldmVudCk7XG4gICAgICAgIGlmIChvcmRlclJlZi5jdXJyZW50WzBdID09PSAncmVmZXJlbmNlJyAmJiB0YXJnZXQgPT09IGRvbVJlZmVyZW5jZSkge1xuICAgICAgICAgIHN0b3BFdmVudChldmVudCk7XG4gICAgICAgICAgaWYgKGV2ZW50LnNoaWZ0S2V5KSB7XG4gICAgICAgICAgICBlbnF1ZXVlRm9jdXMoZWxzW2Vscy5sZW5ndGggLSAxXSk7XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIGVucXVldWVGb2N1cyhlbHNbMV0pO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBpZiAob3JkZXJSZWYuY3VycmVudFsxXSA9PT0gJ2Zsb2F0aW5nJyAmJiB0YXJnZXQgPT09IGZsb2F0aW5nRm9jdXNFbGVtZW50ICYmIGV2ZW50LnNoaWZ0S2V5KSB7XG4gICAgICAgICAgc3RvcEV2ZW50KGV2ZW50KTtcbiAgICAgICAgICBlbnF1ZXVlRm9jdXMoZWxzWzBdKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cbiAgICBjb25zdCBkb2MgPSBnZXREb2N1bWVudCQxKGZsb2F0aW5nRm9jdXNFbGVtZW50KTtcbiAgICBkb2MuYWRkRXZlbnRMaXN0ZW5lcigna2V5ZG93bicsIG9uS2V5RG93bik7XG4gICAgcmV0dXJuICgpID0+IHtcbiAgICAgIGRvYy5yZW1vdmVFdmVudExpc3RlbmVyKCdrZXlkb3duJywgb25LZXlEb3duKTtcbiAgICB9O1xuICB9LCBbZGlzYWJsZWQsIGRvbVJlZmVyZW5jZSwgZmxvYXRpbmdGb2N1c0VsZW1lbnQsIG1vZGFsLCBvcmRlclJlZiwgaXNVbnRyYXBwZWRUeXBlYWJsZUNvbWJvYm94LCBnZXRUYWJiYWJsZUNvbnRlbnQsIGdldFRhYmJhYmxlRWxlbWVudHNdKTtcbiAgUmVhY3QudXNlRWZmZWN0KCgpID0+IHtcbiAgICBpZiAoZGlzYWJsZWQpIHJldHVybjtcbiAgICBpZiAoIWZsb2F0aW5nKSByZXR1cm47XG4gICAgZnVuY3Rpb24gaGFuZGxlRm9jdXNJbihldmVudCkge1xuICAgICAgY29uc3QgdGFyZ2V0ID0gZ2V0VGFyZ2V0JDEoZXZlbnQpO1xuICAgICAgY29uc3QgdGFiYmFibGVDb250ZW50ID0gZ2V0VGFiYmFibGVDb250ZW50KCk7XG4gICAgICBjb25zdCB0YWJiYWJsZUluZGV4ID0gdGFiYmFibGVDb250ZW50LmluZGV4T2YodGFyZ2V0KTtcbiAgICAgIGlmICh0YWJiYWJsZUluZGV4ICE9PSAtMSkge1xuICAgICAgICB0YWJiYWJsZUluZGV4UmVmLmN1cnJlbnQgPSB0YWJiYWJsZUluZGV4O1xuICAgICAgfVxuICAgIH1cbiAgICBmbG9hdGluZy5hZGRFdmVudExpc3RlbmVyKCdmb2N1c2luJywgaGFuZGxlRm9jdXNJbik7XG4gICAgcmV0dXJuICgpID0+IHtcbiAgICAgIGZsb2F0aW5nLnJlbW92ZUV2ZW50TGlzdGVuZXIoJ2ZvY3VzaW4nLCBoYW5kbGVGb2N1c0luKTtcbiAgICB9O1xuICB9LCBbZGlzYWJsZWQsIGZsb2F0aW5nLCBnZXRUYWJiYWJsZUNvbnRlbnRdKTtcbiAgUmVhY3QudXNlRWZmZWN0KCgpID0+IHtcbiAgICBpZiAoZGlzYWJsZWQpIHJldHVybjtcbiAgICBpZiAoIWNsb3NlT25Gb2N1c091dCkgcmV0dXJuO1xuXG4gICAgLy8gSW4gU2FmYXJpLCBidXR0b25zIGxvc2UgZm9jdXMgd2hlbiBwcmVzc2luZyB0aGVtLlxuICAgIGZ1bmN0aW9uIGhhbmRsZVBvaW50ZXJEb3duKCkge1xuICAgICAgaXNQb2ludGVyRG93blJlZi5jdXJyZW50ID0gdHJ1ZTtcbiAgICAgIHNldFRpbWVvdXQoKCkgPT4ge1xuICAgICAgICBpc1BvaW50ZXJEb3duUmVmLmN1cnJlbnQgPSBmYWxzZTtcbiAgICAgIH0pO1xuICAgIH1cbiAgICBmdW5jdGlvbiBoYW5kbGVGb2N1c091dHNpZGUoZXZlbnQpIHtcbiAgICAgIGNvbnN0IHJlbGF0ZWRUYXJnZXQgPSBldmVudC5yZWxhdGVkVGFyZ2V0O1xuICAgICAgY29uc3QgY3VycmVudFRhcmdldCA9IGV2ZW50LmN1cnJlbnRUYXJnZXQ7XG4gICAgICBjb25zdCB0YXJnZXQgPSBnZXRUYXJnZXQkMShldmVudCk7XG4gICAgICBxdWV1ZU1pY3JvdGFzaygoKSA9PiB7XG4gICAgICAgIGNvbnN0IG5vZGVJZCA9IGdldE5vZGVJZCgpO1xuICAgICAgICBjb25zdCBtb3ZlZFRvVW5yZWxhdGVkTm9kZSA9ICEoY29udGFpbnMkMShkb21SZWZlcmVuY2UsIHJlbGF0ZWRUYXJnZXQpIHx8IGNvbnRhaW5zJDEoZmxvYXRpbmcsIHJlbGF0ZWRUYXJnZXQpIHx8IGNvbnRhaW5zJDEocmVsYXRlZFRhcmdldCwgZmxvYXRpbmcpIHx8IGNvbnRhaW5zJDEocG9ydGFsQ29udGV4dCA9PSBudWxsID8gdm9pZCAwIDogcG9ydGFsQ29udGV4dC5wb3J0YWxOb2RlLCByZWxhdGVkVGFyZ2V0KSB8fCByZWxhdGVkVGFyZ2V0ICE9IG51bGwgJiYgcmVsYXRlZFRhcmdldC5oYXNBdHRyaWJ1dGUoY3JlYXRlQXR0cmlidXRlKCdmb2N1cy1ndWFyZCcpKSB8fCB0cmVlICYmIChnZXROb2RlQ2hpbGRyZW4kMSh0cmVlLm5vZGVzUmVmLmN1cnJlbnQsIG5vZGVJZCkuZmluZChub2RlID0+IHtcbiAgICAgICAgICB2YXIgX25vZGUkY29udGV4dCwgX25vZGUkY29udGV4dDI7XG4gICAgICAgICAgcmV0dXJuIGNvbnRhaW5zJDEoKF9ub2RlJGNvbnRleHQgPSBub2RlLmNvbnRleHQpID09IG51bGwgPyB2b2lkIDAgOiBfbm9kZSRjb250ZXh0LmVsZW1lbnRzLmZsb2F0aW5nLCByZWxhdGVkVGFyZ2V0KSB8fCBjb250YWlucyQxKChfbm9kZSRjb250ZXh0MiA9IG5vZGUuY29udGV4dCkgPT0gbnVsbCA/IHZvaWQgMCA6IF9ub2RlJGNvbnRleHQyLmVsZW1lbnRzLmRvbVJlZmVyZW5jZSwgcmVsYXRlZFRhcmdldCk7XG4gICAgICAgIH0pIHx8IGdldE5vZGVBbmNlc3RvcnModHJlZS5ub2Rlc1JlZi5jdXJyZW50LCBub2RlSWQpLmZpbmQobm9kZSA9PiB7XG4gICAgICAgICAgdmFyIF9ub2RlJGNvbnRleHQzLCBfbm9kZSRjb250ZXh0NCwgX25vZGUkY29udGV4dDU7XG4gICAgICAgICAgcmV0dXJuIFsoX25vZGUkY29udGV4dDMgPSBub2RlLmNvbnRleHQpID09IG51bGwgPyB2b2lkIDAgOiBfbm9kZSRjb250ZXh0My5lbGVtZW50cy5mbG9hdGluZywgZ2V0RmxvYXRpbmdGb2N1c0VsZW1lbnQoKF9ub2RlJGNvbnRleHQ0ID0gbm9kZS5jb250ZXh0KSA9PSBudWxsID8gdm9pZCAwIDogX25vZGUkY29udGV4dDQuZWxlbWVudHMuZmxvYXRpbmcpXS5pbmNsdWRlcyhyZWxhdGVkVGFyZ2V0KSB8fCAoKF9ub2RlJGNvbnRleHQ1ID0gbm9kZS5jb250ZXh0KSA9PSBudWxsID8gdm9pZCAwIDogX25vZGUkY29udGV4dDUuZWxlbWVudHMuZG9tUmVmZXJlbmNlKSA9PT0gcmVsYXRlZFRhcmdldDtcbiAgICAgICAgfSkpKTtcbiAgICAgICAgaWYgKGN1cnJlbnRUYXJnZXQgPT09IGRvbVJlZmVyZW5jZSAmJiBmbG9hdGluZ0ZvY3VzRWxlbWVudCkge1xuICAgICAgICAgIGhhbmRsZVRhYkluZGV4KGZsb2F0aW5nRm9jdXNFbGVtZW50LCBvcmRlclJlZik7XG4gICAgICAgIH1cblxuICAgICAgICAvLyBSZXN0b3JlIGZvY3VzIHRvIHRoZSBwcmV2aW91cyB0YWJiYWJsZSBlbGVtZW50IGluZGV4IHRvIHByZXZlbnRcbiAgICAgICAgLy8gZm9jdXMgZnJvbSBiZWluZyBsb3N0IG91dHNpZGUgdGhlIGZsb2F0aW5nIHRyZWUuXG4gICAgICAgIGlmIChyZXN0b3JlRm9jdXMgJiYgY3VycmVudFRhcmdldCAhPT0gZG9tUmVmZXJlbmNlICYmICEodGFyZ2V0ICE9IG51bGwgJiYgdGFyZ2V0LmlzQ29ubmVjdGVkKSAmJiBhY3RpdmVFbGVtZW50KGdldERvY3VtZW50JDEoZmxvYXRpbmdGb2N1c0VsZW1lbnQpKSA9PT0gZ2V0RG9jdW1lbnQkMShmbG9hdGluZ0ZvY3VzRWxlbWVudCkuYm9keSkge1xuICAgICAgICAgIC8vIExldCBgRmxvYXRpbmdQb3J0YWxgIGVmZmVjdCBrbm93cyB0aGF0IGZvY3VzIGlzIHN0aWxsIGluc2lkZSB0aGVcbiAgICAgICAgICAvLyBmbG9hdGluZyB0cmVlLlxuICAgICAgICAgIGlmIChpc0hUTUxFbGVtZW50KGZsb2F0aW5nRm9jdXNFbGVtZW50KSkge1xuICAgICAgICAgICAgZmxvYXRpbmdGb2N1c0VsZW1lbnQuZm9jdXMoKTtcbiAgICAgICAgICB9XG4gICAgICAgICAgY29uc3QgcHJldlRhYmJhYmxlSW5kZXggPSB0YWJiYWJsZUluZGV4UmVmLmN1cnJlbnQ7XG4gICAgICAgICAgY29uc3QgdGFiYmFibGVDb250ZW50ID0gZ2V0VGFiYmFibGVDb250ZW50KCk7XG4gICAgICAgICAgY29uc3Qgbm9kZVRvRm9jdXMgPSB0YWJiYWJsZUNvbnRlbnRbcHJldlRhYmJhYmxlSW5kZXhdIHx8IHRhYmJhYmxlQ29udGVudFt0YWJiYWJsZUNvbnRlbnQubGVuZ3RoIC0gMV0gfHwgZmxvYXRpbmdGb2N1c0VsZW1lbnQ7XG4gICAgICAgICAgaWYgKGlzSFRNTEVsZW1lbnQobm9kZVRvRm9jdXMpKSB7XG4gICAgICAgICAgICBub2RlVG9Gb2N1cy5mb2N1cygpO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIC8vIGh0dHBzOi8vZ2l0aHViLmNvbS9mbG9hdGluZy11aS9mbG9hdGluZy11aS9pc3N1ZXMvMzA2MFxuICAgICAgICBpZiAoZGF0YVJlZi5jdXJyZW50Lmluc2lkZVJlYWN0VHJlZSkge1xuICAgICAgICAgIGRhdGFSZWYuY3VycmVudC5pbnNpZGVSZWFjdFRyZWUgPSBmYWxzZTtcbiAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cblxuICAgICAgICAvLyBGb2N1cyBkaWQgbm90IG1vdmUgaW5zaWRlIHRoZSBmbG9hdGluZyB0cmVlLCBhbmQgdGhlcmUgYXJlIG5vIHRhYmJhYmxlXG4gICAgICAgIC8vIHBvcnRhbCBndWFyZHMgdG8gaGFuZGxlIGNsb3NpbmcuXG4gICAgICAgIGlmICgoaXNVbnRyYXBwZWRUeXBlYWJsZUNvbWJvYm94ID8gdHJ1ZSA6ICFtb2RhbCkgJiYgcmVsYXRlZFRhcmdldCAmJiBtb3ZlZFRvVW5yZWxhdGVkTm9kZSAmJiAhaXNQb2ludGVyRG93blJlZi5jdXJyZW50ICYmXG4gICAgICAgIC8vIEZpeCBSZWFjdCAxOCBTdHJpY3QgTW9kZSByZXR1cm5Gb2N1cyBkdWUgdG8gZG91YmxlIHJlbmRlcmluZy5cbiAgICAgICAgcmVsYXRlZFRhcmdldCAhPT0gZ2V0UHJldmlvdXNseUZvY3VzZWRFbGVtZW50KCkpIHtcbiAgICAgICAgICBwcmV2ZW50UmV0dXJuRm9jdXNSZWYuY3VycmVudCA9IHRydWU7XG4gICAgICAgICAgb25PcGVuQ2hhbmdlKGZhbHNlLCBldmVudCwgJ2ZvY3VzLW91dCcpO1xuICAgICAgICB9XG4gICAgICB9KTtcbiAgICB9XG4gICAgY29uc3Qgc2hvdWxkSGFuZGxlQmx1ckNhcHR1cmUgPSBCb29sZWFuKCF0cmVlICYmIHBvcnRhbENvbnRleHQpO1xuICAgIGZ1bmN0aW9uIG1hcmtJbnNpZGVSZWFjdFRyZWUoKSB7XG4gICAgICBjbGVhclRpbWVvdXRJZlNldChibHVyVGltZW91dFJlZik7XG4gICAgICBkYXRhUmVmLmN1cnJlbnQuaW5zaWRlUmVhY3RUcmVlID0gdHJ1ZTtcbiAgICAgIGJsdXJUaW1lb3V0UmVmLmN1cnJlbnQgPSB3aW5kb3cuc2V0VGltZW91dCgoKSA9PiB7XG4gICAgICAgIGRhdGFSZWYuY3VycmVudC5pbnNpZGVSZWFjdFRyZWUgPSBmYWxzZTtcbiAgICAgIH0pO1xuICAgIH1cbiAgICBpZiAoZmxvYXRpbmcgJiYgaXNIVE1MRWxlbWVudChkb21SZWZlcmVuY2UpKSB7XG4gICAgICBkb21SZWZlcmVuY2UuYWRkRXZlbnRMaXN0ZW5lcignZm9jdXNvdXQnLCBoYW5kbGVGb2N1c091dHNpZGUpO1xuICAgICAgZG9tUmVmZXJlbmNlLmFkZEV2ZW50TGlzdGVuZXIoJ3BvaW50ZXJkb3duJywgaGFuZGxlUG9pbnRlckRvd24pO1xuICAgICAgZmxvYXRpbmcuYWRkRXZlbnRMaXN0ZW5lcignZm9jdXNvdXQnLCBoYW5kbGVGb2N1c091dHNpZGUpO1xuICAgICAgaWYgKHNob3VsZEhhbmRsZUJsdXJDYXB0dXJlKSB7XG4gICAgICAgIGZsb2F0aW5nLmFkZEV2ZW50TGlzdGVuZXIoJ2ZvY3Vzb3V0JywgbWFya0luc2lkZVJlYWN0VHJlZSwgdHJ1ZSk7XG4gICAgICB9XG4gICAgICByZXR1cm4gKCkgPT4ge1xuICAgICAgICBkb21SZWZlcmVuY2UucmVtb3ZlRXZlbnRMaXN0ZW5lcignZm9jdXNvdXQnLCBoYW5kbGVGb2N1c091dHNpZGUpO1xuICAgICAgICBkb21SZWZlcmVuY2UucmVtb3ZlRXZlbnRMaXN0ZW5lcigncG9pbnRlcmRvd24nLCBoYW5kbGVQb2ludGVyRG93bik7XG4gICAgICAgIGZsb2F0aW5nLnJlbW92ZUV2ZW50TGlzdGVuZXIoJ2ZvY3Vzb3V0JywgaGFuZGxlRm9jdXNPdXRzaWRlKTtcbiAgICAgICAgaWYgKHNob3VsZEhhbmRsZUJsdXJDYXB0dXJlKSB7XG4gICAgICAgICAgZmxvYXRpbmcucmVtb3ZlRXZlbnRMaXN0ZW5lcignZm9jdXNvdXQnLCBtYXJrSW5zaWRlUmVhY3RUcmVlLCB0cnVlKTtcbiAgICAgICAgfVxuICAgICAgfTtcbiAgICB9XG4gIH0sIFtkaXNhYmxlZCwgZG9tUmVmZXJlbmNlLCBmbG9hdGluZywgZmxvYXRpbmdGb2N1c0VsZW1lbnQsIG1vZGFsLCB0cmVlLCBwb3J0YWxDb250ZXh0LCBvbk9wZW5DaGFuZ2UsIGNsb3NlT25Gb2N1c091dCwgcmVzdG9yZUZvY3VzLCBnZXRUYWJiYWJsZUNvbnRlbnQsIGlzVW50cmFwcGVkVHlwZWFibGVDb21ib2JveCwgZ2V0Tm9kZUlkLCBvcmRlclJlZiwgZGF0YVJlZl0pO1xuICBjb25zdCBiZWZvcmVHdWFyZFJlZiA9IFJlYWN0LnVzZVJlZihudWxsKTtcbiAgY29uc3QgYWZ0ZXJHdWFyZFJlZiA9IFJlYWN0LnVzZVJlZihudWxsKTtcbiAgY29uc3QgbWVyZ2VkQmVmb3JlR3VhcmRSZWYgPSB1c2VMaXRlTWVyZ2VSZWZzKFtiZWZvcmVHdWFyZFJlZiwgcG9ydGFsQ29udGV4dCA9PSBudWxsID8gdm9pZCAwIDogcG9ydGFsQ29udGV4dC5iZWZvcmVJbnNpZGVSZWZdKTtcbiAgY29uc3QgbWVyZ2VkQWZ0ZXJHdWFyZFJlZiA9IHVzZUxpdGVNZXJnZVJlZnMoW2FmdGVyR3VhcmRSZWYsIHBvcnRhbENvbnRleHQgPT0gbnVsbCA/IHZvaWQgMCA6IHBvcnRhbENvbnRleHQuYWZ0ZXJJbnNpZGVSZWZdKTtcbiAgUmVhY3QudXNlRWZmZWN0KCgpID0+IHtcbiAgICB2YXIgX3BvcnRhbENvbnRleHQkcG9ydGFsLCBfYW5jZXN0b3JzJGZpbmQ7XG4gICAgaWYgKGRpc2FibGVkKSByZXR1cm47XG4gICAgaWYgKCFmbG9hdGluZykgcmV0dXJuO1xuXG4gICAgLy8gRG9uJ3QgaGlkZSBwb3J0YWxzIG5lc3RlZCB3aXRoaW4gdGhlIHBhcmVudCBwb3J0YWwuXG4gICAgY29uc3QgcG9ydGFsTm9kZXMgPSBBcnJheS5mcm9tKChwb3J0YWxDb250ZXh0ID09IG51bGwgfHwgKF9wb3J0YWxDb250ZXh0JHBvcnRhbCA9IHBvcnRhbENvbnRleHQucG9ydGFsTm9kZSkgPT0gbnVsbCA/IHZvaWQgMCA6IF9wb3J0YWxDb250ZXh0JHBvcnRhbC5xdWVyeVNlbGVjdG9yQWxsKFwiW1wiICsgY3JlYXRlQXR0cmlidXRlKCdwb3J0YWwnKSArIFwiXVwiKSkgfHwgW10pO1xuICAgIGNvbnN0IGFuY2VzdG9ycyA9IHRyZWUgPyBnZXROb2RlQW5jZXN0b3JzKHRyZWUubm9kZXNSZWYuY3VycmVudCwgZ2V0Tm9kZUlkKCkpIDogW107XG4gICAgY29uc3Qgcm9vdEFuY2VzdG9yQ29tYm9ib3hEb21SZWZlcmVuY2UgPSAoX2FuY2VzdG9ycyRmaW5kID0gYW5jZXN0b3JzLmZpbmQobm9kZSA9PiB7XG4gICAgICB2YXIgX25vZGUkY29udGV4dDY7XG4gICAgICByZXR1cm4gaXNUeXBlYWJsZUNvbWJvYm94KCgoX25vZGUkY29udGV4dDYgPSBub2RlLmNvbnRleHQpID09IG51bGwgPyB2b2lkIDAgOiBfbm9kZSRjb250ZXh0Ni5lbGVtZW50cy5kb21SZWZlcmVuY2UpIHx8IG51bGwpO1xuICAgIH0pKSA9PSBudWxsIHx8IChfYW5jZXN0b3JzJGZpbmQgPSBfYW5jZXN0b3JzJGZpbmQuY29udGV4dCkgPT0gbnVsbCA/IHZvaWQgMCA6IF9hbmNlc3RvcnMkZmluZC5lbGVtZW50cy5kb21SZWZlcmVuY2U7XG4gICAgY29uc3QgaW5zaWRlRWxlbWVudHMgPSBbZmxvYXRpbmcsIHJvb3RBbmNlc3RvckNvbWJvYm94RG9tUmVmZXJlbmNlLCAuLi5wb3J0YWxOb2RlcywgLi4uZ2V0SW5zaWRlRWxlbWVudHMoKSwgc3RhcnREaXNtaXNzQnV0dG9uUmVmLmN1cnJlbnQsIGVuZERpc21pc3NCdXR0b25SZWYuY3VycmVudCwgYmVmb3JlR3VhcmRSZWYuY3VycmVudCwgYWZ0ZXJHdWFyZFJlZi5jdXJyZW50LCBwb3J0YWxDb250ZXh0ID09IG51bGwgPyB2b2lkIDAgOiBwb3J0YWxDb250ZXh0LmJlZm9yZU91dHNpZGVSZWYuY3VycmVudCwgcG9ydGFsQ29udGV4dCA9PSBudWxsID8gdm9pZCAwIDogcG9ydGFsQ29udGV4dC5hZnRlck91dHNpZGVSZWYuY3VycmVudCwgb3JkZXJSZWYuY3VycmVudC5pbmNsdWRlcygncmVmZXJlbmNlJykgfHwgaXNVbnRyYXBwZWRUeXBlYWJsZUNvbWJvYm94ID8gZG9tUmVmZXJlbmNlIDogbnVsbF0uZmlsdGVyKHggPT4geCAhPSBudWxsKTtcbiAgICBjb25zdCBjbGVhbnVwID0gbW9kYWwgfHwgaXNVbnRyYXBwZWRUeXBlYWJsZUNvbWJvYm94ID8gbWFya090aGVycyhpbnNpZGVFbGVtZW50cywgIXVzZUluZXJ0LCB1c2VJbmVydCkgOiBtYXJrT3RoZXJzKGluc2lkZUVsZW1lbnRzKTtcbiAgICByZXR1cm4gKCkgPT4ge1xuICAgICAgY2xlYW51cCgpO1xuICAgIH07XG4gIH0sIFtkaXNhYmxlZCwgZG9tUmVmZXJlbmNlLCBmbG9hdGluZywgbW9kYWwsIG9yZGVyUmVmLCBwb3J0YWxDb250ZXh0LCBpc1VudHJhcHBlZFR5cGVhYmxlQ29tYm9ib3gsIGd1YXJkcywgdXNlSW5lcnQsIHRyZWUsIGdldE5vZGVJZCwgZ2V0SW5zaWRlRWxlbWVudHNdKTtcbiAgdXNlTW9kZXJuTGF5b3V0RWZmZWN0KCgpID0+IHtcbiAgICBpZiAoZGlzYWJsZWQgfHwgIWlzSFRNTEVsZW1lbnQoZmxvYXRpbmdGb2N1c0VsZW1lbnQpKSByZXR1cm47XG4gICAgY29uc3QgZG9jID0gZ2V0RG9jdW1lbnQkMShmbG9hdGluZ0ZvY3VzRWxlbWVudCk7XG4gICAgY29uc3QgcHJldmlvdXNseUZvY3VzZWRFbGVtZW50ID0gYWN0aXZlRWxlbWVudChkb2MpO1xuXG4gICAgLy8gV2FpdCBmb3IgYW55IGxheW91dCBlZmZlY3Qgc3RhdGUgc2V0dGVycyB0byBleGVjdXRlIHRvIHNldCBgdGFiSW5kZXhgLlxuICAgIHF1ZXVlTWljcm90YXNrKCgpID0+IHtcbiAgICAgIGNvbnN0IGZvY3VzYWJsZUVsZW1lbnRzID0gZ2V0VGFiYmFibGVFbGVtZW50cyhmbG9hdGluZ0ZvY3VzRWxlbWVudCk7XG4gICAgICBjb25zdCBpbml0aWFsRm9jdXNWYWx1ZSA9IGluaXRpYWxGb2N1c1JlZi5jdXJyZW50O1xuICAgICAgY29uc3QgZWxUb0ZvY3VzID0gKHR5cGVvZiBpbml0aWFsRm9jdXNWYWx1ZSA9PT0gJ251bWJlcicgPyBmb2N1c2FibGVFbGVtZW50c1tpbml0aWFsRm9jdXNWYWx1ZV0gOiBpbml0aWFsRm9jdXNWYWx1ZS5jdXJyZW50KSB8fCBmbG9hdGluZ0ZvY3VzRWxlbWVudDtcbiAgICAgIGNvbnN0IGZvY3VzQWxyZWFkeUluc2lkZUZsb2F0aW5nRWwgPSBjb250YWlucyQxKGZsb2F0aW5nRm9jdXNFbGVtZW50LCBwcmV2aW91c2x5Rm9jdXNlZEVsZW1lbnQpO1xuICAgICAgaWYgKCFpZ25vcmVJbml0aWFsRm9jdXMgJiYgIWZvY3VzQWxyZWFkeUluc2lkZUZsb2F0aW5nRWwgJiYgb3Blbikge1xuICAgICAgICBlbnF1ZXVlRm9jdXMoZWxUb0ZvY3VzLCB7XG4gICAgICAgICAgcHJldmVudFNjcm9sbDogZWxUb0ZvY3VzID09PSBmbG9hdGluZ0ZvY3VzRWxlbWVudFxuICAgICAgICB9KTtcbiAgICAgIH1cbiAgICB9KTtcbiAgfSwgW2Rpc2FibGVkLCBvcGVuLCBmbG9hdGluZ0ZvY3VzRWxlbWVudCwgaWdub3JlSW5pdGlhbEZvY3VzLCBnZXRUYWJiYWJsZUVsZW1lbnRzLCBpbml0aWFsRm9jdXNSZWZdKTtcbiAgdXNlTW9kZXJuTGF5b3V0RWZmZWN0KCgpID0+IHtcbiAgICBpZiAoZGlzYWJsZWQgfHwgIWZsb2F0aW5nRm9jdXNFbGVtZW50KSByZXR1cm47XG4gICAgY29uc3QgZG9jID0gZ2V0RG9jdW1lbnQkMShmbG9hdGluZ0ZvY3VzRWxlbWVudCk7XG4gICAgY29uc3QgcHJldmlvdXNseUZvY3VzZWRFbGVtZW50ID0gYWN0aXZlRWxlbWVudChkb2MpO1xuICAgIGFkZFByZXZpb3VzbHlGb2N1c2VkRWxlbWVudChwcmV2aW91c2x5Rm9jdXNlZEVsZW1lbnQpO1xuXG4gICAgLy8gRGlzbWlzc2luZyB2aWEgb3V0c2lkZSBwcmVzcyBzaG91bGQgYWx3YXlzIGlnbm9yZSBgcmV0dXJuRm9jdXNgIHRvXG4gICAgLy8gcHJldmVudCB1bndhbnRlZCBzY3JvbGxpbmcuXG4gICAgZnVuY3Rpb24gb25PcGVuQ2hhbmdlKF9yZWYpIHtcbiAgICAgIGxldCB7XG4gICAgICAgIHJlYXNvbixcbiAgICAgICAgZXZlbnQsXG4gICAgICAgIG5lc3RlZFxuICAgICAgfSA9IF9yZWY7XG4gICAgICBpZiAoWydob3ZlcicsICdzYWZlLXBvbHlnb24nXS5pbmNsdWRlcyhyZWFzb24pICYmIGV2ZW50LnR5cGUgPT09ICdtb3VzZWxlYXZlJykge1xuICAgICAgICBwcmV2ZW50UmV0dXJuRm9jdXNSZWYuY3VycmVudCA9IHRydWU7XG4gICAgICB9XG4gICAgICBpZiAocmVhc29uICE9PSAnb3V0c2lkZS1wcmVzcycpIHJldHVybjtcbiAgICAgIGlmIChuZXN0ZWQpIHtcbiAgICAgICAgcHJldmVudFJldHVybkZvY3VzUmVmLmN1cnJlbnQgPSBmYWxzZTtcbiAgICAgIH0gZWxzZSBpZiAoaXNWaXJ0dWFsQ2xpY2soZXZlbnQpIHx8IGlzVmlydHVhbFBvaW50ZXJFdmVudChldmVudCkpIHtcbiAgICAgICAgcHJldmVudFJldHVybkZvY3VzUmVmLmN1cnJlbnQgPSBmYWxzZTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGxldCBpc1ByZXZlbnRTY3JvbGxTdXBwb3J0ZWQgPSBmYWxzZTtcbiAgICAgICAgZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnZGl2JykuZm9jdXMoe1xuICAgICAgICAgIGdldCBwcmV2ZW50U2Nyb2xsKCkge1xuICAgICAgICAgICAgaXNQcmV2ZW50U2Nyb2xsU3VwcG9ydGVkID0gdHJ1ZTtcbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgICAgICBpZiAoaXNQcmV2ZW50U2Nyb2xsU3VwcG9ydGVkKSB7XG4gICAgICAgICAgcHJldmVudFJldHVybkZvY3VzUmVmLmN1cnJlbnQgPSBmYWxzZTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBwcmV2ZW50UmV0dXJuRm9jdXNSZWYuY3VycmVudCA9IHRydWU7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG4gICAgZXZlbnRzLm9uKCdvcGVuY2hhbmdlJywgb25PcGVuQ2hhbmdlKTtcbiAgICBjb25zdCBmYWxsYmFja0VsID0gZG9jLmNyZWF0ZUVsZW1lbnQoJ3NwYW4nKTtcbiAgICBmYWxsYmFja0VsLnNldEF0dHJpYnV0ZSgndGFiaW5kZXgnLCAnLTEnKTtcbiAgICBmYWxsYmFja0VsLnNldEF0dHJpYnV0ZSgnYXJpYS1oaWRkZW4nLCAndHJ1ZScpO1xuICAgIE9iamVjdC5hc3NpZ24oZmFsbGJhY2tFbC5zdHlsZSwgSElEREVOX1NUWUxFUyk7XG4gICAgaWYgKGlzSW5zaWRlUG9ydGFsICYmIGRvbVJlZmVyZW5jZSkge1xuICAgICAgZG9tUmVmZXJlbmNlLmluc2VydEFkamFjZW50RWxlbWVudCgnYWZ0ZXJlbmQnLCBmYWxsYmFja0VsKTtcbiAgICB9XG4gICAgZnVuY3Rpb24gZ2V0UmV0dXJuRWxlbWVudCgpIHtcbiAgICAgIGlmICh0eXBlb2YgcmV0dXJuRm9jdXNSZWYuY3VycmVudCA9PT0gJ2Jvb2xlYW4nKSB7XG4gICAgICAgIGNvbnN0IGVsID0gZG9tUmVmZXJlbmNlIHx8IGdldFByZXZpb3VzbHlGb2N1c2VkRWxlbWVudCgpO1xuICAgICAgICByZXR1cm4gZWwgJiYgZWwuaXNDb25uZWN0ZWQgPyBlbCA6IGZhbGxiYWNrRWw7XG4gICAgICB9XG4gICAgICByZXR1cm4gcmV0dXJuRm9jdXNSZWYuY3VycmVudC5jdXJyZW50IHx8IGZhbGxiYWNrRWw7XG4gICAgfVxuICAgIHJldHVybiAoKSA9PiB7XG4gICAgICBldmVudHMub2ZmKCdvcGVuY2hhbmdlJywgb25PcGVuQ2hhbmdlKTtcbiAgICAgIGNvbnN0IGFjdGl2ZUVsID0gYWN0aXZlRWxlbWVudChkb2MpO1xuICAgICAgY29uc3QgaXNGb2N1c0luc2lkZUZsb2F0aW5nVHJlZSA9IGNvbnRhaW5zJDEoZmxvYXRpbmcsIGFjdGl2ZUVsKSB8fCB0cmVlICYmIGdldE5vZGVDaGlsZHJlbiQxKHRyZWUubm9kZXNSZWYuY3VycmVudCwgZ2V0Tm9kZUlkKCksIGZhbHNlKS5zb21lKG5vZGUgPT4ge1xuICAgICAgICB2YXIgX25vZGUkY29udGV4dDc7XG4gICAgICAgIHJldHVybiBjb250YWlucyQxKChfbm9kZSRjb250ZXh0NyA9IG5vZGUuY29udGV4dCkgPT0gbnVsbCA/IHZvaWQgMCA6IF9ub2RlJGNvbnRleHQ3LmVsZW1lbnRzLmZsb2F0aW5nLCBhY3RpdmVFbCk7XG4gICAgICB9KTtcbiAgICAgIGNvbnN0IHJldHVybkVsZW1lbnQgPSBnZXRSZXR1cm5FbGVtZW50KCk7XG4gICAgICBxdWV1ZU1pY3JvdGFzaygoKSA9PiB7XG4gICAgICAgIC8vIFRoaXMgaXMgYHJldHVybkVsZW1lbnRgLCBpZiBpdCdzIHRhYmJhYmxlLCBvciBpdHMgZmlyc3QgdGFiYmFibGUgY2hpbGQuXG4gICAgICAgIGNvbnN0IHRhYmJhYmxlUmV0dXJuRWxlbWVudCA9IGdldEZpcnN0VGFiYmFibGVFbGVtZW50KHJldHVybkVsZW1lbnQpO1xuICAgICAgICBpZiAoXG4gICAgICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSByZWFjdC1ob29rcy9leGhhdXN0aXZlLWRlcHNcbiAgICAgICAgcmV0dXJuRm9jdXNSZWYuY3VycmVudCAmJiAhcHJldmVudFJldHVybkZvY3VzUmVmLmN1cnJlbnQgJiYgaXNIVE1MRWxlbWVudCh0YWJiYWJsZVJldHVybkVsZW1lbnQpICYmIChcbiAgICAgICAgLy8gSWYgdGhlIGZvY3VzIG1vdmVkIHNvbWV3aGVyZSBlbHNlIGFmdGVyIG1vdW50LCBhdm9pZCByZXR1cm5pbmcgZm9jdXNcbiAgICAgICAgLy8gc2luY2UgaXQgbGlrZWx5IGVudGVyZWQgYSBkaWZmZXJlbnQgZWxlbWVudCB3aGljaCBzaG91bGQgYmVcbiAgICAgICAgLy8gcmVzcGVjdGVkOiBodHRwczovL2dpdGh1Yi5jb20vZmxvYXRpbmctdWkvZmxvYXRpbmctdWkvaXNzdWVzLzI2MDdcbiAgICAgICAgdGFiYmFibGVSZXR1cm5FbGVtZW50ICE9PSBhY3RpdmVFbCAmJiBhY3RpdmVFbCAhPT0gZG9jLmJvZHkgPyBpc0ZvY3VzSW5zaWRlRmxvYXRpbmdUcmVlIDogdHJ1ZSkpIHtcbiAgICAgICAgICB0YWJiYWJsZVJldHVybkVsZW1lbnQuZm9jdXMoe1xuICAgICAgICAgICAgcHJldmVudFNjcm9sbDogdHJ1ZVxuICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgICAgIGZhbGxiYWNrRWwucmVtb3ZlKCk7XG4gICAgICB9KTtcbiAgICB9O1xuICB9LCBbZGlzYWJsZWQsIGZsb2F0aW5nLCBmbG9hdGluZ0ZvY3VzRWxlbWVudCwgcmV0dXJuRm9jdXNSZWYsIGRhdGFSZWYsIGV2ZW50cywgdHJlZSwgaXNJbnNpZGVQb3J0YWwsIGRvbVJlZmVyZW5jZSwgZ2V0Tm9kZUlkXSk7XG4gIFJlYWN0LnVzZUVmZmVjdCgoKSA9PiB7XG4gICAgLy8gVGhlIGByZXR1cm5Gb2N1c2AgY2xlYW51cCBiZWhhdmlvciBpcyBpbnNpZGUgYSBtaWNyb3Rhc2s7IGVuc3VyZSB3ZVxuICAgIC8vIHdhaXQgZm9yIGl0IHRvIGNvbXBsZXRlIGJlZm9yZSByZXNldHRpbmcgdGhlIGZsYWcuXG4gICAgcXVldWVNaWNyb3Rhc2soKCkgPT4ge1xuICAgICAgcHJldmVudFJldHVybkZvY3VzUmVmLmN1cnJlbnQgPSBmYWxzZTtcbiAgICB9KTtcbiAgICByZXR1cm4gKCkgPT4ge1xuICAgICAgcXVldWVNaWNyb3Rhc2soY2xlYXJEaXNjb25uZWN0ZWRQcmV2aW91c2x5Rm9jdXNlZEVsZW1lbnRzKTtcbiAgICB9O1xuICB9LCBbZGlzYWJsZWRdKTtcblxuICAvLyBTeW5jaHJvbml6ZSB0aGUgYGNvbnRleHRgICYgYG1vZGFsYCB2YWx1ZSB0byB0aGUgRmxvYXRpbmdQb3J0YWwgY29udGV4dC5cbiAgLy8gSXQgd2lsbCBkZWNpZGUgd2hldGhlciBvciBub3QgaXQgbmVlZHMgdG8gcmVuZGVyIGl0cyBvd24gZ3VhcmRzLlxuICB1c2VNb2Rlcm5MYXlvdXRFZmZlY3QoKCkgPT4ge1xuICAgIGlmIChkaXNhYmxlZCkgcmV0dXJuO1xuICAgIGlmICghcG9ydGFsQ29udGV4dCkgcmV0dXJuO1xuICAgIHBvcnRhbENvbnRleHQuc2V0Rm9jdXNNYW5hZ2VyU3RhdGUoe1xuICAgICAgbW9kYWwsXG4gICAgICBjbG9zZU9uRm9jdXNPdXQsXG4gICAgICBvcGVuLFxuICAgICAgb25PcGVuQ2hhbmdlLFxuICAgICAgZG9tUmVmZXJlbmNlXG4gICAgfSk7XG4gICAgcmV0dXJuICgpID0+IHtcbiAgICAgIHBvcnRhbENvbnRleHQuc2V0Rm9jdXNNYW5hZ2VyU3RhdGUobnVsbCk7XG4gICAgfTtcbiAgfSwgW2Rpc2FibGVkLCBwb3J0YWxDb250ZXh0LCBtb2RhbCwgb3Blbiwgb25PcGVuQ2hhbmdlLCBjbG9zZU9uRm9jdXNPdXQsIGRvbVJlZmVyZW5jZV0pO1xuICB1c2VNb2Rlcm5MYXlvdXRFZmZlY3QoKCkgPT4ge1xuICAgIGlmIChkaXNhYmxlZCkgcmV0dXJuO1xuICAgIGlmICghZmxvYXRpbmdGb2N1c0VsZW1lbnQpIHJldHVybjtcbiAgICBoYW5kbGVUYWJJbmRleChmbG9hdGluZ0ZvY3VzRWxlbWVudCwgb3JkZXJSZWYpO1xuICB9LCBbZGlzYWJsZWQsIGZsb2F0aW5nRm9jdXNFbGVtZW50LCBvcmRlclJlZl0pO1xuICBmdW5jdGlvbiByZW5kZXJEaXNtaXNzQnV0dG9uKGxvY2F0aW9uKSB7XG4gICAgaWYgKGRpc2FibGVkIHx8ICF2aXN1YWxseUhpZGRlbkRpc21pc3MgfHwgIW1vZGFsKSB7XG4gICAgICByZXR1cm4gbnVsbDtcbiAgICB9XG4gICAgcmV0dXJuIC8qI19fUFVSRV9fKi9qc3goVmlzdWFsbHlIaWRkZW5EaXNtaXNzLCB7XG4gICAgICByZWY6IGxvY2F0aW9uID09PSAnc3RhcnQnID8gc3RhcnREaXNtaXNzQnV0dG9uUmVmIDogZW5kRGlzbWlzc0J1dHRvblJlZixcbiAgICAgIG9uQ2xpY2s6IGV2ZW50ID0+IG9uT3BlbkNoYW5nZShmYWxzZSwgZXZlbnQubmF0aXZlRXZlbnQpLFxuICAgICAgY2hpbGRyZW46IHR5cGVvZiB2aXN1YWxseUhpZGRlbkRpc21pc3MgPT09ICdzdHJpbmcnID8gdmlzdWFsbHlIaWRkZW5EaXNtaXNzIDogJ0Rpc21pc3MnXG4gICAgfSk7XG4gIH1cbiAgY29uc3Qgc2hvdWxkUmVuZGVyR3VhcmRzID0gIWRpc2FibGVkICYmIGd1YXJkcyAmJiAobW9kYWwgPyAhaXNVbnRyYXBwZWRUeXBlYWJsZUNvbWJvYm94IDogdHJ1ZSkgJiYgKGlzSW5zaWRlUG9ydGFsIHx8IG1vZGFsKTtcbiAgcmV0dXJuIC8qI19fUFVSRV9fKi9qc3hzKEZyYWdtZW50LCB7XG4gICAgY2hpbGRyZW46IFtzaG91bGRSZW5kZXJHdWFyZHMgJiYgLyojX19QVVJFX18qL2pzeChGb2N1c0d1YXJkLCB7XG4gICAgICBcImRhdGEtdHlwZVwiOiBcImluc2lkZVwiLFxuICAgICAgcmVmOiBtZXJnZWRCZWZvcmVHdWFyZFJlZixcbiAgICAgIG9uRm9jdXM6IGV2ZW50ID0+IHtcbiAgICAgICAgaWYgKG1vZGFsKSB7XG4gICAgICAgICAgY29uc3QgZWxzID0gZ2V0VGFiYmFibGVFbGVtZW50cygpO1xuICAgICAgICAgIGVucXVldWVGb2N1cyhvcmRlclswXSA9PT0gJ3JlZmVyZW5jZScgPyBlbHNbMF0gOiBlbHNbZWxzLmxlbmd0aCAtIDFdKTtcbiAgICAgICAgfSBlbHNlIGlmIChwb3J0YWxDb250ZXh0ICE9IG51bGwgJiYgcG9ydGFsQ29udGV4dC5wcmVzZXJ2ZVRhYk9yZGVyICYmIHBvcnRhbENvbnRleHQucG9ydGFsTm9kZSkge1xuICAgICAgICAgIHByZXZlbnRSZXR1cm5Gb2N1c1JlZi5jdXJyZW50ID0gZmFsc2U7XG4gICAgICAgICAgaWYgKGlzT3V0c2lkZUV2ZW50KGV2ZW50LCBwb3J0YWxDb250ZXh0LnBvcnRhbE5vZGUpKSB7XG4gICAgICAgICAgICBjb25zdCBuZXh0VGFiYmFibGUgPSBnZXROZXh0VGFiYmFibGUoZG9tUmVmZXJlbmNlKTtcbiAgICAgICAgICAgIG5leHRUYWJiYWJsZSA9PSBudWxsIHx8IG5leHRUYWJiYWJsZS5mb2N1cygpO1xuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICB2YXIgX3BvcnRhbENvbnRleHQkYmVmb3JlO1xuICAgICAgICAgICAgKF9wb3J0YWxDb250ZXh0JGJlZm9yZSA9IHBvcnRhbENvbnRleHQuYmVmb3JlT3V0c2lkZVJlZi5jdXJyZW50KSA9PSBudWxsIHx8IF9wb3J0YWxDb250ZXh0JGJlZm9yZS5mb2N1cygpO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfVxuICAgIH0pLCAhaXNVbnRyYXBwZWRUeXBlYWJsZUNvbWJvYm94ICYmIHJlbmRlckRpc21pc3NCdXR0b24oJ3N0YXJ0JyksIGNoaWxkcmVuLCByZW5kZXJEaXNtaXNzQnV0dG9uKCdlbmQnKSwgc2hvdWxkUmVuZGVyR3VhcmRzICYmIC8qI19fUFVSRV9fKi9qc3goRm9jdXNHdWFyZCwge1xuICAgICAgXCJkYXRhLXR5cGVcIjogXCJpbnNpZGVcIixcbiAgICAgIHJlZjogbWVyZ2VkQWZ0ZXJHdWFyZFJlZixcbiAgICAgIG9uRm9jdXM6IGV2ZW50ID0+IHtcbiAgICAgICAgaWYgKG1vZGFsKSB7XG4gICAgICAgICAgZW5xdWV1ZUZvY3VzKGdldFRhYmJhYmxlRWxlbWVudHMoKVswXSk7XG4gICAgICAgIH0gZWxzZSBpZiAocG9ydGFsQ29udGV4dCAhPSBudWxsICYmIHBvcnRhbENvbnRleHQucHJlc2VydmVUYWJPcmRlciAmJiBwb3J0YWxDb250ZXh0LnBvcnRhbE5vZGUpIHtcbiAgICAgICAgICBpZiAoY2xvc2VPbkZvY3VzT3V0KSB7XG4gICAgICAgICAgICBwcmV2ZW50UmV0dXJuRm9jdXNSZWYuY3VycmVudCA9IHRydWU7XG4gICAgICAgICAgfVxuICAgICAgICAgIGlmIChpc091dHNpZGVFdmVudChldmVudCwgcG9ydGFsQ29udGV4dC5wb3J0YWxOb2RlKSkge1xuICAgICAgICAgICAgY29uc3QgcHJldlRhYmJhYmxlID0gZ2V0UHJldmlvdXNUYWJiYWJsZShkb21SZWZlcmVuY2UpO1xuICAgICAgICAgICAgcHJldlRhYmJhYmxlID09IG51bGwgfHwgcHJldlRhYmJhYmxlLmZvY3VzKCk7XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHZhciBfcG9ydGFsQ29udGV4dCRhZnRlck87XG4gICAgICAgICAgICAoX3BvcnRhbENvbnRleHQkYWZ0ZXJPID0gcG9ydGFsQ29udGV4dC5hZnRlck91dHNpZGVSZWYuY3VycmVudCkgPT0gbnVsbCB8fCBfcG9ydGFsQ29udGV4dCRhZnRlck8uZm9jdXMoKTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9KV1cbiAgfSk7XG59XG5cbmxldCBsb2NrQ291bnQgPSAwO1xuY29uc3Qgc2Nyb2xsYmFyUHJvcGVydHkgPSAnLS1mbG9hdGluZy11aS1zY3JvbGxiYXItd2lkdGgnO1xuZnVuY3Rpb24gZW5hYmxlU2Nyb2xsTG9jaygpIHtcbiAgY29uc3QgcGxhdGZvcm0gPSBnZXRQbGF0Zm9ybSgpO1xuICBjb25zdCBpc0lPUyA9IC9pUChob25lfGFkfG9kKXxpT1MvLnRlc3QocGxhdGZvcm0pIHx8XG4gIC8vIGlQYWRzIGNhbiBjbGFpbSB0byBiZSBNYWNJbnRlbFxuICBwbGF0Zm9ybSA9PT0gJ01hY0ludGVsJyAmJiBuYXZpZ2F0b3IubWF4VG91Y2hQb2ludHMgPiAxO1xuICBjb25zdCBib2R5U3R5bGUgPSBkb2N1bWVudC5ib2R5LnN0eWxlO1xuICAvLyBSVEwgPGJvZHk+IHNjcm9sbGJhclxuICBjb25zdCBzY3JvbGxiYXJYID0gTWF0aC5yb3VuZChkb2N1bWVudC5kb2N1bWVudEVsZW1lbnQuZ2V0Qm91bmRpbmdDbGllbnRSZWN0KCkubGVmdCkgKyBkb2N1bWVudC5kb2N1bWVudEVsZW1lbnQuc2Nyb2xsTGVmdDtcbiAgY29uc3QgcGFkZGluZ1Byb3AgPSBzY3JvbGxiYXJYID8gJ3BhZGRpbmdMZWZ0JyA6ICdwYWRkaW5nUmlnaHQnO1xuICBjb25zdCBzY3JvbGxiYXJXaWR0aCA9IHdpbmRvdy5pbm5lcldpZHRoIC0gZG9jdW1lbnQuZG9jdW1lbnRFbGVtZW50LmNsaWVudFdpZHRoO1xuICBjb25zdCBzY3JvbGxYID0gYm9keVN0eWxlLmxlZnQgPyBwYXJzZUZsb2F0KGJvZHlTdHlsZS5sZWZ0KSA6IHdpbmRvdy5zY3JvbGxYO1xuICBjb25zdCBzY3JvbGxZID0gYm9keVN0eWxlLnRvcCA/IHBhcnNlRmxvYXQoYm9keVN0eWxlLnRvcCkgOiB3aW5kb3cuc2Nyb2xsWTtcbiAgYm9keVN0eWxlLm92ZXJmbG93ID0gJ2hpZGRlbic7XG4gIGJvZHlTdHlsZS5zZXRQcm9wZXJ0eShzY3JvbGxiYXJQcm9wZXJ0eSwgc2Nyb2xsYmFyV2lkdGggKyBcInB4XCIpO1xuICBpZiAoc2Nyb2xsYmFyV2lkdGgpIHtcbiAgICBib2R5U3R5bGVbcGFkZGluZ1Byb3BdID0gc2Nyb2xsYmFyV2lkdGggKyBcInB4XCI7XG4gIH1cblxuICAvLyBPbmx5IGlPUyBkb2Vzbid0IHJlc3BlY3QgYG92ZXJmbG93OiBoaWRkZW5gIG9uIGRvY3VtZW50LmJvZHksIGFuZCB0aGlzXG4gIC8vIHRlY2huaXF1ZSBoYXMgZmV3ZXIgc2lkZSBlZmZlY3RzLlxuICBpZiAoaXNJT1MpIHtcbiAgICB2YXIgX3dpbmRvdyR2aXN1YWxWaWV3cG9yLCBfd2luZG93JHZpc3VhbFZpZXdwb3IyO1xuICAgIC8vIGlPUyAxMiBkb2VzIG5vdCBzdXBwb3J0IGB2aXN1YWxWaWV3cG9ydGAuXG4gICAgY29uc3Qgb2Zmc2V0TGVmdCA9ICgoX3dpbmRvdyR2aXN1YWxWaWV3cG9yID0gd2luZG93LnZpc3VhbFZpZXdwb3J0KSA9PSBudWxsID8gdm9pZCAwIDogX3dpbmRvdyR2aXN1YWxWaWV3cG9yLm9mZnNldExlZnQpIHx8IDA7XG4gICAgY29uc3Qgb2Zmc2V0VG9wID0gKChfd2luZG93JHZpc3VhbFZpZXdwb3IyID0gd2luZG93LnZpc3VhbFZpZXdwb3J0KSA9PSBudWxsID8gdm9pZCAwIDogX3dpbmRvdyR2aXN1YWxWaWV3cG9yMi5vZmZzZXRUb3ApIHx8IDA7XG4gICAgT2JqZWN0LmFzc2lnbihib2R5U3R5bGUsIHtcbiAgICAgIHBvc2l0aW9uOiAnZml4ZWQnLFxuICAgICAgdG9wOiAtKHNjcm9sbFkgLSBNYXRoLmZsb29yKG9mZnNldFRvcCkpICsgXCJweFwiLFxuICAgICAgbGVmdDogLShzY3JvbGxYIC0gTWF0aC5mbG9vcihvZmZzZXRMZWZ0KSkgKyBcInB4XCIsXG4gICAgICByaWdodDogJzAnXG4gICAgfSk7XG4gIH1cbiAgcmV0dXJuICgpID0+IHtcbiAgICBPYmplY3QuYXNzaWduKGJvZHlTdHlsZSwge1xuICAgICAgb3ZlcmZsb3c6ICcnLFxuICAgICAgW3BhZGRpbmdQcm9wXTogJydcbiAgICB9KTtcbiAgICBib2R5U3R5bGUucmVtb3ZlUHJvcGVydHkoc2Nyb2xsYmFyUHJvcGVydHkpO1xuICAgIGlmIChpc0lPUykge1xuICAgICAgT2JqZWN0LmFzc2lnbihib2R5U3R5bGUsIHtcbiAgICAgICAgcG9zaXRpb246ICcnLFxuICAgICAgICB0b3A6ICcnLFxuICAgICAgICBsZWZ0OiAnJyxcbiAgICAgICAgcmlnaHQ6ICcnXG4gICAgICB9KTtcbiAgICAgIHdpbmRvdy5zY3JvbGxUbyhzY3JvbGxYLCBzY3JvbGxZKTtcbiAgICB9XG4gIH07XG59XG5sZXQgY2xlYW51cCA9ICgpID0+IHt9O1xuXG4vKipcbiAqIFByb3ZpZGVzIGJhc2Ugc3R5bGluZyBmb3IgYSBmaXhlZCBvdmVybGF5IGVsZW1lbnQgdG8gZGltIGNvbnRlbnQgb3IgYmxvY2tcbiAqIHBvaW50ZXIgZXZlbnRzIGJlaGluZCBhIGZsb2F0aW5nIGVsZW1lbnQuXG4gKiBJdCdzIGEgcmVndWxhciBgPGRpdj5gLCBzbyBpdCBjYW4gYmUgc3R5bGVkIHZpYSBhbnkgQ1NTIHNvbHV0aW9uIHlvdSBwcmVmZXIuXG4gKiBAc2VlIGh0dHBzOi8vZmxvYXRpbmctdWkuY29tL2RvY3MvRmxvYXRpbmdPdmVybGF5XG4gKi9cbmNvbnN0IEZsb2F0aW5nT3ZlcmxheSA9IC8qI19fUFVSRV9fKi9SZWFjdC5mb3J3YXJkUmVmKGZ1bmN0aW9uIEZsb2F0aW5nT3ZlcmxheShwcm9wcywgcmVmKSB7XG4gIGNvbnN0IHtcbiAgICBsb2NrU2Nyb2xsID0gZmFsc2UsXG4gICAgLi4ucmVzdFxuICB9ID0gcHJvcHM7XG4gIHVzZU1vZGVybkxheW91dEVmZmVjdCgoKSA9PiB7XG4gICAgaWYgKCFsb2NrU2Nyb2xsKSByZXR1cm47XG4gICAgbG9ja0NvdW50Kys7XG4gICAgaWYgKGxvY2tDb3VudCA9PT0gMSkge1xuICAgICAgY2xlYW51cCA9IGVuYWJsZVNjcm9sbExvY2soKTtcbiAgICB9XG4gICAgcmV0dXJuICgpID0+IHtcbiAgICAgIGxvY2tDb3VudC0tO1xuICAgICAgaWYgKGxvY2tDb3VudCA9PT0gMCkge1xuICAgICAgICBjbGVhbnVwKCk7XG4gICAgICB9XG4gICAgfTtcbiAgfSwgW2xvY2tTY3JvbGxdKTtcbiAgcmV0dXJuIC8qI19fUFVSRV9fKi9qc3goXCJkaXZcIiwge1xuICAgIHJlZjogcmVmLFxuICAgIC4uLnJlc3QsXG4gICAgc3R5bGU6IHtcbiAgICAgIHBvc2l0aW9uOiAnZml4ZWQnLFxuICAgICAgb3ZlcmZsb3c6ICdhdXRvJyxcbiAgICAgIHRvcDogMCxcbiAgICAgIHJpZ2h0OiAwLFxuICAgICAgYm90dG9tOiAwLFxuICAgICAgbGVmdDogMCxcbiAgICAgIC4uLnJlc3Quc3R5bGVcbiAgICB9XG4gIH0pO1xufSk7XG5cbmZ1bmN0aW9uIGlzQnV0dG9uVGFyZ2V0KGV2ZW50KSB7XG4gIHJldHVybiBpc0hUTUxFbGVtZW50KGV2ZW50LnRhcmdldCkgJiYgZXZlbnQudGFyZ2V0LnRhZ05hbWUgPT09ICdCVVRUT04nO1xufVxuZnVuY3Rpb24gaXNBbmNob3JUYXJnZXQoZXZlbnQpIHtcbiAgcmV0dXJuIGlzSFRNTEVsZW1lbnQoZXZlbnQudGFyZ2V0KSAmJiBldmVudC50YXJnZXQudGFnTmFtZSA9PT0gJ0EnO1xufVxuZnVuY3Rpb24gaXNTcGFjZUlnbm9yZWQoZWxlbWVudCkge1xuICByZXR1cm4gaXNUeXBlYWJsZUVsZW1lbnQoZWxlbWVudCk7XG59XG4vKipcbiAqIE9wZW5zIG9yIGNsb3NlcyB0aGUgZmxvYXRpbmcgZWxlbWVudCB3aGVuIGNsaWNraW5nIHRoZSByZWZlcmVuY2UgZWxlbWVudC5cbiAqIEBzZWUgaHR0cHM6Ly9mbG9hdGluZy11aS5jb20vZG9jcy91c2VDbGlja1xuICovXG5mdW5jdGlvbiB1c2VDbGljayhjb250ZXh0LCBwcm9wcykge1xuICBpZiAocHJvcHMgPT09IHZvaWQgMCkge1xuICAgIHByb3BzID0ge307XG4gIH1cbiAgY29uc3Qge1xuICAgIG9wZW4sXG4gICAgb25PcGVuQ2hhbmdlLFxuICAgIGRhdGFSZWYsXG4gICAgZWxlbWVudHM6IHtcbiAgICAgIGRvbVJlZmVyZW5jZVxuICAgIH1cbiAgfSA9IGNvbnRleHQ7XG4gIGNvbnN0IHtcbiAgICBlbmFibGVkID0gdHJ1ZSxcbiAgICBldmVudDogZXZlbnRPcHRpb24gPSAnY2xpY2snLFxuICAgIHRvZ2dsZSA9IHRydWUsXG4gICAgaWdub3JlTW91c2UgPSBmYWxzZSxcbiAgICBrZXlib2FyZEhhbmRsZXJzID0gdHJ1ZSxcbiAgICBzdGlja0lmT3BlbiA9IHRydWVcbiAgfSA9IHByb3BzO1xuICBjb25zdCBwb2ludGVyVHlwZVJlZiA9IFJlYWN0LnVzZVJlZigpO1xuICBjb25zdCBkaWRLZXlEb3duUmVmID0gUmVhY3QudXNlUmVmKGZhbHNlKTtcbiAgY29uc3QgcmVmZXJlbmNlID0gUmVhY3QudXNlTWVtbygoKSA9PiAoe1xuICAgIG9uUG9pbnRlckRvd24oZXZlbnQpIHtcbiAgICAgIHBvaW50ZXJUeXBlUmVmLmN1cnJlbnQgPSBldmVudC5wb2ludGVyVHlwZTtcbiAgICB9LFxuICAgIG9uTW91c2VEb3duKGV2ZW50KSB7XG4gICAgICBjb25zdCBwb2ludGVyVHlwZSA9IHBvaW50ZXJUeXBlUmVmLmN1cnJlbnQ7XG5cbiAgICAgIC8vIElnbm9yZSBhbGwgYnV0dG9ucyBleGNlcHQgZm9yIHRoZSBcIm1haW5cIiBidXR0b24uXG4gICAgICAvLyBodHRwczovL2RldmVsb3Blci5tb3ppbGxhLm9yZy9lbi1VUy9kb2NzL1dlYi9BUEkvTW91c2VFdmVudC9idXR0b25cbiAgICAgIGlmIChldmVudC5idXR0b24gIT09IDApIHJldHVybjtcbiAgICAgIGlmIChldmVudE9wdGlvbiA9PT0gJ2NsaWNrJykgcmV0dXJuO1xuICAgICAgaWYgKGlzTW91c2VMaWtlUG9pbnRlclR5cGUocG9pbnRlclR5cGUsIHRydWUpICYmIGlnbm9yZU1vdXNlKSByZXR1cm47XG4gICAgICBpZiAob3BlbiAmJiB0b2dnbGUgJiYgKGRhdGFSZWYuY3VycmVudC5vcGVuRXZlbnQgJiYgc3RpY2tJZk9wZW4gPyBkYXRhUmVmLmN1cnJlbnQub3BlbkV2ZW50LnR5cGUgPT09ICdtb3VzZWRvd24nIDogdHJ1ZSkpIHtcbiAgICAgICAgb25PcGVuQ2hhbmdlKGZhbHNlLCBldmVudC5uYXRpdmVFdmVudCwgJ2NsaWNrJyk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICAvLyBQcmV2ZW50IHN0ZWFsaW5nIGZvY3VzIGZyb20gdGhlIGZsb2F0aW5nIGVsZW1lbnRcbiAgICAgICAgZXZlbnQucHJldmVudERlZmF1bHQoKTtcbiAgICAgICAgb25PcGVuQ2hhbmdlKHRydWUsIGV2ZW50Lm5hdGl2ZUV2ZW50LCAnY2xpY2snKTtcbiAgICAgIH1cbiAgICB9LFxuICAgIG9uQ2xpY2soZXZlbnQpIHtcbiAgICAgIGNvbnN0IHBvaW50ZXJUeXBlID0gcG9pbnRlclR5cGVSZWYuY3VycmVudDtcbiAgICAgIGlmIChldmVudE9wdGlvbiA9PT0gJ21vdXNlZG93bicgJiYgcG9pbnRlclR5cGVSZWYuY3VycmVudCkge1xuICAgICAgICBwb2ludGVyVHlwZVJlZi5jdXJyZW50ID0gdW5kZWZpbmVkO1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG4gICAgICBpZiAoaXNNb3VzZUxpa2VQb2ludGVyVHlwZShwb2ludGVyVHlwZSwgdHJ1ZSkgJiYgaWdub3JlTW91c2UpIHJldHVybjtcbiAgICAgIGlmIChvcGVuICYmIHRvZ2dsZSAmJiAoZGF0YVJlZi5jdXJyZW50Lm9wZW5FdmVudCAmJiBzdGlja0lmT3BlbiA/IGRhdGFSZWYuY3VycmVudC5vcGVuRXZlbnQudHlwZSA9PT0gJ2NsaWNrJyA6IHRydWUpKSB7XG4gICAgICAgIG9uT3BlbkNoYW5nZShmYWxzZSwgZXZlbnQubmF0aXZlRXZlbnQsICdjbGljaycpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgb25PcGVuQ2hhbmdlKHRydWUsIGV2ZW50Lm5hdGl2ZUV2ZW50LCAnY2xpY2snKTtcbiAgICAgIH1cbiAgICB9LFxuICAgIG9uS2V5RG93bihldmVudCkge1xuICAgICAgcG9pbnRlclR5cGVSZWYuY3VycmVudCA9IHVuZGVmaW5lZDtcbiAgICAgIGlmIChldmVudC5kZWZhdWx0UHJldmVudGVkIHx8ICFrZXlib2FyZEhhbmRsZXJzIHx8IGlzQnV0dG9uVGFyZ2V0KGV2ZW50KSkge1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG4gICAgICBpZiAoZXZlbnQua2V5ID09PSAnICcgJiYgIWlzU3BhY2VJZ25vcmVkKGRvbVJlZmVyZW5jZSkpIHtcbiAgICAgICAgLy8gUHJldmVudCBzY3JvbGxpbmdcbiAgICAgICAgZXZlbnQucHJldmVudERlZmF1bHQoKTtcbiAgICAgICAgZGlkS2V5RG93blJlZi5jdXJyZW50ID0gdHJ1ZTtcbiAgICAgIH1cbiAgICAgIGlmIChpc0FuY2hvclRhcmdldChldmVudCkpIHtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuICAgICAgaWYgKGV2ZW50LmtleSA9PT0gJ0VudGVyJykge1xuICAgICAgICBpZiAob3BlbiAmJiB0b2dnbGUpIHtcbiAgICAgICAgICBvbk9wZW5DaGFuZ2UoZmFsc2UsIGV2ZW50Lm5hdGl2ZUV2ZW50LCAnY2xpY2snKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBvbk9wZW5DaGFuZ2UodHJ1ZSwgZXZlbnQubmF0aXZlRXZlbnQsICdjbGljaycpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfSxcbiAgICBvbktleVVwKGV2ZW50KSB7XG4gICAgICBpZiAoZXZlbnQuZGVmYXVsdFByZXZlbnRlZCB8fCAha2V5Ym9hcmRIYW5kbGVycyB8fCBpc0J1dHRvblRhcmdldChldmVudCkgfHwgaXNTcGFjZUlnbm9yZWQoZG9tUmVmZXJlbmNlKSkge1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG4gICAgICBpZiAoZXZlbnQua2V5ID09PSAnICcgJiYgZGlkS2V5RG93blJlZi5jdXJyZW50KSB7XG4gICAgICAgIGRpZEtleURvd25SZWYuY3VycmVudCA9IGZhbHNlO1xuICAgICAgICBpZiAob3BlbiAmJiB0b2dnbGUpIHtcbiAgICAgICAgICBvbk9wZW5DaGFuZ2UoZmFsc2UsIGV2ZW50Lm5hdGl2ZUV2ZW50LCAnY2xpY2snKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBvbk9wZW5DaGFuZ2UodHJ1ZSwgZXZlbnQubmF0aXZlRXZlbnQsICdjbGljaycpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICB9KSwgW2RhdGFSZWYsIGRvbVJlZmVyZW5jZSwgZXZlbnRPcHRpb24sIGlnbm9yZU1vdXNlLCBrZXlib2FyZEhhbmRsZXJzLCBvbk9wZW5DaGFuZ2UsIG9wZW4sIHN0aWNrSWZPcGVuLCB0b2dnbGVdKTtcbiAgcmV0dXJuIFJlYWN0LnVzZU1lbW8oKCkgPT4gZW5hYmxlZCA/IHtcbiAgICByZWZlcmVuY2VcbiAgfSA6IHt9LCBbZW5hYmxlZCwgcmVmZXJlbmNlXSk7XG59XG5cbmZ1bmN0aW9uIGNyZWF0ZVZpcnR1YWxFbGVtZW50KGRvbUVsZW1lbnQsIGRhdGEpIHtcbiAgbGV0IG9mZnNldFggPSBudWxsO1xuICBsZXQgb2Zmc2V0WSA9IG51bGw7XG4gIGxldCBpc0F1dG9VcGRhdGVFdmVudCA9IGZhbHNlO1xuICByZXR1cm4ge1xuICAgIGNvbnRleHRFbGVtZW50OiBkb21FbGVtZW50IHx8IHVuZGVmaW5lZCxcbiAgICBnZXRCb3VuZGluZ0NsaWVudFJlY3QoKSB7XG4gICAgICB2YXIgX2RhdGEkZGF0YVJlZiRjdXJyZW50O1xuICAgICAgY29uc3QgZG9tUmVjdCA9IChkb21FbGVtZW50ID09IG51bGwgPyB2b2lkIDAgOiBkb21FbGVtZW50LmdldEJvdW5kaW5nQ2xpZW50UmVjdCgpKSB8fCB7XG4gICAgICAgIHdpZHRoOiAwLFxuICAgICAgICBoZWlnaHQ6IDAsXG4gICAgICAgIHg6IDAsXG4gICAgICAgIHk6IDBcbiAgICAgIH07XG4gICAgICBjb25zdCBpc1hBeGlzID0gZGF0YS5heGlzID09PSAneCcgfHwgZGF0YS5heGlzID09PSAnYm90aCc7XG4gICAgICBjb25zdCBpc1lBeGlzID0gZGF0YS5heGlzID09PSAneScgfHwgZGF0YS5heGlzID09PSAnYm90aCc7XG4gICAgICBjb25zdCBjYW5UcmFja0N1cnNvck9uQXV0b1VwZGF0ZSA9IFsnbW91c2VlbnRlcicsICdtb3VzZW1vdmUnXS5pbmNsdWRlcygoKF9kYXRhJGRhdGFSZWYkY3VycmVudCA9IGRhdGEuZGF0YVJlZi5jdXJyZW50Lm9wZW5FdmVudCkgPT0gbnVsbCA/IHZvaWQgMCA6IF9kYXRhJGRhdGFSZWYkY3VycmVudC50eXBlKSB8fCAnJykgJiYgZGF0YS5wb2ludGVyVHlwZSAhPT0gJ3RvdWNoJztcbiAgICAgIGxldCB3aWR0aCA9IGRvbVJlY3Qud2lkdGg7XG4gICAgICBsZXQgaGVpZ2h0ID0gZG9tUmVjdC5oZWlnaHQ7XG4gICAgICBsZXQgeCA9IGRvbVJlY3QueDtcbiAgICAgIGxldCB5ID0gZG9tUmVjdC55O1xuICAgICAgaWYgKG9mZnNldFggPT0gbnVsbCAmJiBkYXRhLnggJiYgaXNYQXhpcykge1xuICAgICAgICBvZmZzZXRYID0gZG9tUmVjdC54IC0gZGF0YS54O1xuICAgICAgfVxuICAgICAgaWYgKG9mZnNldFkgPT0gbnVsbCAmJiBkYXRhLnkgJiYgaXNZQXhpcykge1xuICAgICAgICBvZmZzZXRZID0gZG9tUmVjdC55IC0gZGF0YS55O1xuICAgICAgfVxuICAgICAgeCAtPSBvZmZzZXRYIHx8IDA7XG4gICAgICB5IC09IG9mZnNldFkgfHwgMDtcbiAgICAgIHdpZHRoID0gMDtcbiAgICAgIGhlaWdodCA9IDA7XG4gICAgICBpZiAoIWlzQXV0b1VwZGF0ZUV2ZW50IHx8IGNhblRyYWNrQ3Vyc29yT25BdXRvVXBkYXRlKSB7XG4gICAgICAgIHdpZHRoID0gZGF0YS5heGlzID09PSAneScgPyBkb21SZWN0LndpZHRoIDogMDtcbiAgICAgICAgaGVpZ2h0ID0gZGF0YS5heGlzID09PSAneCcgPyBkb21SZWN0LmhlaWdodCA6IDA7XG4gICAgICAgIHggPSBpc1hBeGlzICYmIGRhdGEueCAhPSBudWxsID8gZGF0YS54IDogeDtcbiAgICAgICAgeSA9IGlzWUF4aXMgJiYgZGF0YS55ICE9IG51bGwgPyBkYXRhLnkgOiB5O1xuICAgICAgfSBlbHNlIGlmIChpc0F1dG9VcGRhdGVFdmVudCAmJiAhY2FuVHJhY2tDdXJzb3JPbkF1dG9VcGRhdGUpIHtcbiAgICAgICAgaGVpZ2h0ID0gZGF0YS5heGlzID09PSAneCcgPyBkb21SZWN0LmhlaWdodCA6IGhlaWdodDtcbiAgICAgICAgd2lkdGggPSBkYXRhLmF4aXMgPT09ICd5JyA/IGRvbVJlY3Qud2lkdGggOiB3aWR0aDtcbiAgICAgIH1cbiAgICAgIGlzQXV0b1VwZGF0ZUV2ZW50ID0gdHJ1ZTtcbiAgICAgIHJldHVybiB7XG4gICAgICAgIHdpZHRoLFxuICAgICAgICBoZWlnaHQsXG4gICAgICAgIHgsXG4gICAgICAgIHksXG4gICAgICAgIHRvcDogeSxcbiAgICAgICAgcmlnaHQ6IHggKyB3aWR0aCxcbiAgICAgICAgYm90dG9tOiB5ICsgaGVpZ2h0LFxuICAgICAgICBsZWZ0OiB4XG4gICAgICB9O1xuICAgIH1cbiAgfTtcbn1cbmZ1bmN0aW9uIGlzTW91c2VCYXNlZEV2ZW50KGV2ZW50KSB7XG4gIHJldHVybiBldmVudCAhPSBudWxsICYmIGV2ZW50LmNsaWVudFggIT0gbnVsbDtcbn1cbi8qKlxuICogUG9zaXRpb25zIHRoZSBmbG9hdGluZyBlbGVtZW50IHJlbGF0aXZlIHRvIGEgY2xpZW50IHBvaW50IChpbiB0aGUgdmlld3BvcnQpLFxuICogc3VjaCBhcyB0aGUgbW91c2UgcG9zaXRpb24uIEJ5IGRlZmF1bHQsIGl0IGZvbGxvd3MgdGhlIG1vdXNlIGN1cnNvci5cbiAqIEBzZWUgaHR0cHM6Ly9mbG9hdGluZy11aS5jb20vZG9jcy91c2VDbGllbnRQb2ludFxuICovXG5mdW5jdGlvbiB1c2VDbGllbnRQb2ludChjb250ZXh0LCBwcm9wcykge1xuICBpZiAocHJvcHMgPT09IHZvaWQgMCkge1xuICAgIHByb3BzID0ge307XG4gIH1cbiAgY29uc3Qge1xuICAgIG9wZW4sXG4gICAgZGF0YVJlZixcbiAgICBlbGVtZW50czoge1xuICAgICAgZmxvYXRpbmcsXG4gICAgICBkb21SZWZlcmVuY2VcbiAgICB9LFxuICAgIHJlZnNcbiAgfSA9IGNvbnRleHQ7XG4gIGNvbnN0IHtcbiAgICBlbmFibGVkID0gdHJ1ZSxcbiAgICBheGlzID0gJ2JvdGgnLFxuICAgIHggPSBudWxsLFxuICAgIHkgPSBudWxsXG4gIH0gPSBwcm9wcztcbiAgY29uc3QgaW5pdGlhbFJlZiA9IFJlYWN0LnVzZVJlZihmYWxzZSk7XG4gIGNvbnN0IGNsZWFudXBMaXN0ZW5lclJlZiA9IFJlYWN0LnVzZVJlZihudWxsKTtcbiAgY29uc3QgW3BvaW50ZXJUeXBlLCBzZXRQb2ludGVyVHlwZV0gPSBSZWFjdC51c2VTdGF0ZSgpO1xuICBjb25zdCBbcmVhY3RpdmUsIHNldFJlYWN0aXZlXSA9IFJlYWN0LnVzZVN0YXRlKFtdKTtcbiAgY29uc3Qgc2V0UmVmZXJlbmNlID0gdXNlRWZmZWN0RXZlbnQoKHgsIHkpID0+IHtcbiAgICBpZiAoaW5pdGlhbFJlZi5jdXJyZW50KSByZXR1cm47XG5cbiAgICAvLyBQcmV2ZW50IHNldHRpbmcgaWYgdGhlIG9wZW4gZXZlbnQgd2FzIG5vdCBhIG1vdXNlLWxpa2Ugb25lXG4gICAgLy8gKGUuZy4gZm9jdXMgdG8gb3BlbiwgdGhlbiBob3ZlciBvdmVyIHRoZSByZWZlcmVuY2UgZWxlbWVudCkuXG4gICAgLy8gT25seSBhcHBseSBpZiB0aGUgZXZlbnQgZXhpc3RzLlxuICAgIGlmIChkYXRhUmVmLmN1cnJlbnQub3BlbkV2ZW50ICYmICFpc01vdXNlQmFzZWRFdmVudChkYXRhUmVmLmN1cnJlbnQub3BlbkV2ZW50KSkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICByZWZzLnNldFBvc2l0aW9uUmVmZXJlbmNlKGNyZWF0ZVZpcnR1YWxFbGVtZW50KGRvbVJlZmVyZW5jZSwge1xuICAgICAgeCxcbiAgICAgIHksXG4gICAgICBheGlzLFxuICAgICAgZGF0YVJlZixcbiAgICAgIHBvaW50ZXJUeXBlXG4gICAgfSkpO1xuICB9KTtcbiAgY29uc3QgaGFuZGxlUmVmZXJlbmNlRW50ZXJPck1vdmUgPSB1c2VFZmZlY3RFdmVudChldmVudCA9PiB7XG4gICAgaWYgKHggIT0gbnVsbCB8fCB5ICE9IG51bGwpIHJldHVybjtcbiAgICBpZiAoIW9wZW4pIHtcbiAgICAgIHNldFJlZmVyZW5jZShldmVudC5jbGllbnRYLCBldmVudC5jbGllbnRZKTtcbiAgICB9IGVsc2UgaWYgKCFjbGVhbnVwTGlzdGVuZXJSZWYuY3VycmVudCkge1xuICAgICAgLy8gSWYgdGhlcmUncyBubyBjbGVhbnVwLCB0aGVyZSdzIG5vIGxpc3RlbmVyLCBidXQgd2Ugd2FudCB0byBlbnN1cmVcbiAgICAgIC8vIHdlIGFkZCB0aGUgbGlzdGVuZXIgaWYgdGhlIGN1cnNvciBsYW5kZWQgb24gdGhlIGZsb2F0aW5nIGVsZW1lbnQgYW5kXG4gICAgICAvLyB0aGVuIGJhY2sgb24gdGhlIHJlZmVyZW5jZSAoaS5lLiBpdCdzIGludGVyYWN0aXZlKS5cbiAgICAgIHNldFJlYWN0aXZlKFtdKTtcbiAgICB9XG4gIH0pO1xuXG4gIC8vIElmIHRoZSBwb2ludGVyIGlzIGEgbW91c2UtbGlrZSBwb2ludGVyLCB3ZSB3YW50IHRvIGNvbnRpbnVlIGZvbGxvd2luZyB0aGVcbiAgLy8gbW91c2UgZXZlbiBpZiB0aGUgZmxvYXRpbmcgZWxlbWVudCBpcyB0cmFuc2l0aW9uaW5nIG91dC4gT24gdG91Y2hcbiAgLy8gZGV2aWNlcywgdGhpcyBpcyB1bmRlc2lyYWJsZSBiZWNhdXNlIHRoZSBmbG9hdGluZyBlbGVtZW50IHdpbGwgbW92ZSB0b1xuICAvLyB0aGUgZGlzbWlzc2FsIHRvdWNoIHBvaW50LlxuICBjb25zdCBvcGVuQ2hlY2sgPSBpc01vdXNlTGlrZVBvaW50ZXJUeXBlKHBvaW50ZXJUeXBlKSA/IGZsb2F0aW5nIDogb3BlbjtcbiAgY29uc3QgYWRkTGlzdGVuZXIgPSBSZWFjdC51c2VDYWxsYmFjaygoKSA9PiB7XG4gICAgLy8gRXhwbGljaXRseSBzcGVjaWZpZWQgYHhgL2B5YCBjb29yZGluYXRlcyBzaG91bGRuJ3QgYWRkIGEgbGlzdGVuZXIuXG4gICAgaWYgKCFvcGVuQ2hlY2sgfHwgIWVuYWJsZWQgfHwgeCAhPSBudWxsIHx8IHkgIT0gbnVsbCkgcmV0dXJuO1xuICAgIGNvbnN0IHdpbiA9IGdldFdpbmRvdyhmbG9hdGluZyk7XG4gICAgZnVuY3Rpb24gaGFuZGxlTW91c2VNb3ZlKGV2ZW50KSB7XG4gICAgICBjb25zdCB0YXJnZXQgPSBnZXRUYXJnZXQkMShldmVudCk7XG4gICAgICBpZiAoIWNvbnRhaW5zJDEoZmxvYXRpbmcsIHRhcmdldCkpIHtcbiAgICAgICAgc2V0UmVmZXJlbmNlKGV2ZW50LmNsaWVudFgsIGV2ZW50LmNsaWVudFkpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgd2luLnJlbW92ZUV2ZW50TGlzdGVuZXIoJ21vdXNlbW92ZScsIGhhbmRsZU1vdXNlTW92ZSk7XG4gICAgICAgIGNsZWFudXBMaXN0ZW5lclJlZi5jdXJyZW50ID0gbnVsbDtcbiAgICAgIH1cbiAgICB9XG4gICAgaWYgKCFkYXRhUmVmLmN1cnJlbnQub3BlbkV2ZW50IHx8IGlzTW91c2VCYXNlZEV2ZW50KGRhdGFSZWYuY3VycmVudC5vcGVuRXZlbnQpKSB7XG4gICAgICB3aW4uYWRkRXZlbnRMaXN0ZW5lcignbW91c2Vtb3ZlJywgaGFuZGxlTW91c2VNb3ZlKTtcbiAgICAgIGNvbnN0IGNsZWFudXAgPSAoKSA9PiB7XG4gICAgICAgIHdpbi5yZW1vdmVFdmVudExpc3RlbmVyKCdtb3VzZW1vdmUnLCBoYW5kbGVNb3VzZU1vdmUpO1xuICAgICAgICBjbGVhbnVwTGlzdGVuZXJSZWYuY3VycmVudCA9IG51bGw7XG4gICAgICB9O1xuICAgICAgY2xlYW51cExpc3RlbmVyUmVmLmN1cnJlbnQgPSBjbGVhbnVwO1xuICAgICAgcmV0dXJuIGNsZWFudXA7XG4gICAgfVxuICAgIHJlZnMuc2V0UG9zaXRpb25SZWZlcmVuY2UoZG9tUmVmZXJlbmNlKTtcbiAgfSwgW29wZW5DaGVjaywgZW5hYmxlZCwgeCwgeSwgZmxvYXRpbmcsIGRhdGFSZWYsIHJlZnMsIGRvbVJlZmVyZW5jZSwgc2V0UmVmZXJlbmNlXSk7XG4gIFJlYWN0LnVzZUVmZmVjdCgoKSA9PiB7XG4gICAgcmV0dXJuIGFkZExpc3RlbmVyKCk7XG4gIH0sIFthZGRMaXN0ZW5lciwgcmVhY3RpdmVdKTtcbiAgUmVhY3QudXNlRWZmZWN0KCgpID0+IHtcbiAgICBpZiAoZW5hYmxlZCAmJiAhZmxvYXRpbmcpIHtcbiAgICAgIGluaXRpYWxSZWYuY3VycmVudCA9IGZhbHNlO1xuICAgIH1cbiAgfSwgW2VuYWJsZWQsIGZsb2F0aW5nXSk7XG4gIFJlYWN0LnVzZUVmZmVjdCgoKSA9PiB7XG4gICAgaWYgKCFlbmFibGVkICYmIG9wZW4pIHtcbiAgICAgIGluaXRpYWxSZWYuY3VycmVudCA9IHRydWU7XG4gICAgfVxuICB9LCBbZW5hYmxlZCwgb3Blbl0pO1xuICB1c2VNb2Rlcm5MYXlvdXRFZmZlY3QoKCkgPT4ge1xuICAgIGlmIChlbmFibGVkICYmICh4ICE9IG51bGwgfHwgeSAhPSBudWxsKSkge1xuICAgICAgaW5pdGlhbFJlZi5jdXJyZW50ID0gZmFsc2U7XG4gICAgICBzZXRSZWZlcmVuY2UoeCwgeSk7XG4gICAgfVxuICB9LCBbZW5hYmxlZCwgeCwgeSwgc2V0UmVmZXJlbmNlXSk7XG4gIGNvbnN0IHJlZmVyZW5jZSA9IFJlYWN0LnVzZU1lbW8oKCkgPT4ge1xuICAgIGZ1bmN0aW9uIHNldFBvaW50ZXJUeXBlUmVmKF9yZWYpIHtcbiAgICAgIGxldCB7XG4gICAgICAgIHBvaW50ZXJUeXBlXG4gICAgICB9ID0gX3JlZjtcbiAgICAgIHNldFBvaW50ZXJUeXBlKHBvaW50ZXJUeXBlKTtcbiAgICB9XG4gICAgcmV0dXJuIHtcbiAgICAgIG9uUG9pbnRlckRvd246IHNldFBvaW50ZXJUeXBlUmVmLFxuICAgICAgb25Qb2ludGVyRW50ZXI6IHNldFBvaW50ZXJUeXBlUmVmLFxuICAgICAgb25Nb3VzZU1vdmU6IGhhbmRsZVJlZmVyZW5jZUVudGVyT3JNb3ZlLFxuICAgICAgb25Nb3VzZUVudGVyOiBoYW5kbGVSZWZlcmVuY2VFbnRlck9yTW92ZVxuICAgIH07XG4gIH0sIFtoYW5kbGVSZWZlcmVuY2VFbnRlck9yTW92ZV0pO1xuICByZXR1cm4gUmVhY3QudXNlTWVtbygoKSA9PiBlbmFibGVkID8ge1xuICAgIHJlZmVyZW5jZVxuICB9IDoge30sIFtlbmFibGVkLCByZWZlcmVuY2VdKTtcbn1cblxuY29uc3QgYnViYmxlSGFuZGxlcktleXMgPSB7XG4gIHBvaW50ZXJkb3duOiAnb25Qb2ludGVyRG93bicsXG4gIG1vdXNlZG93bjogJ29uTW91c2VEb3duJyxcbiAgY2xpY2s6ICdvbkNsaWNrJ1xufTtcbmNvbnN0IGNhcHR1cmVIYW5kbGVyS2V5cyA9IHtcbiAgcG9pbnRlcmRvd246ICdvblBvaW50ZXJEb3duQ2FwdHVyZScsXG4gIG1vdXNlZG93bjogJ29uTW91c2VEb3duQ2FwdHVyZScsXG4gIGNsaWNrOiAnb25DbGlja0NhcHR1cmUnXG59O1xuY29uc3Qgbm9ybWFsaXplUHJvcCA9IG5vcm1hbGl6YWJsZSA9PiB7XG4gIHZhciBfbm9ybWFsaXphYmxlJGVzY2FwZUssIF9ub3JtYWxpemFibGUkb3V0c2lkZTtcbiAgcmV0dXJuIHtcbiAgICBlc2NhcGVLZXk6IHR5cGVvZiBub3JtYWxpemFibGUgPT09ICdib29sZWFuJyA/IG5vcm1hbGl6YWJsZSA6IChfbm9ybWFsaXphYmxlJGVzY2FwZUsgPSBub3JtYWxpemFibGUgPT0gbnVsbCA/IHZvaWQgMCA6IG5vcm1hbGl6YWJsZS5lc2NhcGVLZXkpICE9IG51bGwgPyBfbm9ybWFsaXphYmxlJGVzY2FwZUsgOiBmYWxzZSxcbiAgICBvdXRzaWRlUHJlc3M6IHR5cGVvZiBub3JtYWxpemFibGUgPT09ICdib29sZWFuJyA/IG5vcm1hbGl6YWJsZSA6IChfbm9ybWFsaXphYmxlJG91dHNpZGUgPSBub3JtYWxpemFibGUgPT0gbnVsbCA/IHZvaWQgMCA6IG5vcm1hbGl6YWJsZS5vdXRzaWRlUHJlc3MpICE9IG51bGwgPyBfbm9ybWFsaXphYmxlJG91dHNpZGUgOiB0cnVlXG4gIH07XG59O1xuLyoqXG4gKiBDbG9zZXMgdGhlIGZsb2F0aW5nIGVsZW1lbnQgd2hlbiBhIGRpc21pc3NhbCBpcyByZXF1ZXN0ZWQg4oCUIGJ5IGRlZmF1bHQsIHdoZW5cbiAqIHRoZSB1c2VyIHByZXNzZXMgdGhlIGBlc2NhcGVgIGtleSBvciBvdXRzaWRlIG9mIHRoZSBmbG9hdGluZyBlbGVtZW50LlxuICogQHNlZSBodHRwczovL2Zsb2F0aW5nLXVpLmNvbS9kb2NzL3VzZURpc21pc3NcbiAqL1xuZnVuY3Rpb24gdXNlRGlzbWlzcyhjb250ZXh0LCBwcm9wcykge1xuICBpZiAocHJvcHMgPT09IHZvaWQgMCkge1xuICAgIHByb3BzID0ge307XG4gIH1cbiAgY29uc3Qge1xuICAgIG9wZW4sXG4gICAgb25PcGVuQ2hhbmdlLFxuICAgIGVsZW1lbnRzLFxuICAgIGRhdGFSZWZcbiAgfSA9IGNvbnRleHQ7XG4gIGNvbnN0IHtcbiAgICBlbmFibGVkID0gdHJ1ZSxcbiAgICBlc2NhcGVLZXkgPSB0cnVlLFxuICAgIG91dHNpZGVQcmVzczogdW5zdGFibGVfb3V0c2lkZVByZXNzID0gdHJ1ZSxcbiAgICBvdXRzaWRlUHJlc3NFdmVudCA9ICdwb2ludGVyZG93bicsXG4gICAgcmVmZXJlbmNlUHJlc3MgPSBmYWxzZSxcbiAgICByZWZlcmVuY2VQcmVzc0V2ZW50ID0gJ3BvaW50ZXJkb3duJyxcbiAgICBhbmNlc3RvclNjcm9sbCA9IGZhbHNlLFxuICAgIGJ1YmJsZXMsXG4gICAgY2FwdHVyZVxuICB9ID0gcHJvcHM7XG4gIGNvbnN0IHRyZWUgPSB1c2VGbG9hdGluZ1RyZWUoKTtcbiAgY29uc3Qgb3V0c2lkZVByZXNzRm4gPSB1c2VFZmZlY3RFdmVudCh0eXBlb2YgdW5zdGFibGVfb3V0c2lkZVByZXNzID09PSAnZnVuY3Rpb24nID8gdW5zdGFibGVfb3V0c2lkZVByZXNzIDogKCkgPT4gZmFsc2UpO1xuICBjb25zdCBvdXRzaWRlUHJlc3MgPSB0eXBlb2YgdW5zdGFibGVfb3V0c2lkZVByZXNzID09PSAnZnVuY3Rpb24nID8gb3V0c2lkZVByZXNzRm4gOiB1bnN0YWJsZV9vdXRzaWRlUHJlc3M7XG4gIGNvbnN0IGVuZGVkT3JTdGFydGVkSW5zaWRlUmVmID0gUmVhY3QudXNlUmVmKGZhbHNlKTtcbiAgY29uc3Qge1xuICAgIGVzY2FwZUtleTogZXNjYXBlS2V5QnViYmxlcyxcbiAgICBvdXRzaWRlUHJlc3M6IG91dHNpZGVQcmVzc0J1YmJsZXNcbiAgfSA9IG5vcm1hbGl6ZVByb3AoYnViYmxlcyk7XG4gIGNvbnN0IHtcbiAgICBlc2NhcGVLZXk6IGVzY2FwZUtleUNhcHR1cmUsXG4gICAgb3V0c2lkZVByZXNzOiBvdXRzaWRlUHJlc3NDYXB0dXJlXG4gIH0gPSBub3JtYWxpemVQcm9wKGNhcHR1cmUpO1xuICBjb25zdCBpc0NvbXBvc2luZ1JlZiA9IFJlYWN0LnVzZVJlZihmYWxzZSk7XG4gIGNvbnN0IGNsb3NlT25Fc2NhcGVLZXlEb3duID0gdXNlRWZmZWN0RXZlbnQoZXZlbnQgPT4ge1xuICAgIHZhciBfZGF0YVJlZiRjdXJyZW50JGZsb2E7XG4gICAgaWYgKCFvcGVuIHx8ICFlbmFibGVkIHx8ICFlc2NhcGVLZXkgfHwgZXZlbnQua2V5ICE9PSAnRXNjYXBlJykge1xuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIC8vIFdhaXQgdW50aWwgSU1FIGlzIHNldHRsZWQuIFByZXNzaW5nIGBFc2NhcGVgIHdoaWxlIGNvbXBvc2luZyBzaG91bGRcbiAgICAvLyBjbG9zZSB0aGUgY29tcG9zZSBtZW51LCBidXQgbm90IHRoZSBmbG9hdGluZyBlbGVtZW50LlxuICAgIGlmIChpc0NvbXBvc2luZ1JlZi5jdXJyZW50KSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIGNvbnN0IG5vZGVJZCA9IChfZGF0YVJlZiRjdXJyZW50JGZsb2EgPSBkYXRhUmVmLmN1cnJlbnQuZmxvYXRpbmdDb250ZXh0KSA9PSBudWxsID8gdm9pZCAwIDogX2RhdGFSZWYkY3VycmVudCRmbG9hLm5vZGVJZDtcbiAgICBjb25zdCBjaGlsZHJlbiA9IHRyZWUgPyBnZXROb2RlQ2hpbGRyZW4kMSh0cmVlLm5vZGVzUmVmLmN1cnJlbnQsIG5vZGVJZCkgOiBbXTtcbiAgICBpZiAoIWVzY2FwZUtleUJ1YmJsZXMpIHtcbiAgICAgIGV2ZW50LnN0b3BQcm9wYWdhdGlvbigpO1xuICAgICAgaWYgKGNoaWxkcmVuLmxlbmd0aCA+IDApIHtcbiAgICAgICAgbGV0IHNob3VsZERpc21pc3MgPSB0cnVlO1xuICAgICAgICBjaGlsZHJlbi5mb3JFYWNoKGNoaWxkID0+IHtcbiAgICAgICAgICB2YXIgX2NoaWxkJGNvbnRleHQ7XG4gICAgICAgICAgaWYgKChfY2hpbGQkY29udGV4dCA9IGNoaWxkLmNvbnRleHQpICE9IG51bGwgJiYgX2NoaWxkJGNvbnRleHQub3BlbiAmJiAhY2hpbGQuY29udGV4dC5kYXRhUmVmLmN1cnJlbnQuX19lc2NhcGVLZXlCdWJibGVzKSB7XG4gICAgICAgICAgICBzaG91bGREaXNtaXNzID0gZmFsc2U7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICAgICAgaWYgKCFzaG91bGREaXNtaXNzKSB7XG4gICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICAgIG9uT3BlbkNoYW5nZShmYWxzZSwgaXNSZWFjdEV2ZW50KGV2ZW50KSA/IGV2ZW50Lm5hdGl2ZUV2ZW50IDogZXZlbnQsICdlc2NhcGUta2V5Jyk7XG4gIH0pO1xuICBjb25zdCBjbG9zZU9uRXNjYXBlS2V5RG93bkNhcHR1cmUgPSB1c2VFZmZlY3RFdmVudChldmVudCA9PiB7XG4gICAgdmFyIF9nZXRUYXJnZXQyO1xuICAgIGNvbnN0IGNhbGxiYWNrID0gKCkgPT4ge1xuICAgICAgdmFyIF9nZXRUYXJnZXQ7XG4gICAgICBjbG9zZU9uRXNjYXBlS2V5RG93bihldmVudCk7XG4gICAgICAoX2dldFRhcmdldCA9IGdldFRhcmdldCQxKGV2ZW50KSkgPT0gbnVsbCB8fCBfZ2V0VGFyZ2V0LnJlbW92ZUV2ZW50TGlzdGVuZXIoJ2tleWRvd24nLCBjYWxsYmFjayk7XG4gICAgfTtcbiAgICAoX2dldFRhcmdldDIgPSBnZXRUYXJnZXQkMShldmVudCkpID09IG51bGwgfHwgX2dldFRhcmdldDIuYWRkRXZlbnRMaXN0ZW5lcigna2V5ZG93bicsIGNhbGxiYWNrKTtcbiAgfSk7XG4gIGNvbnN0IGNsb3NlT25QcmVzc091dHNpZGUgPSB1c2VFZmZlY3RFdmVudChldmVudCA9PiB7XG4gICAgdmFyIF9kYXRhUmVmJGN1cnJlbnQkZmxvYTI7XG4gICAgLy8gR2l2ZW4gZGV2ZWxvcGVycyBjYW4gc3RvcCB0aGUgcHJvcGFnYXRpb24gb2YgdGhlIHN5bnRoZXRpYyBldmVudCxcbiAgICAvLyB3ZSBjYW4gb25seSBiZSBjb25maWRlbnQgd2l0aCBhIHBvc2l0aXZlIHZhbHVlLlxuICAgIGNvbnN0IGluc2lkZVJlYWN0VHJlZSA9IGRhdGFSZWYuY3VycmVudC5pbnNpZGVSZWFjdFRyZWU7XG4gICAgZGF0YVJlZi5jdXJyZW50Lmluc2lkZVJlYWN0VHJlZSA9IGZhbHNlO1xuXG4gICAgLy8gV2hlbiBjbGljayBvdXRzaWRlIGlzIGxhenkgKGBjbGlja2AgZXZlbnQpLCBoYW5kbGUgZHJhZ2dpbmcuXG4gICAgLy8gRG9uJ3QgY2xvc2UgaWY6XG4gICAgLy8gLSBUaGUgY2xpY2sgc3RhcnRlZCBpbnNpZGUgdGhlIGZsb2F0aW5nIGVsZW1lbnQuXG4gICAgLy8gLSBUaGUgY2xpY2sgZW5kZWQgaW5zaWRlIHRoZSBmbG9hdGluZyBlbGVtZW50LlxuICAgIGNvbnN0IGVuZGVkT3JTdGFydGVkSW5zaWRlID0gZW5kZWRPclN0YXJ0ZWRJbnNpZGVSZWYuY3VycmVudDtcbiAgICBlbmRlZE9yU3RhcnRlZEluc2lkZVJlZi5jdXJyZW50ID0gZmFsc2U7XG4gICAgaWYgKG91dHNpZGVQcmVzc0V2ZW50ID09PSAnY2xpY2snICYmIGVuZGVkT3JTdGFydGVkSW5zaWRlKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIGlmIChpbnNpZGVSZWFjdFRyZWUpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgaWYgKHR5cGVvZiBvdXRzaWRlUHJlc3MgPT09ICdmdW5jdGlvbicgJiYgIW91dHNpZGVQcmVzcyhldmVudCkpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgY29uc3QgdGFyZ2V0ID0gZ2V0VGFyZ2V0JDEoZXZlbnQpO1xuICAgIGNvbnN0IGluZXJ0U2VsZWN0b3IgPSBcIltcIiArIGNyZWF0ZUF0dHJpYnV0ZSgnaW5lcnQnKSArIFwiXVwiO1xuICAgIGNvbnN0IG1hcmtlcnMgPSBnZXREb2N1bWVudCQxKGVsZW1lbnRzLmZsb2F0aW5nKS5xdWVyeVNlbGVjdG9yQWxsKGluZXJ0U2VsZWN0b3IpO1xuICAgIGxldCB0YXJnZXRSb290QW5jZXN0b3IgPSBpc0VsZW1lbnQodGFyZ2V0KSA/IHRhcmdldCA6IG51bGw7XG4gICAgd2hpbGUgKHRhcmdldFJvb3RBbmNlc3RvciAmJiAhaXNMYXN0VHJhdmVyc2FibGVOb2RlKHRhcmdldFJvb3RBbmNlc3RvcikpIHtcbiAgICAgIGNvbnN0IG5leHRQYXJlbnQgPSBnZXRQYXJlbnROb2RlKHRhcmdldFJvb3RBbmNlc3Rvcik7XG4gICAgICBpZiAoaXNMYXN0VHJhdmVyc2FibGVOb2RlKG5leHRQYXJlbnQpIHx8ICFpc0VsZW1lbnQobmV4dFBhcmVudCkpIHtcbiAgICAgICAgYnJlYWs7XG4gICAgICB9XG4gICAgICB0YXJnZXRSb290QW5jZXN0b3IgPSBuZXh0UGFyZW50O1xuICAgIH1cblxuICAgIC8vIENoZWNrIGlmIHRoZSBjbGljayBvY2N1cnJlZCBvbiBhIHRoaXJkLXBhcnR5IGVsZW1lbnQgaW5qZWN0ZWQgYWZ0ZXIgdGhlXG4gICAgLy8gZmxvYXRpbmcgZWxlbWVudCByZW5kZXJlZC5cbiAgICBpZiAobWFya2Vycy5sZW5ndGggJiYgaXNFbGVtZW50KHRhcmdldCkgJiYgIWlzUm9vdEVsZW1lbnQodGFyZ2V0KSAmJlxuICAgIC8vIENsaWNrZWQgb24gYSBkaXJlY3QgYW5jZXN0b3IgKGUuZy4gRmxvYXRpbmdPdmVybGF5KS5cbiAgICAhY29udGFpbnMkMSh0YXJnZXQsIGVsZW1lbnRzLmZsb2F0aW5nKSAmJlxuICAgIC8vIElmIHRoZSB0YXJnZXQgcm9vdCBlbGVtZW50IGNvbnRhaW5zIG5vbmUgb2YgdGhlIG1hcmtlcnMsIHRoZW4gdGhlXG4gICAgLy8gZWxlbWVudCB3YXMgaW5qZWN0ZWQgYWZ0ZXIgdGhlIGZsb2F0aW5nIGVsZW1lbnQgcmVuZGVyZWQuXG4gICAgQXJyYXkuZnJvbShtYXJrZXJzKS5ldmVyeShtYXJrZXIgPT4gIWNvbnRhaW5zJDEodGFyZ2V0Um9vdEFuY2VzdG9yLCBtYXJrZXIpKSkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIC8vIENoZWNrIGlmIHRoZSBjbGljayBvY2N1cnJlZCBvbiB0aGUgc2Nyb2xsYmFyXG4gICAgaWYgKGlzSFRNTEVsZW1lbnQodGFyZ2V0KSAmJiBmbG9hdGluZykge1xuICAgICAgY29uc3QgbGFzdFRyYXZlcnNhYmxlTm9kZSA9IGlzTGFzdFRyYXZlcnNhYmxlTm9kZSh0YXJnZXQpO1xuICAgICAgY29uc3Qgc3R5bGUgPSBnZXRDb21wdXRlZFN0eWxlKHRhcmdldCk7XG4gICAgICBjb25zdCBzY3JvbGxSZSA9IC9hdXRvfHNjcm9sbC87XG4gICAgICBjb25zdCBpc1Njcm9sbGFibGVYID0gbGFzdFRyYXZlcnNhYmxlTm9kZSB8fCBzY3JvbGxSZS50ZXN0KHN0eWxlLm92ZXJmbG93WCk7XG4gICAgICBjb25zdCBpc1Njcm9sbGFibGVZID0gbGFzdFRyYXZlcnNhYmxlTm9kZSB8fCBzY3JvbGxSZS50ZXN0KHN0eWxlLm92ZXJmbG93WSk7XG4gICAgICBjb25zdCBjYW5TY3JvbGxYID0gaXNTY3JvbGxhYmxlWCAmJiB0YXJnZXQuY2xpZW50V2lkdGggPiAwICYmIHRhcmdldC5zY3JvbGxXaWR0aCA+IHRhcmdldC5jbGllbnRXaWR0aDtcbiAgICAgIGNvbnN0IGNhblNjcm9sbFkgPSBpc1Njcm9sbGFibGVZICYmIHRhcmdldC5jbGllbnRIZWlnaHQgPiAwICYmIHRhcmdldC5zY3JvbGxIZWlnaHQgPiB0YXJnZXQuY2xpZW50SGVpZ2h0O1xuICAgICAgY29uc3QgaXNSVEwgPSBzdHlsZS5kaXJlY3Rpb24gPT09ICdydGwnO1xuXG4gICAgICAvLyBDaGVjayBjbGljayBwb3NpdGlvbiByZWxhdGl2ZSB0byBzY3JvbGxiYXIuXG4gICAgICAvLyBJbiBzb21lIGJyb3dzZXJzIGl0IGlzIHBvc3NpYmxlIHRvIGNoYW5nZSB0aGUgPGJvZHk+IChvciB3aW5kb3cpXG4gICAgICAvLyBzY3JvbGxiYXIgdG8gdGhlIGxlZnQgc2lkZSwgYnV0IGlzIHZlcnkgcmFyZSBhbmQgaXMgZGlmZmljdWx0IHRvXG4gICAgICAvLyBjaGVjayBmb3IuIFBsdXMsIGZvciBtb2RhbCBkaWFsb2dzIHdpdGggYmFja2Ryb3BzLCBpdCBpcyBtb3JlXG4gICAgICAvLyBpbXBvcnRhbnQgdGhhdCB0aGUgYmFja2Ryb3AgaXMgY2hlY2tlZCBidXQgbm90IHNvIG11Y2ggdGhlIHdpbmRvdy5cbiAgICAgIGNvbnN0IHByZXNzZWRWZXJ0aWNhbFNjcm9sbGJhciA9IGNhblNjcm9sbFkgJiYgKGlzUlRMID8gZXZlbnQub2Zmc2V0WCA8PSB0YXJnZXQub2Zmc2V0V2lkdGggLSB0YXJnZXQuY2xpZW50V2lkdGggOiBldmVudC5vZmZzZXRYID4gdGFyZ2V0LmNsaWVudFdpZHRoKTtcbiAgICAgIGNvbnN0IHByZXNzZWRIb3Jpem9udGFsU2Nyb2xsYmFyID0gY2FuU2Nyb2xsWCAmJiBldmVudC5vZmZzZXRZID4gdGFyZ2V0LmNsaWVudEhlaWdodDtcbiAgICAgIGlmIChwcmVzc2VkVmVydGljYWxTY3JvbGxiYXIgfHwgcHJlc3NlZEhvcml6b250YWxTY3JvbGxiYXIpIHtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuICAgIH1cbiAgICBjb25zdCBub2RlSWQgPSAoX2RhdGFSZWYkY3VycmVudCRmbG9hMiA9IGRhdGFSZWYuY3VycmVudC5mbG9hdGluZ0NvbnRleHQpID09IG51bGwgPyB2b2lkIDAgOiBfZGF0YVJlZiRjdXJyZW50JGZsb2EyLm5vZGVJZDtcbiAgICBjb25zdCB0YXJnZXRJc0luc2lkZUNoaWxkcmVuID0gdHJlZSAmJiBnZXROb2RlQ2hpbGRyZW4kMSh0cmVlLm5vZGVzUmVmLmN1cnJlbnQsIG5vZGVJZCkuc29tZShub2RlID0+IHtcbiAgICAgIHZhciBfbm9kZSRjb250ZXh0O1xuICAgICAgcmV0dXJuIGlzRXZlbnRUYXJnZXRXaXRoaW4oZXZlbnQsIChfbm9kZSRjb250ZXh0ID0gbm9kZS5jb250ZXh0KSA9PSBudWxsID8gdm9pZCAwIDogX25vZGUkY29udGV4dC5lbGVtZW50cy5mbG9hdGluZyk7XG4gICAgfSk7XG4gICAgaWYgKGlzRXZlbnRUYXJnZXRXaXRoaW4oZXZlbnQsIGVsZW1lbnRzLmZsb2F0aW5nKSB8fCBpc0V2ZW50VGFyZ2V0V2l0aGluKGV2ZW50LCBlbGVtZW50cy5kb21SZWZlcmVuY2UpIHx8IHRhcmdldElzSW5zaWRlQ2hpbGRyZW4pIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgY29uc3QgY2hpbGRyZW4gPSB0cmVlID8gZ2V0Tm9kZUNoaWxkcmVuJDEodHJlZS5ub2Rlc1JlZi5jdXJyZW50LCBub2RlSWQpIDogW107XG4gICAgaWYgKGNoaWxkcmVuLmxlbmd0aCA+IDApIHtcbiAgICAgIGxldCBzaG91bGREaXNtaXNzID0gdHJ1ZTtcbiAgICAgIGNoaWxkcmVuLmZvckVhY2goY2hpbGQgPT4ge1xuICAgICAgICB2YXIgX2NoaWxkJGNvbnRleHQyO1xuICAgICAgICBpZiAoKF9jaGlsZCRjb250ZXh0MiA9IGNoaWxkLmNvbnRleHQpICE9IG51bGwgJiYgX2NoaWxkJGNvbnRleHQyLm9wZW4gJiYgIWNoaWxkLmNvbnRleHQuZGF0YVJlZi5jdXJyZW50Ll9fb3V0c2lkZVByZXNzQnViYmxlcykge1xuICAgICAgICAgIHNob3VsZERpc21pc3MgPSBmYWxzZTtcbiAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgIH0pO1xuICAgICAgaWYgKCFzaG91bGREaXNtaXNzKSB7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cbiAgICB9XG4gICAgb25PcGVuQ2hhbmdlKGZhbHNlLCBldmVudCwgJ291dHNpZGUtcHJlc3MnKTtcbiAgfSk7XG4gIGNvbnN0IGNsb3NlT25QcmVzc091dHNpZGVDYXB0dXJlID0gdXNlRWZmZWN0RXZlbnQoZXZlbnQgPT4ge1xuICAgIHZhciBfZ2V0VGFyZ2V0NDtcbiAgICBjb25zdCBjYWxsYmFjayA9ICgpID0+IHtcbiAgICAgIHZhciBfZ2V0VGFyZ2V0MztcbiAgICAgIGNsb3NlT25QcmVzc091dHNpZGUoZXZlbnQpO1xuICAgICAgKF9nZXRUYXJnZXQzID0gZ2V0VGFyZ2V0JDEoZXZlbnQpKSA9PSBudWxsIHx8IF9nZXRUYXJnZXQzLnJlbW92ZUV2ZW50TGlzdGVuZXIob3V0c2lkZVByZXNzRXZlbnQsIGNhbGxiYWNrKTtcbiAgICB9O1xuICAgIChfZ2V0VGFyZ2V0NCA9IGdldFRhcmdldCQxKGV2ZW50KSkgPT0gbnVsbCB8fCBfZ2V0VGFyZ2V0NC5hZGRFdmVudExpc3RlbmVyKG91dHNpZGVQcmVzc0V2ZW50LCBjYWxsYmFjayk7XG4gIH0pO1xuICBSZWFjdC51c2VFZmZlY3QoKCkgPT4ge1xuICAgIGlmICghb3BlbiB8fCAhZW5hYmxlZCkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBkYXRhUmVmLmN1cnJlbnQuX19lc2NhcGVLZXlCdWJibGVzID0gZXNjYXBlS2V5QnViYmxlcztcbiAgICBkYXRhUmVmLmN1cnJlbnQuX19vdXRzaWRlUHJlc3NCdWJibGVzID0gb3V0c2lkZVByZXNzQnViYmxlcztcbiAgICBsZXQgY29tcG9zaXRpb25UaW1lb3V0ID0gLTE7XG4gICAgZnVuY3Rpb24gb25TY3JvbGwoZXZlbnQpIHtcbiAgICAgIG9uT3BlbkNoYW5nZShmYWxzZSwgZXZlbnQsICdhbmNlc3Rvci1zY3JvbGwnKTtcbiAgICB9XG4gICAgZnVuY3Rpb24gaGFuZGxlQ29tcG9zaXRpb25TdGFydCgpIHtcbiAgICAgIHdpbmRvdy5jbGVhclRpbWVvdXQoY29tcG9zaXRpb25UaW1lb3V0KTtcbiAgICAgIGlzQ29tcG9zaW5nUmVmLmN1cnJlbnQgPSB0cnVlO1xuICAgIH1cbiAgICBmdW5jdGlvbiBoYW5kbGVDb21wb3NpdGlvbkVuZCgpIHtcbiAgICAgIC8vIFNhZmFyaSBmaXJlcyBgY29tcG9zaXRpb25lbmRgIGJlZm9yZSBga2V5ZG93bmAsIHNvIHdlIG5lZWQgdG8gd2FpdFxuICAgICAgLy8gdW50aWwgdGhlIG5leHQgdGljayB0byBzZXQgYGlzQ29tcG9zaW5nYCB0byBgZmFsc2VgLlxuICAgICAgLy8gaHR0cHM6Ly9idWdzLndlYmtpdC5vcmcvc2hvd19idWcuY2dpP2lkPTE2NTAwNFxuICAgICAgY29tcG9zaXRpb25UaW1lb3V0ID0gd2luZG93LnNldFRpbWVvdXQoKCkgPT4ge1xuICAgICAgICBpc0NvbXBvc2luZ1JlZi5jdXJyZW50ID0gZmFsc2U7XG4gICAgICB9LFxuICAgICAgLy8gMG1zIG9yIDFtcyBkb24ndCB3b3JrIGluIFNhZmFyaS4gNW1zIGFwcGVhcnMgdG8gY29uc2lzdGVudGx5IHdvcmsuXG4gICAgICAvLyBPbmx5IGFwcGx5IHRvIFdlYktpdCBmb3IgdGhlIHRlc3QgdG8gcmVtYWluIDBtcy5cbiAgICAgIGlzV2ViS2l0KCkgPyA1IDogMCk7XG4gICAgfVxuICAgIGNvbnN0IGRvYyA9IGdldERvY3VtZW50JDEoZWxlbWVudHMuZmxvYXRpbmcpO1xuICAgIGlmIChlc2NhcGVLZXkpIHtcbiAgICAgIGRvYy5hZGRFdmVudExpc3RlbmVyKCdrZXlkb3duJywgZXNjYXBlS2V5Q2FwdHVyZSA/IGNsb3NlT25Fc2NhcGVLZXlEb3duQ2FwdHVyZSA6IGNsb3NlT25Fc2NhcGVLZXlEb3duLCBlc2NhcGVLZXlDYXB0dXJlKTtcbiAgICAgIGRvYy5hZGRFdmVudExpc3RlbmVyKCdjb21wb3NpdGlvbnN0YXJ0JywgaGFuZGxlQ29tcG9zaXRpb25TdGFydCk7XG4gICAgICBkb2MuYWRkRXZlbnRMaXN0ZW5lcignY29tcG9zaXRpb25lbmQnLCBoYW5kbGVDb21wb3NpdGlvbkVuZCk7XG4gICAgfVxuICAgIG91dHNpZGVQcmVzcyAmJiBkb2MuYWRkRXZlbnRMaXN0ZW5lcihvdXRzaWRlUHJlc3NFdmVudCwgb3V0c2lkZVByZXNzQ2FwdHVyZSA/IGNsb3NlT25QcmVzc091dHNpZGVDYXB0dXJlIDogY2xvc2VPblByZXNzT3V0c2lkZSwgb3V0c2lkZVByZXNzQ2FwdHVyZSk7XG4gICAgbGV0IGFuY2VzdG9ycyA9IFtdO1xuICAgIGlmIChhbmNlc3RvclNjcm9sbCkge1xuICAgICAgaWYgKGlzRWxlbWVudChlbGVtZW50cy5kb21SZWZlcmVuY2UpKSB7XG4gICAgICAgIGFuY2VzdG9ycyA9IGdldE92ZXJmbG93QW5jZXN0b3JzKGVsZW1lbnRzLmRvbVJlZmVyZW5jZSk7XG4gICAgICB9XG4gICAgICBpZiAoaXNFbGVtZW50KGVsZW1lbnRzLmZsb2F0aW5nKSkge1xuICAgICAgICBhbmNlc3RvcnMgPSBhbmNlc3RvcnMuY29uY2F0KGdldE92ZXJmbG93QW5jZXN0b3JzKGVsZW1lbnRzLmZsb2F0aW5nKSk7XG4gICAgICB9XG4gICAgICBpZiAoIWlzRWxlbWVudChlbGVtZW50cy5yZWZlcmVuY2UpICYmIGVsZW1lbnRzLnJlZmVyZW5jZSAmJiBlbGVtZW50cy5yZWZlcmVuY2UuY29udGV4dEVsZW1lbnQpIHtcbiAgICAgICAgYW5jZXN0b3JzID0gYW5jZXN0b3JzLmNvbmNhdChnZXRPdmVyZmxvd0FuY2VzdG9ycyhlbGVtZW50cy5yZWZlcmVuY2UuY29udGV4dEVsZW1lbnQpKTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICAvLyBJZ25vcmUgdGhlIHZpc3VhbCB2aWV3cG9ydCBmb3Igc2Nyb2xsaW5nIGRpc21pc3NhbCAoYWxsb3cgcGluY2gtem9vbSlcbiAgICBhbmNlc3RvcnMgPSBhbmNlc3RvcnMuZmlsdGVyKGFuY2VzdG9yID0+IHtcbiAgICAgIHZhciBfZG9jJGRlZmF1bHRWaWV3O1xuICAgICAgcmV0dXJuIGFuY2VzdG9yICE9PSAoKF9kb2MkZGVmYXVsdFZpZXcgPSBkb2MuZGVmYXVsdFZpZXcpID09IG51bGwgPyB2b2lkIDAgOiBfZG9jJGRlZmF1bHRWaWV3LnZpc3VhbFZpZXdwb3J0KTtcbiAgICB9KTtcbiAgICBhbmNlc3RvcnMuZm9yRWFjaChhbmNlc3RvciA9PiB7XG4gICAgICBhbmNlc3Rvci5hZGRFdmVudExpc3RlbmVyKCdzY3JvbGwnLCBvblNjcm9sbCwge1xuICAgICAgICBwYXNzaXZlOiB0cnVlXG4gICAgICB9KTtcbiAgICB9KTtcbiAgICByZXR1cm4gKCkgPT4ge1xuICAgICAgaWYgKGVzY2FwZUtleSkge1xuICAgICAgICBkb2MucmVtb3ZlRXZlbnRMaXN0ZW5lcigna2V5ZG93bicsIGVzY2FwZUtleUNhcHR1cmUgPyBjbG9zZU9uRXNjYXBlS2V5RG93bkNhcHR1cmUgOiBjbG9zZU9uRXNjYXBlS2V5RG93biwgZXNjYXBlS2V5Q2FwdHVyZSk7XG4gICAgICAgIGRvYy5yZW1vdmVFdmVudExpc3RlbmVyKCdjb21wb3NpdGlvbnN0YXJ0JywgaGFuZGxlQ29tcG9zaXRpb25TdGFydCk7XG4gICAgICAgIGRvYy5yZW1vdmVFdmVudExpc3RlbmVyKCdjb21wb3NpdGlvbmVuZCcsIGhhbmRsZUNvbXBvc2l0aW9uRW5kKTtcbiAgICAgIH1cbiAgICAgIG91dHNpZGVQcmVzcyAmJiBkb2MucmVtb3ZlRXZlbnRMaXN0ZW5lcihvdXRzaWRlUHJlc3NFdmVudCwgb3V0c2lkZVByZXNzQ2FwdHVyZSA/IGNsb3NlT25QcmVzc091dHNpZGVDYXB0dXJlIDogY2xvc2VPblByZXNzT3V0c2lkZSwgb3V0c2lkZVByZXNzQ2FwdHVyZSk7XG4gICAgICBhbmNlc3RvcnMuZm9yRWFjaChhbmNlc3RvciA9PiB7XG4gICAgICAgIGFuY2VzdG9yLnJlbW92ZUV2ZW50TGlzdGVuZXIoJ3Njcm9sbCcsIG9uU2Nyb2xsKTtcbiAgICAgIH0pO1xuICAgICAgd2luZG93LmNsZWFyVGltZW91dChjb21wb3NpdGlvblRpbWVvdXQpO1xuICAgIH07XG4gIH0sIFtkYXRhUmVmLCBlbGVtZW50cywgZXNjYXBlS2V5LCBvdXRzaWRlUHJlc3MsIG91dHNpZGVQcmVzc0V2ZW50LCBvcGVuLCBvbk9wZW5DaGFuZ2UsIGFuY2VzdG9yU2Nyb2xsLCBlbmFibGVkLCBlc2NhcGVLZXlCdWJibGVzLCBvdXRzaWRlUHJlc3NCdWJibGVzLCBjbG9zZU9uRXNjYXBlS2V5RG93biwgZXNjYXBlS2V5Q2FwdHVyZSwgY2xvc2VPbkVzY2FwZUtleURvd25DYXB0dXJlLCBjbG9zZU9uUHJlc3NPdXRzaWRlLCBvdXRzaWRlUHJlc3NDYXB0dXJlLCBjbG9zZU9uUHJlc3NPdXRzaWRlQ2FwdHVyZV0pO1xuICBSZWFjdC51c2VFZmZlY3QoKCkgPT4ge1xuICAgIGRhdGFSZWYuY3VycmVudC5pbnNpZGVSZWFjdFRyZWUgPSBmYWxzZTtcbiAgfSwgW2RhdGFSZWYsIG91dHNpZGVQcmVzcywgb3V0c2lkZVByZXNzRXZlbnRdKTtcbiAgY29uc3QgcmVmZXJlbmNlID0gUmVhY3QudXNlTWVtbygoKSA9PiAoe1xuICAgIG9uS2V5RG93bjogY2xvc2VPbkVzY2FwZUtleURvd24sXG4gICAgLi4uKHJlZmVyZW5jZVByZXNzICYmIHtcbiAgICAgIFtidWJibGVIYW5kbGVyS2V5c1tyZWZlcmVuY2VQcmVzc0V2ZW50XV06IGV2ZW50ID0+IHtcbiAgICAgICAgb25PcGVuQ2hhbmdlKGZhbHNlLCBldmVudC5uYXRpdmVFdmVudCwgJ3JlZmVyZW5jZS1wcmVzcycpO1xuICAgICAgfSxcbiAgICAgIC4uLihyZWZlcmVuY2VQcmVzc0V2ZW50ICE9PSAnY2xpY2snICYmIHtcbiAgICAgICAgb25DbGljayhldmVudCkge1xuICAgICAgICAgIG9uT3BlbkNoYW5nZShmYWxzZSwgZXZlbnQubmF0aXZlRXZlbnQsICdyZWZlcmVuY2UtcHJlc3MnKTtcbiAgICAgICAgfVxuICAgICAgfSlcbiAgICB9KVxuICB9KSwgW2Nsb3NlT25Fc2NhcGVLZXlEb3duLCBvbk9wZW5DaGFuZ2UsIHJlZmVyZW5jZVByZXNzLCByZWZlcmVuY2VQcmVzc0V2ZW50XSk7XG4gIGNvbnN0IGZsb2F0aW5nID0gUmVhY3QudXNlTWVtbygoKSA9PiAoe1xuICAgIG9uS2V5RG93bjogY2xvc2VPbkVzY2FwZUtleURvd24sXG4gICAgb25Nb3VzZURvd24oKSB7XG4gICAgICBlbmRlZE9yU3RhcnRlZEluc2lkZVJlZi5jdXJyZW50ID0gdHJ1ZTtcbiAgICB9LFxuICAgIG9uTW91c2VVcCgpIHtcbiAgICAgIGVuZGVkT3JTdGFydGVkSW5zaWRlUmVmLmN1cnJlbnQgPSB0cnVlO1xuICAgIH0sXG4gICAgW2NhcHR1cmVIYW5kbGVyS2V5c1tvdXRzaWRlUHJlc3NFdmVudF1dOiAoKSA9PiB7XG4gICAgICBkYXRhUmVmLmN1cnJlbnQuaW5zaWRlUmVhY3RUcmVlID0gdHJ1ZTtcbiAgICB9XG4gIH0pLCBbY2xvc2VPbkVzY2FwZUtleURvd24sIG91dHNpZGVQcmVzc0V2ZW50LCBkYXRhUmVmXSk7XG4gIHJldHVybiBSZWFjdC51c2VNZW1vKCgpID0+IGVuYWJsZWQgPyB7XG4gICAgcmVmZXJlbmNlLFxuICAgIGZsb2F0aW5nXG4gIH0gOiB7fSwgW2VuYWJsZWQsIHJlZmVyZW5jZSwgZmxvYXRpbmddKTtcbn1cblxuZnVuY3Rpb24gdXNlRmxvYXRpbmdSb290Q29udGV4dChvcHRpb25zKSB7XG4gIGNvbnN0IHtcbiAgICBvcGVuID0gZmFsc2UsXG4gICAgb25PcGVuQ2hhbmdlOiBvbk9wZW5DaGFuZ2VQcm9wLFxuICAgIGVsZW1lbnRzOiBlbGVtZW50c1Byb3BcbiAgfSA9IG9wdGlvbnM7XG4gIGNvbnN0IGZsb2F0aW5nSWQgPSB1c2VJZCgpO1xuICBjb25zdCBkYXRhUmVmID0gUmVhY3QudXNlUmVmKHt9KTtcbiAgY29uc3QgW2V2ZW50c10gPSBSZWFjdC51c2VTdGF0ZSgoKSA9PiBjcmVhdGVFdmVudEVtaXR0ZXIoKSk7XG4gIGNvbnN0IG5lc3RlZCA9IHVzZUZsb2F0aW5nUGFyZW50Tm9kZUlkKCkgIT0gbnVsbDtcbiAgaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSBcInByb2R1Y3Rpb25cIikge1xuICAgIGNvbnN0IG9wdGlvbkRvbVJlZmVyZW5jZSA9IGVsZW1lbnRzUHJvcC5yZWZlcmVuY2U7XG4gICAgaWYgKG9wdGlvbkRvbVJlZmVyZW5jZSAmJiAhaXNFbGVtZW50KG9wdGlvbkRvbVJlZmVyZW5jZSkpIHtcbiAgICAgIGVycm9yKCdDYW5ub3QgcGFzcyBhIHZpcnR1YWwgZWxlbWVudCB0byB0aGUgYGVsZW1lbnRzLnJlZmVyZW5jZWAgb3B0aW9uLCcsICdhcyBpdCBtdXN0IGJlIGEgcmVhbCBET00gZWxlbWVudC4gVXNlIGByZWZzLnNldFBvc2l0aW9uUmVmZXJlbmNlKClgJywgJ2luc3RlYWQuJyk7XG4gICAgfVxuICB9XG4gIGNvbnN0IFtwb3NpdGlvblJlZmVyZW5jZSwgc2V0UG9zaXRpb25SZWZlcmVuY2VdID0gUmVhY3QudXNlU3RhdGUoZWxlbWVudHNQcm9wLnJlZmVyZW5jZSk7XG4gIGNvbnN0IG9uT3BlbkNoYW5nZSA9IHVzZUVmZmVjdEV2ZW50KChvcGVuLCBldmVudCwgcmVhc29uKSA9PiB7XG4gICAgZGF0YVJlZi5jdXJyZW50Lm9wZW5FdmVudCA9IG9wZW4gPyBldmVudCA6IHVuZGVmaW5lZDtcbiAgICBldmVudHMuZW1pdCgnb3BlbmNoYW5nZScsIHtcbiAgICAgIG9wZW4sXG4gICAgICBldmVudCxcbiAgICAgIHJlYXNvbixcbiAgICAgIG5lc3RlZFxuICAgIH0pO1xuICAgIG9uT3BlbkNoYW5nZVByb3AgPT0gbnVsbCB8fCBvbk9wZW5DaGFuZ2VQcm9wKG9wZW4sIGV2ZW50LCByZWFzb24pO1xuICB9KTtcbiAgY29uc3QgcmVmcyA9IFJlYWN0LnVzZU1lbW8oKCkgPT4gKHtcbiAgICBzZXRQb3NpdGlvblJlZmVyZW5jZVxuICB9KSwgW10pO1xuICBjb25zdCBlbGVtZW50cyA9IFJlYWN0LnVzZU1lbW8oKCkgPT4gKHtcbiAgICByZWZlcmVuY2U6IHBvc2l0aW9uUmVmZXJlbmNlIHx8IGVsZW1lbnRzUHJvcC5yZWZlcmVuY2UgfHwgbnVsbCxcbiAgICBmbG9hdGluZzogZWxlbWVudHNQcm9wLmZsb2F0aW5nIHx8IG51bGwsXG4gICAgZG9tUmVmZXJlbmNlOiBlbGVtZW50c1Byb3AucmVmZXJlbmNlXG4gIH0pLCBbcG9zaXRpb25SZWZlcmVuY2UsIGVsZW1lbnRzUHJvcC5yZWZlcmVuY2UsIGVsZW1lbnRzUHJvcC5mbG9hdGluZ10pO1xuICByZXR1cm4gUmVhY3QudXNlTWVtbygoKSA9PiAoe1xuICAgIGRhdGFSZWYsXG4gICAgb3BlbixcbiAgICBvbk9wZW5DaGFuZ2UsXG4gICAgZWxlbWVudHMsXG4gICAgZXZlbnRzLFxuICAgIGZsb2F0aW5nSWQsXG4gICAgcmVmc1xuICB9KSwgW29wZW4sIG9uT3BlbkNoYW5nZSwgZWxlbWVudHMsIGV2ZW50cywgZmxvYXRpbmdJZCwgcmVmc10pO1xufVxuXG4vKipcbiAqIFByb3ZpZGVzIGRhdGEgdG8gcG9zaXRpb24gYSBmbG9hdGluZyBlbGVtZW50IGFuZCBjb250ZXh0IHRvIGFkZCBpbnRlcmFjdGlvbnMuXG4gKiBAc2VlIGh0dHBzOi8vZmxvYXRpbmctdWkuY29tL2RvY3MvdXNlRmxvYXRpbmdcbiAqL1xuZnVuY3Rpb24gdXNlRmxvYXRpbmcob3B0aW9ucykge1xuICBpZiAob3B0aW9ucyA9PT0gdm9pZCAwKSB7XG4gICAgb3B0aW9ucyA9IHt9O1xuICB9XG4gIGNvbnN0IHtcbiAgICBub2RlSWRcbiAgfSA9IG9wdGlvbnM7XG4gIGNvbnN0IGludGVybmFsUm9vdENvbnRleHQgPSB1c2VGbG9hdGluZ1Jvb3RDb250ZXh0KHtcbiAgICAuLi5vcHRpb25zLFxuICAgIGVsZW1lbnRzOiB7XG4gICAgICByZWZlcmVuY2U6IG51bGwsXG4gICAgICBmbG9hdGluZzogbnVsbCxcbiAgICAgIC4uLm9wdGlvbnMuZWxlbWVudHNcbiAgICB9XG4gIH0pO1xuICBjb25zdCByb290Q29udGV4dCA9IG9wdGlvbnMucm9vdENvbnRleHQgfHwgaW50ZXJuYWxSb290Q29udGV4dDtcbiAgY29uc3QgY29tcHV0ZWRFbGVtZW50cyA9IHJvb3RDb250ZXh0LmVsZW1lbnRzO1xuICBjb25zdCBbX2RvbVJlZmVyZW5jZSwgc2V0RG9tUmVmZXJlbmNlXSA9IFJlYWN0LnVzZVN0YXRlKG51bGwpO1xuICBjb25zdCBbcG9zaXRpb25SZWZlcmVuY2UsIF9zZXRQb3NpdGlvblJlZmVyZW5jZV0gPSBSZWFjdC51c2VTdGF0ZShudWxsKTtcbiAgY29uc3Qgb3B0aW9uRG9tUmVmZXJlbmNlID0gY29tcHV0ZWRFbGVtZW50cyA9PSBudWxsID8gdm9pZCAwIDogY29tcHV0ZWRFbGVtZW50cy5kb21SZWZlcmVuY2U7XG4gIGNvbnN0IGRvbVJlZmVyZW5jZSA9IG9wdGlvbkRvbVJlZmVyZW5jZSB8fCBfZG9tUmVmZXJlbmNlO1xuICBjb25zdCBkb21SZWZlcmVuY2VSZWYgPSBSZWFjdC51c2VSZWYobnVsbCk7XG4gIGNvbnN0IHRyZWUgPSB1c2VGbG9hdGluZ1RyZWUoKTtcbiAgdXNlTW9kZXJuTGF5b3V0RWZmZWN0KCgpID0+IHtcbiAgICBpZiAoZG9tUmVmZXJlbmNlKSB7XG4gICAgICBkb21SZWZlcmVuY2VSZWYuY3VycmVudCA9IGRvbVJlZmVyZW5jZTtcbiAgICB9XG4gIH0sIFtkb21SZWZlcmVuY2VdKTtcbiAgY29uc3QgcG9zaXRpb24gPSB1c2VGbG9hdGluZyQxKHtcbiAgICAuLi5vcHRpb25zLFxuICAgIGVsZW1lbnRzOiB7XG4gICAgICAuLi5jb21wdXRlZEVsZW1lbnRzLFxuICAgICAgLi4uKHBvc2l0aW9uUmVmZXJlbmNlICYmIHtcbiAgICAgICAgcmVmZXJlbmNlOiBwb3NpdGlvblJlZmVyZW5jZVxuICAgICAgfSlcbiAgICB9XG4gIH0pO1xuICBjb25zdCBzZXRQb3NpdGlvblJlZmVyZW5jZSA9IFJlYWN0LnVzZUNhbGxiYWNrKG5vZGUgPT4ge1xuICAgIGNvbnN0IGNvbXB1dGVkUG9zaXRpb25SZWZlcmVuY2UgPSBpc0VsZW1lbnQobm9kZSkgPyB7XG4gICAgICBnZXRCb3VuZGluZ0NsaWVudFJlY3Q6ICgpID0+IG5vZGUuZ2V0Qm91bmRpbmdDbGllbnRSZWN0KCksXG4gICAgICBnZXRDbGllbnRSZWN0czogKCkgPT4gbm9kZS5nZXRDbGllbnRSZWN0cygpLFxuICAgICAgY29udGV4dEVsZW1lbnQ6IG5vZGVcbiAgICB9IDogbm9kZTtcbiAgICAvLyBTdG9yZSB0aGUgcG9zaXRpb25SZWZlcmVuY2UgaW4gc3RhdGUgaWYgdGhlIERPTSByZWZlcmVuY2UgaXMgc3BlY2lmaWVkIGV4dGVybmFsbHkgdmlhIHRoZVxuICAgIC8vIGBlbGVtZW50cy5yZWZlcmVuY2VgIG9wdGlvbi4gVGhpcyBlbnN1cmVzIHRoYXQgaXQgd29uJ3QgYmUgb3ZlcnJpZGRlbiBvbiBmdXR1cmUgcmVuZGVycy5cbiAgICBfc2V0UG9zaXRpb25SZWZlcmVuY2UoY29tcHV0ZWRQb3NpdGlvblJlZmVyZW5jZSk7XG4gICAgcG9zaXRpb24ucmVmcy5zZXRSZWZlcmVuY2UoY29tcHV0ZWRQb3NpdGlvblJlZmVyZW5jZSk7XG4gIH0sIFtwb3NpdGlvbi5yZWZzXSk7XG4gIGNvbnN0IHNldFJlZmVyZW5jZSA9IFJlYWN0LnVzZUNhbGxiYWNrKG5vZGUgPT4ge1xuICAgIGlmIChpc0VsZW1lbnQobm9kZSkgfHwgbm9kZSA9PT0gbnVsbCkge1xuICAgICAgZG9tUmVmZXJlbmNlUmVmLmN1cnJlbnQgPSBub2RlO1xuICAgICAgc2V0RG9tUmVmZXJlbmNlKG5vZGUpO1xuICAgIH1cblxuICAgIC8vIEJhY2t3YXJkcy1jb21wYXRpYmlsaXR5IGZvciBwYXNzaW5nIGEgdmlydHVhbCBlbGVtZW50IHRvIGByZWZlcmVuY2VgXG4gICAgLy8gYWZ0ZXIgaXQgaGFzIHNldCB0aGUgRE9NIHJlZmVyZW5jZS5cbiAgICBpZiAoaXNFbGVtZW50KHBvc2l0aW9uLnJlZnMucmVmZXJlbmNlLmN1cnJlbnQpIHx8IHBvc2l0aW9uLnJlZnMucmVmZXJlbmNlLmN1cnJlbnQgPT09IG51bGwgfHxcbiAgICAvLyBEb24ndCBhbGxvdyBzZXR0aW5nIHZpcnR1YWwgZWxlbWVudHMgdXNpbmcgdGhlIG9sZCB0ZWNobmlxdWUgYmFjayB0b1xuICAgIC8vIGBudWxsYCB0byBzdXBwb3J0IGBwb3NpdGlvblJlZmVyZW5jZWAgKyBhbiB1bnN0YWJsZSBgcmVmZXJlbmNlYFxuICAgIC8vIGNhbGxiYWNrIHJlZi5cbiAgICBub2RlICE9PSBudWxsICYmICFpc0VsZW1lbnQobm9kZSkpIHtcbiAgICAgIHBvc2l0aW9uLnJlZnMuc2V0UmVmZXJlbmNlKG5vZGUpO1xuICAgIH1cbiAgfSwgW3Bvc2l0aW9uLnJlZnNdKTtcbiAgY29uc3QgcmVmcyA9IFJlYWN0LnVzZU1lbW8oKCkgPT4gKHtcbiAgICAuLi5wb3NpdGlvbi5yZWZzLFxuICAgIHNldFJlZmVyZW5jZSxcbiAgICBzZXRQb3NpdGlvblJlZmVyZW5jZSxcbiAgICBkb21SZWZlcmVuY2U6IGRvbVJlZmVyZW5jZVJlZlxuICB9KSwgW3Bvc2l0aW9uLnJlZnMsIHNldFJlZmVyZW5jZSwgc2V0UG9zaXRpb25SZWZlcmVuY2VdKTtcbiAgY29uc3QgZWxlbWVudHMgPSBSZWFjdC51c2VNZW1vKCgpID0+ICh7XG4gICAgLi4ucG9zaXRpb24uZWxlbWVudHMsXG4gICAgZG9tUmVmZXJlbmNlOiBkb21SZWZlcmVuY2VcbiAgfSksIFtwb3NpdGlvbi5lbGVtZW50cywgZG9tUmVmZXJlbmNlXSk7XG4gIGNvbnN0IGNvbnRleHQgPSBSZWFjdC51c2VNZW1vKCgpID0+ICh7XG4gICAgLi4ucG9zaXRpb24sXG4gICAgLi4ucm9vdENvbnRleHQsXG4gICAgcmVmcyxcbiAgICBlbGVtZW50cyxcbiAgICBub2RlSWRcbiAgfSksIFtwb3NpdGlvbiwgcmVmcywgZWxlbWVudHMsIG5vZGVJZCwgcm9vdENvbnRleHRdKTtcbiAgdXNlTW9kZXJuTGF5b3V0RWZmZWN0KCgpID0+IHtcbiAgICByb290Q29udGV4dC5kYXRhUmVmLmN1cnJlbnQuZmxvYXRpbmdDb250ZXh0ID0gY29udGV4dDtcbiAgICBjb25zdCBub2RlID0gdHJlZSA9PSBudWxsID8gdm9pZCAwIDogdHJlZS5ub2Rlc1JlZi5jdXJyZW50LmZpbmQobm9kZSA9PiBub2RlLmlkID09PSBub2RlSWQpO1xuICAgIGlmIChub2RlKSB7XG4gICAgICBub2RlLmNvbnRleHQgPSBjb250ZXh0O1xuICAgIH1cbiAgfSk7XG4gIHJldHVybiBSZWFjdC51c2VNZW1vKCgpID0+ICh7XG4gICAgLi4ucG9zaXRpb24sXG4gICAgY29udGV4dCxcbiAgICByZWZzLFxuICAgIGVsZW1lbnRzXG4gIH0pLCBbcG9zaXRpb24sIHJlZnMsIGVsZW1lbnRzLCBjb250ZXh0XSk7XG59XG5cbmZ1bmN0aW9uIGlzTWFjU2FmYXJpKCkge1xuICByZXR1cm4gaXNNYWMoKSAmJiBpc1NhZmFyaSgpO1xufVxuLyoqXG4gKiBPcGVucyB0aGUgZmxvYXRpbmcgZWxlbWVudCB3aGlsZSB0aGUgcmVmZXJlbmNlIGVsZW1lbnQgaGFzIGZvY3VzLCBsaWtlIENTU1xuICogYDpmb2N1c2AuXG4gKiBAc2VlIGh0dHBzOi8vZmxvYXRpbmctdWkuY29tL2RvY3MvdXNlRm9jdXNcbiAqL1xuZnVuY3Rpb24gdXNlRm9jdXMoY29udGV4dCwgcHJvcHMpIHtcbiAgaWYgKHByb3BzID09PSB2b2lkIDApIHtcbiAgICBwcm9wcyA9IHt9O1xuICB9XG4gIGNvbnN0IHtcbiAgICBvcGVuLFxuICAgIG9uT3BlbkNoYW5nZSxcbiAgICBldmVudHMsXG4gICAgZGF0YVJlZixcbiAgICBlbGVtZW50c1xuICB9ID0gY29udGV4dDtcbiAgY29uc3Qge1xuICAgIGVuYWJsZWQgPSB0cnVlLFxuICAgIHZpc2libGVPbmx5ID0gdHJ1ZVxuICB9ID0gcHJvcHM7XG4gIGNvbnN0IGJsb2NrRm9jdXNSZWYgPSBSZWFjdC51c2VSZWYoZmFsc2UpO1xuICBjb25zdCB0aW1lb3V0UmVmID0gUmVhY3QudXNlUmVmKC0xKTtcbiAgY29uc3Qga2V5Ym9hcmRNb2RhbGl0eVJlZiA9IFJlYWN0LnVzZVJlZih0cnVlKTtcbiAgUmVhY3QudXNlRWZmZWN0KCgpID0+IHtcbiAgICBpZiAoIWVuYWJsZWQpIHJldHVybjtcbiAgICBjb25zdCB3aW4gPSBnZXRXaW5kb3coZWxlbWVudHMuZG9tUmVmZXJlbmNlKTtcblxuICAgIC8vIElmIHRoZSByZWZlcmVuY2Ugd2FzIGZvY3VzZWQgYW5kIHRoZSB1c2VyIGxlZnQgdGhlIHRhYi93aW5kb3csIGFuZCB0aGVcbiAgICAvLyBmbG9hdGluZyBlbGVtZW50IHdhcyBub3Qgb3BlbiwgdGhlIGZvY3VzIHNob3VsZCBiZSBibG9ja2VkIHdoZW4gdGhleVxuICAgIC8vIHJldHVybiB0byB0aGUgdGFiL3dpbmRvdy5cbiAgICBmdW5jdGlvbiBvbkJsdXIoKSB7XG4gICAgICBpZiAoIW9wZW4gJiYgaXNIVE1MRWxlbWVudChlbGVtZW50cy5kb21SZWZlcmVuY2UpICYmIGVsZW1lbnRzLmRvbVJlZmVyZW5jZSA9PT0gYWN0aXZlRWxlbWVudChnZXREb2N1bWVudCQxKGVsZW1lbnRzLmRvbVJlZmVyZW5jZSkpKSB7XG4gICAgICAgIGJsb2NrRm9jdXNSZWYuY3VycmVudCA9IHRydWU7XG4gICAgICB9XG4gICAgfVxuICAgIGZ1bmN0aW9uIG9uS2V5RG93bigpIHtcbiAgICAgIGtleWJvYXJkTW9kYWxpdHlSZWYuY3VycmVudCA9IHRydWU7XG4gICAgfVxuICAgIGZ1bmN0aW9uIG9uUG9pbnRlckRvd24oKSB7XG4gICAgICBrZXlib2FyZE1vZGFsaXR5UmVmLmN1cnJlbnQgPSBmYWxzZTtcbiAgICB9XG4gICAgd2luLmFkZEV2ZW50TGlzdGVuZXIoJ2JsdXInLCBvbkJsdXIpO1xuICAgIGlmIChpc01hY1NhZmFyaSgpKSB7XG4gICAgICB3aW4uYWRkRXZlbnRMaXN0ZW5lcigna2V5ZG93bicsIG9uS2V5RG93biwgdHJ1ZSk7XG4gICAgICB3aW4uYWRkRXZlbnRMaXN0ZW5lcigncG9pbnRlcmRvd24nLCBvblBvaW50ZXJEb3duLCB0cnVlKTtcbiAgICB9XG4gICAgcmV0dXJuICgpID0+IHtcbiAgICAgIHdpbi5yZW1vdmVFdmVudExpc3RlbmVyKCdibHVyJywgb25CbHVyKTtcbiAgICAgIGlmIChpc01hY1NhZmFyaSgpKSB7XG4gICAgICAgIHdpbi5yZW1vdmVFdmVudExpc3RlbmVyKCdrZXlkb3duJywgb25LZXlEb3duLCB0cnVlKTtcbiAgICAgICAgd2luLnJlbW92ZUV2ZW50TGlzdGVuZXIoJ3BvaW50ZXJkb3duJywgb25Qb2ludGVyRG93biwgdHJ1ZSk7XG4gICAgICB9XG4gICAgfTtcbiAgfSwgW2VsZW1lbnRzLmRvbVJlZmVyZW5jZSwgb3BlbiwgZW5hYmxlZF0pO1xuICBSZWFjdC51c2VFZmZlY3QoKCkgPT4ge1xuICAgIGlmICghZW5hYmxlZCkgcmV0dXJuO1xuICAgIGZ1bmN0aW9uIG9uT3BlbkNoYW5nZShfcmVmKSB7XG4gICAgICBsZXQge1xuICAgICAgICByZWFzb25cbiAgICAgIH0gPSBfcmVmO1xuICAgICAgaWYgKHJlYXNvbiA9PT0gJ3JlZmVyZW5jZS1wcmVzcycgfHwgcmVhc29uID09PSAnZXNjYXBlLWtleScpIHtcbiAgICAgICAgYmxvY2tGb2N1c1JlZi5jdXJyZW50ID0gdHJ1ZTtcbiAgICAgIH1cbiAgICB9XG4gICAgZXZlbnRzLm9uKCdvcGVuY2hhbmdlJywgb25PcGVuQ2hhbmdlKTtcbiAgICByZXR1cm4gKCkgPT4ge1xuICAgICAgZXZlbnRzLm9mZignb3BlbmNoYW5nZScsIG9uT3BlbkNoYW5nZSk7XG4gICAgfTtcbiAgfSwgW2V2ZW50cywgZW5hYmxlZF0pO1xuICBSZWFjdC51c2VFZmZlY3QoKCkgPT4ge1xuICAgIHJldHVybiAoKSA9PiB7XG4gICAgICBjbGVhclRpbWVvdXRJZlNldCh0aW1lb3V0UmVmKTtcbiAgICB9O1xuICB9LCBbXSk7XG4gIGNvbnN0IHJlZmVyZW5jZSA9IFJlYWN0LnVzZU1lbW8oKCkgPT4gKHtcbiAgICBvbk1vdXNlTGVhdmUoKSB7XG4gICAgICBibG9ja0ZvY3VzUmVmLmN1cnJlbnQgPSBmYWxzZTtcbiAgICB9LFxuICAgIG9uRm9jdXMoZXZlbnQpIHtcbiAgICAgIGlmIChibG9ja0ZvY3VzUmVmLmN1cnJlbnQpIHJldHVybjtcbiAgICAgIGNvbnN0IHRhcmdldCA9IGdldFRhcmdldCQxKGV2ZW50Lm5hdGl2ZUV2ZW50KTtcbiAgICAgIGlmICh2aXNpYmxlT25seSAmJiBpc0VsZW1lbnQodGFyZ2V0KSkge1xuICAgICAgICAvLyBTYWZhcmkgZmFpbHMgdG8gbWF0Y2ggYDpmb2N1cy12aXNpYmxlYCBpZiBmb2N1cyB3YXMgaW5pdGlhbGx5XG4gICAgICAgIC8vIG91dHNpZGUgdGhlIGRvY3VtZW50LlxuICAgICAgICBpZiAoaXNNYWNTYWZhcmkoKSAmJiAhZXZlbnQucmVsYXRlZFRhcmdldCkge1xuICAgICAgICAgIGlmICgha2V5Ym9hcmRNb2RhbGl0eVJlZi5jdXJyZW50ICYmICFpc1R5cGVhYmxlRWxlbWVudCh0YXJnZXQpKSB7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgfVxuICAgICAgICB9IGVsc2UgaWYgKCFtYXRjaGVzRm9jdXNWaXNpYmxlKHRhcmdldCkpIHtcbiAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIG9uT3BlbkNoYW5nZSh0cnVlLCBldmVudC5uYXRpdmVFdmVudCwgJ2ZvY3VzJyk7XG4gICAgfSxcbiAgICBvbkJsdXIoZXZlbnQpIHtcbiAgICAgIGJsb2NrRm9jdXNSZWYuY3VycmVudCA9IGZhbHNlO1xuICAgICAgY29uc3QgcmVsYXRlZFRhcmdldCA9IGV2ZW50LnJlbGF0ZWRUYXJnZXQ7XG4gICAgICBjb25zdCBuYXRpdmVFdmVudCA9IGV2ZW50Lm5hdGl2ZUV2ZW50O1xuXG4gICAgICAvLyBIaXQgdGhlIG5vbi1tb2RhbCBmb2N1cyBtYW5hZ2VtZW50IHBvcnRhbCBndWFyZC4gRm9jdXMgd2lsbCBiZVxuICAgICAgLy8gbW92ZWQgaW50byB0aGUgZmxvYXRpbmcgZWxlbWVudCBpbW1lZGlhdGVseSBhZnRlci5cbiAgICAgIGNvbnN0IG1vdmVkVG9Gb2N1c0d1YXJkID0gaXNFbGVtZW50KHJlbGF0ZWRUYXJnZXQpICYmIHJlbGF0ZWRUYXJnZXQuaGFzQXR0cmlidXRlKGNyZWF0ZUF0dHJpYnV0ZSgnZm9jdXMtZ3VhcmQnKSkgJiYgcmVsYXRlZFRhcmdldC5nZXRBdHRyaWJ1dGUoJ2RhdGEtdHlwZScpID09PSAnb3V0c2lkZSc7XG5cbiAgICAgIC8vIFdhaXQgZm9yIHRoZSB3aW5kb3cgYmx1ciBsaXN0ZW5lciB0byBmaXJlLlxuICAgICAgdGltZW91dFJlZi5jdXJyZW50ID0gd2luZG93LnNldFRpbWVvdXQoKCkgPT4ge1xuICAgICAgICB2YXIgX2RhdGFSZWYkY3VycmVudCRmbG9hO1xuICAgICAgICBjb25zdCBhY3RpdmVFbCA9IGFjdGl2ZUVsZW1lbnQoZWxlbWVudHMuZG9tUmVmZXJlbmNlID8gZWxlbWVudHMuZG9tUmVmZXJlbmNlLm93bmVyRG9jdW1lbnQgOiBkb2N1bWVudCk7XG5cbiAgICAgICAgLy8gRm9jdXMgbGVmdCB0aGUgcGFnZSwga2VlcCBpdCBvcGVuLlxuICAgICAgICBpZiAoIXJlbGF0ZWRUYXJnZXQgJiYgYWN0aXZlRWwgPT09IGVsZW1lbnRzLmRvbVJlZmVyZW5jZSkgcmV0dXJuO1xuXG4gICAgICAgIC8vIFdoZW4gZm9jdXNpbmcgdGhlIHJlZmVyZW5jZSBlbGVtZW50IChlLmcuIHJlZ3VsYXIgY2xpY2spLCB0aGVuXG4gICAgICAgIC8vIGNsaWNraW5nIGludG8gdGhlIGZsb2F0aW5nIGVsZW1lbnQsIHByZXZlbnQgaXQgZnJvbSBoaWRpbmcuXG4gICAgICAgIC8vIE5vdGU6IGl0IG11c3QgYmUgZm9jdXNhYmxlLCBlLmcuIGB0YWJpbmRleD1cIi0xXCJgLlxuICAgICAgICAvLyBXZSBjYW4gbm90IHJlbHkgb24gcmVsYXRlZFRhcmdldCB0byBwb2ludCB0byB0aGUgY29ycmVjdCBlbGVtZW50XG4gICAgICAgIC8vIGFzIGl0IHdpbGwgb25seSBwb2ludCB0byB0aGUgc2hhZG93IGhvc3Qgb2YgdGhlIG5ld2x5IGZvY3VzZWQgZWxlbWVudFxuICAgICAgICAvLyBhbmQgbm90IHRoZSBlbGVtZW50IHRoYXQgYWN0dWFsbHkgaGFzIHJlY2VpdmVkIGZvY3VzIGlmIGl0IGlzIGxvY2F0ZWRcbiAgICAgICAgLy8gaW5zaWRlIGEgc2hhZG93IHJvb3QuXG4gICAgICAgIGlmIChjb250YWlucyQxKChfZGF0YVJlZiRjdXJyZW50JGZsb2EgPSBkYXRhUmVmLmN1cnJlbnQuZmxvYXRpbmdDb250ZXh0KSA9PSBudWxsID8gdm9pZCAwIDogX2RhdGFSZWYkY3VycmVudCRmbG9hLnJlZnMuZmxvYXRpbmcuY3VycmVudCwgYWN0aXZlRWwpIHx8IGNvbnRhaW5zJDEoZWxlbWVudHMuZG9tUmVmZXJlbmNlLCBhY3RpdmVFbCkgfHwgbW92ZWRUb0ZvY3VzR3VhcmQpIHtcbiAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgb25PcGVuQ2hhbmdlKGZhbHNlLCBuYXRpdmVFdmVudCwgJ2ZvY3VzJyk7XG4gICAgICB9KTtcbiAgICB9XG4gIH0pLCBbZGF0YVJlZiwgZWxlbWVudHMuZG9tUmVmZXJlbmNlLCBvbk9wZW5DaGFuZ2UsIHZpc2libGVPbmx5XSk7XG4gIHJldHVybiBSZWFjdC51c2VNZW1vKCgpID0+IGVuYWJsZWQgPyB7XG4gICAgcmVmZXJlbmNlXG4gIH0gOiB7fSwgW2VuYWJsZWQsIHJlZmVyZW5jZV0pO1xufVxuXG5mdW5jdGlvbiBtZXJnZVByb3BzKHVzZXJQcm9wcywgcHJvcHNMaXN0LCBlbGVtZW50S2V5KSB7XG4gIGNvbnN0IG1hcCA9IG5ldyBNYXAoKTtcbiAgY29uc3QgaXNJdGVtID0gZWxlbWVudEtleSA9PT0gJ2l0ZW0nO1xuICBsZXQgZG9tVXNlclByb3BzID0gdXNlclByb3BzO1xuICBpZiAoaXNJdGVtICYmIHVzZXJQcm9wcykge1xuICAgIGNvbnN0IHtcbiAgICAgIFtBQ1RJVkVfS0VZXTogXyxcbiAgICAgIFtTRUxFQ1RFRF9LRVldOiBfXyxcbiAgICAgIC4uLnZhbGlkUHJvcHNcbiAgICB9ID0gdXNlclByb3BzO1xuICAgIGRvbVVzZXJQcm9wcyA9IHZhbGlkUHJvcHM7XG4gIH1cbiAgcmV0dXJuIHtcbiAgICAuLi4oZWxlbWVudEtleSA9PT0gJ2Zsb2F0aW5nJyAmJiB7XG4gICAgICB0YWJJbmRleDogLTEsXG4gICAgICBbRk9DVVNBQkxFX0FUVFJJQlVURV06ICcnXG4gICAgfSksXG4gICAgLi4uZG9tVXNlclByb3BzLFxuICAgIC4uLnByb3BzTGlzdC5tYXAodmFsdWUgPT4ge1xuICAgICAgY29uc3QgcHJvcHNPckdldFByb3BzID0gdmFsdWUgPyB2YWx1ZVtlbGVtZW50S2V5XSA6IG51bGw7XG4gICAgICBpZiAodHlwZW9mIHByb3BzT3JHZXRQcm9wcyA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICByZXR1cm4gdXNlclByb3BzID8gcHJvcHNPckdldFByb3BzKHVzZXJQcm9wcykgOiBudWxsO1xuICAgICAgfVxuICAgICAgcmV0dXJuIHByb3BzT3JHZXRQcm9wcztcbiAgICB9KS5jb25jYXQodXNlclByb3BzKS5yZWR1Y2UoKGFjYywgcHJvcHMpID0+IHtcbiAgICAgIGlmICghcHJvcHMpIHtcbiAgICAgICAgcmV0dXJuIGFjYztcbiAgICAgIH1cbiAgICAgIE9iamVjdC5lbnRyaWVzKHByb3BzKS5mb3JFYWNoKF9yZWYgPT4ge1xuICAgICAgICBsZXQgW2tleSwgdmFsdWVdID0gX3JlZjtcbiAgICAgICAgaWYgKGlzSXRlbSAmJiBbQUNUSVZFX0tFWSwgU0VMRUNURURfS0VZXS5pbmNsdWRlcyhrZXkpKSB7XG4gICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIGlmIChrZXkuaW5kZXhPZignb24nKSA9PT0gMCkge1xuICAgICAgICAgIGlmICghbWFwLmhhcyhrZXkpKSB7XG4gICAgICAgICAgICBtYXAuc2V0KGtleSwgW10pO1xuICAgICAgICAgIH1cbiAgICAgICAgICBpZiAodHlwZW9mIHZhbHVlID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICAgICAgICB2YXIgX21hcCRnZXQ7XG4gICAgICAgICAgICAoX21hcCRnZXQgPSBtYXAuZ2V0KGtleSkpID09IG51bGwgfHwgX21hcCRnZXQucHVzaCh2YWx1ZSk7XG4gICAgICAgICAgICBhY2Nba2V5XSA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgICAgdmFyIF9tYXAkZ2V0MjtcbiAgICAgICAgICAgICAgZm9yICh2YXIgX2xlbiA9IGFyZ3VtZW50cy5sZW5ndGgsIGFyZ3MgPSBuZXcgQXJyYXkoX2xlbiksIF9rZXkgPSAwOyBfa2V5IDwgX2xlbjsgX2tleSsrKSB7XG4gICAgICAgICAgICAgICAgYXJnc1tfa2V5XSA9IGFyZ3VtZW50c1tfa2V5XTtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICByZXR1cm4gKF9tYXAkZ2V0MiA9IG1hcC5nZXQoa2V5KSkgPT0gbnVsbCA/IHZvaWQgMCA6IF9tYXAkZ2V0Mi5tYXAoZm4gPT4gZm4oLi4uYXJncykpLmZpbmQodmFsID0+IHZhbCAhPT0gdW5kZWZpbmVkKTtcbiAgICAgICAgICAgIH07XG4gICAgICAgICAgfVxuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIGFjY1trZXldID0gdmFsdWU7XG4gICAgICAgIH1cbiAgICAgIH0pO1xuICAgICAgcmV0dXJuIGFjYztcbiAgICB9LCB7fSlcbiAgfTtcbn1cbi8qKlxuICogTWVyZ2VzIGFuIGFycmF5IG9mIGludGVyYWN0aW9uIGhvb2tzJyBwcm9wcyBpbnRvIHByb3AgZ2V0dGVycywgYWxsb3dpbmdcbiAqIGV2ZW50IGhhbmRsZXIgZnVuY3Rpb25zIHRvIGJlIGNvbXBvc2VkIHRvZ2V0aGVyIHdpdGhvdXQgb3ZlcndyaXRpbmcgb25lXG4gKiBhbm90aGVyLlxuICogQHNlZSBodHRwczovL2Zsb2F0aW5nLXVpLmNvbS9kb2NzL3VzZUludGVyYWN0aW9uc1xuICovXG5mdW5jdGlvbiB1c2VJbnRlcmFjdGlvbnMocHJvcHNMaXN0KSB7XG4gIGlmIChwcm9wc0xpc3QgPT09IHZvaWQgMCkge1xuICAgIHByb3BzTGlzdCA9IFtdO1xuICB9XG4gIGNvbnN0IHJlZmVyZW5jZURlcHMgPSBwcm9wc0xpc3QubWFwKGtleSA9PiBrZXkgPT0gbnVsbCA/IHZvaWQgMCA6IGtleS5yZWZlcmVuY2UpO1xuICBjb25zdCBmbG9hdGluZ0RlcHMgPSBwcm9wc0xpc3QubWFwKGtleSA9PiBrZXkgPT0gbnVsbCA/IHZvaWQgMCA6IGtleS5mbG9hdGluZyk7XG4gIGNvbnN0IGl0ZW1EZXBzID0gcHJvcHNMaXN0Lm1hcChrZXkgPT4ga2V5ID09IG51bGwgPyB2b2lkIDAgOiBrZXkuaXRlbSk7XG4gIGNvbnN0IGdldFJlZmVyZW5jZVByb3BzID0gUmVhY3QudXNlQ2FsbGJhY2sodXNlclByb3BzID0+IG1lcmdlUHJvcHModXNlclByb3BzLCBwcm9wc0xpc3QsICdyZWZlcmVuY2UnKSxcbiAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIHJlYWN0LWhvb2tzL2V4aGF1c3RpdmUtZGVwc1xuICByZWZlcmVuY2VEZXBzKTtcbiAgY29uc3QgZ2V0RmxvYXRpbmdQcm9wcyA9IFJlYWN0LnVzZUNhbGxiYWNrKHVzZXJQcm9wcyA9PiBtZXJnZVByb3BzKHVzZXJQcm9wcywgcHJvcHNMaXN0LCAnZmxvYXRpbmcnKSxcbiAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIHJlYWN0LWhvb2tzL2V4aGF1c3RpdmUtZGVwc1xuICBmbG9hdGluZ0RlcHMpO1xuICBjb25zdCBnZXRJdGVtUHJvcHMgPSBSZWFjdC51c2VDYWxsYmFjayh1c2VyUHJvcHMgPT4gbWVyZ2VQcm9wcyh1c2VyUHJvcHMsIHByb3BzTGlzdCwgJ2l0ZW0nKSxcbiAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIHJlYWN0LWhvb2tzL2V4aGF1c3RpdmUtZGVwc1xuICBpdGVtRGVwcyk7XG4gIHJldHVybiBSZWFjdC51c2VNZW1vKCgpID0+ICh7XG4gICAgZ2V0UmVmZXJlbmNlUHJvcHMsXG4gICAgZ2V0RmxvYXRpbmdQcm9wcyxcbiAgICBnZXRJdGVtUHJvcHNcbiAgfSksIFtnZXRSZWZlcmVuY2VQcm9wcywgZ2V0RmxvYXRpbmdQcm9wcywgZ2V0SXRlbVByb3BzXSk7XG59XG5cbmNvbnN0IEVTQ0FQRSA9ICdFc2NhcGUnO1xuZnVuY3Rpb24gZG9Td2l0Y2gob3JpZW50YXRpb24sIHZlcnRpY2FsLCBob3Jpem9udGFsKSB7XG4gIHN3aXRjaCAob3JpZW50YXRpb24pIHtcbiAgICBjYXNlICd2ZXJ0aWNhbCc6XG4gICAgICByZXR1cm4gdmVydGljYWw7XG4gICAgY2FzZSAnaG9yaXpvbnRhbCc6XG4gICAgICByZXR1cm4gaG9yaXpvbnRhbDtcbiAgICBkZWZhdWx0OlxuICAgICAgcmV0dXJuIHZlcnRpY2FsIHx8IGhvcml6b250YWw7XG4gIH1cbn1cbmZ1bmN0aW9uIGlzTWFpbk9yaWVudGF0aW9uS2V5KGtleSwgb3JpZW50YXRpb24pIHtcbiAgY29uc3QgdmVydGljYWwgPSBrZXkgPT09IEFSUk9XX1VQIHx8IGtleSA9PT0gQVJST1dfRE9XTjtcbiAgY29uc3QgaG9yaXpvbnRhbCA9IGtleSA9PT0gQVJST1dfTEVGVCB8fCBrZXkgPT09IEFSUk9XX1JJR0hUO1xuICByZXR1cm4gZG9Td2l0Y2gob3JpZW50YXRpb24sIHZlcnRpY2FsLCBob3Jpem9udGFsKTtcbn1cbmZ1bmN0aW9uIGlzTWFpbk9yaWVudGF0aW9uVG9FbmRLZXkoa2V5LCBvcmllbnRhdGlvbiwgcnRsKSB7XG4gIGNvbnN0IHZlcnRpY2FsID0ga2V5ID09PSBBUlJPV19ET1dOO1xuICBjb25zdCBob3Jpem9udGFsID0gcnRsID8ga2V5ID09PSBBUlJPV19MRUZUIDoga2V5ID09PSBBUlJPV19SSUdIVDtcbiAgcmV0dXJuIGRvU3dpdGNoKG9yaWVudGF0aW9uLCB2ZXJ0aWNhbCwgaG9yaXpvbnRhbCkgfHwga2V5ID09PSAnRW50ZXInIHx8IGtleSA9PT0gJyAnIHx8IGtleSA9PT0gJyc7XG59XG5mdW5jdGlvbiBpc0Nyb3NzT3JpZW50YXRpb25PcGVuS2V5KGtleSwgb3JpZW50YXRpb24sIHJ0bCkge1xuICBjb25zdCB2ZXJ0aWNhbCA9IHJ0bCA/IGtleSA9PT0gQVJST1dfTEVGVCA6IGtleSA9PT0gQVJST1dfUklHSFQ7XG4gIGNvbnN0IGhvcml6b250YWwgPSBrZXkgPT09IEFSUk9XX0RPV047XG4gIHJldHVybiBkb1N3aXRjaChvcmllbnRhdGlvbiwgdmVydGljYWwsIGhvcml6b250YWwpO1xufVxuZnVuY3Rpb24gaXNDcm9zc09yaWVudGF0aW9uQ2xvc2VLZXkoa2V5LCBvcmllbnRhdGlvbiwgcnRsLCBjb2xzKSB7XG4gIGNvbnN0IHZlcnRpY2FsID0gcnRsID8ga2V5ID09PSBBUlJPV19SSUdIVCA6IGtleSA9PT0gQVJST1dfTEVGVDtcbiAgY29uc3QgaG9yaXpvbnRhbCA9IGtleSA9PT0gQVJST1dfVVA7XG4gIGlmIChvcmllbnRhdGlvbiA9PT0gJ2JvdGgnIHx8IG9yaWVudGF0aW9uID09PSAnaG9yaXpvbnRhbCcgJiYgY29scyAmJiBjb2xzID4gMSkge1xuICAgIHJldHVybiBrZXkgPT09IEVTQ0FQRTtcbiAgfVxuICByZXR1cm4gZG9Td2l0Y2gob3JpZW50YXRpb24sIHZlcnRpY2FsLCBob3Jpem9udGFsKTtcbn1cbi8qKlxuICogQWRkcyBhcnJvdyBrZXktYmFzZWQgbmF2aWdhdGlvbiBvZiBhIGxpc3Qgb2YgaXRlbXMsIGVpdGhlciB1c2luZyByZWFsIERPTVxuICogZm9jdXMgb3IgdmlydHVhbCBmb2N1cy5cbiAqIEBzZWUgaHR0cHM6Ly9mbG9hdGluZy11aS5jb20vZG9jcy91c2VMaXN0TmF2aWdhdGlvblxuICovXG5mdW5jdGlvbiB1c2VMaXN0TmF2aWdhdGlvbihjb250ZXh0LCBwcm9wcykge1xuICBjb25zdCB7XG4gICAgb3BlbixcbiAgICBvbk9wZW5DaGFuZ2UsXG4gICAgZWxlbWVudHMsXG4gICAgZmxvYXRpbmdJZFxuICB9ID0gY29udGV4dDtcbiAgY29uc3Qge1xuICAgIGxpc3RSZWYsXG4gICAgYWN0aXZlSW5kZXgsXG4gICAgb25OYXZpZ2F0ZTogdW5zdGFibGVfb25OYXZpZ2F0ZSA9ICgpID0+IHt9LFxuICAgIGVuYWJsZWQgPSB0cnVlLFxuICAgIHNlbGVjdGVkSW5kZXggPSBudWxsLFxuICAgIGFsbG93RXNjYXBlID0gZmFsc2UsXG4gICAgbG9vcCA9IGZhbHNlLFxuICAgIG5lc3RlZCA9IGZhbHNlLFxuICAgIHJ0bCA9IGZhbHNlLFxuICAgIHZpcnR1YWwgPSBmYWxzZSxcbiAgICBmb2N1c0l0ZW1Pbk9wZW4gPSAnYXV0bycsXG4gICAgZm9jdXNJdGVtT25Ib3ZlciA9IHRydWUsXG4gICAgb3Blbk9uQXJyb3dLZXlEb3duID0gdHJ1ZSxcbiAgICBkaXNhYmxlZEluZGljZXMgPSB1bmRlZmluZWQsXG4gICAgb3JpZW50YXRpb24gPSAndmVydGljYWwnLFxuICAgIHBhcmVudE9yaWVudGF0aW9uLFxuICAgIGNvbHMgPSAxLFxuICAgIHNjcm9sbEl0ZW1JbnRvVmlldyA9IHRydWUsXG4gICAgdmlydHVhbEl0ZW1SZWYsXG4gICAgaXRlbVNpemVzLFxuICAgIGRlbnNlID0gZmFsc2VcbiAgfSA9IHByb3BzO1xuICBpZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09IFwicHJvZHVjdGlvblwiKSB7XG4gICAgaWYgKGFsbG93RXNjYXBlKSB7XG4gICAgICBpZiAoIWxvb3ApIHtcbiAgICAgICAgd2FybignYHVzZUxpc3ROYXZpZ2F0aW9uYCBsb29waW5nIG11c3QgYmUgZW5hYmxlZCB0byBhbGxvdyBlc2NhcGluZy4nKTtcbiAgICAgIH1cbiAgICAgIGlmICghdmlydHVhbCkge1xuICAgICAgICB3YXJuKCdgdXNlTGlzdE5hdmlnYXRpb25gIG11c3QgYmUgdmlydHVhbCB0byBhbGxvdyBlc2NhcGluZy4nKTtcbiAgICAgIH1cbiAgICB9XG4gICAgaWYgKG9yaWVudGF0aW9uID09PSAndmVydGljYWwnICYmIGNvbHMgPiAxKSB7XG4gICAgICB3YXJuKCdJbiBncmlkIGxpc3QgbmF2aWdhdGlvbiBtb2RlIChgY29sc2AgPiAxKSwgdGhlIGBvcmllbnRhdGlvbmAgc2hvdWxkJywgJ2JlIGVpdGhlciBcImhvcml6b250YWxcIiBvciBcImJvdGhcIi4nKTtcbiAgICB9XG4gIH1cbiAgY29uc3QgZmxvYXRpbmdGb2N1c0VsZW1lbnQgPSBnZXRGbG9hdGluZ0ZvY3VzRWxlbWVudChlbGVtZW50cy5mbG9hdGluZyk7XG4gIGNvbnN0IGZsb2F0aW5nRm9jdXNFbGVtZW50UmVmID0gdXNlTGF0ZXN0UmVmKGZsb2F0aW5nRm9jdXNFbGVtZW50KTtcbiAgY29uc3QgcGFyZW50SWQgPSB1c2VGbG9hdGluZ1BhcmVudE5vZGVJZCgpO1xuICBjb25zdCB0cmVlID0gdXNlRmxvYXRpbmdUcmVlKCk7XG4gIHVzZU1vZGVybkxheW91dEVmZmVjdCgoKSA9PiB7XG4gICAgY29udGV4dC5kYXRhUmVmLmN1cnJlbnQub3JpZW50YXRpb24gPSBvcmllbnRhdGlvbjtcbiAgfSwgW2NvbnRleHQsIG9yaWVudGF0aW9uXSk7XG4gIGNvbnN0IG9uTmF2aWdhdGUgPSB1c2VFZmZlY3RFdmVudCgoKSA9PiB7XG4gICAgdW5zdGFibGVfb25OYXZpZ2F0ZShpbmRleFJlZi5jdXJyZW50ID09PSAtMSA/IG51bGwgOiBpbmRleFJlZi5jdXJyZW50KTtcbiAgfSk7XG4gIGNvbnN0IHR5cGVhYmxlQ29tYm9ib3hSZWZlcmVuY2UgPSBpc1R5cGVhYmxlQ29tYm9ib3goZWxlbWVudHMuZG9tUmVmZXJlbmNlKTtcbiAgY29uc3QgZm9jdXNJdGVtT25PcGVuUmVmID0gUmVhY3QudXNlUmVmKGZvY3VzSXRlbU9uT3Blbik7XG4gIGNvbnN0IGluZGV4UmVmID0gUmVhY3QudXNlUmVmKHNlbGVjdGVkSW5kZXggIT0gbnVsbCA/IHNlbGVjdGVkSW5kZXggOiAtMSk7XG4gIGNvbnN0IGtleVJlZiA9IFJlYWN0LnVzZVJlZihudWxsKTtcbiAgY29uc3QgaXNQb2ludGVyTW9kYWxpdHlSZWYgPSBSZWFjdC51c2VSZWYodHJ1ZSk7XG4gIGNvbnN0IHByZXZpb3VzT25OYXZpZ2F0ZVJlZiA9IFJlYWN0LnVzZVJlZihvbk5hdmlnYXRlKTtcbiAgY29uc3QgcHJldmlvdXNNb3VudGVkUmVmID0gUmVhY3QudXNlUmVmKCEhZWxlbWVudHMuZmxvYXRpbmcpO1xuICBjb25zdCBwcmV2aW91c09wZW5SZWYgPSBSZWFjdC51c2VSZWYob3Blbik7XG4gIGNvbnN0IGZvcmNlU3luY0ZvY3VzUmVmID0gUmVhY3QudXNlUmVmKGZhbHNlKTtcbiAgY29uc3QgZm9yY2VTY3JvbGxJbnRvVmlld1JlZiA9IFJlYWN0LnVzZVJlZihmYWxzZSk7XG4gIGNvbnN0IGRpc2FibGVkSW5kaWNlc1JlZiA9IHVzZUxhdGVzdFJlZihkaXNhYmxlZEluZGljZXMpO1xuICBjb25zdCBsYXRlc3RPcGVuUmVmID0gdXNlTGF0ZXN0UmVmKG9wZW4pO1xuICBjb25zdCBzY3JvbGxJdGVtSW50b1ZpZXdSZWYgPSB1c2VMYXRlc3RSZWYoc2Nyb2xsSXRlbUludG9WaWV3KTtcbiAgY29uc3Qgc2VsZWN0ZWRJbmRleFJlZiA9IHVzZUxhdGVzdFJlZihzZWxlY3RlZEluZGV4KTtcbiAgY29uc3QgW2FjdGl2ZUlkLCBzZXRBY3RpdmVJZF0gPSBSZWFjdC51c2VTdGF0ZSgpO1xuICBjb25zdCBbdmlydHVhbElkLCBzZXRWaXJ0dWFsSWRdID0gUmVhY3QudXNlU3RhdGUoKTtcbiAgY29uc3QgZm9jdXNJdGVtID0gdXNlRWZmZWN0RXZlbnQoKCkgPT4ge1xuICAgIGZ1bmN0aW9uIHJ1bkZvY3VzKGl0ZW0pIHtcbiAgICAgIGlmICh2aXJ0dWFsKSB7XG4gICAgICAgIHZhciBfaXRlbSRpZDtcbiAgICAgICAgaWYgKChfaXRlbSRpZCA9IGl0ZW0uaWQpICE9IG51bGwgJiYgX2l0ZW0kaWQuZW5kc1dpdGgoJy1mdWktb3B0aW9uJykpIHtcbiAgICAgICAgICBpdGVtLmlkID0gZmxvYXRpbmdJZCArIFwiLVwiICsgTWF0aC5yYW5kb20oKS50b1N0cmluZygxNikuc2xpY2UoMiwgMTApO1xuICAgICAgICB9XG4gICAgICAgIHNldEFjdGl2ZUlkKGl0ZW0uaWQpO1xuICAgICAgICB0cmVlID09IG51bGwgfHwgdHJlZS5ldmVudHMuZW1pdCgndmlydHVhbGZvY3VzJywgaXRlbSk7XG4gICAgICAgIGlmICh2aXJ0dWFsSXRlbVJlZikge1xuICAgICAgICAgIHZpcnR1YWxJdGVtUmVmLmN1cnJlbnQgPSBpdGVtO1xuICAgICAgICB9XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBlbnF1ZXVlRm9jdXMoaXRlbSwge1xuICAgICAgICAgIHN5bmM6IGZvcmNlU3luY0ZvY3VzUmVmLmN1cnJlbnQsXG4gICAgICAgICAgcHJldmVudFNjcm9sbDogdHJ1ZVxuICAgICAgICB9KTtcbiAgICAgIH1cbiAgICB9XG4gICAgY29uc3QgaW5pdGlhbEl0ZW0gPSBsaXN0UmVmLmN1cnJlbnRbaW5kZXhSZWYuY3VycmVudF07XG4gICAgY29uc3QgZm9yY2VTY3JvbGxJbnRvVmlldyA9IGZvcmNlU2Nyb2xsSW50b1ZpZXdSZWYuY3VycmVudDtcbiAgICBpZiAoaW5pdGlhbEl0ZW0pIHtcbiAgICAgIHJ1bkZvY3VzKGluaXRpYWxJdGVtKTtcbiAgICB9XG4gICAgY29uc3Qgc2NoZWR1bGVyID0gZm9yY2VTeW5jRm9jdXNSZWYuY3VycmVudCA/IHYgPT4gdigpIDogcmVxdWVzdEFuaW1hdGlvbkZyYW1lO1xuICAgIHNjaGVkdWxlcigoKSA9PiB7XG4gICAgICBjb25zdCB3YWl0ZWRJdGVtID0gbGlzdFJlZi5jdXJyZW50W2luZGV4UmVmLmN1cnJlbnRdIHx8IGluaXRpYWxJdGVtO1xuICAgICAgaWYgKCF3YWl0ZWRJdGVtKSByZXR1cm47XG4gICAgICBpZiAoIWluaXRpYWxJdGVtKSB7XG4gICAgICAgIHJ1bkZvY3VzKHdhaXRlZEl0ZW0pO1xuICAgICAgfVxuICAgICAgY29uc3Qgc2Nyb2xsSW50b1ZpZXdPcHRpb25zID0gc2Nyb2xsSXRlbUludG9WaWV3UmVmLmN1cnJlbnQ7XG4gICAgICBjb25zdCBzaG91bGRTY3JvbGxJbnRvVmlldyA9IHNjcm9sbEludG9WaWV3T3B0aW9ucyAmJiBpdGVtICYmIChmb3JjZVNjcm9sbEludG9WaWV3IHx8ICFpc1BvaW50ZXJNb2RhbGl0eVJlZi5jdXJyZW50KTtcbiAgICAgIGlmIChzaG91bGRTY3JvbGxJbnRvVmlldykge1xuICAgICAgICAvLyBKU0RPTSBkb2Vzbid0IHN1cHBvcnQgYC5zY3JvbGxJbnRvVmlldygpYCBidXQgaXQncyB3aWRlbHkgc3VwcG9ydGVkXG4gICAgICAgIC8vIGJ5IGFsbCBicm93c2Vycy5cbiAgICAgICAgd2FpdGVkSXRlbS5zY3JvbGxJbnRvVmlldyA9PSBudWxsIHx8IHdhaXRlZEl0ZW0uc2Nyb2xsSW50b1ZpZXcodHlwZW9mIHNjcm9sbEludG9WaWV3T3B0aW9ucyA9PT0gJ2Jvb2xlYW4nID8ge1xuICAgICAgICAgIGJsb2NrOiAnbmVhcmVzdCcsXG4gICAgICAgICAgaW5saW5lOiAnbmVhcmVzdCdcbiAgICAgICAgfSA6IHNjcm9sbEludG9WaWV3T3B0aW9ucyk7XG4gICAgICB9XG4gICAgfSk7XG4gIH0pO1xuXG4gIC8vIFN5bmMgYHNlbGVjdGVkSW5kZXhgIHRvIGJlIHRoZSBgYWN0aXZlSW5kZXhgIHVwb24gb3BlbmluZyB0aGUgZmxvYXRpbmdcbiAgLy8gZWxlbWVudC4gQWxzbywgcmVzZXQgYGFjdGl2ZUluZGV4YCB1cG9uIGNsb3NpbmcgdGhlIGZsb2F0aW5nIGVsZW1lbnQuXG4gIHVzZU1vZGVybkxheW91dEVmZmVjdCgoKSA9PiB7XG4gICAgaWYgKCFlbmFibGVkKSByZXR1cm47XG4gICAgaWYgKG9wZW4gJiYgZWxlbWVudHMuZmxvYXRpbmcpIHtcbiAgICAgIGlmIChmb2N1c0l0ZW1Pbk9wZW5SZWYuY3VycmVudCAmJiBzZWxlY3RlZEluZGV4ICE9IG51bGwpIHtcbiAgICAgICAgLy8gUmVnYXJkbGVzcyBvZiB0aGUgcG9pbnRlciBtb2RhbGl0eSwgd2Ugd2FudCB0byBlbnN1cmUgdGhlIHNlbGVjdGVkXG4gICAgICAgIC8vIGl0ZW0gY29tZXMgaW50byB2aWV3IHdoZW4gdGhlIGZsb2F0aW5nIGVsZW1lbnQgaXMgb3BlbmVkLlxuICAgICAgICBmb3JjZVNjcm9sbEludG9WaWV3UmVmLmN1cnJlbnQgPSB0cnVlO1xuICAgICAgICBpbmRleFJlZi5jdXJyZW50ID0gc2VsZWN0ZWRJbmRleDtcbiAgICAgICAgb25OYXZpZ2F0ZSgpO1xuICAgICAgfVxuICAgIH0gZWxzZSBpZiAocHJldmlvdXNNb3VudGVkUmVmLmN1cnJlbnQpIHtcbiAgICAgIC8vIFNpbmNlIHRoZSB1c2VyIGNhbiBzcGVjaWZ5IGBvbk5hdmlnYXRlYCBjb25kaXRpb25hbGx5XG4gICAgICAvLyAob25OYXZpZ2F0ZTogb3BlbiA/IHNldEFjdGl2ZUluZGV4IDogc2V0U2VsZWN0ZWRJbmRleCksXG4gICAgICAvLyB3ZSBzdG9yZSBhbmQgY2FsbCB0aGUgcHJldmlvdXMgZnVuY3Rpb24uXG4gICAgICBpbmRleFJlZi5jdXJyZW50ID0gLTE7XG4gICAgICBwcmV2aW91c09uTmF2aWdhdGVSZWYuY3VycmVudCgpO1xuICAgIH1cbiAgfSwgW2VuYWJsZWQsIG9wZW4sIGVsZW1lbnRzLmZsb2F0aW5nLCBzZWxlY3RlZEluZGV4LCBvbk5hdmlnYXRlXSk7XG5cbiAgLy8gU3luYyBgYWN0aXZlSW5kZXhgIHRvIGJlIHRoZSBmb2N1c2VkIGl0ZW0gd2hpbGUgdGhlIGZsb2F0aW5nIGVsZW1lbnQgaXNcbiAgLy8gb3Blbi5cbiAgdXNlTW9kZXJuTGF5b3V0RWZmZWN0KCgpID0+IHtcbiAgICBpZiAoIWVuYWJsZWQpIHJldHVybjtcbiAgICBpZiAoIW9wZW4pIHJldHVybjtcbiAgICBpZiAoIWVsZW1lbnRzLmZsb2F0aW5nKSByZXR1cm47XG4gICAgaWYgKGFjdGl2ZUluZGV4ID09IG51bGwpIHtcbiAgICAgIGZvcmNlU3luY0ZvY3VzUmVmLmN1cnJlbnQgPSBmYWxzZTtcbiAgICAgIGlmIChzZWxlY3RlZEluZGV4UmVmLmN1cnJlbnQgIT0gbnVsbCkge1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG5cbiAgICAgIC8vIFJlc2V0IHdoaWxlIHRoZSBmbG9hdGluZyBlbGVtZW50IHdhcyBvcGVuIChlLmcuIHRoZSBsaXN0IGNoYW5nZWQpLlxuICAgICAgaWYgKHByZXZpb3VzTW91bnRlZFJlZi5jdXJyZW50KSB7XG4gICAgICAgIGluZGV4UmVmLmN1cnJlbnQgPSAtMTtcbiAgICAgICAgZm9jdXNJdGVtKCk7XG4gICAgICB9XG5cbiAgICAgIC8vIEluaXRpYWwgc3luYy5cbiAgICAgIGlmICgoIXByZXZpb3VzT3BlblJlZi5jdXJyZW50IHx8ICFwcmV2aW91c01vdW50ZWRSZWYuY3VycmVudCkgJiYgZm9jdXNJdGVtT25PcGVuUmVmLmN1cnJlbnQgJiYgKGtleVJlZi5jdXJyZW50ICE9IG51bGwgfHwgZm9jdXNJdGVtT25PcGVuUmVmLmN1cnJlbnQgPT09IHRydWUgJiYga2V5UmVmLmN1cnJlbnQgPT0gbnVsbCkpIHtcbiAgICAgICAgbGV0IHJ1bnMgPSAwO1xuICAgICAgICBjb25zdCB3YWl0Rm9yTGlzdFBvcHVsYXRlZCA9ICgpID0+IHtcbiAgICAgICAgICBpZiAobGlzdFJlZi5jdXJyZW50WzBdID09IG51bGwpIHtcbiAgICAgICAgICAgIC8vIEF2b2lkIGxldHRpbmcgdGhlIGJyb3dzZXIgcGFpbnQgaWYgcG9zc2libGUgb24gdGhlIGZpcnN0IHRyeSxcbiAgICAgICAgICAgIC8vIG90aGVyd2lzZSB1c2UgckFGLiBEb24ndCB0cnkgbW9yZSB0aGFuIHR3aWNlLCBzaW5jZSBzb21ldGhpbmdcbiAgICAgICAgICAgIC8vIGlzIHdyb25nIG90aGVyd2lzZS5cbiAgICAgICAgICAgIGlmIChydW5zIDwgMikge1xuICAgICAgICAgICAgICBjb25zdCBzY2hlZHVsZXIgPSBydW5zID8gcmVxdWVzdEFuaW1hdGlvbkZyYW1lIDogcXVldWVNaWNyb3Rhc2s7XG4gICAgICAgICAgICAgIHNjaGVkdWxlcih3YWl0Rm9yTGlzdFBvcHVsYXRlZCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBydW5zKys7XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIGluZGV4UmVmLmN1cnJlbnQgPSBrZXlSZWYuY3VycmVudCA9PSBudWxsIHx8IGlzTWFpbk9yaWVudGF0aW9uVG9FbmRLZXkoa2V5UmVmLmN1cnJlbnQsIG9yaWVudGF0aW9uLCBydGwpIHx8IG5lc3RlZCA/IGdldE1pbkxpc3RJbmRleChsaXN0UmVmLCBkaXNhYmxlZEluZGljZXNSZWYuY3VycmVudCkgOiBnZXRNYXhMaXN0SW5kZXgobGlzdFJlZiwgZGlzYWJsZWRJbmRpY2VzUmVmLmN1cnJlbnQpO1xuICAgICAgICAgICAga2V5UmVmLmN1cnJlbnQgPSBudWxsO1xuICAgICAgICAgICAgb25OYXZpZ2F0ZSgpO1xuICAgICAgICAgIH1cbiAgICAgICAgfTtcbiAgICAgICAgd2FpdEZvckxpc3RQb3B1bGF0ZWQoKTtcbiAgICAgIH1cbiAgICB9IGVsc2UgaWYgKCFpc0luZGV4T3V0T2ZMaXN0Qm91bmRzKGxpc3RSZWYsIGFjdGl2ZUluZGV4KSkge1xuICAgICAgaW5kZXhSZWYuY3VycmVudCA9IGFjdGl2ZUluZGV4O1xuICAgICAgZm9jdXNJdGVtKCk7XG4gICAgICBmb3JjZVNjcm9sbEludG9WaWV3UmVmLmN1cnJlbnQgPSBmYWxzZTtcbiAgICB9XG4gIH0sIFtlbmFibGVkLCBvcGVuLCBlbGVtZW50cy5mbG9hdGluZywgYWN0aXZlSW5kZXgsIHNlbGVjdGVkSW5kZXhSZWYsIG5lc3RlZCwgbGlzdFJlZiwgb3JpZW50YXRpb24sIHJ0bCwgb25OYXZpZ2F0ZSwgZm9jdXNJdGVtLCBkaXNhYmxlZEluZGljZXNSZWZdKTtcblxuICAvLyBFbnN1cmUgdGhlIHBhcmVudCBmbG9hdGluZyBlbGVtZW50IGhhcyBmb2N1cyB3aGVuIGEgbmVzdGVkIGNoaWxkIGNsb3Nlc1xuICAvLyB0byBhbGxvdyBhcnJvdyBrZXkgbmF2aWdhdGlvbiB0byB3b3JrIGFmdGVyIHRoZSBwb2ludGVyIGxlYXZlcyB0aGUgY2hpbGQuXG4gIHVzZU1vZGVybkxheW91dEVmZmVjdCgoKSA9PiB7XG4gICAgdmFyIF9ub2RlcyRmaW5kO1xuICAgIGlmICghZW5hYmxlZCB8fCBlbGVtZW50cy5mbG9hdGluZyB8fCAhdHJlZSB8fCB2aXJ0dWFsIHx8ICFwcmV2aW91c01vdW50ZWRSZWYuY3VycmVudCkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBjb25zdCBub2RlcyA9IHRyZWUubm9kZXNSZWYuY3VycmVudDtcbiAgICBjb25zdCBwYXJlbnQgPSAoX25vZGVzJGZpbmQgPSBub2Rlcy5maW5kKG5vZGUgPT4gbm9kZS5pZCA9PT0gcGFyZW50SWQpKSA9PSBudWxsIHx8IChfbm9kZXMkZmluZCA9IF9ub2RlcyRmaW5kLmNvbnRleHQpID09IG51bGwgPyB2b2lkIDAgOiBfbm9kZXMkZmluZC5lbGVtZW50cy5mbG9hdGluZztcbiAgICBjb25zdCBhY3RpdmVFbCA9IGFjdGl2ZUVsZW1lbnQoZ2V0RG9jdW1lbnQkMShlbGVtZW50cy5mbG9hdGluZykpO1xuICAgIGNvbnN0IHRyZWVDb250YWluc0FjdGl2ZUVsID0gbm9kZXMuc29tZShub2RlID0+IG5vZGUuY29udGV4dCAmJiBjb250YWlucyQxKG5vZGUuY29udGV4dC5lbGVtZW50cy5mbG9hdGluZywgYWN0aXZlRWwpKTtcbiAgICBpZiAocGFyZW50ICYmICF0cmVlQ29udGFpbnNBY3RpdmVFbCAmJiBpc1BvaW50ZXJNb2RhbGl0eVJlZi5jdXJyZW50KSB7XG4gICAgICBwYXJlbnQuZm9jdXMoe1xuICAgICAgICBwcmV2ZW50U2Nyb2xsOiB0cnVlXG4gICAgICB9KTtcbiAgICB9XG4gIH0sIFtlbmFibGVkLCBlbGVtZW50cy5mbG9hdGluZywgdHJlZSwgcGFyZW50SWQsIHZpcnR1YWxdKTtcbiAgdXNlTW9kZXJuTGF5b3V0RWZmZWN0KCgpID0+IHtcbiAgICBpZiAoIWVuYWJsZWQpIHJldHVybjtcbiAgICBpZiAoIXRyZWUpIHJldHVybjtcbiAgICBpZiAoIXZpcnR1YWwpIHJldHVybjtcbiAgICBpZiAocGFyZW50SWQpIHJldHVybjtcbiAgICBmdW5jdGlvbiBoYW5kbGVWaXJ0dWFsRm9jdXMoaXRlbSkge1xuICAgICAgc2V0VmlydHVhbElkKGl0ZW0uaWQpO1xuICAgICAgaWYgKHZpcnR1YWxJdGVtUmVmKSB7XG4gICAgICAgIHZpcnR1YWxJdGVtUmVmLmN1cnJlbnQgPSBpdGVtO1xuICAgICAgfVxuICAgIH1cbiAgICB0cmVlLmV2ZW50cy5vbigndmlydHVhbGZvY3VzJywgaGFuZGxlVmlydHVhbEZvY3VzKTtcbiAgICByZXR1cm4gKCkgPT4ge1xuICAgICAgdHJlZS5ldmVudHMub2ZmKCd2aXJ0dWFsZm9jdXMnLCBoYW5kbGVWaXJ0dWFsRm9jdXMpO1xuICAgIH07XG4gIH0sIFtlbmFibGVkLCB0cmVlLCB2aXJ0dWFsLCBwYXJlbnRJZCwgdmlydHVhbEl0ZW1SZWZdKTtcbiAgdXNlTW9kZXJuTGF5b3V0RWZmZWN0KCgpID0+IHtcbiAgICBwcmV2aW91c09uTmF2aWdhdGVSZWYuY3VycmVudCA9IG9uTmF2aWdhdGU7XG4gICAgcHJldmlvdXNPcGVuUmVmLmN1cnJlbnQgPSBvcGVuO1xuICAgIHByZXZpb3VzTW91bnRlZFJlZi5jdXJyZW50ID0gISFlbGVtZW50cy5mbG9hdGluZztcbiAgfSk7XG4gIHVzZU1vZGVybkxheW91dEVmZmVjdCgoKSA9PiB7XG4gICAgaWYgKCFvcGVuKSB7XG4gICAgICBrZXlSZWYuY3VycmVudCA9IG51bGw7XG4gICAgICBmb2N1c0l0ZW1Pbk9wZW5SZWYuY3VycmVudCA9IGZvY3VzSXRlbU9uT3BlbjtcbiAgICB9XG4gIH0sIFtvcGVuLCBmb2N1c0l0ZW1Pbk9wZW5dKTtcbiAgY29uc3QgaGFzQWN0aXZlSW5kZXggPSBhY3RpdmVJbmRleCAhPSBudWxsO1xuICBjb25zdCBpdGVtID0gUmVhY3QudXNlTWVtbygoKSA9PiB7XG4gICAgZnVuY3Rpb24gc3luY0N1cnJlbnRUYXJnZXQoY3VycmVudFRhcmdldCkge1xuICAgICAgaWYgKCFsYXRlc3RPcGVuUmVmLmN1cnJlbnQpIHJldHVybjtcbiAgICAgIGNvbnN0IGluZGV4ID0gbGlzdFJlZi5jdXJyZW50LmluZGV4T2YoY3VycmVudFRhcmdldCk7XG4gICAgICBpZiAoaW5kZXggIT09IC0xICYmIGluZGV4UmVmLmN1cnJlbnQgIT09IGluZGV4KSB7XG4gICAgICAgIGluZGV4UmVmLmN1cnJlbnQgPSBpbmRleDtcbiAgICAgICAgb25OYXZpZ2F0ZSgpO1xuICAgICAgfVxuICAgIH1cbiAgICBjb25zdCBwcm9wcyA9IHtcbiAgICAgIG9uRm9jdXMoX3JlZikge1xuICAgICAgICBsZXQge1xuICAgICAgICAgIGN1cnJlbnRUYXJnZXRcbiAgICAgICAgfSA9IF9yZWY7XG4gICAgICAgIGZvcmNlU3luY0ZvY3VzUmVmLmN1cnJlbnQgPSB0cnVlO1xuICAgICAgICBzeW5jQ3VycmVudFRhcmdldChjdXJyZW50VGFyZ2V0KTtcbiAgICAgIH0sXG4gICAgICBvbkNsaWNrOiBfcmVmMiA9PiB7XG4gICAgICAgIGxldCB7XG4gICAgICAgICAgY3VycmVudFRhcmdldFxuICAgICAgICB9ID0gX3JlZjI7XG4gICAgICAgIHJldHVybiBjdXJyZW50VGFyZ2V0LmZvY3VzKHtcbiAgICAgICAgICBwcmV2ZW50U2Nyb2xsOiB0cnVlXG4gICAgICAgIH0pO1xuICAgICAgfSxcbiAgICAgIC8vIFNhZmFyaVxuICAgICAgb25Nb3VzZU1vdmUoX3JlZjMpIHtcbiAgICAgICAgbGV0IHtcbiAgICAgICAgICBjdXJyZW50VGFyZ2V0XG4gICAgICAgIH0gPSBfcmVmMztcbiAgICAgICAgZm9yY2VTeW5jRm9jdXNSZWYuY3VycmVudCA9IHRydWU7XG4gICAgICAgIGZvcmNlU2Nyb2xsSW50b1ZpZXdSZWYuY3VycmVudCA9IGZhbHNlO1xuICAgICAgICBpZiAoZm9jdXNJdGVtT25Ib3Zlcikge1xuICAgICAgICAgIHN5bmNDdXJyZW50VGFyZ2V0KGN1cnJlbnRUYXJnZXQpO1xuICAgICAgICB9XG4gICAgICB9LFxuICAgICAgb25Qb2ludGVyTGVhdmUoX3JlZjQpIHtcbiAgICAgICAgbGV0IHtcbiAgICAgICAgICBwb2ludGVyVHlwZVxuICAgICAgICB9ID0gX3JlZjQ7XG4gICAgICAgIGlmICghaXNQb2ludGVyTW9kYWxpdHlSZWYuY3VycmVudCB8fCBwb2ludGVyVHlwZSA9PT0gJ3RvdWNoJykge1xuICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICBmb3JjZVN5bmNGb2N1c1JlZi5jdXJyZW50ID0gdHJ1ZTtcbiAgICAgICAgaWYgKCFmb2N1c0l0ZW1PbkhvdmVyKSB7XG4gICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIGluZGV4UmVmLmN1cnJlbnQgPSAtMTtcbiAgICAgICAgb25OYXZpZ2F0ZSgpO1xuICAgICAgICBpZiAoIXZpcnR1YWwpIHtcbiAgICAgICAgICB2YXIgX2Zsb2F0aW5nRm9jdXNFbGVtZW50O1xuICAgICAgICAgIChfZmxvYXRpbmdGb2N1c0VsZW1lbnQgPSBmbG9hdGluZ0ZvY3VzRWxlbWVudFJlZi5jdXJyZW50KSA9PSBudWxsIHx8IF9mbG9hdGluZ0ZvY3VzRWxlbWVudC5mb2N1cyh7XG4gICAgICAgICAgICBwcmV2ZW50U2Nyb2xsOiB0cnVlXG4gICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9O1xuICAgIHJldHVybiBwcm9wcztcbiAgfSwgW2xhdGVzdE9wZW5SZWYsIGZsb2F0aW5nRm9jdXNFbGVtZW50UmVmLCBmb2N1c0l0ZW1PbkhvdmVyLCBsaXN0UmVmLCBvbk5hdmlnYXRlLCB2aXJ0dWFsXSk7XG4gIGNvbnN0IGdldFBhcmVudE9yaWVudGF0aW9uID0gUmVhY3QudXNlQ2FsbGJhY2soKCkgPT4ge1xuICAgIHZhciBfdHJlZSRub2Rlc1JlZiRjdXJyZW47XG4gICAgcmV0dXJuIHBhcmVudE9yaWVudGF0aW9uICE9IG51bGwgPyBwYXJlbnRPcmllbnRhdGlvbiA6IHRyZWUgPT0gbnVsbCB8fCAoX3RyZWUkbm9kZXNSZWYkY3VycmVuID0gdHJlZS5ub2Rlc1JlZi5jdXJyZW50LmZpbmQobm9kZSA9PiBub2RlLmlkID09PSBwYXJlbnRJZCkpID09IG51bGwgfHwgKF90cmVlJG5vZGVzUmVmJGN1cnJlbiA9IF90cmVlJG5vZGVzUmVmJGN1cnJlbi5jb250ZXh0KSA9PSBudWxsIHx8IChfdHJlZSRub2Rlc1JlZiRjdXJyZW4gPSBfdHJlZSRub2Rlc1JlZiRjdXJyZW4uZGF0YVJlZikgPT0gbnVsbCA/IHZvaWQgMCA6IF90cmVlJG5vZGVzUmVmJGN1cnJlbi5jdXJyZW50Lm9yaWVudGF0aW9uO1xuICB9LCBbcGFyZW50SWQsIHRyZWUsIHBhcmVudE9yaWVudGF0aW9uXSk7XG4gIGNvbnN0IGNvbW1vbk9uS2V5RG93biA9IHVzZUVmZmVjdEV2ZW50KGV2ZW50ID0+IHtcbiAgICBpc1BvaW50ZXJNb2RhbGl0eVJlZi5jdXJyZW50ID0gZmFsc2U7XG4gICAgZm9yY2VTeW5jRm9jdXNSZWYuY3VycmVudCA9IHRydWU7XG5cbiAgICAvLyBXaGVuIGNvbXBvc2luZyBhIGNoYXJhY3RlciwgQ2hyb21lIGZpcmVzIEFycm93RG93biB0d2ljZS4gRmlyZWZveC9TYWZhcmlcbiAgICAvLyBkb24ndCBhcHBlYXIgdG8gc3VmZmVyIGZyb20gdGhpcy4gYGV2ZW50LmlzQ29tcG9zaW5nYCBpcyBhdm9pZGVkIGR1ZSB0b1xuICAgIC8vIFNhZmFyaSBub3Qgc3VwcG9ydGluZyBpdCBwcm9wZXJseSAoYWx0aG91Z2ggaXQncyBub3QgbmVlZGVkIGluIHRoZSBmaXJzdFxuICAgIC8vIHBsYWNlIGZvciBTYWZhcmksIGp1c3QgYXZvaWRpbmcgYW55IHBvc3NpYmxlIGlzc3VlcykuXG4gICAgaWYgKGV2ZW50LndoaWNoID09PSAyMjkpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICAvLyBJZiB0aGUgZmxvYXRpbmcgZWxlbWVudCBpcyBhbmltYXRpbmcgb3V0LCBpZ25vcmUgbmF2aWdhdGlvbi4gT3RoZXJ3aXNlLFxuICAgIC8vIHRoZSBgYWN0aXZlSW5kZXhgIGdldHMgc2V0IHRvIDAgZGVzcGl0ZSBub3QgYmVpbmcgb3BlbiBzbyB0aGUgbmV4dCB0aW1lXG4gICAgLy8gdGhlIHVzZXIgQXJyb3dEb3ducywgdGhlIGZpcnN0IGl0ZW0gd29uJ3QgYmUgZm9jdXNlZC5cbiAgICBpZiAoIWxhdGVzdE9wZW5SZWYuY3VycmVudCAmJiBldmVudC5jdXJyZW50VGFyZ2V0ID09PSBmbG9hdGluZ0ZvY3VzRWxlbWVudFJlZi5jdXJyZW50KSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIGlmIChuZXN0ZWQgJiYgaXNDcm9zc09yaWVudGF0aW9uQ2xvc2VLZXkoZXZlbnQua2V5LCBvcmllbnRhdGlvbiwgcnRsLCBjb2xzKSkge1xuICAgICAgLy8gSWYgdGhlIG5lc3RlZCBsaXN0J3MgY2xvc2Uga2V5IGlzIGFsc28gdGhlIHBhcmVudCBuYXZpZ2F0aW9uIGtleSxcbiAgICAgIC8vIGxldCB0aGUgcGFyZW50IG5hdmlnYXRlLiBPdGhlcndpc2UsIHN0b3AgcHJvcGFnYXRpbmcgdGhlIGV2ZW50LlxuICAgICAgaWYgKCFpc01haW5PcmllbnRhdGlvbktleShldmVudC5rZXksIGdldFBhcmVudE9yaWVudGF0aW9uKCkpKSB7XG4gICAgICAgIHN0b3BFdmVudChldmVudCk7XG4gICAgICB9XG4gICAgICBvbk9wZW5DaGFuZ2UoZmFsc2UsIGV2ZW50Lm5hdGl2ZUV2ZW50LCAnbGlzdC1uYXZpZ2F0aW9uJyk7XG4gICAgICBpZiAoaXNIVE1MRWxlbWVudChlbGVtZW50cy5kb21SZWZlcmVuY2UpKSB7XG4gICAgICAgIGlmICh2aXJ0dWFsKSB7XG4gICAgICAgICAgdHJlZSA9PSBudWxsIHx8IHRyZWUuZXZlbnRzLmVtaXQoJ3ZpcnR1YWxmb2N1cycsIGVsZW1lbnRzLmRvbVJlZmVyZW5jZSk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgZWxlbWVudHMuZG9tUmVmZXJlbmNlLmZvY3VzKCk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgY29uc3QgY3VycmVudEluZGV4ID0gaW5kZXhSZWYuY3VycmVudDtcbiAgICBjb25zdCBtaW5JbmRleCA9IGdldE1pbkxpc3RJbmRleChsaXN0UmVmLCBkaXNhYmxlZEluZGljZXMpO1xuICAgIGNvbnN0IG1heEluZGV4ID0gZ2V0TWF4TGlzdEluZGV4KGxpc3RSZWYsIGRpc2FibGVkSW5kaWNlcyk7XG4gICAgaWYgKCF0eXBlYWJsZUNvbWJvYm94UmVmZXJlbmNlKSB7XG4gICAgICBpZiAoZXZlbnQua2V5ID09PSAnSG9tZScpIHtcbiAgICAgICAgc3RvcEV2ZW50KGV2ZW50KTtcbiAgICAgICAgaW5kZXhSZWYuY3VycmVudCA9IG1pbkluZGV4O1xuICAgICAgICBvbk5hdmlnYXRlKCk7XG4gICAgICB9XG4gICAgICBpZiAoZXZlbnQua2V5ID09PSAnRW5kJykge1xuICAgICAgICBzdG9wRXZlbnQoZXZlbnQpO1xuICAgICAgICBpbmRleFJlZi5jdXJyZW50ID0gbWF4SW5kZXg7XG4gICAgICAgIG9uTmF2aWdhdGUoKTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICAvLyBHcmlkIG5hdmlnYXRpb24uXG4gICAgaWYgKGNvbHMgPiAxKSB7XG4gICAgICBjb25zdCBzaXplcyA9IGl0ZW1TaXplcyB8fCBBcnJheS5mcm9tKHtcbiAgICAgICAgbGVuZ3RoOiBsaXN0UmVmLmN1cnJlbnQubGVuZ3RoXG4gICAgICB9LCAoKSA9PiAoe1xuICAgICAgICB3aWR0aDogMSxcbiAgICAgICAgaGVpZ2h0OiAxXG4gICAgICB9KSk7XG4gICAgICAvLyBUbyBjYWxjdWxhdGUgbW92ZW1lbnRzIG9uIHRoZSBncmlkLCB3ZSB1c2UgaHlwb3RoZXRpY2FsIGNlbGwgaW5kaWNlc1xuICAgICAgLy8gYXMgaWYgZXZlcnkgaXRlbSB3YXMgMXgxLCB0aGVuIGNvbnZlcnQgYmFjayB0byByZWFsIGluZGljZXMuXG4gICAgICBjb25zdCBjZWxsTWFwID0gY3JlYXRlR3JpZENlbGxNYXAoc2l6ZXMsIGNvbHMsIGRlbnNlKTtcbiAgICAgIGNvbnN0IG1pbkdyaWRJbmRleCA9IGNlbGxNYXAuZmluZEluZGV4KGluZGV4ID0+IGluZGV4ICE9IG51bGwgJiYgIWlzTGlzdEluZGV4RGlzYWJsZWQobGlzdFJlZiwgaW5kZXgsIGRpc2FibGVkSW5kaWNlcykpO1xuICAgICAgLy8gbGFzdCBlbmFibGVkIGluZGV4XG4gICAgICBjb25zdCBtYXhHcmlkSW5kZXggPSBjZWxsTWFwLnJlZHVjZSgoZm91bmRJbmRleCwgaW5kZXgsIGNlbGxJbmRleCkgPT4gaW5kZXggIT0gbnVsbCAmJiAhaXNMaXN0SW5kZXhEaXNhYmxlZChsaXN0UmVmLCBpbmRleCwgZGlzYWJsZWRJbmRpY2VzKSA/IGNlbGxJbmRleCA6IGZvdW5kSW5kZXgsIC0xKTtcbiAgICAgIGNvbnN0IGluZGV4ID0gY2VsbE1hcFtnZXRHcmlkTmF2aWdhdGVkSW5kZXgoe1xuICAgICAgICBjdXJyZW50OiBjZWxsTWFwLm1hcChpdGVtSW5kZXggPT4gaXRlbUluZGV4ICE9IG51bGwgPyBsaXN0UmVmLmN1cnJlbnRbaXRlbUluZGV4XSA6IG51bGwpXG4gICAgICB9LCB7XG4gICAgICAgIGV2ZW50LFxuICAgICAgICBvcmllbnRhdGlvbixcbiAgICAgICAgbG9vcCxcbiAgICAgICAgcnRsLFxuICAgICAgICBjb2xzLFxuICAgICAgICAvLyB0cmVhdCB1bmRlZmluZWQgKGVtcHR5IGdyaWQgc3BhY2VzKSBhcyBkaXNhYmxlZCBpbmRpY2VzIHNvIHdlXG4gICAgICAgIC8vIGRvbid0IGVuZCB1cCBpbiB0aGVtXG4gICAgICAgIGRpc2FibGVkSW5kaWNlczogZ2V0R3JpZENlbGxJbmRpY2VzKFsuLi4oKHR5cGVvZiBkaXNhYmxlZEluZGljZXMgIT09ICdmdW5jdGlvbicgPyBkaXNhYmxlZEluZGljZXMgOiBudWxsKSB8fCBsaXN0UmVmLmN1cnJlbnQubWFwKChfLCBpbmRleCkgPT4gaXNMaXN0SW5kZXhEaXNhYmxlZChsaXN0UmVmLCBpbmRleCwgZGlzYWJsZWRJbmRpY2VzKSA/IGluZGV4IDogdW5kZWZpbmVkKSksIHVuZGVmaW5lZF0sIGNlbGxNYXApLFxuICAgICAgICBtaW5JbmRleDogbWluR3JpZEluZGV4LFxuICAgICAgICBtYXhJbmRleDogbWF4R3JpZEluZGV4LFxuICAgICAgICBwcmV2SW5kZXg6IGdldEdyaWRDZWxsSW5kZXhPZkNvcm5lcihpbmRleFJlZi5jdXJyZW50ID4gbWF4SW5kZXggPyBtaW5JbmRleCA6IGluZGV4UmVmLmN1cnJlbnQsIHNpemVzLCBjZWxsTWFwLCBjb2xzLFxuICAgICAgICAvLyB1c2UgYSBjb3JuZXIgbWF0Y2hpbmcgdGhlIGVkZ2UgY2xvc2VzdCB0byB0aGUgZGlyZWN0aW9uXG4gICAgICAgIC8vIHdlJ3JlIG1vdmluZyBpbiBzbyB3ZSBkb24ndCBlbmQgdXAgaW4gdGhlIHNhbWUgaXRlbS4gUHJlZmVyXG4gICAgICAgIC8vIHRvcC9sZWZ0IG92ZXIgYm90dG9tL3JpZ2h0LlxuICAgICAgICBldmVudC5rZXkgPT09IEFSUk9XX0RPV04gPyAnYmwnIDogZXZlbnQua2V5ID09PSAocnRsID8gQVJST1dfTEVGVCA6IEFSUk9XX1JJR0hUKSA/ICd0cicgOiAndGwnKSxcbiAgICAgICAgc3RvcEV2ZW50OiB0cnVlXG4gICAgICB9KV07XG4gICAgICBpZiAoaW5kZXggIT0gbnVsbCkge1xuICAgICAgICBpbmRleFJlZi5jdXJyZW50ID0gaW5kZXg7XG4gICAgICAgIG9uTmF2aWdhdGUoKTtcbiAgICAgIH1cbiAgICAgIGlmIChvcmllbnRhdGlvbiA9PT0gJ2JvdGgnKSB7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cbiAgICB9XG4gICAgaWYgKGlzTWFpbk9yaWVudGF0aW9uS2V5KGV2ZW50LmtleSwgb3JpZW50YXRpb24pKSB7XG4gICAgICBzdG9wRXZlbnQoZXZlbnQpO1xuXG4gICAgICAvLyBSZXNldCB0aGUgaW5kZXggaWYgbm8gaXRlbSBpcyBmb2N1c2VkLlxuICAgICAgaWYgKG9wZW4gJiYgIXZpcnR1YWwgJiYgYWN0aXZlRWxlbWVudChldmVudC5jdXJyZW50VGFyZ2V0Lm93bmVyRG9jdW1lbnQpID09PSBldmVudC5jdXJyZW50VGFyZ2V0KSB7XG4gICAgICAgIGluZGV4UmVmLmN1cnJlbnQgPSBpc01haW5PcmllbnRhdGlvblRvRW5kS2V5KGV2ZW50LmtleSwgb3JpZW50YXRpb24sIHJ0bCkgPyBtaW5JbmRleCA6IG1heEluZGV4O1xuICAgICAgICBvbk5hdmlnYXRlKCk7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cbiAgICAgIGlmIChpc01haW5PcmllbnRhdGlvblRvRW5kS2V5KGV2ZW50LmtleSwgb3JpZW50YXRpb24sIHJ0bCkpIHtcbiAgICAgICAgaWYgKGxvb3ApIHtcbiAgICAgICAgICBpbmRleFJlZi5jdXJyZW50ID0gY3VycmVudEluZGV4ID49IG1heEluZGV4ID8gYWxsb3dFc2NhcGUgJiYgY3VycmVudEluZGV4ICE9PSBsaXN0UmVmLmN1cnJlbnQubGVuZ3RoID8gLTEgOiBtaW5JbmRleCA6IGZpbmROb25EaXNhYmxlZExpc3RJbmRleChsaXN0UmVmLCB7XG4gICAgICAgICAgICBzdGFydGluZ0luZGV4OiBjdXJyZW50SW5kZXgsXG4gICAgICAgICAgICBkaXNhYmxlZEluZGljZXNcbiAgICAgICAgICB9KTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBpbmRleFJlZi5jdXJyZW50ID0gTWF0aC5taW4obWF4SW5kZXgsIGZpbmROb25EaXNhYmxlZExpc3RJbmRleChsaXN0UmVmLCB7XG4gICAgICAgICAgICBzdGFydGluZ0luZGV4OiBjdXJyZW50SW5kZXgsXG4gICAgICAgICAgICBkaXNhYmxlZEluZGljZXNcbiAgICAgICAgICB9KSk7XG4gICAgICAgIH1cbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGlmIChsb29wKSB7XG4gICAgICAgICAgaW5kZXhSZWYuY3VycmVudCA9IGN1cnJlbnRJbmRleCA8PSBtaW5JbmRleCA/IGFsbG93RXNjYXBlICYmIGN1cnJlbnRJbmRleCAhPT0gLTEgPyBsaXN0UmVmLmN1cnJlbnQubGVuZ3RoIDogbWF4SW5kZXggOiBmaW5kTm9uRGlzYWJsZWRMaXN0SW5kZXgobGlzdFJlZiwge1xuICAgICAgICAgICAgc3RhcnRpbmdJbmRleDogY3VycmVudEluZGV4LFxuICAgICAgICAgICAgZGVjcmVtZW50OiB0cnVlLFxuICAgICAgICAgICAgZGlzYWJsZWRJbmRpY2VzXG4gICAgICAgICAgfSk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgaW5kZXhSZWYuY3VycmVudCA9IE1hdGgubWF4KG1pbkluZGV4LCBmaW5kTm9uRGlzYWJsZWRMaXN0SW5kZXgobGlzdFJlZiwge1xuICAgICAgICAgICAgc3RhcnRpbmdJbmRleDogY3VycmVudEluZGV4LFxuICAgICAgICAgICAgZGVjcmVtZW50OiB0cnVlLFxuICAgICAgICAgICAgZGlzYWJsZWRJbmRpY2VzXG4gICAgICAgICAgfSkpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICBpZiAoaXNJbmRleE91dE9mTGlzdEJvdW5kcyhsaXN0UmVmLCBpbmRleFJlZi5jdXJyZW50KSkge1xuICAgICAgICBpbmRleFJlZi5jdXJyZW50ID0gLTE7XG4gICAgICB9XG4gICAgICBvbk5hdmlnYXRlKCk7XG4gICAgfVxuICB9KTtcbiAgY29uc3QgYXJpYUFjdGl2ZURlc2NlbmRhbnRQcm9wID0gUmVhY3QudXNlTWVtbygoKSA9PiB7XG4gICAgcmV0dXJuIHZpcnR1YWwgJiYgb3BlbiAmJiBoYXNBY3RpdmVJbmRleCAmJiB7XG4gICAgICAnYXJpYS1hY3RpdmVkZXNjZW5kYW50JzogdmlydHVhbElkIHx8IGFjdGl2ZUlkXG4gICAgfTtcbiAgfSwgW3ZpcnR1YWwsIG9wZW4sIGhhc0FjdGl2ZUluZGV4LCB2aXJ0dWFsSWQsIGFjdGl2ZUlkXSk7XG4gIGNvbnN0IGZsb2F0aW5nID0gUmVhY3QudXNlTWVtbygoKSA9PiB7XG4gICAgcmV0dXJuIHtcbiAgICAgICdhcmlhLW9yaWVudGF0aW9uJzogb3JpZW50YXRpb24gPT09ICdib3RoJyA/IHVuZGVmaW5lZCA6IG9yaWVudGF0aW9uLFxuICAgICAgLi4uKCF0eXBlYWJsZUNvbWJvYm94UmVmZXJlbmNlID8gYXJpYUFjdGl2ZURlc2NlbmRhbnRQcm9wIDoge30pLFxuICAgICAgb25LZXlEb3duOiBjb21tb25PbktleURvd24sXG4gICAgICBvblBvaW50ZXJNb3ZlKCkge1xuICAgICAgICBpc1BvaW50ZXJNb2RhbGl0eVJlZi5jdXJyZW50ID0gdHJ1ZTtcbiAgICAgIH1cbiAgICB9O1xuICB9LCBbYXJpYUFjdGl2ZURlc2NlbmRhbnRQcm9wLCBjb21tb25PbktleURvd24sIG9yaWVudGF0aW9uLCB0eXBlYWJsZUNvbWJvYm94UmVmZXJlbmNlXSk7XG4gIGNvbnN0IHJlZmVyZW5jZSA9IFJlYWN0LnVzZU1lbW8oKCkgPT4ge1xuICAgIGZ1bmN0aW9uIGNoZWNrVmlydHVhbE1vdXNlKGV2ZW50KSB7XG4gICAgICBpZiAoZm9jdXNJdGVtT25PcGVuID09PSAnYXV0bycgJiYgaXNWaXJ0dWFsQ2xpY2soZXZlbnQubmF0aXZlRXZlbnQpKSB7XG4gICAgICAgIGZvY3VzSXRlbU9uT3BlblJlZi5jdXJyZW50ID0gdHJ1ZTtcbiAgICAgIH1cbiAgICB9XG4gICAgZnVuY3Rpb24gY2hlY2tWaXJ0dWFsUG9pbnRlcihldmVudCkge1xuICAgICAgLy8gYHBvaW50ZXJkb3duYCBmaXJlcyBmaXJzdCwgcmVzZXQgdGhlIHN0YXRlIHRoZW4gcGVyZm9ybSB0aGUgY2hlY2tzLlxuICAgICAgZm9jdXNJdGVtT25PcGVuUmVmLmN1cnJlbnQgPSBmb2N1c0l0ZW1Pbk9wZW47XG4gICAgICBpZiAoZm9jdXNJdGVtT25PcGVuID09PSAnYXV0bycgJiYgaXNWaXJ0dWFsUG9pbnRlckV2ZW50KGV2ZW50Lm5hdGl2ZUV2ZW50KSkge1xuICAgICAgICBmb2N1c0l0ZW1Pbk9wZW5SZWYuY3VycmVudCA9IHRydWU7XG4gICAgICB9XG4gICAgfVxuICAgIHJldHVybiB7XG4gICAgICAuLi5hcmlhQWN0aXZlRGVzY2VuZGFudFByb3AsXG4gICAgICBvbktleURvd24oZXZlbnQpIHtcbiAgICAgICAgaXNQb2ludGVyTW9kYWxpdHlSZWYuY3VycmVudCA9IGZhbHNlO1xuICAgICAgICBjb25zdCBpc0Fycm93S2V5ID0gZXZlbnQua2V5LnN0YXJ0c1dpdGgoJ0Fycm93Jyk7XG4gICAgICAgIGNvbnN0IGlzSG9tZU9yRW5kS2V5ID0gWydIb21lJywgJ0VuZCddLmluY2x1ZGVzKGV2ZW50LmtleSk7XG4gICAgICAgIGNvbnN0IGlzTW92ZUtleSA9IGlzQXJyb3dLZXkgfHwgaXNIb21lT3JFbmRLZXk7XG4gICAgICAgIGNvbnN0IGlzQ3Jvc3NPcGVuS2V5ID0gaXNDcm9zc09yaWVudGF0aW9uT3BlbktleShldmVudC5rZXksIG9yaWVudGF0aW9uLCBydGwpO1xuICAgICAgICBjb25zdCBpc0Nyb3NzQ2xvc2VLZXkgPSBpc0Nyb3NzT3JpZW50YXRpb25DbG9zZUtleShldmVudC5rZXksIG9yaWVudGF0aW9uLCBydGwsIGNvbHMpO1xuICAgICAgICBjb25zdCBpc1BhcmVudENyb3NzT3BlbktleSA9IGlzQ3Jvc3NPcmllbnRhdGlvbk9wZW5LZXkoZXZlbnQua2V5LCBnZXRQYXJlbnRPcmllbnRhdGlvbigpLCBydGwpO1xuICAgICAgICBjb25zdCBpc01haW5LZXkgPSBpc01haW5PcmllbnRhdGlvbktleShldmVudC5rZXksIG9yaWVudGF0aW9uKTtcbiAgICAgICAgY29uc3QgaXNOYXZpZ2F0aW9uS2V5ID0gKG5lc3RlZCA/IGlzUGFyZW50Q3Jvc3NPcGVuS2V5IDogaXNNYWluS2V5KSB8fCBldmVudC5rZXkgPT09ICdFbnRlcicgfHwgZXZlbnQua2V5LnRyaW0oKSA9PT0gJyc7XG4gICAgICAgIGlmICh2aXJ0dWFsICYmIG9wZW4pIHtcbiAgICAgICAgICBjb25zdCByb290Tm9kZSA9IHRyZWUgPT0gbnVsbCA/IHZvaWQgMCA6IHRyZWUubm9kZXNSZWYuY3VycmVudC5maW5kKG5vZGUgPT4gbm9kZS5wYXJlbnRJZCA9PSBudWxsKTtcbiAgICAgICAgICBjb25zdCBkZWVwZXN0Tm9kZSA9IHRyZWUgJiYgcm9vdE5vZGUgPyBnZXREZWVwZXN0Tm9kZSh0cmVlLm5vZGVzUmVmLmN1cnJlbnQsIHJvb3ROb2RlLmlkKSA6IG51bGw7XG4gICAgICAgICAgaWYgKGlzTW92ZUtleSAmJiBkZWVwZXN0Tm9kZSAmJiB2aXJ0dWFsSXRlbVJlZikge1xuICAgICAgICAgICAgY29uc3QgZXZlbnRPYmplY3QgPSBuZXcgS2V5Ym9hcmRFdmVudCgna2V5ZG93bicsIHtcbiAgICAgICAgICAgICAga2V5OiBldmVudC5rZXksXG4gICAgICAgICAgICAgIGJ1YmJsZXM6IHRydWVcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgaWYgKGlzQ3Jvc3NPcGVuS2V5IHx8IGlzQ3Jvc3NDbG9zZUtleSkge1xuICAgICAgICAgICAgICB2YXIgX2RlZXBlc3ROb2RlJGNvbnRleHQsIF9kZWVwZXN0Tm9kZSRjb250ZXh0MjtcbiAgICAgICAgICAgICAgY29uc3QgaXNDdXJyZW50VGFyZ2V0ID0gKChfZGVlcGVzdE5vZGUkY29udGV4dCA9IGRlZXBlc3ROb2RlLmNvbnRleHQpID09IG51bGwgPyB2b2lkIDAgOiBfZGVlcGVzdE5vZGUkY29udGV4dC5lbGVtZW50cy5kb21SZWZlcmVuY2UpID09PSBldmVudC5jdXJyZW50VGFyZ2V0O1xuICAgICAgICAgICAgICBjb25zdCBkaXNwYXRjaEl0ZW0gPSBpc0Nyb3NzQ2xvc2VLZXkgJiYgIWlzQ3VycmVudFRhcmdldCA/IChfZGVlcGVzdE5vZGUkY29udGV4dDIgPSBkZWVwZXN0Tm9kZS5jb250ZXh0KSA9PSBudWxsID8gdm9pZCAwIDogX2RlZXBlc3ROb2RlJGNvbnRleHQyLmVsZW1lbnRzLmRvbVJlZmVyZW5jZSA6IGlzQ3Jvc3NPcGVuS2V5ID8gbGlzdFJlZi5jdXJyZW50LmZpbmQoaXRlbSA9PiAoaXRlbSA9PSBudWxsID8gdm9pZCAwIDogaXRlbS5pZCkgPT09IGFjdGl2ZUlkKSA6IG51bGw7XG4gICAgICAgICAgICAgIGlmIChkaXNwYXRjaEl0ZW0pIHtcbiAgICAgICAgICAgICAgICBzdG9wRXZlbnQoZXZlbnQpO1xuICAgICAgICAgICAgICAgIGRpc3BhdGNoSXRlbS5kaXNwYXRjaEV2ZW50KGV2ZW50T2JqZWN0KTtcbiAgICAgICAgICAgICAgICBzZXRWaXJ0dWFsSWQodW5kZWZpbmVkKTtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKChpc01haW5LZXkgfHwgaXNIb21lT3JFbmRLZXkpICYmIGRlZXBlc3ROb2RlLmNvbnRleHQpIHtcbiAgICAgICAgICAgICAgaWYgKGRlZXBlc3ROb2RlLmNvbnRleHQub3BlbiAmJiBkZWVwZXN0Tm9kZS5wYXJlbnRJZCAmJiBldmVudC5jdXJyZW50VGFyZ2V0ICE9PSBkZWVwZXN0Tm9kZS5jb250ZXh0LmVsZW1lbnRzLmRvbVJlZmVyZW5jZSkge1xuICAgICAgICAgICAgICAgIHZhciBfZGVlcGVzdE5vZGUkY29udGV4dCQ7XG4gICAgICAgICAgICAgICAgc3RvcEV2ZW50KGV2ZW50KTtcbiAgICAgICAgICAgICAgICAoX2RlZXBlc3ROb2RlJGNvbnRleHQkID0gZGVlcGVzdE5vZGUuY29udGV4dC5lbGVtZW50cy5kb21SZWZlcmVuY2UpID09IG51bGwgfHwgX2RlZXBlc3ROb2RlJGNvbnRleHQkLmRpc3BhdGNoRXZlbnQoZXZlbnRPYmplY3QpO1xuICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgICByZXR1cm4gY29tbW9uT25LZXlEb3duKGV2ZW50KTtcbiAgICAgICAgfVxuICAgICAgICAvLyBJZiBhIGZsb2F0aW5nIGVsZW1lbnQgc2hvdWxkIG5vdCBvcGVuIG9uIGFycm93IGtleSBkb3duLCBhdm9pZFxuICAgICAgICAvLyBzZXR0aW5nIGBhY3RpdmVJbmRleGAgd2hpbGUgaXQncyBjbG9zZWQuXG4gICAgICAgIGlmICghb3BlbiAmJiAhb3Blbk9uQXJyb3dLZXlEb3duICYmIGlzQXJyb3dLZXkpIHtcbiAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGlzTmF2aWdhdGlvbktleSkge1xuICAgICAgICAgIGNvbnN0IGlzUGFyZW50TWFpbktleSA9IGlzTWFpbk9yaWVudGF0aW9uS2V5KGV2ZW50LmtleSwgZ2V0UGFyZW50T3JpZW50YXRpb24oKSk7XG4gICAgICAgICAga2V5UmVmLmN1cnJlbnQgPSBuZXN0ZWQgJiYgaXNQYXJlbnRNYWluS2V5ID8gbnVsbCA6IGV2ZW50LmtleTtcbiAgICAgICAgfVxuICAgICAgICBpZiAobmVzdGVkKSB7XG4gICAgICAgICAgaWYgKGlzUGFyZW50Q3Jvc3NPcGVuS2V5KSB7XG4gICAgICAgICAgICBzdG9wRXZlbnQoZXZlbnQpO1xuICAgICAgICAgICAgaWYgKG9wZW4pIHtcbiAgICAgICAgICAgICAgaW5kZXhSZWYuY3VycmVudCA9IGdldE1pbkxpc3RJbmRleChsaXN0UmVmLCBkaXNhYmxlZEluZGljZXNSZWYuY3VycmVudCk7XG4gICAgICAgICAgICAgIG9uTmF2aWdhdGUoKTtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgIG9uT3BlbkNoYW5nZSh0cnVlLCBldmVudC5uYXRpdmVFdmVudCwgJ2xpc3QtbmF2aWdhdGlvbicpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGlzTWFpbktleSkge1xuICAgICAgICAgIGlmIChzZWxlY3RlZEluZGV4ICE9IG51bGwpIHtcbiAgICAgICAgICAgIGluZGV4UmVmLmN1cnJlbnQgPSBzZWxlY3RlZEluZGV4O1xuICAgICAgICAgIH1cbiAgICAgICAgICBzdG9wRXZlbnQoZXZlbnQpO1xuICAgICAgICAgIGlmICghb3BlbiAmJiBvcGVuT25BcnJvd0tleURvd24pIHtcbiAgICAgICAgICAgIG9uT3BlbkNoYW5nZSh0cnVlLCBldmVudC5uYXRpdmVFdmVudCwgJ2xpc3QtbmF2aWdhdGlvbicpO1xuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBjb21tb25PbktleURvd24oZXZlbnQpO1xuICAgICAgICAgIH1cbiAgICAgICAgICBpZiAob3Blbikge1xuICAgICAgICAgICAgb25OYXZpZ2F0ZSgpO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfSxcbiAgICAgIG9uRm9jdXMoKSB7XG4gICAgICAgIGlmIChvcGVuICYmICF2aXJ0dWFsKSB7XG4gICAgICAgICAgaW5kZXhSZWYuY3VycmVudCA9IC0xO1xuICAgICAgICAgIG9uTmF2aWdhdGUoKTtcbiAgICAgICAgfVxuICAgICAgfSxcbiAgICAgIG9uUG9pbnRlckRvd246IGNoZWNrVmlydHVhbFBvaW50ZXIsXG4gICAgICBvblBvaW50ZXJFbnRlcjogY2hlY2tWaXJ0dWFsUG9pbnRlcixcbiAgICAgIG9uTW91c2VEb3duOiBjaGVja1ZpcnR1YWxNb3VzZSxcbiAgICAgIG9uQ2xpY2s6IGNoZWNrVmlydHVhbE1vdXNlXG4gICAgfTtcbiAgfSwgW2FjdGl2ZUlkLCBhcmlhQWN0aXZlRGVzY2VuZGFudFByb3AsIGNvbHMsIGNvbW1vbk9uS2V5RG93biwgZGlzYWJsZWRJbmRpY2VzUmVmLCBmb2N1c0l0ZW1Pbk9wZW4sIGxpc3RSZWYsIG5lc3RlZCwgb25OYXZpZ2F0ZSwgb25PcGVuQ2hhbmdlLCBvcGVuLCBvcGVuT25BcnJvd0tleURvd24sIG9yaWVudGF0aW9uLCBnZXRQYXJlbnRPcmllbnRhdGlvbiwgcnRsLCBzZWxlY3RlZEluZGV4LCB0cmVlLCB2aXJ0dWFsLCB2aXJ0dWFsSXRlbVJlZl0pO1xuICByZXR1cm4gUmVhY3QudXNlTWVtbygoKSA9PiBlbmFibGVkID8ge1xuICAgIHJlZmVyZW5jZSxcbiAgICBmbG9hdGluZyxcbiAgICBpdGVtXG4gIH0gOiB7fSwgW2VuYWJsZWQsIHJlZmVyZW5jZSwgZmxvYXRpbmcsIGl0ZW1dKTtcbn1cblxuY29uc3QgY29tcG9uZW50Um9sZVRvQXJpYVJvbGVNYXAgPSAvKiNfX1BVUkVfXyovbmV3IE1hcChbWydzZWxlY3QnLCAnbGlzdGJveCddLCBbJ2NvbWJvYm94JywgJ2xpc3Rib3gnXSwgWydsYWJlbCcsIGZhbHNlXV0pO1xuXG4vKipcbiAqIEFkZHMgYmFzZSBzY3JlZW4gcmVhZGVyIHByb3BzIHRvIHRoZSByZWZlcmVuY2UgYW5kIGZsb2F0aW5nIGVsZW1lbnRzIGZvciBhXG4gKiBnaXZlbiBmbG9hdGluZyBlbGVtZW50IGByb2xlYC5cbiAqIEBzZWUgaHR0cHM6Ly9mbG9hdGluZy11aS5jb20vZG9jcy91c2VSb2xlXG4gKi9cbmZ1bmN0aW9uIHVzZVJvbGUoY29udGV4dCwgcHJvcHMpIHtcbiAgdmFyIF9lbGVtZW50cyRkb21SZWZlcmVuYywgX2NvbXBvbmVudFJvbGVUb0FyaWFSO1xuICBpZiAocHJvcHMgPT09IHZvaWQgMCkge1xuICAgIHByb3BzID0ge307XG4gIH1cbiAgY29uc3Qge1xuICAgIG9wZW4sXG4gICAgZWxlbWVudHMsXG4gICAgZmxvYXRpbmdJZDogZGVmYXVsdEZsb2F0aW5nSWRcbiAgfSA9IGNvbnRleHQ7XG4gIGNvbnN0IHtcbiAgICBlbmFibGVkID0gdHJ1ZSxcbiAgICByb2xlID0gJ2RpYWxvZydcbiAgfSA9IHByb3BzO1xuICBjb25zdCBkZWZhdWx0UmVmZXJlbmNlSWQgPSB1c2VJZCgpO1xuICBjb25zdCByZWZlcmVuY2VJZCA9ICgoX2VsZW1lbnRzJGRvbVJlZmVyZW5jID0gZWxlbWVudHMuZG9tUmVmZXJlbmNlKSA9PSBudWxsID8gdm9pZCAwIDogX2VsZW1lbnRzJGRvbVJlZmVyZW5jLmlkKSB8fCBkZWZhdWx0UmVmZXJlbmNlSWQ7XG4gIGNvbnN0IGZsb2F0aW5nSWQgPSBSZWFjdC51c2VNZW1vKCgpID0+IHtcbiAgICB2YXIgX2dldEZsb2F0aW5nRm9jdXNFbGVtO1xuICAgIHJldHVybiAoKF9nZXRGbG9hdGluZ0ZvY3VzRWxlbSA9IGdldEZsb2F0aW5nRm9jdXNFbGVtZW50KGVsZW1lbnRzLmZsb2F0aW5nKSkgPT0gbnVsbCA/IHZvaWQgMCA6IF9nZXRGbG9hdGluZ0ZvY3VzRWxlbS5pZCkgfHwgZGVmYXVsdEZsb2F0aW5nSWQ7XG4gIH0sIFtlbGVtZW50cy5mbG9hdGluZywgZGVmYXVsdEZsb2F0aW5nSWRdKTtcbiAgY29uc3QgYXJpYVJvbGUgPSAoX2NvbXBvbmVudFJvbGVUb0FyaWFSID0gY29tcG9uZW50Um9sZVRvQXJpYVJvbGVNYXAuZ2V0KHJvbGUpKSAhPSBudWxsID8gX2NvbXBvbmVudFJvbGVUb0FyaWFSIDogcm9sZTtcbiAgY29uc3QgcGFyZW50SWQgPSB1c2VGbG9hdGluZ1BhcmVudE5vZGVJZCgpO1xuICBjb25zdCBpc05lc3RlZCA9IHBhcmVudElkICE9IG51bGw7XG4gIGNvbnN0IHJlZmVyZW5jZSA9IFJlYWN0LnVzZU1lbW8oKCkgPT4ge1xuICAgIGlmIChhcmlhUm9sZSA9PT0gJ3Rvb2x0aXAnIHx8IHJvbGUgPT09ICdsYWJlbCcpIHtcbiAgICAgIHJldHVybiB7XG4gICAgICAgIFtcImFyaWEtXCIgKyAocm9sZSA9PT0gJ2xhYmVsJyA/ICdsYWJlbGxlZGJ5JyA6ICdkZXNjcmliZWRieScpXTogb3BlbiA/IGZsb2F0aW5nSWQgOiB1bmRlZmluZWRcbiAgICAgIH07XG4gICAgfVxuICAgIHJldHVybiB7XG4gICAgICAnYXJpYS1leHBhbmRlZCc6IG9wZW4gPyAndHJ1ZScgOiAnZmFsc2UnLFxuICAgICAgJ2FyaWEtaGFzcG9wdXAnOiBhcmlhUm9sZSA9PT0gJ2FsZXJ0ZGlhbG9nJyA/ICdkaWFsb2cnIDogYXJpYVJvbGUsXG4gICAgICAnYXJpYS1jb250cm9scyc6IG9wZW4gPyBmbG9hdGluZ0lkIDogdW5kZWZpbmVkLFxuICAgICAgLi4uKGFyaWFSb2xlID09PSAnbGlzdGJveCcgJiYge1xuICAgICAgICByb2xlOiAnY29tYm9ib3gnXG4gICAgICB9KSxcbiAgICAgIC4uLihhcmlhUm9sZSA9PT0gJ21lbnUnICYmIHtcbiAgICAgICAgaWQ6IHJlZmVyZW5jZUlkXG4gICAgICB9KSxcbiAgICAgIC4uLihhcmlhUm9sZSA9PT0gJ21lbnUnICYmIGlzTmVzdGVkICYmIHtcbiAgICAgICAgcm9sZTogJ21lbnVpdGVtJ1xuICAgICAgfSksXG4gICAgICAuLi4ocm9sZSA9PT0gJ3NlbGVjdCcgJiYge1xuICAgICAgICAnYXJpYS1hdXRvY29tcGxldGUnOiAnbm9uZSdcbiAgICAgIH0pLFxuICAgICAgLi4uKHJvbGUgPT09ICdjb21ib2JveCcgJiYge1xuICAgICAgICAnYXJpYS1hdXRvY29tcGxldGUnOiAnbGlzdCdcbiAgICAgIH0pXG4gICAgfTtcbiAgfSwgW2FyaWFSb2xlLCBmbG9hdGluZ0lkLCBpc05lc3RlZCwgb3BlbiwgcmVmZXJlbmNlSWQsIHJvbGVdKTtcbiAgY29uc3QgZmxvYXRpbmcgPSBSZWFjdC51c2VNZW1vKCgpID0+IHtcbiAgICBjb25zdCBmbG9hdGluZ1Byb3BzID0ge1xuICAgICAgaWQ6IGZsb2F0aW5nSWQsXG4gICAgICAuLi4oYXJpYVJvbGUgJiYge1xuICAgICAgICByb2xlOiBhcmlhUm9sZVxuICAgICAgfSlcbiAgICB9O1xuICAgIGlmIChhcmlhUm9sZSA9PT0gJ3Rvb2x0aXAnIHx8IHJvbGUgPT09ICdsYWJlbCcpIHtcbiAgICAgIHJldHVybiBmbG9hdGluZ1Byb3BzO1xuICAgIH1cbiAgICByZXR1cm4ge1xuICAgICAgLi4uZmxvYXRpbmdQcm9wcyxcbiAgICAgIC4uLihhcmlhUm9sZSA9PT0gJ21lbnUnICYmIHtcbiAgICAgICAgJ2FyaWEtbGFiZWxsZWRieSc6IHJlZmVyZW5jZUlkXG4gICAgICB9KVxuICAgIH07XG4gIH0sIFthcmlhUm9sZSwgZmxvYXRpbmdJZCwgcmVmZXJlbmNlSWQsIHJvbGVdKTtcbiAgY29uc3QgaXRlbSA9IFJlYWN0LnVzZUNhbGxiYWNrKF9yZWYgPT4ge1xuICAgIGxldCB7XG4gICAgICBhY3RpdmUsXG4gICAgICBzZWxlY3RlZFxuICAgIH0gPSBfcmVmO1xuICAgIGNvbnN0IGNvbW1vblByb3BzID0ge1xuICAgICAgcm9sZTogJ29wdGlvbicsXG4gICAgICAuLi4oYWN0aXZlICYmIHtcbiAgICAgICAgaWQ6IGZsb2F0aW5nSWQgKyBcIi1mdWktb3B0aW9uXCJcbiAgICAgIH0pXG4gICAgfTtcblxuICAgIC8vIEZvciBgbWVudWAsIHdlIGFyZSB1bmFibGUgdG8gdGVsbCBpZiB0aGUgaXRlbSBpcyBhIGBtZW51aXRlbXJhZGlvYFxuICAgIC8vIG9yIGBtZW51aXRlbWNoZWNrYm94YC4gRm9yIGJhY2t3YXJkcy1jb21wYXRpYmlsaXR5IHJlYXNvbnMsIGFsc29cbiAgICAvLyBhdm9pZCBkZWZhdWx0aW5nIHRvIGBtZW51aXRlbWAgYXMgaXQgbWF5IG92ZXJ3cml0ZSBjdXN0b20gcm9sZSBwcm9wcy5cbiAgICBzd2l0Y2ggKHJvbGUpIHtcbiAgICAgIGNhc2UgJ3NlbGVjdCc6XG4gICAgICBjYXNlICdjb21ib2JveCc6XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgLi4uY29tbW9uUHJvcHMsXG4gICAgICAgICAgJ2FyaWEtc2VsZWN0ZWQnOiBzZWxlY3RlZFxuICAgICAgICB9O1xuICAgIH1cbiAgICByZXR1cm4ge307XG4gIH0sIFtmbG9hdGluZ0lkLCByb2xlXSk7XG4gIHJldHVybiBSZWFjdC51c2VNZW1vKCgpID0+IGVuYWJsZWQgPyB7XG4gICAgcmVmZXJlbmNlLFxuICAgIGZsb2F0aW5nLFxuICAgIGl0ZW1cbiAgfSA6IHt9LCBbZW5hYmxlZCwgcmVmZXJlbmNlLCBmbG9hdGluZywgaXRlbV0pO1xufVxuXG4vLyBDb252ZXJ0cyBhIEpTIHN0eWxlIGtleSBsaWtlIGBiYWNrZ3JvdW5kQ29sb3JgIHRvIGEgQ1NTIHRyYW5zaXRpb24tcHJvcGVydHlcbi8vIGxpa2UgYGJhY2tncm91bmQtY29sb3JgLlxuY29uc3QgY2FtZWxDYXNlVG9LZWJhYkNhc2UgPSBzdHIgPT4gc3RyLnJlcGxhY2UoL1tBLVpdKyg/IVthLXpdKXxbQS1aXS9nLCAoJCwgb2ZzKSA9PiAob2ZzID8gJy0nIDogJycpICsgJC50b0xvd2VyQ2FzZSgpKTtcbmZ1bmN0aW9uIGV4ZWNXaXRoQXJnc09yUmV0dXJuKHZhbHVlT3JGbiwgYXJncykge1xuICByZXR1cm4gdHlwZW9mIHZhbHVlT3JGbiA9PT0gJ2Z1bmN0aW9uJyA/IHZhbHVlT3JGbihhcmdzKSA6IHZhbHVlT3JGbjtcbn1cbmZ1bmN0aW9uIHVzZURlbGF5VW5tb3VudChvcGVuLCBkdXJhdGlvbk1zKSB7XG4gIGNvbnN0IFtpc01vdW50ZWQsIHNldElzTW91bnRlZF0gPSBSZWFjdC51c2VTdGF0ZShvcGVuKTtcbiAgaWYgKG9wZW4gJiYgIWlzTW91bnRlZCkge1xuICAgIHNldElzTW91bnRlZCh0cnVlKTtcbiAgfVxuICBSZWFjdC51c2VFZmZlY3QoKCkgPT4ge1xuICAgIGlmICghb3BlbiAmJiBpc01vdW50ZWQpIHtcbiAgICAgIGNvbnN0IHRpbWVvdXQgPSBzZXRUaW1lb3V0KCgpID0+IHNldElzTW91bnRlZChmYWxzZSksIGR1cmF0aW9uTXMpO1xuICAgICAgcmV0dXJuICgpID0+IGNsZWFyVGltZW91dCh0aW1lb3V0KTtcbiAgICB9XG4gIH0sIFtvcGVuLCBpc01vdW50ZWQsIGR1cmF0aW9uTXNdKTtcbiAgcmV0dXJuIGlzTW91bnRlZDtcbn1cbi8qKlxuICogUHJvdmlkZXMgYSBzdGF0dXMgc3RyaW5nIHRvIGFwcGx5IENTUyB0cmFuc2l0aW9ucyB0byBhIGZsb2F0aW5nIGVsZW1lbnQsXG4gKiBjb3JyZWN0bHkgaGFuZGxpbmcgcGxhY2VtZW50LWF3YXJlIHRyYW5zaXRpb25zLlxuICogQHNlZSBodHRwczovL2Zsb2F0aW5nLXVpLmNvbS9kb2NzL3VzZVRyYW5zaXRpb24jdXNldHJhbnNpdGlvbnN0YXR1c1xuICovXG5mdW5jdGlvbiB1c2VUcmFuc2l0aW9uU3RhdHVzKGNvbnRleHQsIHByb3BzKSB7XG4gIGlmIChwcm9wcyA9PT0gdm9pZCAwKSB7XG4gICAgcHJvcHMgPSB7fTtcbiAgfVxuICBjb25zdCB7XG4gICAgb3BlbixcbiAgICBlbGVtZW50czoge1xuICAgICAgZmxvYXRpbmdcbiAgICB9XG4gIH0gPSBjb250ZXh0O1xuICBjb25zdCB7XG4gICAgZHVyYXRpb24gPSAyNTBcbiAgfSA9IHByb3BzO1xuICBjb25zdCBpc051bWJlckR1cmF0aW9uID0gdHlwZW9mIGR1cmF0aW9uID09PSAnbnVtYmVyJztcbiAgY29uc3QgY2xvc2VEdXJhdGlvbiA9IChpc051bWJlckR1cmF0aW9uID8gZHVyYXRpb24gOiBkdXJhdGlvbi5jbG9zZSkgfHwgMDtcbiAgY29uc3QgW3N0YXR1cywgc2V0U3RhdHVzXSA9IFJlYWN0LnVzZVN0YXRlKCd1bm1vdW50ZWQnKTtcbiAgY29uc3QgaXNNb3VudGVkID0gdXNlRGVsYXlVbm1vdW50KG9wZW4sIGNsb3NlRHVyYXRpb24pO1xuICBpZiAoIWlzTW91bnRlZCAmJiBzdGF0dXMgPT09ICdjbG9zZScpIHtcbiAgICBzZXRTdGF0dXMoJ3VubW91bnRlZCcpO1xuICB9XG4gIHVzZU1vZGVybkxheW91dEVmZmVjdCgoKSA9PiB7XG4gICAgaWYgKCFmbG9hdGluZykgcmV0dXJuO1xuICAgIGlmIChvcGVuKSB7XG4gICAgICBzZXRTdGF0dXMoJ2luaXRpYWwnKTtcbiAgICAgIGNvbnN0IGZyYW1lID0gcmVxdWVzdEFuaW1hdGlvbkZyYW1lKCgpID0+IHtcbiAgICAgICAgLy8gRW5zdXJlIGl0IG9wZW5zIGJlZm9yZSBwYWludC4gV2l0aCBgRmxvYXRpbmdEZWxheUdyb3VwYCxcbiAgICAgICAgLy8gdGhpcyBhdm9pZHMgYSBmbGlja2VyIHdoZW4gbW92aW5nIGJldHdlZW4gZmxvYXRpbmcgZWxlbWVudHNcbiAgICAgICAgLy8gdG8gZW5zdXJlIG9uZSBpcyBhbHdheXMgb3BlbiB3aXRoIG5vIG1pc3NpbmcgZnJhbWVzLlxuICAgICAgICBSZWFjdERPTS5mbHVzaFN5bmMoKCkgPT4ge1xuICAgICAgICAgIHNldFN0YXR1cygnb3BlbicpO1xuICAgICAgICB9KTtcbiAgICAgIH0pO1xuICAgICAgcmV0dXJuICgpID0+IHtcbiAgICAgICAgY2FuY2VsQW5pbWF0aW9uRnJhbWUoZnJhbWUpO1xuICAgICAgfTtcbiAgICB9XG4gICAgc2V0U3RhdHVzKCdjbG9zZScpO1xuICB9LCBbb3BlbiwgZmxvYXRpbmddKTtcbiAgcmV0dXJuIHtcbiAgICBpc01vdW50ZWQsXG4gICAgc3RhdHVzXG4gIH07XG59XG4vKipcbiAqIFByb3ZpZGVzIHN0eWxlcyB0byBhcHBseSBDU1MgdHJhbnNpdGlvbnMgdG8gYSBmbG9hdGluZyBlbGVtZW50LCBjb3JyZWN0bHlcbiAqIGhhbmRsaW5nIHBsYWNlbWVudC1hd2FyZSB0cmFuc2l0aW9ucy4gV3JhcHBlciBhcm91bmQgYHVzZVRyYW5zaXRpb25TdGF0dXNgLlxuICogQHNlZSBodHRwczovL2Zsb2F0aW5nLXVpLmNvbS9kb2NzL3VzZVRyYW5zaXRpb24jdXNldHJhbnNpdGlvbnN0eWxlc1xuICovXG5mdW5jdGlvbiB1c2VUcmFuc2l0aW9uU3R5bGVzKGNvbnRleHQsIHByb3BzKSB7XG4gIGlmIChwcm9wcyA9PT0gdm9pZCAwKSB7XG4gICAgcHJvcHMgPSB7fTtcbiAgfVxuICBjb25zdCB7XG4gICAgaW5pdGlhbDogdW5zdGFibGVfaW5pdGlhbCA9IHtcbiAgICAgIG9wYWNpdHk6IDBcbiAgICB9LFxuICAgIG9wZW46IHVuc3RhYmxlX29wZW4sXG4gICAgY2xvc2U6IHVuc3RhYmxlX2Nsb3NlLFxuICAgIGNvbW1vbjogdW5zdGFibGVfY29tbW9uLFxuICAgIGR1cmF0aW9uID0gMjUwXG4gIH0gPSBwcm9wcztcbiAgY29uc3QgcGxhY2VtZW50ID0gY29udGV4dC5wbGFjZW1lbnQ7XG4gIGNvbnN0IHNpZGUgPSBwbGFjZW1lbnQuc3BsaXQoJy0nKVswXTtcbiAgY29uc3QgZm5BcmdzID0gUmVhY3QudXNlTWVtbygoKSA9PiAoe1xuICAgIHNpZGUsXG4gICAgcGxhY2VtZW50XG4gIH0pLCBbc2lkZSwgcGxhY2VtZW50XSk7XG4gIGNvbnN0IGlzTnVtYmVyRHVyYXRpb24gPSB0eXBlb2YgZHVyYXRpb24gPT09ICdudW1iZXInO1xuICBjb25zdCBvcGVuRHVyYXRpb24gPSAoaXNOdW1iZXJEdXJhdGlvbiA/IGR1cmF0aW9uIDogZHVyYXRpb24ub3BlbikgfHwgMDtcbiAgY29uc3QgY2xvc2VEdXJhdGlvbiA9IChpc051bWJlckR1cmF0aW9uID8gZHVyYXRpb24gOiBkdXJhdGlvbi5jbG9zZSkgfHwgMDtcbiAgY29uc3QgW3N0eWxlcywgc2V0U3R5bGVzXSA9IFJlYWN0LnVzZVN0YXRlKCgpID0+ICh7XG4gICAgLi4uZXhlY1dpdGhBcmdzT3JSZXR1cm4odW5zdGFibGVfY29tbW9uLCBmbkFyZ3MpLFxuICAgIC4uLmV4ZWNXaXRoQXJnc09yUmV0dXJuKHVuc3RhYmxlX2luaXRpYWwsIGZuQXJncylcbiAgfSkpO1xuICBjb25zdCB7XG4gICAgaXNNb3VudGVkLFxuICAgIHN0YXR1c1xuICB9ID0gdXNlVHJhbnNpdGlvblN0YXR1cyhjb250ZXh0LCB7XG4gICAgZHVyYXRpb25cbiAgfSk7XG4gIGNvbnN0IGluaXRpYWxSZWYgPSB1c2VMYXRlc3RSZWYodW5zdGFibGVfaW5pdGlhbCk7XG4gIGNvbnN0IG9wZW5SZWYgPSB1c2VMYXRlc3RSZWYodW5zdGFibGVfb3Blbik7XG4gIGNvbnN0IGNsb3NlUmVmID0gdXNlTGF0ZXN0UmVmKHVuc3RhYmxlX2Nsb3NlKTtcbiAgY29uc3QgY29tbW9uUmVmID0gdXNlTGF0ZXN0UmVmKHVuc3RhYmxlX2NvbW1vbik7XG4gIHVzZU1vZGVybkxheW91dEVmZmVjdCgoKSA9PiB7XG4gICAgY29uc3QgaW5pdGlhbFN0eWxlcyA9IGV4ZWNXaXRoQXJnc09yUmV0dXJuKGluaXRpYWxSZWYuY3VycmVudCwgZm5BcmdzKTtcbiAgICBjb25zdCBjbG9zZVN0eWxlcyA9IGV4ZWNXaXRoQXJnc09yUmV0dXJuKGNsb3NlUmVmLmN1cnJlbnQsIGZuQXJncyk7XG4gICAgY29uc3QgY29tbW9uU3R5bGVzID0gZXhlY1dpdGhBcmdzT3JSZXR1cm4oY29tbW9uUmVmLmN1cnJlbnQsIGZuQXJncyk7XG4gICAgY29uc3Qgb3BlblN0eWxlcyA9IGV4ZWNXaXRoQXJnc09yUmV0dXJuKG9wZW5SZWYuY3VycmVudCwgZm5BcmdzKSB8fCBPYmplY3Qua2V5cyhpbml0aWFsU3R5bGVzKS5yZWR1Y2UoKGFjYywga2V5KSA9PiB7XG4gICAgICBhY2Nba2V5XSA9ICcnO1xuICAgICAgcmV0dXJuIGFjYztcbiAgICB9LCB7fSk7XG4gICAgaWYgKHN0YXR1cyA9PT0gJ2luaXRpYWwnKSB7XG4gICAgICBzZXRTdHlsZXMoc3R5bGVzID0+ICh7XG4gICAgICAgIHRyYW5zaXRpb25Qcm9wZXJ0eTogc3R5bGVzLnRyYW5zaXRpb25Qcm9wZXJ0eSxcbiAgICAgICAgLi4uY29tbW9uU3R5bGVzLFxuICAgICAgICAuLi5pbml0aWFsU3R5bGVzXG4gICAgICB9KSk7XG4gICAgfVxuICAgIGlmIChzdGF0dXMgPT09ICdvcGVuJykge1xuICAgICAgc2V0U3R5bGVzKHtcbiAgICAgICAgdHJhbnNpdGlvblByb3BlcnR5OiBPYmplY3Qua2V5cyhvcGVuU3R5bGVzKS5tYXAoY2FtZWxDYXNlVG9LZWJhYkNhc2UpLmpvaW4oJywnKSxcbiAgICAgICAgdHJhbnNpdGlvbkR1cmF0aW9uOiBvcGVuRHVyYXRpb24gKyBcIm1zXCIsXG4gICAgICAgIC4uLmNvbW1vblN0eWxlcyxcbiAgICAgICAgLi4ub3BlblN0eWxlc1xuICAgICAgfSk7XG4gICAgfVxuICAgIGlmIChzdGF0dXMgPT09ICdjbG9zZScpIHtcbiAgICAgIGNvbnN0IHN0eWxlcyA9IGNsb3NlU3R5bGVzIHx8IGluaXRpYWxTdHlsZXM7XG4gICAgICBzZXRTdHlsZXMoe1xuICAgICAgICB0cmFuc2l0aW9uUHJvcGVydHk6IE9iamVjdC5rZXlzKHN0eWxlcykubWFwKGNhbWVsQ2FzZVRvS2ViYWJDYXNlKS5qb2luKCcsJyksXG4gICAgICAgIHRyYW5zaXRpb25EdXJhdGlvbjogY2xvc2VEdXJhdGlvbiArIFwibXNcIixcbiAgICAgICAgLi4uY29tbW9uU3R5bGVzLFxuICAgICAgICAuLi5zdHlsZXNcbiAgICAgIH0pO1xuICAgIH1cbiAgfSwgW2Nsb3NlRHVyYXRpb24sIGNsb3NlUmVmLCBpbml0aWFsUmVmLCBvcGVuUmVmLCBjb21tb25SZWYsIG9wZW5EdXJhdGlvbiwgc3RhdHVzLCBmbkFyZ3NdKTtcbiAgcmV0dXJuIHtcbiAgICBpc01vdW50ZWQsXG4gICAgc3R5bGVzXG4gIH07XG59XG5cbi8qKlxuICogUHJvdmlkZXMgYSBtYXRjaGluZyBjYWxsYmFjayB0aGF0IGNhbiBiZSB1c2VkIHRvIGZvY3VzIGFuIGl0ZW0gYXMgdGhlIHVzZXJcbiAqIHR5cGVzLCBvZnRlbiB1c2VkIGluIHRhbmRlbSB3aXRoIGB1c2VMaXN0TmF2aWdhdGlvbigpYC5cbiAqIEBzZWUgaHR0cHM6Ly9mbG9hdGluZy11aS5jb20vZG9jcy91c2VUeXBlYWhlYWRcbiAqL1xuZnVuY3Rpb24gdXNlVHlwZWFoZWFkKGNvbnRleHQsIHByb3BzKSB7XG4gIHZhciBfcmVmO1xuICBjb25zdCB7XG4gICAgb3BlbixcbiAgICBkYXRhUmVmXG4gIH0gPSBjb250ZXh0O1xuICBjb25zdCB7XG4gICAgbGlzdFJlZixcbiAgICBhY3RpdmVJbmRleCxcbiAgICBvbk1hdGNoOiB1bnN0YWJsZV9vbk1hdGNoLFxuICAgIG9uVHlwaW5nQ2hhbmdlOiB1bnN0YWJsZV9vblR5cGluZ0NoYW5nZSxcbiAgICBlbmFibGVkID0gdHJ1ZSxcbiAgICBmaW5kTWF0Y2ggPSBudWxsLFxuICAgIHJlc2V0TXMgPSA3NTAsXG4gICAgaWdub3JlS2V5cyA9IFtdLFxuICAgIHNlbGVjdGVkSW5kZXggPSBudWxsXG4gIH0gPSBwcm9wcztcbiAgY29uc3QgdGltZW91dElkUmVmID0gUmVhY3QudXNlUmVmKC0xKTtcbiAgY29uc3Qgc3RyaW5nUmVmID0gUmVhY3QudXNlUmVmKCcnKTtcbiAgY29uc3QgcHJldkluZGV4UmVmID0gUmVhY3QudXNlUmVmKChfcmVmID0gc2VsZWN0ZWRJbmRleCAhPSBudWxsID8gc2VsZWN0ZWRJbmRleCA6IGFjdGl2ZUluZGV4KSAhPSBudWxsID8gX3JlZiA6IC0xKTtcbiAgY29uc3QgbWF0Y2hJbmRleFJlZiA9IFJlYWN0LnVzZVJlZihudWxsKTtcbiAgY29uc3Qgb25NYXRjaCA9IHVzZUVmZmVjdEV2ZW50KHVuc3RhYmxlX29uTWF0Y2gpO1xuICBjb25zdCBvblR5cGluZ0NoYW5nZSA9IHVzZUVmZmVjdEV2ZW50KHVuc3RhYmxlX29uVHlwaW5nQ2hhbmdlKTtcbiAgY29uc3QgZmluZE1hdGNoUmVmID0gdXNlTGF0ZXN0UmVmKGZpbmRNYXRjaCk7XG4gIGNvbnN0IGlnbm9yZUtleXNSZWYgPSB1c2VMYXRlc3RSZWYoaWdub3JlS2V5cyk7XG4gIHVzZU1vZGVybkxheW91dEVmZmVjdCgoKSA9PiB7XG4gICAgaWYgKG9wZW4pIHtcbiAgICAgIGNsZWFyVGltZW91dElmU2V0KHRpbWVvdXRJZFJlZik7XG4gICAgICBtYXRjaEluZGV4UmVmLmN1cnJlbnQgPSBudWxsO1xuICAgICAgc3RyaW5nUmVmLmN1cnJlbnQgPSAnJztcbiAgICB9XG4gIH0sIFtvcGVuXSk7XG4gIHVzZU1vZGVybkxheW91dEVmZmVjdCgoKSA9PiB7XG4gICAgLy8gU3luYyBhcnJvdyBrZXkgbmF2aWdhdGlvbiBidXQgbm90IHR5cGVhaGVhZCBuYXZpZ2F0aW9uLlxuICAgIGlmIChvcGVuICYmIHN0cmluZ1JlZi5jdXJyZW50ID09PSAnJykge1xuICAgICAgdmFyIF9yZWYyO1xuICAgICAgcHJldkluZGV4UmVmLmN1cnJlbnQgPSAoX3JlZjIgPSBzZWxlY3RlZEluZGV4ICE9IG51bGwgPyBzZWxlY3RlZEluZGV4IDogYWN0aXZlSW5kZXgpICE9IG51bGwgPyBfcmVmMiA6IC0xO1xuICAgIH1cbiAgfSwgW29wZW4sIHNlbGVjdGVkSW5kZXgsIGFjdGl2ZUluZGV4XSk7XG4gIGNvbnN0IHNldFR5cGluZ0NoYW5nZSA9IHVzZUVmZmVjdEV2ZW50KHZhbHVlID0+IHtcbiAgICBpZiAodmFsdWUpIHtcbiAgICAgIGlmICghZGF0YVJlZi5jdXJyZW50LnR5cGluZykge1xuICAgICAgICBkYXRhUmVmLmN1cnJlbnQudHlwaW5nID0gdmFsdWU7XG4gICAgICAgIG9uVHlwaW5nQ2hhbmdlKHZhbHVlKTtcbiAgICAgIH1cbiAgICB9IGVsc2Uge1xuICAgICAgaWYgKGRhdGFSZWYuY3VycmVudC50eXBpbmcpIHtcbiAgICAgICAgZGF0YVJlZi5jdXJyZW50LnR5cGluZyA9IHZhbHVlO1xuICAgICAgICBvblR5cGluZ0NoYW5nZSh2YWx1ZSk7XG4gICAgICB9XG4gICAgfVxuICB9KTtcbiAgY29uc3Qgb25LZXlEb3duID0gdXNlRWZmZWN0RXZlbnQoZXZlbnQgPT4ge1xuICAgIGZ1bmN0aW9uIGdldE1hdGNoaW5nSW5kZXgobGlzdCwgb3JkZXJlZExpc3QsIHN0cmluZykge1xuICAgICAgY29uc3Qgc3RyID0gZmluZE1hdGNoUmVmLmN1cnJlbnQgPyBmaW5kTWF0Y2hSZWYuY3VycmVudChvcmRlcmVkTGlzdCwgc3RyaW5nKSA6IG9yZGVyZWRMaXN0LmZpbmQodGV4dCA9PiAodGV4dCA9PSBudWxsID8gdm9pZCAwIDogdGV4dC50b0xvY2FsZUxvd2VyQ2FzZSgpLmluZGV4T2Yoc3RyaW5nLnRvTG9jYWxlTG93ZXJDYXNlKCkpKSA9PT0gMCk7XG4gICAgICByZXR1cm4gc3RyID8gbGlzdC5pbmRleE9mKHN0cikgOiAtMTtcbiAgICB9XG4gICAgY29uc3QgbGlzdENvbnRlbnQgPSBsaXN0UmVmLmN1cnJlbnQ7XG4gICAgaWYgKHN0cmluZ1JlZi5jdXJyZW50Lmxlbmd0aCA+IDAgJiYgc3RyaW5nUmVmLmN1cnJlbnRbMF0gIT09ICcgJykge1xuICAgICAgaWYgKGdldE1hdGNoaW5nSW5kZXgobGlzdENvbnRlbnQsIGxpc3RDb250ZW50LCBzdHJpbmdSZWYuY3VycmVudCkgPT09IC0xKSB7XG4gICAgICAgIHNldFR5cGluZ0NoYW5nZShmYWxzZSk7XG4gICAgICB9IGVsc2UgaWYgKGV2ZW50LmtleSA9PT0gJyAnKSB7XG4gICAgICAgIHN0b3BFdmVudChldmVudCk7XG4gICAgICB9XG4gICAgfVxuICAgIGlmIChsaXN0Q29udGVudCA9PSBudWxsIHx8IGlnbm9yZUtleXNSZWYuY3VycmVudC5pbmNsdWRlcyhldmVudC5rZXkpIHx8XG4gICAgLy8gQ2hhcmFjdGVyIGtleS5cbiAgICBldmVudC5rZXkubGVuZ3RoICE9PSAxIHx8XG4gICAgLy8gTW9kaWZpZXIga2V5LlxuICAgIGV2ZW50LmN0cmxLZXkgfHwgZXZlbnQubWV0YUtleSB8fCBldmVudC5hbHRLZXkpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgaWYgKG9wZW4gJiYgZXZlbnQua2V5ICE9PSAnICcpIHtcbiAgICAgIHN0b3BFdmVudChldmVudCk7XG4gICAgICBzZXRUeXBpbmdDaGFuZ2UodHJ1ZSk7XG4gICAgfVxuXG4gICAgLy8gQmFpbCBvdXQgaWYgdGhlIGxpc3QgY29udGFpbnMgYSB3b3JkIGxpa2UgXCJsbGFtYVwiIG9yIFwiYWFyb25cIi4gVE9ETzpcbiAgICAvLyBhbGxvdyBpdCBpbiB0aGlzIGNhc2UsIHRvby5cbiAgICBjb25zdCBhbGxvd1JhcGlkU3VjY2Vzc2lvbk9mRmlyc3RMZXR0ZXIgPSBsaXN0Q29udGVudC5ldmVyeSh0ZXh0ID0+IHtcbiAgICAgIHZhciBfdGV4dCQsIF90ZXh0JDI7XG4gICAgICByZXR1cm4gdGV4dCA/ICgoX3RleHQkID0gdGV4dFswXSkgPT0gbnVsbCA/IHZvaWQgMCA6IF90ZXh0JC50b0xvY2FsZUxvd2VyQ2FzZSgpKSAhPT0gKChfdGV4dCQyID0gdGV4dFsxXSkgPT0gbnVsbCA/IHZvaWQgMCA6IF90ZXh0JDIudG9Mb2NhbGVMb3dlckNhc2UoKSkgOiB0cnVlO1xuICAgIH0pO1xuXG4gICAgLy8gQWxsb3dzIHRoZSB1c2VyIHRvIGN5Y2xlIHRocm91Z2ggaXRlbXMgdGhhdCBzdGFydCB3aXRoIHRoZSBzYW1lIGxldHRlclxuICAgIC8vIGluIHJhcGlkIHN1Y2Nlc3Npb24uXG4gICAgaWYgKGFsbG93UmFwaWRTdWNjZXNzaW9uT2ZGaXJzdExldHRlciAmJiBzdHJpbmdSZWYuY3VycmVudCA9PT0gZXZlbnQua2V5KSB7XG4gICAgICBzdHJpbmdSZWYuY3VycmVudCA9ICcnO1xuICAgICAgcHJldkluZGV4UmVmLmN1cnJlbnQgPSBtYXRjaEluZGV4UmVmLmN1cnJlbnQ7XG4gICAgfVxuICAgIHN0cmluZ1JlZi5jdXJyZW50ICs9IGV2ZW50LmtleTtcbiAgICBjbGVhclRpbWVvdXRJZlNldCh0aW1lb3V0SWRSZWYpO1xuICAgIHRpbWVvdXRJZFJlZi5jdXJyZW50ID0gd2luZG93LnNldFRpbWVvdXQoKCkgPT4ge1xuICAgICAgc3RyaW5nUmVmLmN1cnJlbnQgPSAnJztcbiAgICAgIHByZXZJbmRleFJlZi5jdXJyZW50ID0gbWF0Y2hJbmRleFJlZi5jdXJyZW50O1xuICAgICAgc2V0VHlwaW5nQ2hhbmdlKGZhbHNlKTtcbiAgICB9LCByZXNldE1zKTtcbiAgICBjb25zdCBwcmV2SW5kZXggPSBwcmV2SW5kZXhSZWYuY3VycmVudDtcbiAgICBjb25zdCBpbmRleCA9IGdldE1hdGNoaW5nSW5kZXgobGlzdENvbnRlbnQsIFsuLi5saXN0Q29udGVudC5zbGljZSgocHJldkluZGV4IHx8IDApICsgMSksIC4uLmxpc3RDb250ZW50LnNsaWNlKDAsIChwcmV2SW5kZXggfHwgMCkgKyAxKV0sIHN0cmluZ1JlZi5jdXJyZW50KTtcbiAgICBpZiAoaW5kZXggIT09IC0xKSB7XG4gICAgICBvbk1hdGNoKGluZGV4KTtcbiAgICAgIG1hdGNoSW5kZXhSZWYuY3VycmVudCA9IGluZGV4O1xuICAgIH0gZWxzZSBpZiAoZXZlbnQua2V5ICE9PSAnICcpIHtcbiAgICAgIHN0cmluZ1JlZi5jdXJyZW50ID0gJyc7XG4gICAgICBzZXRUeXBpbmdDaGFuZ2UoZmFsc2UpO1xuICAgIH1cbiAgfSk7XG4gIGNvbnN0IHJlZmVyZW5jZSA9IFJlYWN0LnVzZU1lbW8oKCkgPT4gKHtcbiAgICBvbktleURvd25cbiAgfSksIFtvbktleURvd25dKTtcbiAgY29uc3QgZmxvYXRpbmcgPSBSZWFjdC51c2VNZW1vKCgpID0+IHtcbiAgICByZXR1cm4ge1xuICAgICAgb25LZXlEb3duLFxuICAgICAgb25LZXlVcChldmVudCkge1xuICAgICAgICBpZiAoZXZlbnQua2V5ID09PSAnICcpIHtcbiAgICAgICAgICBzZXRUeXBpbmdDaGFuZ2UoZmFsc2UpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfTtcbiAgfSwgW29uS2V5RG93biwgc2V0VHlwaW5nQ2hhbmdlXSk7XG4gIHJldHVybiBSZWFjdC51c2VNZW1vKCgpID0+IGVuYWJsZWQgPyB7XG4gICAgcmVmZXJlbmNlLFxuICAgIGZsb2F0aW5nXG4gIH0gOiB7fSwgW2VuYWJsZWQsIHJlZmVyZW5jZSwgZmxvYXRpbmddKTtcbn1cblxuZnVuY3Rpb24gZ2V0QXJnc1dpdGhDdXN0b21GbG9hdGluZ0hlaWdodChzdGF0ZSwgaGVpZ2h0KSB7XG4gIHJldHVybiB7XG4gICAgLi4uc3RhdGUsXG4gICAgcmVjdHM6IHtcbiAgICAgIC4uLnN0YXRlLnJlY3RzLFxuICAgICAgZmxvYXRpbmc6IHtcbiAgICAgICAgLi4uc3RhdGUucmVjdHMuZmxvYXRpbmcsXG4gICAgICAgIGhlaWdodFxuICAgICAgfVxuICAgIH1cbiAgfTtcbn1cbi8qKlxuICogUG9zaXRpb25zIHRoZSBmbG9hdGluZyBlbGVtZW50IHN1Y2ggdGhhdCBhbiBpbm5lciBlbGVtZW50IGluc2lkZSBvZiBpdCBpc1xuICogYW5jaG9yZWQgdG8gdGhlIHJlZmVyZW5jZSBlbGVtZW50LlxuICogQHNlZSBodHRwczovL2Zsb2F0aW5nLXVpLmNvbS9kb2NzL2lubmVyXG4gKiBAZGVwcmVjYXRlZFxuICovXG5jb25zdCBpbm5lciA9IHByb3BzID0+ICh7XG4gIG5hbWU6ICdpbm5lcicsXG4gIG9wdGlvbnM6IHByb3BzLFxuICBhc3luYyBmbihzdGF0ZSkge1xuICAgIGNvbnN0IHtcbiAgICAgIGxpc3RSZWYsXG4gICAgICBvdmVyZmxvd1JlZixcbiAgICAgIG9uRmFsbGJhY2tDaGFuZ2UsXG4gICAgICBvZmZzZXQ6IGlubmVyT2Zmc2V0ID0gMCxcbiAgICAgIGluZGV4ID0gMCxcbiAgICAgIG1pbkl0ZW1zVmlzaWJsZSA9IDQsXG4gICAgICByZWZlcmVuY2VPdmVyZmxvd1RocmVzaG9sZCA9IDAsXG4gICAgICBzY3JvbGxSZWYsXG4gICAgICAuLi5kZXRlY3RPdmVyZmxvd09wdGlvbnNcbiAgICB9ID0gZXZhbHVhdGUocHJvcHMsIHN0YXRlKTtcbiAgICBjb25zdCB7XG4gICAgICByZWN0cyxcbiAgICAgIGVsZW1lbnRzOiB7XG4gICAgICAgIGZsb2F0aW5nXG4gICAgICB9XG4gICAgfSA9IHN0YXRlO1xuICAgIGNvbnN0IGl0ZW0gPSBsaXN0UmVmLmN1cnJlbnRbaW5kZXhdO1xuICAgIGNvbnN0IHNjcm9sbEVsID0gKHNjcm9sbFJlZiA9PSBudWxsID8gdm9pZCAwIDogc2Nyb2xsUmVmLmN1cnJlbnQpIHx8IGZsb2F0aW5nO1xuXG4gICAgLy8gVmFsaWQgY29tYmluYXRpb25zOlxuICAgIC8vIDEuIEZsb2F0aW5nIGVsZW1lbnQgaXMgdGhlIHNjcm9sbFJlZiBhbmQgaGFzIGEgYm9yZGVyIChkZWZhdWx0KVxuICAgIC8vIDIuIEZsb2F0aW5nIGVsZW1lbnQgaXMgbm90IHRoZSBzY3JvbGxSZWYsIGZsb2F0aW5nIGVsZW1lbnQgaGFzIGEgYm9yZGVyXG4gICAgLy8gMy4gRmxvYXRpbmcgZWxlbWVudCBpcyBub3QgdGhlIHNjcm9sbFJlZiwgc2Nyb2xsUmVmIGhhcyBhIGJvcmRlclxuICAgIC8vIEZsb2F0aW5nID4gey4uLmdldEZsb2F0aW5nUHJvcHMoKX0gd3JhcHBlciA+IHNjcm9sbFJlZiA+IGl0ZW1zIGlzIG5vdFxuICAgIC8vIGFsbG93ZWQgYXMgVm9pY2VPdmVyIGRvZXNuJ3Qgd29yay5cbiAgICBjb25zdCBjbGllbnRUb3AgPSBmbG9hdGluZy5jbGllbnRUb3AgfHwgc2Nyb2xsRWwuY2xpZW50VG9wO1xuICAgIGNvbnN0IGZsb2F0aW5nSXNCb3JkZXJlZCA9IGZsb2F0aW5nLmNsaWVudFRvcCAhPT0gMDtcbiAgICBjb25zdCBzY3JvbGxFbElzQm9yZGVyZWQgPSBzY3JvbGxFbC5jbGllbnRUb3AgIT09IDA7XG4gICAgY29uc3QgZmxvYXRpbmdJc1Njcm9sbEVsID0gZmxvYXRpbmcgPT09IHNjcm9sbEVsO1xuICAgIGlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gXCJwcm9kdWN0aW9uXCIpIHtcbiAgICAgIGlmICghc3RhdGUucGxhY2VtZW50LnN0YXJ0c1dpdGgoJ2JvdHRvbScpKSB7XG4gICAgICAgIHdhcm4oJ2BwbGFjZW1lbnRgIHNpZGUgbXVzdCBiZSBcImJvdHRvbVwiIHdoZW4gdXNpbmcgdGhlIGBpbm5lcmAnLCAnbWlkZGxld2FyZS4nKTtcbiAgICAgIH1cbiAgICB9XG4gICAgaWYgKCFpdGVtKSB7XG4gICAgICByZXR1cm4ge307XG4gICAgfVxuICAgIGNvbnN0IG5leHRBcmdzID0ge1xuICAgICAgLi4uc3RhdGUsXG4gICAgICAuLi4oYXdhaXQgb2Zmc2V0KC1pdGVtLm9mZnNldFRvcCAtIGZsb2F0aW5nLmNsaWVudFRvcCAtIHJlY3RzLnJlZmVyZW5jZS5oZWlnaHQgLyAyIC0gaXRlbS5vZmZzZXRIZWlnaHQgLyAyIC0gaW5uZXJPZmZzZXQpLmZuKHN0YXRlKSlcbiAgICB9O1xuICAgIGNvbnN0IG92ZXJmbG93ID0gYXdhaXQgZGV0ZWN0T3ZlcmZsb3coZ2V0QXJnc1dpdGhDdXN0b21GbG9hdGluZ0hlaWdodChuZXh0QXJncywgc2Nyb2xsRWwuc2Nyb2xsSGVpZ2h0ICsgY2xpZW50VG9wICsgZmxvYXRpbmcuY2xpZW50VG9wKSwgZGV0ZWN0T3ZlcmZsb3dPcHRpb25zKTtcbiAgICBjb25zdCByZWZPdmVyZmxvdyA9IGF3YWl0IGRldGVjdE92ZXJmbG93KG5leHRBcmdzLCB7XG4gICAgICAuLi5kZXRlY3RPdmVyZmxvd09wdGlvbnMsXG4gICAgICBlbGVtZW50Q29udGV4dDogJ3JlZmVyZW5jZSdcbiAgICB9KTtcbiAgICBjb25zdCBkaWZmWSA9IG1heCgwLCBvdmVyZmxvdy50b3ApO1xuICAgIGNvbnN0IG5leHRZID0gbmV4dEFyZ3MueSArIGRpZmZZO1xuICAgIGNvbnN0IGlzU2Nyb2xsYWJsZSA9IHNjcm9sbEVsLnNjcm9sbEhlaWdodCA+IHNjcm9sbEVsLmNsaWVudEhlaWdodDtcbiAgICBjb25zdCByb3VuZGVyID0gaXNTY3JvbGxhYmxlID8gdiA9PiB2IDogcm91bmQ7XG4gICAgY29uc3QgbWF4SGVpZ2h0ID0gcm91bmRlcihtYXgoMCwgc2Nyb2xsRWwuc2Nyb2xsSGVpZ2h0ICsgKGZsb2F0aW5nSXNCb3JkZXJlZCAmJiBmbG9hdGluZ0lzU2Nyb2xsRWwgfHwgc2Nyb2xsRWxJc0JvcmRlcmVkID8gY2xpZW50VG9wICogMiA6IDApIC0gZGlmZlkgLSBtYXgoMCwgb3ZlcmZsb3cuYm90dG9tKSkpO1xuICAgIHNjcm9sbEVsLnN0eWxlLm1heEhlaWdodCA9IG1heEhlaWdodCArIFwicHhcIjtcbiAgICBzY3JvbGxFbC5zY3JvbGxUb3AgPSBkaWZmWTtcblxuICAgIC8vIFRoZXJlIGlzIG5vdCBlbm91Z2ggc3BhY2UsIGZhbGxiYWNrIHRvIHN0YW5kYXJkIGFuY2hvcmVkIHBvc2l0aW9uaW5nXG4gICAgaWYgKG9uRmFsbGJhY2tDaGFuZ2UpIHtcbiAgICAgIGNvbnN0IHNob3VsZEZhbGxiYWNrID0gc2Nyb2xsRWwub2Zmc2V0SGVpZ2h0IDwgaXRlbS5vZmZzZXRIZWlnaHQgKiBtaW4obWluSXRlbXNWaXNpYmxlLCBsaXN0UmVmLmN1cnJlbnQubGVuZ3RoKSAtIDEgfHwgcmVmT3ZlcmZsb3cudG9wID49IC1yZWZlcmVuY2VPdmVyZmxvd1RocmVzaG9sZCB8fCByZWZPdmVyZmxvdy5ib3R0b20gPj0gLXJlZmVyZW5jZU92ZXJmbG93VGhyZXNob2xkO1xuICAgICAgUmVhY3RET00uZmx1c2hTeW5jKCgpID0+IG9uRmFsbGJhY2tDaGFuZ2Uoc2hvdWxkRmFsbGJhY2spKTtcbiAgICB9XG4gICAgaWYgKG92ZXJmbG93UmVmKSB7XG4gICAgICBvdmVyZmxvd1JlZi5jdXJyZW50ID0gYXdhaXQgZGV0ZWN0T3ZlcmZsb3coZ2V0QXJnc1dpdGhDdXN0b21GbG9hdGluZ0hlaWdodCh7XG4gICAgICAgIC4uLm5leHRBcmdzLFxuICAgICAgICB5OiBuZXh0WVxuICAgICAgfSwgc2Nyb2xsRWwub2Zmc2V0SGVpZ2h0ICsgY2xpZW50VG9wICsgZmxvYXRpbmcuY2xpZW50VG9wKSwgZGV0ZWN0T3ZlcmZsb3dPcHRpb25zKTtcbiAgICB9XG4gICAgcmV0dXJuIHtcbiAgICAgIHk6IG5leHRZXG4gICAgfTtcbiAgfVxufSk7XG4vKipcbiAqIENoYW5nZXMgdGhlIGBpbm5lcmAgbWlkZGxld2FyZSdzIGBvZmZzZXRgIHVwb24gYSBgd2hlZWxgIGV2ZW50IHRvXG4gKiBleHBhbmQgdGhlIGZsb2F0aW5nIGVsZW1lbnQncyBoZWlnaHQsIHJldmVhbGluZyBtb3JlIGxpc3QgaXRlbXMuXG4gKiBAc2VlIGh0dHBzOi8vZmxvYXRpbmctdWkuY29tL2RvY3MvaW5uZXJcbiAqIEBkZXByZWNhdGVkXG4gKi9cbmZ1bmN0aW9uIHVzZUlubmVyT2Zmc2V0KGNvbnRleHQsIHByb3BzKSB7XG4gIGNvbnN0IHtcbiAgICBvcGVuLFxuICAgIGVsZW1lbnRzXG4gIH0gPSBjb250ZXh0O1xuICBjb25zdCB7XG4gICAgZW5hYmxlZCA9IHRydWUsXG4gICAgb3ZlcmZsb3dSZWYsXG4gICAgc2Nyb2xsUmVmLFxuICAgIG9uQ2hhbmdlOiB1bnN0YWJsZV9vbkNoYW5nZVxuICB9ID0gcHJvcHM7XG4gIGNvbnN0IG9uQ2hhbmdlID0gdXNlRWZmZWN0RXZlbnQodW5zdGFibGVfb25DaGFuZ2UpO1xuICBjb25zdCBjb250cm9sbGVkU2Nyb2xsaW5nUmVmID0gUmVhY3QudXNlUmVmKGZhbHNlKTtcbiAgY29uc3QgcHJldlNjcm9sbFRvcFJlZiA9IFJlYWN0LnVzZVJlZihudWxsKTtcbiAgY29uc3QgaW5pdGlhbE92ZXJmbG93UmVmID0gUmVhY3QudXNlUmVmKG51bGwpO1xuICBSZWFjdC51c2VFZmZlY3QoKCkgPT4ge1xuICAgIGlmICghZW5hYmxlZCkgcmV0dXJuO1xuICAgIGZ1bmN0aW9uIG9uV2hlZWwoZSkge1xuICAgICAgaWYgKGUuY3RybEtleSB8fCAhZWwgfHwgb3ZlcmZsb3dSZWYuY3VycmVudCA9PSBudWxsKSB7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cbiAgICAgIGNvbnN0IGRZID0gZS5kZWx0YVk7XG4gICAgICBjb25zdCBpc0F0VG9wID0gb3ZlcmZsb3dSZWYuY3VycmVudC50b3AgPj0gLTAuNTtcbiAgICAgIGNvbnN0IGlzQXRCb3R0b20gPSBvdmVyZmxvd1JlZi5jdXJyZW50LmJvdHRvbSA+PSAtMC41O1xuICAgICAgY29uc3QgcmVtYWluaW5nU2Nyb2xsID0gZWwuc2Nyb2xsSGVpZ2h0IC0gZWwuY2xpZW50SGVpZ2h0O1xuICAgICAgY29uc3Qgc2lnbiA9IGRZIDwgMCA/IC0xIDogMTtcbiAgICAgIGNvbnN0IG1ldGhvZCA9IGRZIDwgMCA/ICdtYXgnIDogJ21pbic7XG4gICAgICBpZiAoZWwuc2Nyb2xsSGVpZ2h0IDw9IGVsLmNsaWVudEhlaWdodCkge1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG4gICAgICBpZiAoIWlzQXRUb3AgJiYgZFkgPiAwIHx8ICFpc0F0Qm90dG9tICYmIGRZIDwgMCkge1xuICAgICAgICBlLnByZXZlbnREZWZhdWx0KCk7XG4gICAgICAgIFJlYWN0RE9NLmZsdXNoU3luYygoKSA9PiB7XG4gICAgICAgICAgb25DaGFuZ2UoZCA9PiBkICsgTWF0aFttZXRob2RdKGRZLCByZW1haW5pbmdTY3JvbGwgKiBzaWduKSk7XG4gICAgICAgIH0pO1xuICAgICAgfSBlbHNlIGlmICgvZmlyZWZveC9pLnRlc3QoZ2V0VXNlckFnZW50KCkpKSB7XG4gICAgICAgIC8vIE5lZWRlZCB0byBwcm9wYWdhdGUgc2Nyb2xsaW5nIGR1cmluZyBtb21lbnR1bSBzY3JvbGxpbmcgcGhhc2Ugb25jZVxuICAgICAgICAvLyBpdCBnZXRzIGxpbWl0ZWQgYnkgdGhlIGJvdW5kYXJ5LiBVWCBpbXByb3ZlbWVudCwgbm90IGNyaXRpY2FsLlxuICAgICAgICBlbC5zY3JvbGxUb3AgKz0gZFk7XG4gICAgICB9XG4gICAgfVxuICAgIGNvbnN0IGVsID0gKHNjcm9sbFJlZiA9PSBudWxsID8gdm9pZCAwIDogc2Nyb2xsUmVmLmN1cnJlbnQpIHx8IGVsZW1lbnRzLmZsb2F0aW5nO1xuICAgIGlmIChvcGVuICYmIGVsKSB7XG4gICAgICBlbC5hZGRFdmVudExpc3RlbmVyKCd3aGVlbCcsIG9uV2hlZWwpO1xuXG4gICAgICAvLyBXYWl0IGZvciB0aGUgcG9zaXRpb24gdG8gYmUgcmVhZHkuXG4gICAgICByZXF1ZXN0QW5pbWF0aW9uRnJhbWUoKCkgPT4ge1xuICAgICAgICBwcmV2U2Nyb2xsVG9wUmVmLmN1cnJlbnQgPSBlbC5zY3JvbGxUb3A7XG4gICAgICAgIGlmIChvdmVyZmxvd1JlZi5jdXJyZW50ICE9IG51bGwpIHtcbiAgICAgICAgICBpbml0aWFsT3ZlcmZsb3dSZWYuY3VycmVudCA9IHtcbiAgICAgICAgICAgIC4uLm92ZXJmbG93UmVmLmN1cnJlbnRcbiAgICAgICAgICB9O1xuICAgICAgICB9XG4gICAgICB9KTtcbiAgICAgIHJldHVybiAoKSA9PiB7XG4gICAgICAgIHByZXZTY3JvbGxUb3BSZWYuY3VycmVudCA9IG51bGw7XG4gICAgICAgIGluaXRpYWxPdmVyZmxvd1JlZi5jdXJyZW50ID0gbnVsbDtcbiAgICAgICAgZWwucmVtb3ZlRXZlbnRMaXN0ZW5lcignd2hlZWwnLCBvbldoZWVsKTtcbiAgICAgIH07XG4gICAgfVxuICB9LCBbZW5hYmxlZCwgb3BlbiwgZWxlbWVudHMuZmxvYXRpbmcsIG92ZXJmbG93UmVmLCBzY3JvbGxSZWYsIG9uQ2hhbmdlXSk7XG4gIGNvbnN0IGZsb2F0aW5nID0gUmVhY3QudXNlTWVtbygoKSA9PiAoe1xuICAgIG9uS2V5RG93bigpIHtcbiAgICAgIGNvbnRyb2xsZWRTY3JvbGxpbmdSZWYuY3VycmVudCA9IHRydWU7XG4gICAgfSxcbiAgICBvbldoZWVsKCkge1xuICAgICAgY29udHJvbGxlZFNjcm9sbGluZ1JlZi5jdXJyZW50ID0gZmFsc2U7XG4gICAgfSxcbiAgICBvblBvaW50ZXJNb3ZlKCkge1xuICAgICAgY29udHJvbGxlZFNjcm9sbGluZ1JlZi5jdXJyZW50ID0gZmFsc2U7XG4gICAgfSxcbiAgICBvblNjcm9sbCgpIHtcbiAgICAgIGNvbnN0IGVsID0gKHNjcm9sbFJlZiA9PSBudWxsID8gdm9pZCAwIDogc2Nyb2xsUmVmLmN1cnJlbnQpIHx8IGVsZW1lbnRzLmZsb2F0aW5nO1xuICAgICAgaWYgKCFvdmVyZmxvd1JlZi5jdXJyZW50IHx8ICFlbCB8fCAhY29udHJvbGxlZFNjcm9sbGluZ1JlZi5jdXJyZW50KSB7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cbiAgICAgIGlmIChwcmV2U2Nyb2xsVG9wUmVmLmN1cnJlbnQgIT09IG51bGwpIHtcbiAgICAgICAgY29uc3Qgc2Nyb2xsRGlmZiA9IGVsLnNjcm9sbFRvcCAtIHByZXZTY3JvbGxUb3BSZWYuY3VycmVudDtcbiAgICAgICAgaWYgKG92ZXJmbG93UmVmLmN1cnJlbnQuYm90dG9tIDwgLTAuNSAmJiBzY3JvbGxEaWZmIDwgLTEgfHwgb3ZlcmZsb3dSZWYuY3VycmVudC50b3AgPCAtMC41ICYmIHNjcm9sbERpZmYgPiAxKSB7XG4gICAgICAgICAgUmVhY3RET00uZmx1c2hTeW5jKCgpID0+IG9uQ2hhbmdlKGQgPT4gZCArIHNjcm9sbERpZmYpKTtcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICAvLyBbRmlyZWZveF0gV2FpdCBmb3IgdGhlIGhlaWdodCBjaGFuZ2UgdG8gaGF2ZSBiZWVuIGFwcGxpZWQuXG4gICAgICByZXF1ZXN0QW5pbWF0aW9uRnJhbWUoKCkgPT4ge1xuICAgICAgICBwcmV2U2Nyb2xsVG9wUmVmLmN1cnJlbnQgPSBlbC5zY3JvbGxUb3A7XG4gICAgICB9KTtcbiAgICB9XG4gIH0pLCBbZWxlbWVudHMuZmxvYXRpbmcsIG9uQ2hhbmdlLCBvdmVyZmxvd1JlZiwgc2Nyb2xsUmVmXSk7XG4gIHJldHVybiBSZWFjdC51c2VNZW1vKCgpID0+IGVuYWJsZWQgPyB7XG4gICAgZmxvYXRpbmdcbiAgfSA6IHt9LCBbZW5hYmxlZCwgZmxvYXRpbmddKTtcbn1cblxuZnVuY3Rpb24gZ2V0Tm9kZUNoaWxkcmVuKG5vZGVzLCBpZCwgb25seU9wZW5DaGlsZHJlbikge1xuICBpZiAob25seU9wZW5DaGlsZHJlbiA9PT0gdm9pZCAwKSB7XG4gICAgb25seU9wZW5DaGlsZHJlbiA9IHRydWU7XG4gIH1cbiAgY29uc3QgZGlyZWN0Q2hpbGRyZW4gPSBub2Rlcy5maWx0ZXIobm9kZSA9PiB7XG4gICAgdmFyIF9ub2RlJGNvbnRleHQ7XG4gICAgcmV0dXJuIG5vZGUucGFyZW50SWQgPT09IGlkICYmICghb25seU9wZW5DaGlsZHJlbiB8fCAoKF9ub2RlJGNvbnRleHQgPSBub2RlLmNvbnRleHQpID09IG51bGwgPyB2b2lkIDAgOiBfbm9kZSRjb250ZXh0Lm9wZW4pKTtcbiAgfSk7XG4gIHJldHVybiBkaXJlY3RDaGlsZHJlbi5mbGF0TWFwKGNoaWxkID0+IFtjaGlsZCwgLi4uZ2V0Tm9kZUNoaWxkcmVuKG5vZGVzLCBjaGlsZC5pZCwgb25seU9wZW5DaGlsZHJlbildKTtcbn1cblxuZnVuY3Rpb24gaXNQb2ludEluUG9seWdvbihwb2ludCwgcG9seWdvbikge1xuICBjb25zdCBbeCwgeV0gPSBwb2ludDtcbiAgbGV0IGlzSW5zaWRlID0gZmFsc2U7XG4gIGNvbnN0IGxlbmd0aCA9IHBvbHlnb24ubGVuZ3RoO1xuICBmb3IgKGxldCBpID0gMCwgaiA9IGxlbmd0aCAtIDE7IGkgPCBsZW5ndGg7IGogPSBpKyspIHtcbiAgICBjb25zdCBbeGksIHlpXSA9IHBvbHlnb25baV0gfHwgWzAsIDBdO1xuICAgIGNvbnN0IFt4aiwgeWpdID0gcG9seWdvbltqXSB8fCBbMCwgMF07XG4gICAgY29uc3QgaW50ZXJzZWN0ID0geWkgPj0geSAhPT0geWogPj0geSAmJiB4IDw9ICh4aiAtIHhpKSAqICh5IC0geWkpIC8gKHlqIC0geWkpICsgeGk7XG4gICAgaWYgKGludGVyc2VjdCkge1xuICAgICAgaXNJbnNpZGUgPSAhaXNJbnNpZGU7XG4gICAgfVxuICB9XG4gIHJldHVybiBpc0luc2lkZTtcbn1cbmZ1bmN0aW9uIGlzSW5zaWRlKHBvaW50LCByZWN0KSB7XG4gIHJldHVybiBwb2ludFswXSA+PSByZWN0LnggJiYgcG9pbnRbMF0gPD0gcmVjdC54ICsgcmVjdC53aWR0aCAmJiBwb2ludFsxXSA+PSByZWN0LnkgJiYgcG9pbnRbMV0gPD0gcmVjdC55ICsgcmVjdC5oZWlnaHQ7XG59XG4vKipcbiAqIEdlbmVyYXRlcyBhIHNhZmUgcG9seWdvbiBhcmVhIHRoYXQgdGhlIHVzZXIgY2FuIHRyYXZlcnNlIHdpdGhvdXQgY2xvc2luZyB0aGVcbiAqIGZsb2F0aW5nIGVsZW1lbnQgb25jZSBsZWF2aW5nIHRoZSByZWZlcmVuY2UgZWxlbWVudC5cbiAqIEBzZWUgaHR0cHM6Ly9mbG9hdGluZy11aS5jb20vZG9jcy91c2VIb3ZlciNzYWZlcG9seWdvblxuICovXG5mdW5jdGlvbiBzYWZlUG9seWdvbihvcHRpb25zKSB7XG4gIGlmIChvcHRpb25zID09PSB2b2lkIDApIHtcbiAgICBvcHRpb25zID0ge307XG4gIH1cbiAgY29uc3Qge1xuICAgIGJ1ZmZlciA9IDAuNSxcbiAgICBibG9ja1BvaW50ZXJFdmVudHMgPSBmYWxzZSxcbiAgICByZXF1aXJlSW50ZW50ID0gdHJ1ZVxuICB9ID0gb3B0aW9ucztcbiAgY29uc3QgdGltZW91dFJlZiA9IHtcbiAgICBjdXJyZW50OiAtMVxuICB9O1xuICBsZXQgaGFzTGFuZGVkID0gZmFsc2U7XG4gIGxldCBsYXN0WCA9IG51bGw7XG4gIGxldCBsYXN0WSA9IG51bGw7XG4gIGxldCBsYXN0Q3Vyc29yVGltZSA9IHR5cGVvZiBwZXJmb3JtYW5jZSAhPT0gJ3VuZGVmaW5lZCcgPyBwZXJmb3JtYW5jZS5ub3coKSA6IDA7XG4gIGZ1bmN0aW9uIGdldEN1cnNvclNwZWVkKHgsIHkpIHtcbiAgICBjb25zdCBjdXJyZW50VGltZSA9IHBlcmZvcm1hbmNlLm5vdygpO1xuICAgIGNvbnN0IGVsYXBzZWRUaW1lID0gY3VycmVudFRpbWUgLSBsYXN0Q3Vyc29yVGltZTtcbiAgICBpZiAobGFzdFggPT09IG51bGwgfHwgbGFzdFkgPT09IG51bGwgfHwgZWxhcHNlZFRpbWUgPT09IDApIHtcbiAgICAgIGxhc3RYID0geDtcbiAgICAgIGxhc3RZID0geTtcbiAgICAgIGxhc3RDdXJzb3JUaW1lID0gY3VycmVudFRpbWU7XG4gICAgICByZXR1cm4gbnVsbDtcbiAgICB9XG4gICAgY29uc3QgZGVsdGFYID0geCAtIGxhc3RYO1xuICAgIGNvbnN0IGRlbHRhWSA9IHkgLSBsYXN0WTtcbiAgICBjb25zdCBkaXN0YW5jZSA9IE1hdGguc3FydChkZWx0YVggKiBkZWx0YVggKyBkZWx0YVkgKiBkZWx0YVkpO1xuICAgIGNvbnN0IHNwZWVkID0gZGlzdGFuY2UgLyBlbGFwc2VkVGltZTsgLy8gcHggLyBtc1xuXG4gICAgbGFzdFggPSB4O1xuICAgIGxhc3RZID0geTtcbiAgICBsYXN0Q3Vyc29yVGltZSA9IGN1cnJlbnRUaW1lO1xuICAgIHJldHVybiBzcGVlZDtcbiAgfVxuICBjb25zdCBmbiA9IF9yZWYgPT4ge1xuICAgIGxldCB7XG4gICAgICB4LFxuICAgICAgeSxcbiAgICAgIHBsYWNlbWVudCxcbiAgICAgIGVsZW1lbnRzLFxuICAgICAgb25DbG9zZSxcbiAgICAgIG5vZGVJZCxcbiAgICAgIHRyZWVcbiAgICB9ID0gX3JlZjtcbiAgICByZXR1cm4gZnVuY3Rpb24gb25Nb3VzZU1vdmUoZXZlbnQpIHtcbiAgICAgIGZ1bmN0aW9uIGNsb3NlKCkge1xuICAgICAgICBjbGVhclRpbWVvdXRJZlNldCh0aW1lb3V0UmVmKTtcbiAgICAgICAgb25DbG9zZSgpO1xuICAgICAgfVxuICAgICAgY2xlYXJUaW1lb3V0SWZTZXQodGltZW91dFJlZik7XG4gICAgICBpZiAoIWVsZW1lbnRzLmRvbVJlZmVyZW5jZSB8fCAhZWxlbWVudHMuZmxvYXRpbmcgfHwgcGxhY2VtZW50ID09IG51bGwgfHwgeCA9PSBudWxsIHx8IHkgPT0gbnVsbCkge1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG4gICAgICBjb25zdCB7XG4gICAgICAgIGNsaWVudFgsXG4gICAgICAgIGNsaWVudFlcbiAgICAgIH0gPSBldmVudDtcbiAgICAgIGNvbnN0IGNsaWVudFBvaW50ID0gW2NsaWVudFgsIGNsaWVudFldO1xuICAgICAgY29uc3QgdGFyZ2V0ID0gZ2V0VGFyZ2V0KGV2ZW50KTtcbiAgICAgIGNvbnN0IGlzTGVhdmUgPSBldmVudC50eXBlID09PSAnbW91c2VsZWF2ZSc7XG4gICAgICBjb25zdCBpc092ZXJGbG9hdGluZ0VsID0gY29udGFpbnMoZWxlbWVudHMuZmxvYXRpbmcsIHRhcmdldCk7XG4gICAgICBjb25zdCBpc092ZXJSZWZlcmVuY2VFbCA9IGNvbnRhaW5zKGVsZW1lbnRzLmRvbVJlZmVyZW5jZSwgdGFyZ2V0KTtcbiAgICAgIGNvbnN0IHJlZlJlY3QgPSBlbGVtZW50cy5kb21SZWZlcmVuY2UuZ2V0Qm91bmRpbmdDbGllbnRSZWN0KCk7XG4gICAgICBjb25zdCByZWN0ID0gZWxlbWVudHMuZmxvYXRpbmcuZ2V0Qm91bmRpbmdDbGllbnRSZWN0KCk7XG4gICAgICBjb25zdCBzaWRlID0gcGxhY2VtZW50LnNwbGl0KCctJylbMF07XG4gICAgICBjb25zdCBjdXJzb3JMZWF2ZUZyb21SaWdodCA9IHggPiByZWN0LnJpZ2h0IC0gcmVjdC53aWR0aCAvIDI7XG4gICAgICBjb25zdCBjdXJzb3JMZWF2ZUZyb21Cb3R0b20gPSB5ID4gcmVjdC5ib3R0b20gLSByZWN0LmhlaWdodCAvIDI7XG4gICAgICBjb25zdCBpc092ZXJSZWZlcmVuY2VSZWN0ID0gaXNJbnNpZGUoY2xpZW50UG9pbnQsIHJlZlJlY3QpO1xuICAgICAgY29uc3QgaXNGbG9hdGluZ1dpZGVyID0gcmVjdC53aWR0aCA+IHJlZlJlY3Qud2lkdGg7XG4gICAgICBjb25zdCBpc0Zsb2F0aW5nVGFsbGVyID0gcmVjdC5oZWlnaHQgPiByZWZSZWN0LmhlaWdodDtcbiAgICAgIGNvbnN0IGxlZnQgPSAoaXNGbG9hdGluZ1dpZGVyID8gcmVmUmVjdCA6IHJlY3QpLmxlZnQ7XG4gICAgICBjb25zdCByaWdodCA9IChpc0Zsb2F0aW5nV2lkZXIgPyByZWZSZWN0IDogcmVjdCkucmlnaHQ7XG4gICAgICBjb25zdCB0b3AgPSAoaXNGbG9hdGluZ1RhbGxlciA/IHJlZlJlY3QgOiByZWN0KS50b3A7XG4gICAgICBjb25zdCBib3R0b20gPSAoaXNGbG9hdGluZ1RhbGxlciA/IHJlZlJlY3QgOiByZWN0KS5ib3R0b207XG4gICAgICBpZiAoaXNPdmVyRmxvYXRpbmdFbCkge1xuICAgICAgICBoYXNMYW5kZWQgPSB0cnVlO1xuICAgICAgICBpZiAoIWlzTGVhdmUpIHtcbiAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIGlmIChpc092ZXJSZWZlcmVuY2VFbCkge1xuICAgICAgICBoYXNMYW5kZWQgPSBmYWxzZTtcbiAgICAgIH1cbiAgICAgIGlmIChpc092ZXJSZWZlcmVuY2VFbCAmJiAhaXNMZWF2ZSkge1xuICAgICAgICBoYXNMYW5kZWQgPSB0cnVlO1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG5cbiAgICAgIC8vIFByZXZlbnQgb3ZlcmxhcHBpbmcgZmxvYXRpbmcgZWxlbWVudCBmcm9tIGJlaW5nIHN0dWNrIGluIGFuIG9wZW4tY2xvc2VcbiAgICAgIC8vIGxvb3A6IGh0dHBzOi8vZ2l0aHViLmNvbS9mbG9hdGluZy11aS9mbG9hdGluZy11aS9pc3N1ZXMvMTkxMFxuICAgICAgaWYgKGlzTGVhdmUgJiYgaXNFbGVtZW50KGV2ZW50LnJlbGF0ZWRUYXJnZXQpICYmIGNvbnRhaW5zKGVsZW1lbnRzLmZsb2F0aW5nLCBldmVudC5yZWxhdGVkVGFyZ2V0KSkge1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG5cbiAgICAgIC8vIElmIGFueSBuZXN0ZWQgY2hpbGQgaXMgb3BlbiwgYWJvcnQuXG4gICAgICBpZiAodHJlZSAmJiBnZXROb2RlQ2hpbGRyZW4odHJlZS5ub2Rlc1JlZi5jdXJyZW50LCBub2RlSWQpLmxlbmd0aCkge1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG5cbiAgICAgIC8vIElmIHRoZSBwb2ludGVyIGlzIGxlYXZpbmcgZnJvbSB0aGUgb3Bwb3NpdGUgc2lkZSwgdGhlIFwiYnVmZmVyXCIgbG9naWNcbiAgICAgIC8vIGNyZWF0ZXMgYSBwb2ludCB3aGVyZSB0aGUgZmxvYXRpbmcgZWxlbWVudCByZW1haW5zIG9wZW4sIGJ1dCBzaG91bGQgYmVcbiAgICAgIC8vIGlnbm9yZWQuXG4gICAgICAvLyBBIGNvbnN0YW50IG9mIDEgaGFuZGxlcyBmbG9hdGluZyBwb2ludCByb3VuZGluZyBlcnJvcnMuXG4gICAgICBpZiAoc2lkZSA9PT0gJ3RvcCcgJiYgeSA+PSByZWZSZWN0LmJvdHRvbSAtIDEgfHwgc2lkZSA9PT0gJ2JvdHRvbScgJiYgeSA8PSByZWZSZWN0LnRvcCArIDEgfHwgc2lkZSA9PT0gJ2xlZnQnICYmIHggPj0gcmVmUmVjdC5yaWdodCAtIDEgfHwgc2lkZSA9PT0gJ3JpZ2h0JyAmJiB4IDw9IHJlZlJlY3QubGVmdCArIDEpIHtcbiAgICAgICAgcmV0dXJuIGNsb3NlKCk7XG4gICAgICB9XG5cbiAgICAgIC8vIElnbm9yZSB3aGVuIHRoZSBjdXJzb3IgaXMgd2l0aGluIHRoZSByZWN0YW5ndWxhciB0cm91Z2ggYmV0d2VlbiB0aGVcbiAgICAgIC8vIHR3byBlbGVtZW50cy4gU2luY2UgdGhlIHRyaWFuZ2xlIGlzIGNyZWF0ZWQgZnJvbSB0aGUgY3Vyc29yIHBvaW50LFxuICAgICAgLy8gd2hpY2ggY2FuIHN0YXJ0IGJleW9uZCB0aGUgcmVmIGVsZW1lbnQncyBlZGdlLCB0cmF2ZXJzaW5nIGJhY2sgYW5kXG4gICAgICAvLyBmb3J0aCBmcm9tIHRoZSByZWYgdG8gdGhlIGZsb2F0aW5nIGVsZW1lbnQgY2FuIGNhdXNlIGl0IHRvIGNsb3NlLiBUaGlzXG4gICAgICAvLyBlbnN1cmVzIGl0IGFsd2F5cyByZW1haW5zIG9wZW4gaW4gdGhhdCBjYXNlLlxuICAgICAgbGV0IHJlY3RQb2x5ID0gW107XG4gICAgICBzd2l0Y2ggKHNpZGUpIHtcbiAgICAgICAgY2FzZSAndG9wJzpcbiAgICAgICAgICByZWN0UG9seSA9IFtbbGVmdCwgcmVmUmVjdC50b3AgKyAxXSwgW2xlZnQsIHJlY3QuYm90dG9tIC0gMV0sIFtyaWdodCwgcmVjdC5ib3R0b20gLSAxXSwgW3JpZ2h0LCByZWZSZWN0LnRvcCArIDFdXTtcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgY2FzZSAnYm90dG9tJzpcbiAgICAgICAgICByZWN0UG9seSA9IFtbbGVmdCwgcmVjdC50b3AgKyAxXSwgW2xlZnQsIHJlZlJlY3QuYm90dG9tIC0gMV0sIFtyaWdodCwgcmVmUmVjdC5ib3R0b20gLSAxXSwgW3JpZ2h0LCByZWN0LnRvcCArIDFdXTtcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgY2FzZSAnbGVmdCc6XG4gICAgICAgICAgcmVjdFBvbHkgPSBbW3JlY3QucmlnaHQgLSAxLCBib3R0b21dLCBbcmVjdC5yaWdodCAtIDEsIHRvcF0sIFtyZWZSZWN0LmxlZnQgKyAxLCB0b3BdLCBbcmVmUmVjdC5sZWZ0ICsgMSwgYm90dG9tXV07XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIGNhc2UgJ3JpZ2h0JzpcbiAgICAgICAgICByZWN0UG9seSA9IFtbcmVmUmVjdC5yaWdodCAtIDEsIGJvdHRvbV0sIFtyZWZSZWN0LnJpZ2h0IC0gMSwgdG9wXSwgW3JlY3QubGVmdCArIDEsIHRvcF0sIFtyZWN0LmxlZnQgKyAxLCBib3R0b21dXTtcbiAgICAgICAgICBicmVhaztcbiAgICAgIH1cbiAgICAgIGZ1bmN0aW9uIGdldFBvbHlnb24oX3JlZjIpIHtcbiAgICAgICAgbGV0IFt4LCB5XSA9IF9yZWYyO1xuICAgICAgICBzd2l0Y2ggKHNpZGUpIHtcbiAgICAgICAgICBjYXNlICd0b3AnOlxuICAgICAgICAgICAge1xuICAgICAgICAgICAgICBjb25zdCBjdXJzb3JQb2ludE9uZSA9IFtpc0Zsb2F0aW5nV2lkZXIgPyB4ICsgYnVmZmVyIC8gMiA6IGN1cnNvckxlYXZlRnJvbVJpZ2h0ID8geCArIGJ1ZmZlciAqIDQgOiB4IC0gYnVmZmVyICogNCwgeSArIGJ1ZmZlciArIDFdO1xuICAgICAgICAgICAgICBjb25zdCBjdXJzb3JQb2ludFR3byA9IFtpc0Zsb2F0aW5nV2lkZXIgPyB4IC0gYnVmZmVyIC8gMiA6IGN1cnNvckxlYXZlRnJvbVJpZ2h0ID8geCArIGJ1ZmZlciAqIDQgOiB4IC0gYnVmZmVyICogNCwgeSArIGJ1ZmZlciArIDFdO1xuICAgICAgICAgICAgICBjb25zdCBjb21tb25Qb2ludHMgPSBbW3JlY3QubGVmdCwgY3Vyc29yTGVhdmVGcm9tUmlnaHQgPyByZWN0LmJvdHRvbSAtIGJ1ZmZlciA6IGlzRmxvYXRpbmdXaWRlciA/IHJlY3QuYm90dG9tIC0gYnVmZmVyIDogcmVjdC50b3BdLCBbcmVjdC5yaWdodCwgY3Vyc29yTGVhdmVGcm9tUmlnaHQgPyBpc0Zsb2F0aW5nV2lkZXIgPyByZWN0LmJvdHRvbSAtIGJ1ZmZlciA6IHJlY3QudG9wIDogcmVjdC5ib3R0b20gLSBidWZmZXJdXTtcbiAgICAgICAgICAgICAgcmV0dXJuIFtjdXJzb3JQb2ludE9uZSwgY3Vyc29yUG9pbnRUd28sIC4uLmNvbW1vblBvaW50c107XG4gICAgICAgICAgICB9XG4gICAgICAgICAgY2FzZSAnYm90dG9tJzpcbiAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgY29uc3QgY3Vyc29yUG9pbnRPbmUgPSBbaXNGbG9hdGluZ1dpZGVyID8geCArIGJ1ZmZlciAvIDIgOiBjdXJzb3JMZWF2ZUZyb21SaWdodCA/IHggKyBidWZmZXIgKiA0IDogeCAtIGJ1ZmZlciAqIDQsIHkgLSBidWZmZXJdO1xuICAgICAgICAgICAgICBjb25zdCBjdXJzb3JQb2ludFR3byA9IFtpc0Zsb2F0aW5nV2lkZXIgPyB4IC0gYnVmZmVyIC8gMiA6IGN1cnNvckxlYXZlRnJvbVJpZ2h0ID8geCArIGJ1ZmZlciAqIDQgOiB4IC0gYnVmZmVyICogNCwgeSAtIGJ1ZmZlcl07XG4gICAgICAgICAgICAgIGNvbnN0IGNvbW1vblBvaW50cyA9IFtbcmVjdC5sZWZ0LCBjdXJzb3JMZWF2ZUZyb21SaWdodCA/IHJlY3QudG9wICsgYnVmZmVyIDogaXNGbG9hdGluZ1dpZGVyID8gcmVjdC50b3AgKyBidWZmZXIgOiByZWN0LmJvdHRvbV0sIFtyZWN0LnJpZ2h0LCBjdXJzb3JMZWF2ZUZyb21SaWdodCA/IGlzRmxvYXRpbmdXaWRlciA/IHJlY3QudG9wICsgYnVmZmVyIDogcmVjdC5ib3R0b20gOiByZWN0LnRvcCArIGJ1ZmZlcl1dO1xuICAgICAgICAgICAgICByZXR1cm4gW2N1cnNvclBvaW50T25lLCBjdXJzb3JQb2ludFR3bywgLi4uY29tbW9uUG9pbnRzXTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICBjYXNlICdsZWZ0JzpcbiAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgY29uc3QgY3Vyc29yUG9pbnRPbmUgPSBbeCArIGJ1ZmZlciArIDEsIGlzRmxvYXRpbmdUYWxsZXIgPyB5ICsgYnVmZmVyIC8gMiA6IGN1cnNvckxlYXZlRnJvbUJvdHRvbSA/IHkgKyBidWZmZXIgKiA0IDogeSAtIGJ1ZmZlciAqIDRdO1xuICAgICAgICAgICAgICBjb25zdCBjdXJzb3JQb2ludFR3byA9IFt4ICsgYnVmZmVyICsgMSwgaXNGbG9hdGluZ1RhbGxlciA/IHkgLSBidWZmZXIgLyAyIDogY3Vyc29yTGVhdmVGcm9tQm90dG9tID8geSArIGJ1ZmZlciAqIDQgOiB5IC0gYnVmZmVyICogNF07XG4gICAgICAgICAgICAgIGNvbnN0IGNvbW1vblBvaW50cyA9IFtbY3Vyc29yTGVhdmVGcm9tQm90dG9tID8gcmVjdC5yaWdodCAtIGJ1ZmZlciA6IGlzRmxvYXRpbmdUYWxsZXIgPyByZWN0LnJpZ2h0IC0gYnVmZmVyIDogcmVjdC5sZWZ0LCByZWN0LnRvcF0sIFtjdXJzb3JMZWF2ZUZyb21Cb3R0b20gPyBpc0Zsb2F0aW5nVGFsbGVyID8gcmVjdC5yaWdodCAtIGJ1ZmZlciA6IHJlY3QubGVmdCA6IHJlY3QucmlnaHQgLSBidWZmZXIsIHJlY3QuYm90dG9tXV07XG4gICAgICAgICAgICAgIHJldHVybiBbLi4uY29tbW9uUG9pbnRzLCBjdXJzb3JQb2ludE9uZSwgY3Vyc29yUG9pbnRUd29dO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIGNhc2UgJ3JpZ2h0JzpcbiAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgY29uc3QgY3Vyc29yUG9pbnRPbmUgPSBbeCAtIGJ1ZmZlciwgaXNGbG9hdGluZ1RhbGxlciA/IHkgKyBidWZmZXIgLyAyIDogY3Vyc29yTGVhdmVGcm9tQm90dG9tID8geSArIGJ1ZmZlciAqIDQgOiB5IC0gYnVmZmVyICogNF07XG4gICAgICAgICAgICAgIGNvbnN0IGN1cnNvclBvaW50VHdvID0gW3ggLSBidWZmZXIsIGlzRmxvYXRpbmdUYWxsZXIgPyB5IC0gYnVmZmVyIC8gMiA6IGN1cnNvckxlYXZlRnJvbUJvdHRvbSA/IHkgKyBidWZmZXIgKiA0IDogeSAtIGJ1ZmZlciAqIDRdO1xuICAgICAgICAgICAgICBjb25zdCBjb21tb25Qb2ludHMgPSBbW2N1cnNvckxlYXZlRnJvbUJvdHRvbSA/IHJlY3QubGVmdCArIGJ1ZmZlciA6IGlzRmxvYXRpbmdUYWxsZXIgPyByZWN0LmxlZnQgKyBidWZmZXIgOiByZWN0LnJpZ2h0LCByZWN0LnRvcF0sIFtjdXJzb3JMZWF2ZUZyb21Cb3R0b20gPyBpc0Zsb2F0aW5nVGFsbGVyID8gcmVjdC5sZWZ0ICsgYnVmZmVyIDogcmVjdC5yaWdodCA6IHJlY3QubGVmdCArIGJ1ZmZlciwgcmVjdC5ib3R0b21dXTtcbiAgICAgICAgICAgICAgcmV0dXJuIFtjdXJzb3JQb2ludE9uZSwgY3Vyc29yUG9pbnRUd28sIC4uLmNvbW1vblBvaW50c107XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIGlmIChpc1BvaW50SW5Qb2x5Z29uKFtjbGllbnRYLCBjbGllbnRZXSwgcmVjdFBvbHkpKSB7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cbiAgICAgIGlmIChoYXNMYW5kZWQgJiYgIWlzT3ZlclJlZmVyZW5jZVJlY3QpIHtcbiAgICAgICAgcmV0dXJuIGNsb3NlKCk7XG4gICAgICB9XG4gICAgICBpZiAoIWlzTGVhdmUgJiYgcmVxdWlyZUludGVudCkge1xuICAgICAgICBjb25zdCBjdXJzb3JTcGVlZCA9IGdldEN1cnNvclNwZWVkKGV2ZW50LmNsaWVudFgsIGV2ZW50LmNsaWVudFkpO1xuICAgICAgICBjb25zdCBjdXJzb3JTcGVlZFRocmVzaG9sZCA9IDAuMTtcbiAgICAgICAgaWYgKGN1cnNvclNwZWVkICE9PSBudWxsICYmIGN1cnNvclNwZWVkIDwgY3Vyc29yU3BlZWRUaHJlc2hvbGQpIHtcbiAgICAgICAgICByZXR1cm4gY2xvc2UoKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgaWYgKCFpc1BvaW50SW5Qb2x5Z29uKFtjbGllbnRYLCBjbGllbnRZXSwgZ2V0UG9seWdvbihbeCwgeV0pKSkge1xuICAgICAgICBjbG9zZSgpO1xuICAgICAgfSBlbHNlIGlmICghaGFzTGFuZGVkICYmIHJlcXVpcmVJbnRlbnQpIHtcbiAgICAgICAgdGltZW91dFJlZi5jdXJyZW50ID0gd2luZG93LnNldFRpbWVvdXQoY2xvc2UsIDQwKTtcbiAgICAgIH1cbiAgICB9O1xuICB9O1xuICBmbi5fX29wdGlvbnMgPSB7XG4gICAgYmxvY2tQb2ludGVyRXZlbnRzXG4gIH07XG4gIHJldHVybiBmbjtcbn1cblxuZXhwb3J0IHsgQ29tcG9zaXRlLCBDb21wb3NpdGVJdGVtLCBGbG9hdGluZ0Fycm93LCBGbG9hdGluZ0RlbGF5R3JvdXAsIEZsb2F0aW5nRm9jdXNNYW5hZ2VyLCBGbG9hdGluZ0xpc3QsIEZsb2F0aW5nTm9kZSwgRmxvYXRpbmdPdmVybGF5LCBGbG9hdGluZ1BvcnRhbCwgRmxvYXRpbmdUcmVlLCBOZXh0RmxvYXRpbmdEZWxheUdyb3VwLCBpbm5lciwgc2FmZVBvbHlnb24sIHVzZUNsaWNrLCB1c2VDbGllbnRQb2ludCwgdXNlRGVsYXlHcm91cCwgdXNlRGVsYXlHcm91cENvbnRleHQsIHVzZURpc21pc3MsIHVzZUZsb2F0aW5nLCB1c2VGbG9hdGluZ05vZGVJZCwgdXNlRmxvYXRpbmdQYXJlbnROb2RlSWQsIHVzZUZsb2F0aW5nUG9ydGFsTm9kZSwgdXNlRmxvYXRpbmdSb290Q29udGV4dCwgdXNlRmxvYXRpbmdUcmVlLCB1c2VGb2N1cywgdXNlSG92ZXIsIHVzZUlkLCB1c2VJbm5lck9mZnNldCwgdXNlSW50ZXJhY3Rpb25zLCB1c2VMaXN0SXRlbSwgdXNlTGlzdE5hdmlnYXRpb24sIHVzZU1lcmdlUmVmcywgdXNlTmV4dERlbGF5R3JvdXAsIHVzZVJvbGUsIHVzZVRyYW5zaXRpb25TdGF0dXMsIHVzZVRyYW5zaXRpb25TdHlsZXMsIHVzZVR5cGVhaGVhZCB9O1xuIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/react-datepicker/node_modules/@floating-ui/react/dist/floating-ui.react.mjs\n");

/***/ }),

/***/ "(ssr)/./node_modules/react-datepicker/node_modules/@floating-ui/react/dist/floating-ui.react.utils.mjs":
/*!********************************************************************************************************!*\
  !*** ./node_modules/react-datepicker/node_modules/@floating-ui/react/dist/floating-ui.react.utils.mjs ***!
  \********************************************************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("var react__WEBPACK_IMPORTED_MODULE_0___namespace_cache;\n__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   activeElement: () => (/* binding */ activeElement),\n/* harmony export */   contains: () => (/* binding */ contains),\n/* harmony export */   createGridCellMap: () => (/* binding */ createGridCellMap),\n/* harmony export */   disableFocusInside: () => (/* binding */ disableFocusInside),\n/* harmony export */   enableFocusInside: () => (/* binding */ enableFocusInside),\n/* harmony export */   findNonDisabledListIndex: () => (/* binding */ findNonDisabledListIndex),\n/* harmony export */   getDeepestNode: () => (/* binding */ getDeepestNode),\n/* harmony export */   getDocument: () => (/* binding */ getDocument),\n/* harmony export */   getFloatingFocusElement: () => (/* binding */ getFloatingFocusElement),\n/* harmony export */   getGridCellIndexOfCorner: () => (/* binding */ getGridCellIndexOfCorner),\n/* harmony export */   getGridCellIndices: () => (/* binding */ getGridCellIndices),\n/* harmony export */   getGridNavigatedIndex: () => (/* binding */ getGridNavigatedIndex),\n/* harmony export */   getMaxListIndex: () => (/* binding */ getMaxListIndex),\n/* harmony export */   getMinListIndex: () => (/* binding */ getMinListIndex),\n/* harmony export */   getNextTabbable: () => (/* binding */ getNextTabbable),\n/* harmony export */   getNodeAncestors: () => (/* binding */ getNodeAncestors),\n/* harmony export */   getNodeChildren: () => (/* binding */ getNodeChildren),\n/* harmony export */   getPlatform: () => (/* binding */ getPlatform),\n/* harmony export */   getPreviousTabbable: () => (/* binding */ getPreviousTabbable),\n/* harmony export */   getTabbableOptions: () => (/* binding */ getTabbableOptions),\n/* harmony export */   getTarget: () => (/* binding */ getTarget),\n/* harmony export */   getUserAgent: () => (/* binding */ getUserAgent),\n/* harmony export */   isAndroid: () => (/* binding */ isAndroid),\n/* harmony export */   isDifferentGridRow: () => (/* binding */ isDifferentGridRow),\n/* harmony export */   isEventTargetWithin: () => (/* binding */ isEventTargetWithin),\n/* harmony export */   isIndexOutOfListBounds: () => (/* binding */ isIndexOutOfListBounds),\n/* harmony export */   isJSDOM: () => (/* binding */ isJSDOM),\n/* harmony export */   isListIndexDisabled: () => (/* binding */ isListIndexDisabled),\n/* harmony export */   isMac: () => (/* binding */ isMac),\n/* harmony export */   isMouseLikePointerType: () => (/* binding */ isMouseLikePointerType),\n/* harmony export */   isOutsideEvent: () => (/* binding */ isOutsideEvent),\n/* harmony export */   isReactEvent: () => (/* binding */ isReactEvent),\n/* harmony export */   isRootElement: () => (/* binding */ isRootElement),\n/* harmony export */   isSafari: () => (/* binding */ isSafari),\n/* harmony export */   isTypeableCombobox: () => (/* binding */ isTypeableCombobox),\n/* harmony export */   isTypeableElement: () => (/* binding */ isTypeableElement),\n/* harmony export */   isVirtualClick: () => (/* binding */ isVirtualClick),\n/* harmony export */   isVirtualPointerEvent: () => (/* binding */ isVirtualPointerEvent),\n/* harmony export */   matchesFocusVisible: () => (/* binding */ matchesFocusVisible),\n/* harmony export */   stopEvent: () => (/* binding */ stopEvent),\n/* harmony export */   useEffectEvent: () => (/* binding */ useEffectEvent),\n/* harmony export */   useLatestRef: () => (/* binding */ useLatestRef),\n/* harmony export */   useModernLayoutEffect: () => (/* binding */ index)\n/* harmony export */ });\n/* harmony import */ var _floating_ui_utils_dom__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! @floating-ui/utils/dom */ \"(ssr)/./node_modules/@floating-ui/utils/dist/floating-ui.utils.dom.mjs\");\n/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! react */ \"(ssr)/./node_modules/next/dist/server/future/route-modules/app-page/vendored/ssr/react.js\");\n/* harmony import */ var _floating_ui_utils__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! @floating-ui/utils */ \"(ssr)/./node_modules/@floating-ui/utils/dist/floating-ui.utils.mjs\");\n/* harmony import */ var tabbable__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! tabbable */ \"(ssr)/./node_modules/tabbable/dist/index.esm.js\");\n\n\n\n\n\n\n// Avoid Chrome DevTools blue warning.\nfunction getPlatform() {\n  const uaData = navigator.userAgentData;\n  if (uaData != null && uaData.platform) {\n    return uaData.platform;\n  }\n  return navigator.platform;\n}\nfunction getUserAgent() {\n  const uaData = navigator.userAgentData;\n  if (uaData && Array.isArray(uaData.brands)) {\n    return uaData.brands.map(_ref => {\n      let {\n        brand,\n        version\n      } = _ref;\n      return brand + \"/\" + version;\n    }).join(' ');\n  }\n  return navigator.userAgent;\n}\nfunction isSafari() {\n  // Chrome DevTools does not complain about navigator.vendor\n  return /apple/i.test(navigator.vendor);\n}\nfunction isAndroid() {\n  const re = /android/i;\n  return re.test(getPlatform()) || re.test(getUserAgent());\n}\nfunction isMac() {\n  return getPlatform().toLowerCase().startsWith('mac') && !navigator.maxTouchPoints;\n}\nfunction isJSDOM() {\n  return getUserAgent().includes('jsdom/');\n}\n\nconst FOCUSABLE_ATTRIBUTE = 'data-floating-ui-focusable';\nconst TYPEABLE_SELECTOR = \"input:not([type='hidden']):not([disabled]),\" + \"[contenteditable]:not([contenteditable='false']),textarea:not([disabled])\";\nconst ARROW_LEFT = 'ArrowLeft';\nconst ARROW_RIGHT = 'ArrowRight';\nconst ARROW_UP = 'ArrowUp';\nconst ARROW_DOWN = 'ArrowDown';\n\nfunction activeElement(doc) {\n  let activeElement = doc.activeElement;\n  while (((_activeElement = activeElement) == null || (_activeElement = _activeElement.shadowRoot) == null ? void 0 : _activeElement.activeElement) != null) {\n    var _activeElement;\n    activeElement = activeElement.shadowRoot.activeElement;\n  }\n  return activeElement;\n}\nfunction contains(parent, child) {\n  if (!parent || !child) {\n    return false;\n  }\n  const rootNode = child.getRootNode == null ? void 0 : child.getRootNode();\n\n  // First, attempt with faster native method\n  if (parent.contains(child)) {\n    return true;\n  }\n\n  // then fallback to custom implementation with Shadow DOM support\n  if (rootNode && (0,_floating_ui_utils_dom__WEBPACK_IMPORTED_MODULE_1__.isShadowRoot)(rootNode)) {\n    let next = child;\n    while (next) {\n      if (parent === next) {\n        return true;\n      }\n      // @ts-ignore\n      next = next.parentNode || next.host;\n    }\n  }\n\n  // Give up, the result is false\n  return false;\n}\nfunction getTarget(event) {\n  if ('composedPath' in event) {\n    return event.composedPath()[0];\n  }\n\n  // TS thinks `event` is of type never as it assumes all browsers support\n  // `composedPath()`, but browsers without shadow DOM don't.\n  return event.target;\n}\nfunction isEventTargetWithin(event, node) {\n  if (node == null) {\n    return false;\n  }\n  if ('composedPath' in event) {\n    return event.composedPath().includes(node);\n  }\n\n  // TS thinks `event` is of type never as it assumes all browsers support composedPath, but browsers without shadow dom don't\n  const e = event;\n  return e.target != null && node.contains(e.target);\n}\nfunction isRootElement(element) {\n  return element.matches('html,body');\n}\nfunction getDocument(node) {\n  return (node == null ? void 0 : node.ownerDocument) || document;\n}\nfunction isTypeableElement(element) {\n  return (0,_floating_ui_utils_dom__WEBPACK_IMPORTED_MODULE_1__.isHTMLElement)(element) && element.matches(TYPEABLE_SELECTOR);\n}\nfunction isTypeableCombobox(element) {\n  if (!element) return false;\n  return element.getAttribute('role') === 'combobox' && isTypeableElement(element);\n}\nfunction matchesFocusVisible(element) {\n  // We don't want to block focus from working with `visibleOnly`\n  // (JSDOM doesn't match `:focus-visible` when the element has `:focus`)\n  if (!element || isJSDOM()) return true;\n  try {\n    return element.matches(':focus-visible');\n  } catch (_e) {\n    return true;\n  }\n}\nfunction getFloatingFocusElement(floatingElement) {\n  if (!floatingElement) {\n    return null;\n  }\n  // Try to find the element that has `{...getFloatingProps()}` spread on it.\n  // This indicates the floating element is acting as a positioning wrapper, and\n  // so focus should be managed on the child element with the event handlers and\n  // aria props.\n  return floatingElement.hasAttribute(FOCUSABLE_ATTRIBUTE) ? floatingElement : floatingElement.querySelector(\"[\" + FOCUSABLE_ATTRIBUTE + \"]\") || floatingElement;\n}\n\nfunction getNodeChildren(nodes, id, onlyOpenChildren) {\n  if (onlyOpenChildren === void 0) {\n    onlyOpenChildren = true;\n  }\n  const directChildren = nodes.filter(node => {\n    var _node$context;\n    return node.parentId === id && (!onlyOpenChildren || ((_node$context = node.context) == null ? void 0 : _node$context.open));\n  });\n  return directChildren.flatMap(child => [child, ...getNodeChildren(nodes, child.id, onlyOpenChildren)]);\n}\nfunction getDeepestNode(nodes, id) {\n  let deepestNodeId;\n  let maxDepth = -1;\n  function findDeepest(nodeId, depth) {\n    if (depth > maxDepth) {\n      deepestNodeId = nodeId;\n      maxDepth = depth;\n    }\n    const children = getNodeChildren(nodes, nodeId);\n    children.forEach(child => {\n      findDeepest(child.id, depth + 1);\n    });\n  }\n  findDeepest(id, 0);\n  return nodes.find(node => node.id === deepestNodeId);\n}\nfunction getNodeAncestors(nodes, id) {\n  var _nodes$find;\n  let allAncestors = [];\n  let currentParentId = (_nodes$find = nodes.find(node => node.id === id)) == null ? void 0 : _nodes$find.parentId;\n  while (currentParentId) {\n    const currentNode = nodes.find(node => node.id === currentParentId);\n    currentParentId = currentNode == null ? void 0 : currentNode.parentId;\n    if (currentNode) {\n      allAncestors = allAncestors.concat(currentNode);\n    }\n  }\n  return allAncestors;\n}\n\nfunction stopEvent(event) {\n  event.preventDefault();\n  event.stopPropagation();\n}\nfunction isReactEvent(event) {\n  return 'nativeEvent' in event;\n}\n\n// License: https://github.com/adobe/react-spectrum/blob/b35d5c02fe900badccd0cf1a8f23bb593419f238/packages/@react-aria/utils/src/isVirtualEvent.ts\nfunction isVirtualClick(event) {\n  // FIXME: Firefox is now emitting a deprecation warning for `mozInputSource`.\n  // Try to find a workaround for this. `react-aria` source still has the check.\n  if (event.mozInputSource === 0 && event.isTrusted) {\n    return true;\n  }\n  if (isAndroid() && event.pointerType) {\n    return event.type === 'click' && event.buttons === 1;\n  }\n  return event.detail === 0 && !event.pointerType;\n}\nfunction isVirtualPointerEvent(event) {\n  if (isJSDOM()) return false;\n  return !isAndroid() && event.width === 0 && event.height === 0 || isAndroid() && event.width === 1 && event.height === 1 && event.pressure === 0 && event.detail === 0 && event.pointerType === 'mouse' ||\n  // iOS VoiceOver returns 0.333 for width/height.\n  event.width < 1 && event.height < 1 && event.pressure === 0 && event.detail === 0 && event.pointerType === 'touch';\n}\nfunction isMouseLikePointerType(pointerType, strict) {\n  // On some Linux machines with Chromium, mouse inputs return a `pointerType`\n  // of \"pen\": https://github.com/floating-ui/floating-ui/issues/2015\n  const values = ['mouse', 'pen'];\n  if (!strict) {\n    values.push('', undefined);\n  }\n  return values.includes(pointerType);\n}\n\nvar isClient = typeof document !== 'undefined';\n\nvar noop = function noop() {};\nvar index = isClient ? react__WEBPACK_IMPORTED_MODULE_0__.useLayoutEffect : noop;\n\n// https://github.com/mui/material-ui/issues/41190#issuecomment-2040873379\nconst SafeReact = {\n  .../*#__PURE__*/ (react__WEBPACK_IMPORTED_MODULE_0___namespace_cache || (react__WEBPACK_IMPORTED_MODULE_0___namespace_cache = __webpack_require__.t(react__WEBPACK_IMPORTED_MODULE_0__, 2)))\n};\n\nfunction useLatestRef(value) {\n  const ref = react__WEBPACK_IMPORTED_MODULE_0__.useRef(value);\n  index(() => {\n    ref.current = value;\n  });\n  return ref;\n}\nconst useInsertionEffect = SafeReact.useInsertionEffect;\nconst useSafeInsertionEffect = useInsertionEffect || (fn => fn());\nfunction useEffectEvent(callback) {\n  const ref = react__WEBPACK_IMPORTED_MODULE_0__.useRef(() => {\n    if (true) {\n      throw new Error('Cannot call an event handler while rendering.');\n    }\n  });\n  useSafeInsertionEffect(() => {\n    ref.current = callback;\n  });\n  return react__WEBPACK_IMPORTED_MODULE_0__.useCallback(function () {\n    for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {\n      args[_key] = arguments[_key];\n    }\n    return ref.current == null ? void 0 : ref.current(...args);\n  }, []);\n}\n\nfunction isDifferentGridRow(index, cols, prevRow) {\n  return Math.floor(index / cols) !== prevRow;\n}\nfunction isIndexOutOfListBounds(listRef, index) {\n  return index < 0 || index >= listRef.current.length;\n}\nfunction getMinListIndex(listRef, disabledIndices) {\n  return findNonDisabledListIndex(listRef, {\n    disabledIndices\n  });\n}\nfunction getMaxListIndex(listRef, disabledIndices) {\n  return findNonDisabledListIndex(listRef, {\n    decrement: true,\n    startingIndex: listRef.current.length,\n    disabledIndices\n  });\n}\nfunction findNonDisabledListIndex(listRef, _temp) {\n  let {\n    startingIndex = -1,\n    decrement = false,\n    disabledIndices,\n    amount = 1\n  } = _temp === void 0 ? {} : _temp;\n  let index = startingIndex;\n  do {\n    index += decrement ? -amount : amount;\n  } while (index >= 0 && index <= listRef.current.length - 1 && isListIndexDisabled(listRef, index, disabledIndices));\n  return index;\n}\nfunction getGridNavigatedIndex(listRef, _ref) {\n  let {\n    event,\n    orientation,\n    loop,\n    rtl,\n    cols,\n    disabledIndices,\n    minIndex,\n    maxIndex,\n    prevIndex,\n    stopEvent: stop = false\n  } = _ref;\n  let nextIndex = prevIndex;\n  if (event.key === ARROW_UP) {\n    stop && stopEvent(event);\n    if (prevIndex === -1) {\n      nextIndex = maxIndex;\n    } else {\n      nextIndex = findNonDisabledListIndex(listRef, {\n        startingIndex: nextIndex,\n        amount: cols,\n        decrement: true,\n        disabledIndices\n      });\n      if (loop && (prevIndex - cols < minIndex || nextIndex < 0)) {\n        const col = prevIndex % cols;\n        const maxCol = maxIndex % cols;\n        const offset = maxIndex - (maxCol - col);\n        if (maxCol === col) {\n          nextIndex = maxIndex;\n        } else {\n          nextIndex = maxCol > col ? offset : offset - cols;\n        }\n      }\n    }\n    if (isIndexOutOfListBounds(listRef, nextIndex)) {\n      nextIndex = prevIndex;\n    }\n  }\n  if (event.key === ARROW_DOWN) {\n    stop && stopEvent(event);\n    if (prevIndex === -1) {\n      nextIndex = minIndex;\n    } else {\n      nextIndex = findNonDisabledListIndex(listRef, {\n        startingIndex: prevIndex,\n        amount: cols,\n        disabledIndices\n      });\n      if (loop && prevIndex + cols > maxIndex) {\n        nextIndex = findNonDisabledListIndex(listRef, {\n          startingIndex: prevIndex % cols - cols,\n          amount: cols,\n          disabledIndices\n        });\n      }\n    }\n    if (isIndexOutOfListBounds(listRef, nextIndex)) {\n      nextIndex = prevIndex;\n    }\n  }\n\n  // Remains on the same row/column.\n  if (orientation === 'both') {\n    const prevRow = (0,_floating_ui_utils__WEBPACK_IMPORTED_MODULE_2__.floor)(prevIndex / cols);\n    if (event.key === (rtl ? ARROW_LEFT : ARROW_RIGHT)) {\n      stop && stopEvent(event);\n      if (prevIndex % cols !== cols - 1) {\n        nextIndex = findNonDisabledListIndex(listRef, {\n          startingIndex: prevIndex,\n          disabledIndices\n        });\n        if (loop && isDifferentGridRow(nextIndex, cols, prevRow)) {\n          nextIndex = findNonDisabledListIndex(listRef, {\n            startingIndex: prevIndex - prevIndex % cols - 1,\n            disabledIndices\n          });\n        }\n      } else if (loop) {\n        nextIndex = findNonDisabledListIndex(listRef, {\n          startingIndex: prevIndex - prevIndex % cols - 1,\n          disabledIndices\n        });\n      }\n      if (isDifferentGridRow(nextIndex, cols, prevRow)) {\n        nextIndex = prevIndex;\n      }\n    }\n    if (event.key === (rtl ? ARROW_RIGHT : ARROW_LEFT)) {\n      stop && stopEvent(event);\n      if (prevIndex % cols !== 0) {\n        nextIndex = findNonDisabledListIndex(listRef, {\n          startingIndex: prevIndex,\n          decrement: true,\n          disabledIndices\n        });\n        if (loop && isDifferentGridRow(nextIndex, cols, prevRow)) {\n          nextIndex = findNonDisabledListIndex(listRef, {\n            startingIndex: prevIndex + (cols - prevIndex % cols),\n            decrement: true,\n            disabledIndices\n          });\n        }\n      } else if (loop) {\n        nextIndex = findNonDisabledListIndex(listRef, {\n          startingIndex: prevIndex + (cols - prevIndex % cols),\n          decrement: true,\n          disabledIndices\n        });\n      }\n      if (isDifferentGridRow(nextIndex, cols, prevRow)) {\n        nextIndex = prevIndex;\n      }\n    }\n    const lastRow = (0,_floating_ui_utils__WEBPACK_IMPORTED_MODULE_2__.floor)(maxIndex / cols) === prevRow;\n    if (isIndexOutOfListBounds(listRef, nextIndex)) {\n      if (loop && lastRow) {\n        nextIndex = event.key === (rtl ? ARROW_RIGHT : ARROW_LEFT) ? maxIndex : findNonDisabledListIndex(listRef, {\n          startingIndex: prevIndex - prevIndex % cols - 1,\n          disabledIndices\n        });\n      } else {\n        nextIndex = prevIndex;\n      }\n    }\n  }\n  return nextIndex;\n}\n\n/** For each cell index, gets the item index that occupies that cell */\nfunction createGridCellMap(sizes, cols, dense) {\n  const cellMap = [];\n  let startIndex = 0;\n  sizes.forEach((_ref2, index) => {\n    let {\n      width,\n      height\n    } = _ref2;\n    if (width > cols) {\n      if (true) {\n        throw new Error(\"[Floating UI]: Invalid grid - item width at index \" + index + \" is greater than grid columns\");\n      }\n    }\n    let itemPlaced = false;\n    if (dense) {\n      startIndex = 0;\n    }\n    while (!itemPlaced) {\n      const targetCells = [];\n      for (let i = 0; i < width; i++) {\n        for (let j = 0; j < height; j++) {\n          targetCells.push(startIndex + i + j * cols);\n        }\n      }\n      if (startIndex % cols + width <= cols && targetCells.every(cell => cellMap[cell] == null)) {\n        targetCells.forEach(cell => {\n          cellMap[cell] = index;\n        });\n        itemPlaced = true;\n      } else {\n        startIndex++;\n      }\n    }\n  });\n\n  // convert into a non-sparse array\n  return [...cellMap];\n}\n\n/** Gets cell index of an item's corner or -1 when index is -1. */\nfunction getGridCellIndexOfCorner(index, sizes, cellMap, cols, corner) {\n  if (index === -1) return -1;\n  const firstCellIndex = cellMap.indexOf(index);\n  const sizeItem = sizes[index];\n  switch (corner) {\n    case 'tl':\n      return firstCellIndex;\n    case 'tr':\n      if (!sizeItem) {\n        return firstCellIndex;\n      }\n      return firstCellIndex + sizeItem.width - 1;\n    case 'bl':\n      if (!sizeItem) {\n        return firstCellIndex;\n      }\n      return firstCellIndex + (sizeItem.height - 1) * cols;\n    case 'br':\n      return cellMap.lastIndexOf(index);\n  }\n}\n\n/** Gets all cell indices that correspond to the specified indices */\nfunction getGridCellIndices(indices, cellMap) {\n  return cellMap.flatMap((index, cellIndex) => indices.includes(index) ? [cellIndex] : []);\n}\nfunction isListIndexDisabled(listRef, index, disabledIndices) {\n  if (typeof disabledIndices === 'function') {\n    return disabledIndices(index);\n  } else if (disabledIndices) {\n    return disabledIndices.includes(index);\n  }\n  const element = listRef.current[index];\n  return element == null || element.hasAttribute('disabled') || element.getAttribute('aria-disabled') === 'true';\n}\n\nconst getTabbableOptions = () => ({\n  getShadowRoot: true,\n  displayCheck:\n  // JSDOM does not support the `tabbable` library. To solve this we can\n  // check if `ResizeObserver` is a real function (not polyfilled), which\n  // determines if the current environment is JSDOM-like.\n  typeof ResizeObserver === 'function' && ResizeObserver.toString().includes('[native code]') ? 'full' : 'none'\n});\nfunction getTabbableIn(container, dir) {\n  const list = (0,tabbable__WEBPACK_IMPORTED_MODULE_3__.tabbable)(container, getTabbableOptions());\n  const len = list.length;\n  if (len === 0) return;\n  const active = activeElement(getDocument(container));\n  const index = list.indexOf(active);\n  const nextIndex = index === -1 ? dir === 1 ? 0 : len - 1 : index + dir;\n  return list[nextIndex];\n}\nfunction getNextTabbable(referenceElement) {\n  return getTabbableIn(getDocument(referenceElement).body, 1) || referenceElement;\n}\nfunction getPreviousTabbable(referenceElement) {\n  return getTabbableIn(getDocument(referenceElement).body, -1) || referenceElement;\n}\nfunction isOutsideEvent(event, container) {\n  const containerElement = container || event.currentTarget;\n  const relatedTarget = event.relatedTarget;\n  return !relatedTarget || !contains(containerElement, relatedTarget);\n}\nfunction disableFocusInside(container) {\n  const tabbableElements = (0,tabbable__WEBPACK_IMPORTED_MODULE_3__.tabbable)(container, getTabbableOptions());\n  tabbableElements.forEach(element => {\n    element.dataset.tabindex = element.getAttribute('tabindex') || '';\n    element.setAttribute('tabindex', '-1');\n  });\n}\nfunction enableFocusInside(container) {\n  const elements = container.querySelectorAll('[data-tabindex]');\n  elements.forEach(element => {\n    const tabindex = element.dataset.tabindex;\n    delete element.dataset.tabindex;\n    if (tabindex) {\n      element.setAttribute('tabindex', tabindex);\n    } else {\n      element.removeAttribute('tabindex');\n    }\n  });\n}\n\n\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvcmVhY3QtZGF0ZXBpY2tlci9ub2RlX21vZHVsZXMvQGZsb2F0aW5nLXVpL3JlYWN0L2Rpc3QvZmxvYXRpbmctdWkucmVhY3QudXRpbHMubWpzIiwibWFwcGluZ3MiOiI7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7OztBQUFxRTtBQUN0QztBQUNTO0FBQ0c7QUFDUDs7QUFFcEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0Esa0JBQWtCLG9FQUFZO0FBQzlCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTLHFFQUFhO0FBQ3RCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx3Q0FBd0Msc0JBQXNCO0FBQzlEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7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O0FBQ0E7QUFDQTtBQUNBLEdBQUc7O0FBRUg7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7QUFDQSxlQUFlLGtEQUFRO0FBQ3ZCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMkJBQTJCLGtEQUFRO0FBQ25DO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7O0FBRW13QiIsInNvdXJjZXMiOlsid2VicGFjazovL2ludm9pY2UtYXBwLy4vbm9kZV9tb2R1bGVzL3JlYWN0LWRhdGVwaWNrZXIvbm9kZV9tb2R1bGVzL0BmbG9hdGluZy11aS9yZWFjdC9kaXN0L2Zsb2F0aW5nLXVpLnJlYWN0LnV0aWxzLm1qcz8wMDYwIl0sInNvdXJjZXNDb250ZW50IjpbImltcG9ydCB7IGlzU2hhZG93Um9vdCwgaXNIVE1MRWxlbWVudCB9IGZyb20gJ0BmbG9hdGluZy11aS91dGlscy9kb20nO1xuaW1wb3J0ICogYXMgUmVhY3QgZnJvbSAncmVhY3QnO1xuaW1wb3J0IHsgdXNlTGF5b3V0RWZmZWN0IH0gZnJvbSAncmVhY3QnO1xuaW1wb3J0IHsgZmxvb3IgfSBmcm9tICdAZmxvYXRpbmctdWkvdXRpbHMnO1xuaW1wb3J0IHsgdGFiYmFibGUgfSBmcm9tICd0YWJiYWJsZSc7XG5cbi8vIEF2b2lkIENocm9tZSBEZXZUb29scyBibHVlIHdhcm5pbmcuXG5mdW5jdGlvbiBnZXRQbGF0Zm9ybSgpIHtcbiAgY29uc3QgdWFEYXRhID0gbmF2aWdhdG9yLnVzZXJBZ2VudERhdGE7XG4gIGlmICh1YURhdGEgIT0gbnVsbCAmJiB1YURhdGEucGxhdGZvcm0pIHtcbiAgICByZXR1cm4gdWFEYXRhLnBsYXRmb3JtO1xuICB9XG4gIHJldHVybiBuYXZpZ2F0b3IucGxhdGZvcm07XG59XG5mdW5jdGlvbiBnZXRVc2VyQWdlbnQoKSB7XG4gIGNvbnN0IHVhRGF0YSA9IG5hdmlnYXRvci51c2VyQWdlbnREYXRhO1xuICBpZiAodWFEYXRhICYmIEFycmF5LmlzQXJyYXkodWFEYXRhLmJyYW5kcykpIHtcbiAgICByZXR1cm4gdWFEYXRhLmJyYW5kcy5tYXAoX3JlZiA9PiB7XG4gICAgICBsZXQge1xuICAgICAgICBicmFuZCxcbiAgICAgICAgdmVyc2lvblxuICAgICAgfSA9IF9yZWY7XG4gICAgICByZXR1cm4gYnJhbmQgKyBcIi9cIiArIHZlcnNpb247XG4gICAgfSkuam9pbignICcpO1xuICB9XG4gIHJldHVybiBuYXZpZ2F0b3IudXNlckFnZW50O1xufVxuZnVuY3Rpb24gaXNTYWZhcmkoKSB7XG4gIC8vIENocm9tZSBEZXZUb29scyBkb2VzIG5vdCBjb21wbGFpbiBhYm91dCBuYXZpZ2F0b3IudmVuZG9yXG4gIHJldHVybiAvYXBwbGUvaS50ZXN0KG5hdmlnYXRvci52ZW5kb3IpO1xufVxuZnVuY3Rpb24gaXNBbmRyb2lkKCkge1xuICBjb25zdCByZSA9IC9hbmRyb2lkL2k7XG4gIHJldHVybiByZS50ZXN0KGdldFBsYXRmb3JtKCkpIHx8IHJlLnRlc3QoZ2V0VXNlckFnZW50KCkpO1xufVxuZnVuY3Rpb24gaXNNYWMoKSB7XG4gIHJldHVybiBnZXRQbGF0Zm9ybSgpLnRvTG93ZXJDYXNlKCkuc3RhcnRzV2l0aCgnbWFjJykgJiYgIW5hdmlnYXRvci5tYXhUb3VjaFBvaW50cztcbn1cbmZ1bmN0aW9uIGlzSlNET00oKSB7XG4gIHJldHVybiBnZXRVc2VyQWdlbnQoKS5pbmNsdWRlcygnanNkb20vJyk7XG59XG5cbmNvbnN0IEZPQ1VTQUJMRV9BVFRSSUJVVEUgPSAnZGF0YS1mbG9hdGluZy11aS1mb2N1c2FibGUnO1xuY29uc3QgVFlQRUFCTEVfU0VMRUNUT1IgPSBcImlucHV0Om5vdChbdHlwZT0naGlkZGVuJ10pOm5vdChbZGlzYWJsZWRdKSxcIiArIFwiW2NvbnRlbnRlZGl0YWJsZV06bm90KFtjb250ZW50ZWRpdGFibGU9J2ZhbHNlJ10pLHRleHRhcmVhOm5vdChbZGlzYWJsZWRdKVwiO1xuY29uc3QgQVJST1dfTEVGVCA9ICdBcnJvd0xlZnQnO1xuY29uc3QgQVJST1dfUklHSFQgPSAnQXJyb3dSaWdodCc7XG5jb25zdCBBUlJPV19VUCA9ICdBcnJvd1VwJztcbmNvbnN0IEFSUk9XX0RPV04gPSAnQXJyb3dEb3duJztcblxuZnVuY3Rpb24gYWN0aXZlRWxlbWVudChkb2MpIHtcbiAgbGV0IGFjdGl2ZUVsZW1lbnQgPSBkb2MuYWN0aXZlRWxlbWVudDtcbiAgd2hpbGUgKCgoX2FjdGl2ZUVsZW1lbnQgPSBhY3RpdmVFbGVtZW50KSA9PSBudWxsIHx8IChfYWN0aXZlRWxlbWVudCA9IF9hY3RpdmVFbGVtZW50LnNoYWRvd1Jvb3QpID09IG51bGwgPyB2b2lkIDAgOiBfYWN0aXZlRWxlbWVudC5hY3RpdmVFbGVtZW50KSAhPSBudWxsKSB7XG4gICAgdmFyIF9hY3RpdmVFbGVtZW50O1xuICAgIGFjdGl2ZUVsZW1lbnQgPSBhY3RpdmVFbGVtZW50LnNoYWRvd1Jvb3QuYWN0aXZlRWxlbWVudDtcbiAgfVxuICByZXR1cm4gYWN0aXZlRWxlbWVudDtcbn1cbmZ1bmN0aW9uIGNvbnRhaW5zKHBhcmVudCwgY2hpbGQpIHtcbiAgaWYgKCFwYXJlbnQgfHwgIWNoaWxkKSB7XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG4gIGNvbnN0IHJvb3ROb2RlID0gY2hpbGQuZ2V0Um9vdE5vZGUgPT0gbnVsbCA/IHZvaWQgMCA6IGNoaWxkLmdldFJvb3ROb2RlKCk7XG5cbiAgLy8gRmlyc3QsIGF0dGVtcHQgd2l0aCBmYXN0ZXIgbmF0aXZlIG1ldGhvZFxuICBpZiAocGFyZW50LmNvbnRhaW5zKGNoaWxkKSkge1xuICAgIHJldHVybiB0cnVlO1xuICB9XG5cbiAgLy8gdGhlbiBmYWxsYmFjayB0byBjdXN0b20gaW1wbGVtZW50YXRpb24gd2l0aCBTaGFkb3cgRE9NIHN1cHBvcnRcbiAgaWYgKHJvb3ROb2RlICYmIGlzU2hhZG93Um9vdChyb290Tm9kZSkpIHtcbiAgICBsZXQgbmV4dCA9IGNoaWxkO1xuICAgIHdoaWxlIChuZXh0KSB7XG4gICAgICBpZiAocGFyZW50ID09PSBuZXh0KSB7XG4gICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgfVxuICAgICAgLy8gQHRzLWlnbm9yZVxuICAgICAgbmV4dCA9IG5leHQucGFyZW50Tm9kZSB8fCBuZXh0Lmhvc3Q7XG4gICAgfVxuICB9XG5cbiAgLy8gR2l2ZSB1cCwgdGhlIHJlc3VsdCBpcyBmYWxzZVxuICByZXR1cm4gZmFsc2U7XG59XG5mdW5jdGlvbiBnZXRUYXJnZXQoZXZlbnQpIHtcbiAgaWYgKCdjb21wb3NlZFBhdGgnIGluIGV2ZW50KSB7XG4gICAgcmV0dXJuIGV2ZW50LmNvbXBvc2VkUGF0aCgpWzBdO1xuICB9XG5cbiAgLy8gVFMgdGhpbmtzIGBldmVudGAgaXMgb2YgdHlwZSBuZXZlciBhcyBpdCBhc3N1bWVzIGFsbCBicm93c2VycyBzdXBwb3J0XG4gIC8vIGBjb21wb3NlZFBhdGgoKWAsIGJ1dCBicm93c2VycyB3aXRob3V0IHNoYWRvdyBET00gZG9uJ3QuXG4gIHJldHVybiBldmVudC50YXJnZXQ7XG59XG5mdW5jdGlvbiBpc0V2ZW50VGFyZ2V0V2l0aGluKGV2ZW50LCBub2RlKSB7XG4gIGlmIChub2RlID09IG51bGwpIHtcbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cbiAgaWYgKCdjb21wb3NlZFBhdGgnIGluIGV2ZW50KSB7XG4gICAgcmV0dXJuIGV2ZW50LmNvbXBvc2VkUGF0aCgpLmluY2x1ZGVzKG5vZGUpO1xuICB9XG5cbiAgLy8gVFMgdGhpbmtzIGBldmVudGAgaXMgb2YgdHlwZSBuZXZlciBhcyBpdCBhc3N1bWVzIGFsbCBicm93c2VycyBzdXBwb3J0IGNvbXBvc2VkUGF0aCwgYnV0IGJyb3dzZXJzIHdpdGhvdXQgc2hhZG93IGRvbSBkb24ndFxuICBjb25zdCBlID0gZXZlbnQ7XG4gIHJldHVybiBlLnRhcmdldCAhPSBudWxsICYmIG5vZGUuY29udGFpbnMoZS50YXJnZXQpO1xufVxuZnVuY3Rpb24gaXNSb290RWxlbWVudChlbGVtZW50KSB7XG4gIHJldHVybiBlbGVtZW50Lm1hdGNoZXMoJ2h0bWwsYm9keScpO1xufVxuZnVuY3Rpb24gZ2V0RG9jdW1lbnQobm9kZSkge1xuICByZXR1cm4gKG5vZGUgPT0gbnVsbCA/IHZvaWQgMCA6IG5vZGUub3duZXJEb2N1bWVudCkgfHwgZG9jdW1lbnQ7XG59XG5mdW5jdGlvbiBpc1R5cGVhYmxlRWxlbWVudChlbGVtZW50KSB7XG4gIHJldHVybiBpc0hUTUxFbGVtZW50KGVsZW1lbnQpICYmIGVsZW1lbnQubWF0Y2hlcyhUWVBFQUJMRV9TRUxFQ1RPUik7XG59XG5mdW5jdGlvbiBpc1R5cGVhYmxlQ29tYm9ib3goZWxlbWVudCkge1xuICBpZiAoIWVsZW1lbnQpIHJldHVybiBmYWxzZTtcbiAgcmV0dXJuIGVsZW1lbnQuZ2V0QXR0cmlidXRlKCdyb2xlJykgPT09ICdjb21ib2JveCcgJiYgaXNUeXBlYWJsZUVsZW1lbnQoZWxlbWVudCk7XG59XG5mdW5jdGlvbiBtYXRjaGVzRm9jdXNWaXNpYmxlKGVsZW1lbnQpIHtcbiAgLy8gV2UgZG9uJ3Qgd2FudCB0byBibG9jayBmb2N1cyBmcm9tIHdvcmtpbmcgd2l0aCBgdmlzaWJsZU9ubHlgXG4gIC8vIChKU0RPTSBkb2Vzbid0IG1hdGNoIGA6Zm9jdXMtdmlzaWJsZWAgd2hlbiB0aGUgZWxlbWVudCBoYXMgYDpmb2N1c2ApXG4gIGlmICghZWxlbWVudCB8fCBpc0pTRE9NKCkpIHJldHVybiB0cnVlO1xuICB0cnkge1xuICAgIHJldHVybiBlbGVtZW50Lm1hdGNoZXMoJzpmb2N1cy12aXNpYmxlJyk7XG4gIH0gY2F0Y2ggKF9lKSB7XG4gICAgcmV0dXJuIHRydWU7XG4gIH1cbn1cbmZ1bmN0aW9uIGdldEZsb2F0aW5nRm9jdXNFbGVtZW50KGZsb2F0aW5nRWxlbWVudCkge1xuICBpZiAoIWZsb2F0aW5nRWxlbWVudCkge1xuICAgIHJldHVybiBudWxsO1xuICB9XG4gIC8vIFRyeSB0byBmaW5kIHRoZSBlbGVtZW50IHRoYXQgaGFzIGB7Li4uZ2V0RmxvYXRpbmdQcm9wcygpfWAgc3ByZWFkIG9uIGl0LlxuICAvLyBUaGlzIGluZGljYXRlcyB0aGUgZmxvYXRpbmcgZWxlbWVudCBpcyBhY3RpbmcgYXMgYSBwb3NpdGlvbmluZyB3cmFwcGVyLCBhbmRcbiAgLy8gc28gZm9jdXMgc2hvdWxkIGJlIG1hbmFnZWQgb24gdGhlIGNoaWxkIGVsZW1lbnQgd2l0aCB0aGUgZXZlbnQgaGFuZGxlcnMgYW5kXG4gIC8vIGFyaWEgcHJvcHMuXG4gIHJldHVybiBmbG9hdGluZ0VsZW1lbnQuaGFzQXR0cmlidXRlKEZPQ1VTQUJMRV9BVFRSSUJVVEUpID8gZmxvYXRpbmdFbGVtZW50IDogZmxvYXRpbmdFbGVtZW50LnF1ZXJ5U2VsZWN0b3IoXCJbXCIgKyBGT0NVU0FCTEVfQVRUUklCVVRFICsgXCJdXCIpIHx8IGZsb2F0aW5nRWxlbWVudDtcbn1cblxuZnVuY3Rpb24gZ2V0Tm9kZUNoaWxkcmVuKG5vZGVzLCBpZCwgb25seU9wZW5DaGlsZHJlbikge1xuICBpZiAob25seU9wZW5DaGlsZHJlbiA9PT0gdm9pZCAwKSB7XG4gICAgb25seU9wZW5DaGlsZHJlbiA9IHRydWU7XG4gIH1cbiAgY29uc3QgZGlyZWN0Q2hpbGRyZW4gPSBub2Rlcy5maWx0ZXIobm9kZSA9PiB7XG4gICAgdmFyIF9ub2RlJGNvbnRleHQ7XG4gICAgcmV0dXJuIG5vZGUucGFyZW50SWQgPT09IGlkICYmICghb25seU9wZW5DaGlsZHJlbiB8fCAoKF9ub2RlJGNvbnRleHQgPSBub2RlLmNvbnRleHQpID09IG51bGwgPyB2b2lkIDAgOiBfbm9kZSRjb250ZXh0Lm9wZW4pKTtcbiAgfSk7XG4gIHJldHVybiBkaXJlY3RDaGlsZHJlbi5mbGF0TWFwKGNoaWxkID0+IFtjaGlsZCwgLi4uZ2V0Tm9kZUNoaWxkcmVuKG5vZGVzLCBjaGlsZC5pZCwgb25seU9wZW5DaGlsZHJlbildKTtcbn1cbmZ1bmN0aW9uIGdldERlZXBlc3ROb2RlKG5vZGVzLCBpZCkge1xuICBsZXQgZGVlcGVzdE5vZGVJZDtcbiAgbGV0IG1heERlcHRoID0gLTE7XG4gIGZ1bmN0aW9uIGZpbmREZWVwZXN0KG5vZGVJZCwgZGVwdGgpIHtcbiAgICBpZiAoZGVwdGggPiBtYXhEZXB0aCkge1xuICAgICAgZGVlcGVzdE5vZGVJZCA9IG5vZGVJZDtcbiAgICAgIG1heERlcHRoID0gZGVwdGg7XG4gICAgfVxuICAgIGNvbnN0IGNoaWxkcmVuID0gZ2V0Tm9kZUNoaWxkcmVuKG5vZGVzLCBub2RlSWQpO1xuICAgIGNoaWxkcmVuLmZvckVhY2goY2hpbGQgPT4ge1xuICAgICAgZmluZERlZXBlc3QoY2hpbGQuaWQsIGRlcHRoICsgMSk7XG4gICAgfSk7XG4gIH1cbiAgZmluZERlZXBlc3QoaWQsIDApO1xuICByZXR1cm4gbm9kZXMuZmluZChub2RlID0+IG5vZGUuaWQgPT09IGRlZXBlc3ROb2RlSWQpO1xufVxuZnVuY3Rpb24gZ2V0Tm9kZUFuY2VzdG9ycyhub2RlcywgaWQpIHtcbiAgdmFyIF9ub2RlcyRmaW5kO1xuICBsZXQgYWxsQW5jZXN0b3JzID0gW107XG4gIGxldCBjdXJyZW50UGFyZW50SWQgPSAoX25vZGVzJGZpbmQgPSBub2Rlcy5maW5kKG5vZGUgPT4gbm9kZS5pZCA9PT0gaWQpKSA9PSBudWxsID8gdm9pZCAwIDogX25vZGVzJGZpbmQucGFyZW50SWQ7XG4gIHdoaWxlIChjdXJyZW50UGFyZW50SWQpIHtcbiAgICBjb25zdCBjdXJyZW50Tm9kZSA9IG5vZGVzLmZpbmQobm9kZSA9PiBub2RlLmlkID09PSBjdXJyZW50UGFyZW50SWQpO1xuICAgIGN1cnJlbnRQYXJlbnRJZCA9IGN1cnJlbnROb2RlID09IG51bGwgPyB2b2lkIDAgOiBjdXJyZW50Tm9kZS5wYXJlbnRJZDtcbiAgICBpZiAoY3VycmVudE5vZGUpIHtcbiAgICAgIGFsbEFuY2VzdG9ycyA9IGFsbEFuY2VzdG9ycy5jb25jYXQoY3VycmVudE5vZGUpO1xuICAgIH1cbiAgfVxuICByZXR1cm4gYWxsQW5jZXN0b3JzO1xufVxuXG5mdW5jdGlvbiBzdG9wRXZlbnQoZXZlbnQpIHtcbiAgZXZlbnQucHJldmVudERlZmF1bHQoKTtcbiAgZXZlbnQuc3RvcFByb3BhZ2F0aW9uKCk7XG59XG5mdW5jdGlvbiBpc1JlYWN0RXZlbnQoZXZlbnQpIHtcbiAgcmV0dXJuICduYXRpdmVFdmVudCcgaW4gZXZlbnQ7XG59XG5cbi8vIExpY2Vuc2U6IGh0dHBzOi8vZ2l0aHViLmNvbS9hZG9iZS9yZWFjdC1zcGVjdHJ1bS9ibG9iL2IzNWQ1YzAyZmU5MDBiYWRjY2QwY2YxYThmMjNiYjU5MzQxOWYyMzgvcGFja2FnZXMvQHJlYWN0LWFyaWEvdXRpbHMvc3JjL2lzVmlydHVhbEV2ZW50LnRzXG5mdW5jdGlvbiBpc1ZpcnR1YWxDbGljayhldmVudCkge1xuICAvLyBGSVhNRTogRmlyZWZveCBpcyBub3cgZW1pdHRpbmcgYSBkZXByZWNhdGlvbiB3YXJuaW5nIGZvciBgbW96SW5wdXRTb3VyY2VgLlxuICAvLyBUcnkgdG8gZmluZCBhIHdvcmthcm91bmQgZm9yIHRoaXMuIGByZWFjdC1hcmlhYCBzb3VyY2Ugc3RpbGwgaGFzIHRoZSBjaGVjay5cbiAgaWYgKGV2ZW50Lm1veklucHV0U291cmNlID09PSAwICYmIGV2ZW50LmlzVHJ1c3RlZCkge1xuICAgIHJldHVybiB0cnVlO1xuICB9XG4gIGlmIChpc0FuZHJvaWQoKSAmJiBldmVudC5wb2ludGVyVHlwZSkge1xuICAgIHJldHVybiBldmVudC50eXBlID09PSAnY2xpY2snICYmIGV2ZW50LmJ1dHRvbnMgPT09IDE7XG4gIH1cbiAgcmV0dXJuIGV2ZW50LmRldGFpbCA9PT0gMCAmJiAhZXZlbnQucG9pbnRlclR5cGU7XG59XG5mdW5jdGlvbiBpc1ZpcnR1YWxQb2ludGVyRXZlbnQoZXZlbnQpIHtcbiAgaWYgKGlzSlNET00oKSkgcmV0dXJuIGZhbHNlO1xuICByZXR1cm4gIWlzQW5kcm9pZCgpICYmIGV2ZW50LndpZHRoID09PSAwICYmIGV2ZW50LmhlaWdodCA9PT0gMCB8fCBpc0FuZHJvaWQoKSAmJiBldmVudC53aWR0aCA9PT0gMSAmJiBldmVudC5oZWlnaHQgPT09IDEgJiYgZXZlbnQucHJlc3N1cmUgPT09IDAgJiYgZXZlbnQuZGV0YWlsID09PSAwICYmIGV2ZW50LnBvaW50ZXJUeXBlID09PSAnbW91c2UnIHx8XG4gIC8vIGlPUyBWb2ljZU92ZXIgcmV0dXJucyAwLjMzM+KAoiBmb3Igd2lkdGgvaGVpZ2h0LlxuICBldmVudC53aWR0aCA8IDEgJiYgZXZlbnQuaGVpZ2h0IDwgMSAmJiBldmVudC5wcmVzc3VyZSA9PT0gMCAmJiBldmVudC5kZXRhaWwgPT09IDAgJiYgZXZlbnQucG9pbnRlclR5cGUgPT09ICd0b3VjaCc7XG59XG5mdW5jdGlvbiBpc01vdXNlTGlrZVBvaW50ZXJUeXBlKHBvaW50ZXJUeXBlLCBzdHJpY3QpIHtcbiAgLy8gT24gc29tZSBMaW51eCBtYWNoaW5lcyB3aXRoIENocm9taXVtLCBtb3VzZSBpbnB1dHMgcmV0dXJuIGEgYHBvaW50ZXJUeXBlYFxuICAvLyBvZiBcInBlblwiOiBodHRwczovL2dpdGh1Yi5jb20vZmxvYXRpbmctdWkvZmxvYXRpbmctdWkvaXNzdWVzLzIwMTVcbiAgY29uc3QgdmFsdWVzID0gWydtb3VzZScsICdwZW4nXTtcbiAgaWYgKCFzdHJpY3QpIHtcbiAgICB2YWx1ZXMucHVzaCgnJywgdW5kZWZpbmVkKTtcbiAgfVxuICByZXR1cm4gdmFsdWVzLmluY2x1ZGVzKHBvaW50ZXJUeXBlKTtcbn1cblxudmFyIGlzQ2xpZW50ID0gdHlwZW9mIGRvY3VtZW50ICE9PSAndW5kZWZpbmVkJztcblxudmFyIG5vb3AgPSBmdW5jdGlvbiBub29wKCkge307XG52YXIgaW5kZXggPSBpc0NsaWVudCA/IHVzZUxheW91dEVmZmVjdCA6IG5vb3A7XG5cbi8vIGh0dHBzOi8vZ2l0aHViLmNvbS9tdWkvbWF0ZXJpYWwtdWkvaXNzdWVzLzQxMTkwI2lzc3VlY29tbWVudC0yMDQwODczMzc5XG5jb25zdCBTYWZlUmVhY3QgPSB7XG4gIC4uLlJlYWN0XG59O1xuXG5mdW5jdGlvbiB1c2VMYXRlc3RSZWYodmFsdWUpIHtcbiAgY29uc3QgcmVmID0gUmVhY3QudXNlUmVmKHZhbHVlKTtcbiAgaW5kZXgoKCkgPT4ge1xuICAgIHJlZi5jdXJyZW50ID0gdmFsdWU7XG4gIH0pO1xuICByZXR1cm4gcmVmO1xufVxuY29uc3QgdXNlSW5zZXJ0aW9uRWZmZWN0ID0gU2FmZVJlYWN0LnVzZUluc2VydGlvbkVmZmVjdDtcbmNvbnN0IHVzZVNhZmVJbnNlcnRpb25FZmZlY3QgPSB1c2VJbnNlcnRpb25FZmZlY3QgfHwgKGZuID0+IGZuKCkpO1xuZnVuY3Rpb24gdXNlRWZmZWN0RXZlbnQoY2FsbGJhY2spIHtcbiAgY29uc3QgcmVmID0gUmVhY3QudXNlUmVmKCgpID0+IHtcbiAgICBpZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09IFwicHJvZHVjdGlvblwiKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoJ0Nhbm5vdCBjYWxsIGFuIGV2ZW50IGhhbmRsZXIgd2hpbGUgcmVuZGVyaW5nLicpO1xuICAgIH1cbiAgfSk7XG4gIHVzZVNhZmVJbnNlcnRpb25FZmZlY3QoKCkgPT4ge1xuICAgIHJlZi5jdXJyZW50ID0gY2FsbGJhY2s7XG4gIH0pO1xuICByZXR1cm4gUmVhY3QudXNlQ2FsbGJhY2soZnVuY3Rpb24gKCkge1xuICAgIGZvciAodmFyIF9sZW4gPSBhcmd1bWVudHMubGVuZ3RoLCBhcmdzID0gbmV3IEFycmF5KF9sZW4pLCBfa2V5ID0gMDsgX2tleSA8IF9sZW47IF9rZXkrKykge1xuICAgICAgYXJnc1tfa2V5XSA9IGFyZ3VtZW50c1tfa2V5XTtcbiAgICB9XG4gICAgcmV0dXJuIHJlZi5jdXJyZW50ID09IG51bGwgPyB2b2lkIDAgOiByZWYuY3VycmVudCguLi5hcmdzKTtcbiAgfSwgW10pO1xufVxuXG5mdW5jdGlvbiBpc0RpZmZlcmVudEdyaWRSb3coaW5kZXgsIGNvbHMsIHByZXZSb3cpIHtcbiAgcmV0dXJuIE1hdGguZmxvb3IoaW5kZXggLyBjb2xzKSAhPT0gcHJldlJvdztcbn1cbmZ1bmN0aW9uIGlzSW5kZXhPdXRPZkxpc3RCb3VuZHMobGlzdFJlZiwgaW5kZXgpIHtcbiAgcmV0dXJuIGluZGV4IDwgMCB8fCBpbmRleCA+PSBsaXN0UmVmLmN1cnJlbnQubGVuZ3RoO1xufVxuZnVuY3Rpb24gZ2V0TWluTGlzdEluZGV4KGxpc3RSZWYsIGRpc2FibGVkSW5kaWNlcykge1xuICByZXR1cm4gZmluZE5vbkRpc2FibGVkTGlzdEluZGV4KGxpc3RSZWYsIHtcbiAgICBkaXNhYmxlZEluZGljZXNcbiAgfSk7XG59XG5mdW5jdGlvbiBnZXRNYXhMaXN0SW5kZXgobGlzdFJlZiwgZGlzYWJsZWRJbmRpY2VzKSB7XG4gIHJldHVybiBmaW5kTm9uRGlzYWJsZWRMaXN0SW5kZXgobGlzdFJlZiwge1xuICAgIGRlY3JlbWVudDogdHJ1ZSxcbiAgICBzdGFydGluZ0luZGV4OiBsaXN0UmVmLmN1cnJlbnQubGVuZ3RoLFxuICAgIGRpc2FibGVkSW5kaWNlc1xuICB9KTtcbn1cbmZ1bmN0aW9uIGZpbmROb25EaXNhYmxlZExpc3RJbmRleChsaXN0UmVmLCBfdGVtcCkge1xuICBsZXQge1xuICAgIHN0YXJ0aW5nSW5kZXggPSAtMSxcbiAgICBkZWNyZW1lbnQgPSBmYWxzZSxcbiAgICBkaXNhYmxlZEluZGljZXMsXG4gICAgYW1vdW50ID0gMVxuICB9ID0gX3RlbXAgPT09IHZvaWQgMCA/IHt9IDogX3RlbXA7XG4gIGxldCBpbmRleCA9IHN0YXJ0aW5nSW5kZXg7XG4gIGRvIHtcbiAgICBpbmRleCArPSBkZWNyZW1lbnQgPyAtYW1vdW50IDogYW1vdW50O1xuICB9IHdoaWxlIChpbmRleCA+PSAwICYmIGluZGV4IDw9IGxpc3RSZWYuY3VycmVudC5sZW5ndGggLSAxICYmIGlzTGlzdEluZGV4RGlzYWJsZWQobGlzdFJlZiwgaW5kZXgsIGRpc2FibGVkSW5kaWNlcykpO1xuICByZXR1cm4gaW5kZXg7XG59XG5mdW5jdGlvbiBnZXRHcmlkTmF2aWdhdGVkSW5kZXgobGlzdFJlZiwgX3JlZikge1xuICBsZXQge1xuICAgIGV2ZW50LFxuICAgIG9yaWVudGF0aW9uLFxuICAgIGxvb3AsXG4gICAgcnRsLFxuICAgIGNvbHMsXG4gICAgZGlzYWJsZWRJbmRpY2VzLFxuICAgIG1pbkluZGV4LFxuICAgIG1heEluZGV4LFxuICAgIHByZXZJbmRleCxcbiAgICBzdG9wRXZlbnQ6IHN0b3AgPSBmYWxzZVxuICB9ID0gX3JlZjtcbiAgbGV0IG5leHRJbmRleCA9IHByZXZJbmRleDtcbiAgaWYgKGV2ZW50LmtleSA9PT0gQVJST1dfVVApIHtcbiAgICBzdG9wICYmIHN0b3BFdmVudChldmVudCk7XG4gICAgaWYgKHByZXZJbmRleCA9PT0gLTEpIHtcbiAgICAgIG5leHRJbmRleCA9IG1heEluZGV4O1xuICAgIH0gZWxzZSB7XG4gICAgICBuZXh0SW5kZXggPSBmaW5kTm9uRGlzYWJsZWRMaXN0SW5kZXgobGlzdFJlZiwge1xuICAgICAgICBzdGFydGluZ0luZGV4OiBuZXh0SW5kZXgsXG4gICAgICAgIGFtb3VudDogY29scyxcbiAgICAgICAgZGVjcmVtZW50OiB0cnVlLFxuICAgICAgICBkaXNhYmxlZEluZGljZXNcbiAgICAgIH0pO1xuICAgICAgaWYgKGxvb3AgJiYgKHByZXZJbmRleCAtIGNvbHMgPCBtaW5JbmRleCB8fCBuZXh0SW5kZXggPCAwKSkge1xuICAgICAgICBjb25zdCBjb2wgPSBwcmV2SW5kZXggJSBjb2xzO1xuICAgICAgICBjb25zdCBtYXhDb2wgPSBtYXhJbmRleCAlIGNvbHM7XG4gICAgICAgIGNvbnN0IG9mZnNldCA9IG1heEluZGV4IC0gKG1heENvbCAtIGNvbCk7XG4gICAgICAgIGlmIChtYXhDb2wgPT09IGNvbCkge1xuICAgICAgICAgIG5leHRJbmRleCA9IG1heEluZGV4O1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIG5leHRJbmRleCA9IG1heENvbCA+IGNvbCA/IG9mZnNldCA6IG9mZnNldCAtIGNvbHM7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG4gICAgaWYgKGlzSW5kZXhPdXRPZkxpc3RCb3VuZHMobGlzdFJlZiwgbmV4dEluZGV4KSkge1xuICAgICAgbmV4dEluZGV4ID0gcHJldkluZGV4O1xuICAgIH1cbiAgfVxuICBpZiAoZXZlbnQua2V5ID09PSBBUlJPV19ET1dOKSB7XG4gICAgc3RvcCAmJiBzdG9wRXZlbnQoZXZlbnQpO1xuICAgIGlmIChwcmV2SW5kZXggPT09IC0xKSB7XG4gICAgICBuZXh0SW5kZXggPSBtaW5JbmRleDtcbiAgICB9IGVsc2Uge1xuICAgICAgbmV4dEluZGV4ID0gZmluZE5vbkRpc2FibGVkTGlzdEluZGV4KGxpc3RSZWYsIHtcbiAgICAgICAgc3RhcnRpbmdJbmRleDogcHJldkluZGV4LFxuICAgICAgICBhbW91bnQ6IGNvbHMsXG4gICAgICAgIGRpc2FibGVkSW5kaWNlc1xuICAgICAgfSk7XG4gICAgICBpZiAobG9vcCAmJiBwcmV2SW5kZXggKyBjb2xzID4gbWF4SW5kZXgpIHtcbiAgICAgICAgbmV4dEluZGV4ID0gZmluZE5vbkRpc2FibGVkTGlzdEluZGV4KGxpc3RSZWYsIHtcbiAgICAgICAgICBzdGFydGluZ0luZGV4OiBwcmV2SW5kZXggJSBjb2xzIC0gY29scyxcbiAgICAgICAgICBhbW91bnQ6IGNvbHMsXG4gICAgICAgICAgZGlzYWJsZWRJbmRpY2VzXG4gICAgICAgIH0pO1xuICAgICAgfVxuICAgIH1cbiAgICBpZiAoaXNJbmRleE91dE9mTGlzdEJvdW5kcyhsaXN0UmVmLCBuZXh0SW5kZXgpKSB7XG4gICAgICBuZXh0SW5kZXggPSBwcmV2SW5kZXg7XG4gICAgfVxuICB9XG5cbiAgLy8gUmVtYWlucyBvbiB0aGUgc2FtZSByb3cvY29sdW1uLlxuICBpZiAob3JpZW50YXRpb24gPT09ICdib3RoJykge1xuICAgIGNvbnN0IHByZXZSb3cgPSBmbG9vcihwcmV2SW5kZXggLyBjb2xzKTtcbiAgICBpZiAoZXZlbnQua2V5ID09PSAocnRsID8gQVJST1dfTEVGVCA6IEFSUk9XX1JJR0hUKSkge1xuICAgICAgc3RvcCAmJiBzdG9wRXZlbnQoZXZlbnQpO1xuICAgICAgaWYgKHByZXZJbmRleCAlIGNvbHMgIT09IGNvbHMgLSAxKSB7XG4gICAgICAgIG5leHRJbmRleCA9IGZpbmROb25EaXNhYmxlZExpc3RJbmRleChsaXN0UmVmLCB7XG4gICAgICAgICAgc3RhcnRpbmdJbmRleDogcHJldkluZGV4LFxuICAgICAgICAgIGRpc2FibGVkSW5kaWNlc1xuICAgICAgICB9KTtcbiAgICAgICAgaWYgKGxvb3AgJiYgaXNEaWZmZXJlbnRHcmlkUm93KG5leHRJbmRleCwgY29scywgcHJldlJvdykpIHtcbiAgICAgICAgICBuZXh0SW5kZXggPSBmaW5kTm9uRGlzYWJsZWRMaXN0SW5kZXgobGlzdFJlZiwge1xuICAgICAgICAgICAgc3RhcnRpbmdJbmRleDogcHJldkluZGV4IC0gcHJldkluZGV4ICUgY29scyAtIDEsXG4gICAgICAgICAgICBkaXNhYmxlZEluZGljZXNcbiAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgICAgfSBlbHNlIGlmIChsb29wKSB7XG4gICAgICAgIG5leHRJbmRleCA9IGZpbmROb25EaXNhYmxlZExpc3RJbmRleChsaXN0UmVmLCB7XG4gICAgICAgICAgc3RhcnRpbmdJbmRleDogcHJldkluZGV4IC0gcHJldkluZGV4ICUgY29scyAtIDEsXG4gICAgICAgICAgZGlzYWJsZWRJbmRpY2VzXG4gICAgICAgIH0pO1xuICAgICAgfVxuICAgICAgaWYgKGlzRGlmZmVyZW50R3JpZFJvdyhuZXh0SW5kZXgsIGNvbHMsIHByZXZSb3cpKSB7XG4gICAgICAgIG5leHRJbmRleCA9IHByZXZJbmRleDtcbiAgICAgIH1cbiAgICB9XG4gICAgaWYgKGV2ZW50LmtleSA9PT0gKHJ0bCA/IEFSUk9XX1JJR0hUIDogQVJST1dfTEVGVCkpIHtcbiAgICAgIHN0b3AgJiYgc3RvcEV2ZW50KGV2ZW50KTtcbiAgICAgIGlmIChwcmV2SW5kZXggJSBjb2xzICE9PSAwKSB7XG4gICAgICAgIG5leHRJbmRleCA9IGZpbmROb25EaXNhYmxlZExpc3RJbmRleChsaXN0UmVmLCB7XG4gICAgICAgICAgc3RhcnRpbmdJbmRleDogcHJldkluZGV4LFxuICAgICAgICAgIGRlY3JlbWVudDogdHJ1ZSxcbiAgICAgICAgICBkaXNhYmxlZEluZGljZXNcbiAgICAgICAgfSk7XG4gICAgICAgIGlmIChsb29wICYmIGlzRGlmZmVyZW50R3JpZFJvdyhuZXh0SW5kZXgsIGNvbHMsIHByZXZSb3cpKSB7XG4gICAgICAgICAgbmV4dEluZGV4ID0gZmluZE5vbkRpc2FibGVkTGlzdEluZGV4KGxpc3RSZWYsIHtcbiAgICAgICAgICAgIHN0YXJ0aW5nSW5kZXg6IHByZXZJbmRleCArIChjb2xzIC0gcHJldkluZGV4ICUgY29scyksXG4gICAgICAgICAgICBkZWNyZW1lbnQ6IHRydWUsXG4gICAgICAgICAgICBkaXNhYmxlZEluZGljZXNcbiAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgICAgfSBlbHNlIGlmIChsb29wKSB7XG4gICAgICAgIG5leHRJbmRleCA9IGZpbmROb25EaXNhYmxlZExpc3RJbmRleChsaXN0UmVmLCB7XG4gICAgICAgICAgc3RhcnRpbmdJbmRleDogcHJldkluZGV4ICsgKGNvbHMgLSBwcmV2SW5kZXggJSBjb2xzKSxcbiAgICAgICAgICBkZWNyZW1lbnQ6IHRydWUsXG4gICAgICAgICAgZGlzYWJsZWRJbmRpY2VzXG4gICAgICAgIH0pO1xuICAgICAgfVxuICAgICAgaWYgKGlzRGlmZmVyZW50R3JpZFJvdyhuZXh0SW5kZXgsIGNvbHMsIHByZXZSb3cpKSB7XG4gICAgICAgIG5leHRJbmRleCA9IHByZXZJbmRleDtcbiAgICAgIH1cbiAgICB9XG4gICAgY29uc3QgbGFzdFJvdyA9IGZsb29yKG1heEluZGV4IC8gY29scykgPT09IHByZXZSb3c7XG4gICAgaWYgKGlzSW5kZXhPdXRPZkxpc3RCb3VuZHMobGlzdFJlZiwgbmV4dEluZGV4KSkge1xuICAgICAgaWYgKGxvb3AgJiYgbGFzdFJvdykge1xuICAgICAgICBuZXh0SW5kZXggPSBldmVudC5rZXkgPT09IChydGwgPyBBUlJPV19SSUdIVCA6IEFSUk9XX0xFRlQpID8gbWF4SW5kZXggOiBmaW5kTm9uRGlzYWJsZWRMaXN0SW5kZXgobGlzdFJlZiwge1xuICAgICAgICAgIHN0YXJ0aW5nSW5kZXg6IHByZXZJbmRleCAtIHByZXZJbmRleCAlIGNvbHMgLSAxLFxuICAgICAgICAgIGRpc2FibGVkSW5kaWNlc1xuICAgICAgICB9KTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIG5leHRJbmRleCA9IHByZXZJbmRleDtcbiAgICAgIH1cbiAgICB9XG4gIH1cbiAgcmV0dXJuIG5leHRJbmRleDtcbn1cblxuLyoqIEZvciBlYWNoIGNlbGwgaW5kZXgsIGdldHMgdGhlIGl0ZW0gaW5kZXggdGhhdCBvY2N1cGllcyB0aGF0IGNlbGwgKi9cbmZ1bmN0aW9uIGNyZWF0ZUdyaWRDZWxsTWFwKHNpemVzLCBjb2xzLCBkZW5zZSkge1xuICBjb25zdCBjZWxsTWFwID0gW107XG4gIGxldCBzdGFydEluZGV4ID0gMDtcbiAgc2l6ZXMuZm9yRWFjaCgoX3JlZjIsIGluZGV4KSA9PiB7XG4gICAgbGV0IHtcbiAgICAgIHdpZHRoLFxuICAgICAgaGVpZ2h0XG4gICAgfSA9IF9yZWYyO1xuICAgIGlmICh3aWR0aCA+IGNvbHMpIHtcbiAgICAgIGlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gXCJwcm9kdWN0aW9uXCIpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiW0Zsb2F0aW5nIFVJXTogSW52YWxpZCBncmlkIC0gaXRlbSB3aWR0aCBhdCBpbmRleCBcIiArIGluZGV4ICsgXCIgaXMgZ3JlYXRlciB0aGFuIGdyaWQgY29sdW1uc1wiKTtcbiAgICAgIH1cbiAgICB9XG4gICAgbGV0IGl0ZW1QbGFjZWQgPSBmYWxzZTtcbiAgICBpZiAoZGVuc2UpIHtcbiAgICAgIHN0YXJ0SW5kZXggPSAwO1xuICAgIH1cbiAgICB3aGlsZSAoIWl0ZW1QbGFjZWQpIHtcbiAgICAgIGNvbnN0IHRhcmdldENlbGxzID0gW107XG4gICAgICBmb3IgKGxldCBpID0gMDsgaSA8IHdpZHRoOyBpKyspIHtcbiAgICAgICAgZm9yIChsZXQgaiA9IDA7IGogPCBoZWlnaHQ7IGorKykge1xuICAgICAgICAgIHRhcmdldENlbGxzLnB1c2goc3RhcnRJbmRleCArIGkgKyBqICogY29scyk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIGlmIChzdGFydEluZGV4ICUgY29scyArIHdpZHRoIDw9IGNvbHMgJiYgdGFyZ2V0Q2VsbHMuZXZlcnkoY2VsbCA9PiBjZWxsTWFwW2NlbGxdID09IG51bGwpKSB7XG4gICAgICAgIHRhcmdldENlbGxzLmZvckVhY2goY2VsbCA9PiB7XG4gICAgICAgICAgY2VsbE1hcFtjZWxsXSA9IGluZGV4O1xuICAgICAgICB9KTtcbiAgICAgICAgaXRlbVBsYWNlZCA9IHRydWU7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBzdGFydEluZGV4Kys7XG4gICAgICB9XG4gICAgfVxuICB9KTtcblxuICAvLyBjb252ZXJ0IGludG8gYSBub24tc3BhcnNlIGFycmF5XG4gIHJldHVybiBbLi4uY2VsbE1hcF07XG59XG5cbi8qKiBHZXRzIGNlbGwgaW5kZXggb2YgYW4gaXRlbSdzIGNvcm5lciBvciAtMSB3aGVuIGluZGV4IGlzIC0xLiAqL1xuZnVuY3Rpb24gZ2V0R3JpZENlbGxJbmRleE9mQ29ybmVyKGluZGV4LCBzaXplcywgY2VsbE1hcCwgY29scywgY29ybmVyKSB7XG4gIGlmIChpbmRleCA9PT0gLTEpIHJldHVybiAtMTtcbiAgY29uc3QgZmlyc3RDZWxsSW5kZXggPSBjZWxsTWFwLmluZGV4T2YoaW5kZXgpO1xuICBjb25zdCBzaXplSXRlbSA9IHNpemVzW2luZGV4XTtcbiAgc3dpdGNoIChjb3JuZXIpIHtcbiAgICBjYXNlICd0bCc6XG4gICAgICByZXR1cm4gZmlyc3RDZWxsSW5kZXg7XG4gICAgY2FzZSAndHInOlxuICAgICAgaWYgKCFzaXplSXRlbSkge1xuICAgICAgICByZXR1cm4gZmlyc3RDZWxsSW5kZXg7XG4gICAgICB9XG4gICAgICByZXR1cm4gZmlyc3RDZWxsSW5kZXggKyBzaXplSXRlbS53aWR0aCAtIDE7XG4gICAgY2FzZSAnYmwnOlxuICAgICAgaWYgKCFzaXplSXRlbSkge1xuICAgICAgICByZXR1cm4gZmlyc3RDZWxsSW5kZXg7XG4gICAgICB9XG4gICAgICByZXR1cm4gZmlyc3RDZWxsSW5kZXggKyAoc2l6ZUl0ZW0uaGVpZ2h0IC0gMSkgKiBjb2xzO1xuICAgIGNhc2UgJ2JyJzpcbiAgICAgIHJldHVybiBjZWxsTWFwLmxhc3RJbmRleE9mKGluZGV4KTtcbiAgfVxufVxuXG4vKiogR2V0cyBhbGwgY2VsbCBpbmRpY2VzIHRoYXQgY29ycmVzcG9uZCB0byB0aGUgc3BlY2lmaWVkIGluZGljZXMgKi9cbmZ1bmN0aW9uIGdldEdyaWRDZWxsSW5kaWNlcyhpbmRpY2VzLCBjZWxsTWFwKSB7XG4gIHJldHVybiBjZWxsTWFwLmZsYXRNYXAoKGluZGV4LCBjZWxsSW5kZXgpID0+IGluZGljZXMuaW5jbHVkZXMoaW5kZXgpID8gW2NlbGxJbmRleF0gOiBbXSk7XG59XG5mdW5jdGlvbiBpc0xpc3RJbmRleERpc2FibGVkKGxpc3RSZWYsIGluZGV4LCBkaXNhYmxlZEluZGljZXMpIHtcbiAgaWYgKHR5cGVvZiBkaXNhYmxlZEluZGljZXMgPT09ICdmdW5jdGlvbicpIHtcbiAgICByZXR1cm4gZGlzYWJsZWRJbmRpY2VzKGluZGV4KTtcbiAgfSBlbHNlIGlmIChkaXNhYmxlZEluZGljZXMpIHtcbiAgICByZXR1cm4gZGlzYWJsZWRJbmRpY2VzLmluY2x1ZGVzKGluZGV4KTtcbiAgfVxuICBjb25zdCBlbGVtZW50ID0gbGlzdFJlZi5jdXJyZW50W2luZGV4XTtcbiAgcmV0dXJuIGVsZW1lbnQgPT0gbnVsbCB8fCBlbGVtZW50Lmhhc0F0dHJpYnV0ZSgnZGlzYWJsZWQnKSB8fCBlbGVtZW50LmdldEF0dHJpYnV0ZSgnYXJpYS1kaXNhYmxlZCcpID09PSAndHJ1ZSc7XG59XG5cbmNvbnN0IGdldFRhYmJhYmxlT3B0aW9ucyA9ICgpID0+ICh7XG4gIGdldFNoYWRvd1Jvb3Q6IHRydWUsXG4gIGRpc3BsYXlDaGVjazpcbiAgLy8gSlNET00gZG9lcyBub3Qgc3VwcG9ydCB0aGUgYHRhYmJhYmxlYCBsaWJyYXJ5LiBUbyBzb2x2ZSB0aGlzIHdlIGNhblxuICAvLyBjaGVjayBpZiBgUmVzaXplT2JzZXJ2ZXJgIGlzIGEgcmVhbCBmdW5jdGlvbiAobm90IHBvbHlmaWxsZWQpLCB3aGljaFxuICAvLyBkZXRlcm1pbmVzIGlmIHRoZSBjdXJyZW50IGVudmlyb25tZW50IGlzIEpTRE9NLWxpa2UuXG4gIHR5cGVvZiBSZXNpemVPYnNlcnZlciA9PT0gJ2Z1bmN0aW9uJyAmJiBSZXNpemVPYnNlcnZlci50b1N0cmluZygpLmluY2x1ZGVzKCdbbmF0aXZlIGNvZGVdJykgPyAnZnVsbCcgOiAnbm9uZSdcbn0pO1xuZnVuY3Rpb24gZ2V0VGFiYmFibGVJbihjb250YWluZXIsIGRpcikge1xuICBjb25zdCBsaXN0ID0gdGFiYmFibGUoY29udGFpbmVyLCBnZXRUYWJiYWJsZU9wdGlvbnMoKSk7XG4gIGNvbnN0IGxlbiA9IGxpc3QubGVuZ3RoO1xuICBpZiAobGVuID09PSAwKSByZXR1cm47XG4gIGNvbnN0IGFjdGl2ZSA9IGFjdGl2ZUVsZW1lbnQoZ2V0RG9jdW1lbnQoY29udGFpbmVyKSk7XG4gIGNvbnN0IGluZGV4ID0gbGlzdC5pbmRleE9mKGFjdGl2ZSk7XG4gIGNvbnN0IG5leHRJbmRleCA9IGluZGV4ID09PSAtMSA/IGRpciA9PT0gMSA/IDAgOiBsZW4gLSAxIDogaW5kZXggKyBkaXI7XG4gIHJldHVybiBsaXN0W25leHRJbmRleF07XG59XG5mdW5jdGlvbiBnZXROZXh0VGFiYmFibGUocmVmZXJlbmNlRWxlbWVudCkge1xuICByZXR1cm4gZ2V0VGFiYmFibGVJbihnZXREb2N1bWVudChyZWZlcmVuY2VFbGVtZW50KS5ib2R5LCAxKSB8fCByZWZlcmVuY2VFbGVtZW50O1xufVxuZnVuY3Rpb24gZ2V0UHJldmlvdXNUYWJiYWJsZShyZWZlcmVuY2VFbGVtZW50KSB7XG4gIHJldHVybiBnZXRUYWJiYWJsZUluKGdldERvY3VtZW50KHJlZmVyZW5jZUVsZW1lbnQpLmJvZHksIC0xKSB8fCByZWZlcmVuY2VFbGVtZW50O1xufVxuZnVuY3Rpb24gaXNPdXRzaWRlRXZlbnQoZXZlbnQsIGNvbnRhaW5lcikge1xuICBjb25zdCBjb250YWluZXJFbGVtZW50ID0gY29udGFpbmVyIHx8IGV2ZW50LmN1cnJlbnRUYXJnZXQ7XG4gIGNvbnN0IHJlbGF0ZWRUYXJnZXQgPSBldmVudC5yZWxhdGVkVGFyZ2V0O1xuICByZXR1cm4gIXJlbGF0ZWRUYXJnZXQgfHwgIWNvbnRhaW5zKGNvbnRhaW5lckVsZW1lbnQsIHJlbGF0ZWRUYXJnZXQpO1xufVxuZnVuY3Rpb24gZGlzYWJsZUZvY3VzSW5zaWRlKGNvbnRhaW5lcikge1xuICBjb25zdCB0YWJiYWJsZUVsZW1lbnRzID0gdGFiYmFibGUoY29udGFpbmVyLCBnZXRUYWJiYWJsZU9wdGlvbnMoKSk7XG4gIHRhYmJhYmxlRWxlbWVudHMuZm9yRWFjaChlbGVtZW50ID0+IHtcbiAgICBlbGVtZW50LmRhdGFzZXQudGFiaW5kZXggPSBlbGVtZW50LmdldEF0dHJpYnV0ZSgndGFiaW5kZXgnKSB8fCAnJztcbiAgICBlbGVtZW50LnNldEF0dHJpYnV0ZSgndGFiaW5kZXgnLCAnLTEnKTtcbiAgfSk7XG59XG5mdW5jdGlvbiBlbmFibGVGb2N1c0luc2lkZShjb250YWluZXIpIHtcbiAgY29uc3QgZWxlbWVudHMgPSBjb250YWluZXIucXVlcnlTZWxlY3RvckFsbCgnW2RhdGEtdGFiaW5kZXhdJyk7XG4gIGVsZW1lbnRzLmZvckVhY2goZWxlbWVudCA9PiB7XG4gICAgY29uc3QgdGFiaW5kZXggPSBlbGVtZW50LmRhdGFzZXQudGFiaW5kZXg7XG4gICAgZGVsZXRlIGVsZW1lbnQuZGF0YXNldC50YWJpbmRleDtcbiAgICBpZiAodGFiaW5kZXgpIHtcbiAgICAgIGVsZW1lbnQuc2V0QXR0cmlidXRlKCd0YWJpbmRleCcsIHRhYmluZGV4KTtcbiAgICB9IGVsc2Uge1xuICAgICAgZWxlbWVudC5yZW1vdmVBdHRyaWJ1dGUoJ3RhYmluZGV4Jyk7XG4gICAgfVxuICB9KTtcbn1cblxuZXhwb3J0IHsgYWN0aXZlRWxlbWVudCwgY29udGFpbnMsIGNyZWF0ZUdyaWRDZWxsTWFwLCBkaXNhYmxlRm9jdXNJbnNpZGUsIGVuYWJsZUZvY3VzSW5zaWRlLCBmaW5kTm9uRGlzYWJsZWRMaXN0SW5kZXgsIGdldERlZXBlc3ROb2RlLCBnZXREb2N1bWVudCwgZ2V0RmxvYXRpbmdGb2N1c0VsZW1lbnQsIGdldEdyaWRDZWxsSW5kZXhPZkNvcm5lciwgZ2V0R3JpZENlbGxJbmRpY2VzLCBnZXRHcmlkTmF2aWdhdGVkSW5kZXgsIGdldE1heExpc3RJbmRleCwgZ2V0TWluTGlzdEluZGV4LCBnZXROZXh0VGFiYmFibGUsIGdldE5vZGVBbmNlc3RvcnMsIGdldE5vZGVDaGlsZHJlbiwgZ2V0UGxhdGZvcm0sIGdldFByZXZpb3VzVGFiYmFibGUsIGdldFRhYmJhYmxlT3B0aW9ucywgZ2V0VGFyZ2V0LCBnZXRVc2VyQWdlbnQsIGlzQW5kcm9pZCwgaXNEaWZmZXJlbnRHcmlkUm93LCBpc0V2ZW50VGFyZ2V0V2l0aGluLCBpc0luZGV4T3V0T2ZMaXN0Qm91bmRzLCBpc0pTRE9NLCBpc0xpc3RJbmRleERpc2FibGVkLCBpc01hYywgaXNNb3VzZUxpa2VQb2ludGVyVHlwZSwgaXNPdXRzaWRlRXZlbnQsIGlzUmVhY3RFdmVudCwgaXNSb290RWxlbWVudCwgaXNTYWZhcmksIGlzVHlwZWFibGVDb21ib2JveCwgaXNUeXBlYWJsZUVsZW1lbnQsIGlzVmlydHVhbENsaWNrLCBpc1ZpcnR1YWxQb2ludGVyRXZlbnQsIG1hdGNoZXNGb2N1c1Zpc2libGUsIHN0b3BFdmVudCwgdXNlRWZmZWN0RXZlbnQsIHVzZUxhdGVzdFJlZiwgaW5kZXggYXMgdXNlTW9kZXJuTGF5b3V0RWZmZWN0IH07XG4iXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/react-datepicker/node_modules/@floating-ui/react/dist/floating-ui.react.utils.mjs\n");

/***/ }),

/***/ "(ssr)/./node_modules/react-datepicker/node_modules/@floating-ui/react/node_modules/@floating-ui/react-dom/dist/floating-ui.react-dom.mjs":
/*!******************************************************************************************************************************************!*\
  !*** ./node_modules/react-datepicker/node_modules/@floating-ui/react/node_modules/@floating-ui/react-dom/dist/floating-ui.react-dom.mjs ***!
  \******************************************************************************************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   arrow: () => (/* binding */ arrow),\n/* harmony export */   autoPlacement: () => (/* binding */ autoPlacement),\n/* harmony export */   autoUpdate: () => (/* reexport safe */ _floating_ui_dom__WEBPACK_IMPORTED_MODULE_0__.autoUpdate),\n/* harmony export */   computePosition: () => (/* reexport safe */ _floating_ui_dom__WEBPACK_IMPORTED_MODULE_0__.computePosition),\n/* harmony export */   detectOverflow: () => (/* reexport safe */ _floating_ui_dom__WEBPACK_IMPORTED_MODULE_0__.detectOverflow),\n/* harmony export */   flip: () => (/* binding */ flip),\n/* harmony export */   getOverflowAncestors: () => (/* reexport safe */ _floating_ui_dom__WEBPACK_IMPORTED_MODULE_1__.getOverflowAncestors),\n/* harmony export */   hide: () => (/* binding */ hide),\n/* harmony export */   inline: () => (/* binding */ inline),\n/* harmony export */   limitShift: () => (/* binding */ limitShift),\n/* harmony export */   offset: () => (/* binding */ offset),\n/* harmony export */   platform: () => (/* reexport safe */ _floating_ui_dom__WEBPACK_IMPORTED_MODULE_0__.platform),\n/* harmony export */   shift: () => (/* binding */ shift),\n/* harmony export */   size: () => (/* binding */ size),\n/* harmony export */   useFloating: () => (/* binding */ useFloating)\n/* harmony export */ });\n/* harmony import */ var _floating_ui_dom__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @floating-ui/dom */ \"(ssr)/./node_modules/@floating-ui/dom/dist/floating-ui.dom.mjs\");\n/* harmony import */ var _floating_ui_dom__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! @floating-ui/dom */ \"(ssr)/./node_modules/@floating-ui/utils/dist/floating-ui.utils.dom.mjs\");\n/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! react */ \"(ssr)/./node_modules/next/dist/server/future/route-modules/app-page/vendored/ssr/react.js\");\n/* harmony import */ var react_dom__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! react-dom */ \"(ssr)/./node_modules/next/dist/server/future/route-modules/app-page/vendored/ssr/react-dom.js\");\n\n\n\n\n\n\nvar isClient = typeof document !== 'undefined';\n\nvar noop = function noop() {};\nvar index = isClient ? react__WEBPACK_IMPORTED_MODULE_2__.useLayoutEffect : noop;\n\n// Fork of `fast-deep-equal` that only does the comparisons we need and compares\n// functions\nfunction deepEqual(a, b) {\n  if (a === b) {\n    return true;\n  }\n  if (typeof a !== typeof b) {\n    return false;\n  }\n  if (typeof a === 'function' && a.toString() === b.toString()) {\n    return true;\n  }\n  let length;\n  let i;\n  let keys;\n  if (a && b && typeof a === 'object') {\n    if (Array.isArray(a)) {\n      length = a.length;\n      if (length !== b.length) return false;\n      for (i = length; i-- !== 0;) {\n        if (!deepEqual(a[i], b[i])) {\n          return false;\n        }\n      }\n      return true;\n    }\n    keys = Object.keys(a);\n    length = keys.length;\n    if (length !== Object.keys(b).length) {\n      return false;\n    }\n    for (i = length; i-- !== 0;) {\n      if (!{}.hasOwnProperty.call(b, keys[i])) {\n        return false;\n      }\n    }\n    for (i = length; i-- !== 0;) {\n      const key = keys[i];\n      if (key === '_owner' && a.$$typeof) {\n        continue;\n      }\n      if (!deepEqual(a[key], b[key])) {\n        return false;\n      }\n    }\n    return true;\n  }\n  return a !== a && b !== b;\n}\n\nfunction getDPR(element) {\n  if (typeof window === 'undefined') {\n    return 1;\n  }\n  const win = element.ownerDocument.defaultView || window;\n  return win.devicePixelRatio || 1;\n}\n\nfunction roundByDPR(element, value) {\n  const dpr = getDPR(element);\n  return Math.round(value * dpr) / dpr;\n}\n\nfunction useLatestRef(value) {\n  const ref = react__WEBPACK_IMPORTED_MODULE_2__.useRef(value);\n  index(() => {\n    ref.current = value;\n  });\n  return ref;\n}\n\n/**\n * Provides data to position a floating element.\n * @see https://floating-ui.com/docs/useFloating\n */\nfunction useFloating(options) {\n  if (options === void 0) {\n    options = {};\n  }\n  const {\n    placement = 'bottom',\n    strategy = 'absolute',\n    middleware = [],\n    platform,\n    elements: {\n      reference: externalReference,\n      floating: externalFloating\n    } = {},\n    transform = true,\n    whileElementsMounted,\n    open\n  } = options;\n  const [data, setData] = react__WEBPACK_IMPORTED_MODULE_2__.useState({\n    x: 0,\n    y: 0,\n    strategy,\n    placement,\n    middlewareData: {},\n    isPositioned: false\n  });\n  const [latestMiddleware, setLatestMiddleware] = react__WEBPACK_IMPORTED_MODULE_2__.useState(middleware);\n  if (!deepEqual(latestMiddleware, middleware)) {\n    setLatestMiddleware(middleware);\n  }\n  const [_reference, _setReference] = react__WEBPACK_IMPORTED_MODULE_2__.useState(null);\n  const [_floating, _setFloating] = react__WEBPACK_IMPORTED_MODULE_2__.useState(null);\n  const setReference = react__WEBPACK_IMPORTED_MODULE_2__.useCallback(node => {\n    if (node !== referenceRef.current) {\n      referenceRef.current = node;\n      _setReference(node);\n    }\n  }, []);\n  const setFloating = react__WEBPACK_IMPORTED_MODULE_2__.useCallback(node => {\n    if (node !== floatingRef.current) {\n      floatingRef.current = node;\n      _setFloating(node);\n    }\n  }, []);\n  const referenceEl = externalReference || _reference;\n  const floatingEl = externalFloating || _floating;\n  const referenceRef = react__WEBPACK_IMPORTED_MODULE_2__.useRef(null);\n  const floatingRef = react__WEBPACK_IMPORTED_MODULE_2__.useRef(null);\n  const dataRef = react__WEBPACK_IMPORTED_MODULE_2__.useRef(data);\n  const hasWhileElementsMounted = whileElementsMounted != null;\n  const whileElementsMountedRef = useLatestRef(whileElementsMounted);\n  const platformRef = useLatestRef(platform);\n  const openRef = useLatestRef(open);\n  const update = react__WEBPACK_IMPORTED_MODULE_2__.useCallback(() => {\n    if (!referenceRef.current || !floatingRef.current) {\n      return;\n    }\n    const config = {\n      placement,\n      strategy,\n      middleware: latestMiddleware\n    };\n    if (platformRef.current) {\n      config.platform = platformRef.current;\n    }\n    (0,_floating_ui_dom__WEBPACK_IMPORTED_MODULE_0__.computePosition)(referenceRef.current, floatingRef.current, config).then(data => {\n      const fullData = {\n        ...data,\n        // The floating element's position may be recomputed while it's closed\n        // but still mounted (such as when transitioning out). To ensure\n        // `isPositioned` will be `false` initially on the next open, avoid\n        // setting it to `true` when `open === false` (must be specified).\n        isPositioned: openRef.current !== false\n      };\n      if (isMountedRef.current && !deepEqual(dataRef.current, fullData)) {\n        dataRef.current = fullData;\n        react_dom__WEBPACK_IMPORTED_MODULE_3__.flushSync(() => {\n          setData(fullData);\n        });\n      }\n    });\n  }, [latestMiddleware, placement, strategy, platformRef, openRef]);\n  index(() => {\n    if (open === false && dataRef.current.isPositioned) {\n      dataRef.current.isPositioned = false;\n      setData(data => ({\n        ...data,\n        isPositioned: false\n      }));\n    }\n  }, [open]);\n  const isMountedRef = react__WEBPACK_IMPORTED_MODULE_2__.useRef(false);\n  index(() => {\n    isMountedRef.current = true;\n    return () => {\n      isMountedRef.current = false;\n    };\n  }, []);\n  index(() => {\n    if (referenceEl) referenceRef.current = referenceEl;\n    if (floatingEl) floatingRef.current = floatingEl;\n    if (referenceEl && floatingEl) {\n      if (whileElementsMountedRef.current) {\n        return whileElementsMountedRef.current(referenceEl, floatingEl, update);\n      }\n      update();\n    }\n  }, [referenceEl, floatingEl, update, whileElementsMountedRef, hasWhileElementsMounted]);\n  const refs = react__WEBPACK_IMPORTED_MODULE_2__.useMemo(() => ({\n    reference: referenceRef,\n    floating: floatingRef,\n    setReference,\n    setFloating\n  }), [setReference, setFloating]);\n  const elements = react__WEBPACK_IMPORTED_MODULE_2__.useMemo(() => ({\n    reference: referenceEl,\n    floating: floatingEl\n  }), [referenceEl, floatingEl]);\n  const floatingStyles = react__WEBPACK_IMPORTED_MODULE_2__.useMemo(() => {\n    const initialStyles = {\n      position: strategy,\n      left: 0,\n      top: 0\n    };\n    if (!elements.floating) {\n      return initialStyles;\n    }\n    const x = roundByDPR(elements.floating, data.x);\n    const y = roundByDPR(elements.floating, data.y);\n    if (transform) {\n      return {\n        ...initialStyles,\n        transform: \"translate(\" + x + \"px, \" + y + \"px)\",\n        ...(getDPR(elements.floating) >= 1.5 && {\n          willChange: 'transform'\n        })\n      };\n    }\n    return {\n      position: strategy,\n      left: x,\n      top: y\n    };\n  }, [strategy, transform, elements.floating, data.x, data.y]);\n  return react__WEBPACK_IMPORTED_MODULE_2__.useMemo(() => ({\n    ...data,\n    update,\n    refs,\n    elements,\n    floatingStyles\n  }), [data, update, refs, elements, floatingStyles]);\n}\n\n/**\n * Provides data to position an inner element of the floating element so that it\n * appears centered to the reference element.\n * This wraps the core `arrow` middleware to allow React refs as the element.\n * @see https://floating-ui.com/docs/arrow\n */\nconst arrow$1 = options => {\n  function isRef(value) {\n    return {}.hasOwnProperty.call(value, 'current');\n  }\n  return {\n    name: 'arrow',\n    options,\n    fn(state) {\n      const {\n        element,\n        padding\n      } = typeof options === 'function' ? options(state) : options;\n      if (element && isRef(element)) {\n        if (element.current != null) {\n          return (0,_floating_ui_dom__WEBPACK_IMPORTED_MODULE_0__.arrow)({\n            element: element.current,\n            padding\n          }).fn(state);\n        }\n        return {};\n      }\n      if (element) {\n        return (0,_floating_ui_dom__WEBPACK_IMPORTED_MODULE_0__.arrow)({\n          element,\n          padding\n        }).fn(state);\n      }\n      return {};\n    }\n  };\n};\n\n/**\n * Modifies the placement by translating the floating element along the\n * specified axes.\n * A number (shorthand for `mainAxis` or distance), or an axes configuration\n * object may be passed.\n * @see https://floating-ui.com/docs/offset\n */\nconst offset = (options, deps) => ({\n  ...(0,_floating_ui_dom__WEBPACK_IMPORTED_MODULE_0__.offset)(options),\n  options: [options, deps]\n});\n\n/**\n * Optimizes the visibility of the floating element by shifting it in order to\n * keep it in view when it will overflow the clipping boundary.\n * @see https://floating-ui.com/docs/shift\n */\nconst shift = (options, deps) => ({\n  ...(0,_floating_ui_dom__WEBPACK_IMPORTED_MODULE_0__.shift)(options),\n  options: [options, deps]\n});\n\n/**\n * Built-in `limiter` that will stop `shift()` at a certain point.\n */\nconst limitShift = (options, deps) => ({\n  ...(0,_floating_ui_dom__WEBPACK_IMPORTED_MODULE_0__.limitShift)(options),\n  options: [options, deps]\n});\n\n/**\n * Optimizes the visibility of the floating element by flipping the `placement`\n * in order to keep it in view when the preferred placement(s) will overflow the\n * clipping boundary. Alternative to `autoPlacement`.\n * @see https://floating-ui.com/docs/flip\n */\nconst flip = (options, deps) => ({\n  ...(0,_floating_ui_dom__WEBPACK_IMPORTED_MODULE_0__.flip)(options),\n  options: [options, deps]\n});\n\n/**\n * Provides data that allows you to change the size of the floating element \n * for instance, prevent it from overflowing the clipping boundary or match the\n * width of the reference element.\n * @see https://floating-ui.com/docs/size\n */\nconst size = (options, deps) => ({\n  ...(0,_floating_ui_dom__WEBPACK_IMPORTED_MODULE_0__.size)(options),\n  options: [options, deps]\n});\n\n/**\n * Optimizes the visibility of the floating element by choosing the placement\n * that has the most space available automatically, without needing to specify a\n * preferred placement. Alternative to `flip`.\n * @see https://floating-ui.com/docs/autoPlacement\n */\nconst autoPlacement = (options, deps) => ({\n  ...(0,_floating_ui_dom__WEBPACK_IMPORTED_MODULE_0__.autoPlacement)(options),\n  options: [options, deps]\n});\n\n/**\n * Provides data to hide the floating element in applicable situations, such as\n * when it is not in the same clipping context as the reference element.\n * @see https://floating-ui.com/docs/hide\n */\nconst hide = (options, deps) => ({\n  ...(0,_floating_ui_dom__WEBPACK_IMPORTED_MODULE_0__.hide)(options),\n  options: [options, deps]\n});\n\n/**\n * Provides improved positioning for inline reference elements that can span\n * over multiple lines, such as hyperlinks or range selections.\n * @see https://floating-ui.com/docs/inline\n */\nconst inline = (options, deps) => ({\n  ...(0,_floating_ui_dom__WEBPACK_IMPORTED_MODULE_0__.inline)(options),\n  options: [options, deps]\n});\n\n/**\n * Provides data to position an inner element of the floating element so that it\n * appears centered to the reference element.\n * This wraps the core `arrow` middleware to allow React refs as the element.\n * @see https://floating-ui.com/docs/arrow\n */\nconst arrow = (options, deps) => ({\n  ...arrow$1(options),\n  options: [options, deps]\n});\n\n\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvcmVhY3QtZGF0ZXBpY2tlci9ub2RlX21vZHVsZXMvQGZsb2F0aW5nLXVpL3JlYWN0L25vZGVfbW9kdWxlcy9AZmxvYXRpbmctdWkvcmVhY3QtZG9tL2Rpc3QvZmxvYXRpbmctdWkucmVhY3QtZG9tLm1qcyIsIm1hcHBpbmdzIjoiOzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7O0FBQTZPO0FBQzlIO0FBQ2hGO0FBQ1M7QUFDRjs7QUFFdEM7O0FBRUE7QUFDQSx1QkFBdUIsa0RBQWU7O0FBRXRDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsdUJBQXVCLFVBQVU7QUFDakM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHFCQUFxQixVQUFVO0FBQy9CLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQSxxQkFBcUIsVUFBVTtBQUMvQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxjQUFjLHlDQUFZO0FBQzFCO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU0sSUFBSTtBQUNWO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSiwwQkFBMEIsMkNBQWM7QUFDeEM7QUFDQTtBQUNBO0FBQ0E7QUFDQSxzQkFBc0I7QUFDdEI7QUFDQSxHQUFHO0FBQ0gsa0RBQWtELDJDQUFjO0FBQ2hFO0FBQ0E7QUFDQTtBQUNBLHNDQUFzQywyQ0FBYztBQUNwRCxvQ0FBb0MsMkNBQWM7QUFDbEQsdUJBQXVCLDhDQUFpQjtBQUN4QztBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSCxzQkFBc0IsOENBQWlCO0FBQ3ZDO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQSx1QkFBdUIseUNBQVk7QUFDbkMsc0JBQXNCLHlDQUFZO0FBQ2xDLGtCQUFrQix5Q0FBWTtBQUM5QjtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQiw4Q0FBaUI7QUFDbEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUksaUVBQWU7QUFDbkI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRLGdEQUFrQjtBQUMxQjtBQUNBLFNBQVM7QUFDVDtBQUNBLEtBQUs7QUFDTCxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0EsR0FBRztBQUNILHVCQUF1Qix5Q0FBWTtBQUNuQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSCxlQUFlLDBDQUFhO0FBQzVCO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNILG1CQUFtQiwwQ0FBYTtBQUNoQztBQUNBO0FBQ0EsR0FBRztBQUNILHlCQUF5QiwwQ0FBYTtBQUN0QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSCxTQUFTLDBDQUFhO0FBQ3RCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQSxpQkFBaUIsdURBQU87QUFDeEI7QUFDQTtBQUNBLFdBQVc7QUFDWDtBQUNBO0FBQ0E7QUFDQTtBQUNBLGVBQWUsdURBQU87QUFDdEI7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLLHdEQUFRO0FBQ2I7QUFDQSxDQUFDOztBQUVEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUssdURBQU87QUFDWjtBQUNBLENBQUM7O0FBRUQ7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLLDREQUFZO0FBQ2pCO0FBQ0EsQ0FBQzs7QUFFRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUssc0RBQU07QUFDWDtBQUNBLENBQUM7O0FBRUQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLLHNEQUFNO0FBQ1g7QUFDQSxDQUFDOztBQUVEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSywrREFBZTtBQUNwQjtBQUNBLENBQUM7O0FBRUQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSyxzREFBTTtBQUNYO0FBQ0EsQ0FBQzs7QUFFRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLLHdEQUFRO0FBQ2I7QUFDQSxDQUFDOztBQUVEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7O0FBRWlHIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vaW52b2ljZS1hcHAvLi9ub2RlX21vZHVsZXMvcmVhY3QtZGF0ZXBpY2tlci9ub2RlX21vZHVsZXMvQGZsb2F0aW5nLXVpL3JlYWN0L25vZGVfbW9kdWxlcy9AZmxvYXRpbmctdWkvcmVhY3QtZG9tL2Rpc3QvZmxvYXRpbmctdWkucmVhY3QtZG9tLm1qcz85NGI5Il0sInNvdXJjZXNDb250ZW50IjpbImltcG9ydCB7IGNvbXB1dGVQb3NpdGlvbiwgYXJyb3cgYXMgYXJyb3ckMiwgYXV0b1BsYWNlbWVudCBhcyBhdXRvUGxhY2VtZW50JDEsIGZsaXAgYXMgZmxpcCQxLCBoaWRlIGFzIGhpZGUkMSwgaW5saW5lIGFzIGlubGluZSQxLCBsaW1pdFNoaWZ0IGFzIGxpbWl0U2hpZnQkMSwgb2Zmc2V0IGFzIG9mZnNldCQxLCBzaGlmdCBhcyBzaGlmdCQxLCBzaXplIGFzIHNpemUkMSB9IGZyb20gJ0BmbG9hdGluZy11aS9kb20nO1xuZXhwb3J0IHsgYXV0b1VwZGF0ZSwgY29tcHV0ZVBvc2l0aW9uLCBkZXRlY3RPdmVyZmxvdywgZ2V0T3ZlcmZsb3dBbmNlc3RvcnMsIHBsYXRmb3JtIH0gZnJvbSAnQGZsb2F0aW5nLXVpL2RvbSc7XG5pbXBvcnQgKiBhcyBSZWFjdCBmcm9tICdyZWFjdCc7XG5pbXBvcnQgeyB1c2VMYXlvdXRFZmZlY3QgfSBmcm9tICdyZWFjdCc7XG5pbXBvcnQgKiBhcyBSZWFjdERPTSBmcm9tICdyZWFjdC1kb20nO1xuXG52YXIgaXNDbGllbnQgPSB0eXBlb2YgZG9jdW1lbnQgIT09ICd1bmRlZmluZWQnO1xuXG52YXIgbm9vcCA9IGZ1bmN0aW9uIG5vb3AoKSB7fTtcbnZhciBpbmRleCA9IGlzQ2xpZW50ID8gdXNlTGF5b3V0RWZmZWN0IDogbm9vcDtcblxuLy8gRm9yayBvZiBgZmFzdC1kZWVwLWVxdWFsYCB0aGF0IG9ubHkgZG9lcyB0aGUgY29tcGFyaXNvbnMgd2UgbmVlZCBhbmQgY29tcGFyZXNcbi8vIGZ1bmN0aW9uc1xuZnVuY3Rpb24gZGVlcEVxdWFsKGEsIGIpIHtcbiAgaWYgKGEgPT09IGIpIHtcbiAgICByZXR1cm4gdHJ1ZTtcbiAgfVxuICBpZiAodHlwZW9mIGEgIT09IHR5cGVvZiBiKSB7XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG4gIGlmICh0eXBlb2YgYSA9PT0gJ2Z1bmN0aW9uJyAmJiBhLnRvU3RyaW5nKCkgPT09IGIudG9TdHJpbmcoKSkge1xuICAgIHJldHVybiB0cnVlO1xuICB9XG4gIGxldCBsZW5ndGg7XG4gIGxldCBpO1xuICBsZXQga2V5cztcbiAgaWYgKGEgJiYgYiAmJiB0eXBlb2YgYSA9PT0gJ29iamVjdCcpIHtcbiAgICBpZiAoQXJyYXkuaXNBcnJheShhKSkge1xuICAgICAgbGVuZ3RoID0gYS5sZW5ndGg7XG4gICAgICBpZiAobGVuZ3RoICE9PSBiLmxlbmd0aCkgcmV0dXJuIGZhbHNlO1xuICAgICAgZm9yIChpID0gbGVuZ3RoOyBpLS0gIT09IDA7KSB7XG4gICAgICAgIGlmICghZGVlcEVxdWFsKGFbaV0sIGJbaV0pKSB7XG4gICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9XG4gICAga2V5cyA9IE9iamVjdC5rZXlzKGEpO1xuICAgIGxlbmd0aCA9IGtleXMubGVuZ3RoO1xuICAgIGlmIChsZW5ndGggIT09IE9iamVjdC5rZXlzKGIpLmxlbmd0aCkge1xuICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbiAgICBmb3IgKGkgPSBsZW5ndGg7IGktLSAhPT0gMDspIHtcbiAgICAgIGlmICghe30uaGFzT3duUHJvcGVydHkuY2FsbChiLCBrZXlzW2ldKSkge1xuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICB9XG4gICAgfVxuICAgIGZvciAoaSA9IGxlbmd0aDsgaS0tICE9PSAwOykge1xuICAgICAgY29uc3Qga2V5ID0ga2V5c1tpXTtcbiAgICAgIGlmIChrZXkgPT09ICdfb3duZXInICYmIGEuJCR0eXBlb2YpIHtcbiAgICAgICAgY29udGludWU7XG4gICAgICB9XG4gICAgICBpZiAoIWRlZXBFcXVhbChhW2tleV0sIGJba2V5XSkpIHtcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gdHJ1ZTtcbiAgfVxuICByZXR1cm4gYSAhPT0gYSAmJiBiICE9PSBiO1xufVxuXG5mdW5jdGlvbiBnZXREUFIoZWxlbWVudCkge1xuICBpZiAodHlwZW9mIHdpbmRvdyA9PT0gJ3VuZGVmaW5lZCcpIHtcbiAgICByZXR1cm4gMTtcbiAgfVxuICBjb25zdCB3aW4gPSBlbGVtZW50Lm93bmVyRG9jdW1lbnQuZGVmYXVsdFZpZXcgfHwgd2luZG93O1xuICByZXR1cm4gd2luLmRldmljZVBpeGVsUmF0aW8gfHwgMTtcbn1cblxuZnVuY3Rpb24gcm91bmRCeURQUihlbGVtZW50LCB2YWx1ZSkge1xuICBjb25zdCBkcHIgPSBnZXREUFIoZWxlbWVudCk7XG4gIHJldHVybiBNYXRoLnJvdW5kKHZhbHVlICogZHByKSAvIGRwcjtcbn1cblxuZnVuY3Rpb24gdXNlTGF0ZXN0UmVmKHZhbHVlKSB7XG4gIGNvbnN0IHJlZiA9IFJlYWN0LnVzZVJlZih2YWx1ZSk7XG4gIGluZGV4KCgpID0+IHtcbiAgICByZWYuY3VycmVudCA9IHZhbHVlO1xuICB9KTtcbiAgcmV0dXJuIHJlZjtcbn1cblxuLyoqXG4gKiBQcm92aWRlcyBkYXRhIHRvIHBvc2l0aW9uIGEgZmxvYXRpbmcgZWxlbWVudC5cbiAqIEBzZWUgaHR0cHM6Ly9mbG9hdGluZy11aS5jb20vZG9jcy91c2VGbG9hdGluZ1xuICovXG5mdW5jdGlvbiB1c2VGbG9hdGluZyhvcHRpb25zKSB7XG4gIGlmIChvcHRpb25zID09PSB2b2lkIDApIHtcbiAgICBvcHRpb25zID0ge307XG4gIH1cbiAgY29uc3Qge1xuICAgIHBsYWNlbWVudCA9ICdib3R0b20nLFxuICAgIHN0cmF0ZWd5ID0gJ2Fic29sdXRlJyxcbiAgICBtaWRkbGV3YXJlID0gW10sXG4gICAgcGxhdGZvcm0sXG4gICAgZWxlbWVudHM6IHtcbiAgICAgIHJlZmVyZW5jZTogZXh0ZXJuYWxSZWZlcmVuY2UsXG4gICAgICBmbG9hdGluZzogZXh0ZXJuYWxGbG9hdGluZ1xuICAgIH0gPSB7fSxcbiAgICB0cmFuc2Zvcm0gPSB0cnVlLFxuICAgIHdoaWxlRWxlbWVudHNNb3VudGVkLFxuICAgIG9wZW5cbiAgfSA9IG9wdGlvbnM7XG4gIGNvbnN0IFtkYXRhLCBzZXREYXRhXSA9IFJlYWN0LnVzZVN0YXRlKHtcbiAgICB4OiAwLFxuICAgIHk6IDAsXG4gICAgc3RyYXRlZ3ksXG4gICAgcGxhY2VtZW50LFxuICAgIG1pZGRsZXdhcmVEYXRhOiB7fSxcbiAgICBpc1Bvc2l0aW9uZWQ6IGZhbHNlXG4gIH0pO1xuICBjb25zdCBbbGF0ZXN0TWlkZGxld2FyZSwgc2V0TGF0ZXN0TWlkZGxld2FyZV0gPSBSZWFjdC51c2VTdGF0ZShtaWRkbGV3YXJlKTtcbiAgaWYgKCFkZWVwRXF1YWwobGF0ZXN0TWlkZGxld2FyZSwgbWlkZGxld2FyZSkpIHtcbiAgICBzZXRMYXRlc3RNaWRkbGV3YXJlKG1pZGRsZXdhcmUpO1xuICB9XG4gIGNvbnN0IFtfcmVmZXJlbmNlLCBfc2V0UmVmZXJlbmNlXSA9IFJlYWN0LnVzZVN0YXRlKG51bGwpO1xuICBjb25zdCBbX2Zsb2F0aW5nLCBfc2V0RmxvYXRpbmddID0gUmVhY3QudXNlU3RhdGUobnVsbCk7XG4gIGNvbnN0IHNldFJlZmVyZW5jZSA9IFJlYWN0LnVzZUNhbGxiYWNrKG5vZGUgPT4ge1xuICAgIGlmIChub2RlICE9PSByZWZlcmVuY2VSZWYuY3VycmVudCkge1xuICAgICAgcmVmZXJlbmNlUmVmLmN1cnJlbnQgPSBub2RlO1xuICAgICAgX3NldFJlZmVyZW5jZShub2RlKTtcbiAgICB9XG4gIH0sIFtdKTtcbiAgY29uc3Qgc2V0RmxvYXRpbmcgPSBSZWFjdC51c2VDYWxsYmFjayhub2RlID0+IHtcbiAgICBpZiAobm9kZSAhPT0gZmxvYXRpbmdSZWYuY3VycmVudCkge1xuICAgICAgZmxvYXRpbmdSZWYuY3VycmVudCA9IG5vZGU7XG4gICAgICBfc2V0RmxvYXRpbmcobm9kZSk7XG4gICAgfVxuICB9LCBbXSk7XG4gIGNvbnN0IHJlZmVyZW5jZUVsID0gZXh0ZXJuYWxSZWZlcmVuY2UgfHwgX3JlZmVyZW5jZTtcbiAgY29uc3QgZmxvYXRpbmdFbCA9IGV4dGVybmFsRmxvYXRpbmcgfHwgX2Zsb2F0aW5nO1xuICBjb25zdCByZWZlcmVuY2VSZWYgPSBSZWFjdC51c2VSZWYobnVsbCk7XG4gIGNvbnN0IGZsb2F0aW5nUmVmID0gUmVhY3QudXNlUmVmKG51bGwpO1xuICBjb25zdCBkYXRhUmVmID0gUmVhY3QudXNlUmVmKGRhdGEpO1xuICBjb25zdCBoYXNXaGlsZUVsZW1lbnRzTW91bnRlZCA9IHdoaWxlRWxlbWVudHNNb3VudGVkICE9IG51bGw7XG4gIGNvbnN0IHdoaWxlRWxlbWVudHNNb3VudGVkUmVmID0gdXNlTGF0ZXN0UmVmKHdoaWxlRWxlbWVudHNNb3VudGVkKTtcbiAgY29uc3QgcGxhdGZvcm1SZWYgPSB1c2VMYXRlc3RSZWYocGxhdGZvcm0pO1xuICBjb25zdCBvcGVuUmVmID0gdXNlTGF0ZXN0UmVmKG9wZW4pO1xuICBjb25zdCB1cGRhdGUgPSBSZWFjdC51c2VDYWxsYmFjaygoKSA9PiB7XG4gICAgaWYgKCFyZWZlcmVuY2VSZWYuY3VycmVudCB8fCAhZmxvYXRpbmdSZWYuY3VycmVudCkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBjb25zdCBjb25maWcgPSB7XG4gICAgICBwbGFjZW1lbnQsXG4gICAgICBzdHJhdGVneSxcbiAgICAgIG1pZGRsZXdhcmU6IGxhdGVzdE1pZGRsZXdhcmVcbiAgICB9O1xuICAgIGlmIChwbGF0Zm9ybVJlZi5jdXJyZW50KSB7XG4gICAgICBjb25maWcucGxhdGZvcm0gPSBwbGF0Zm9ybVJlZi5jdXJyZW50O1xuICAgIH1cbiAgICBjb21wdXRlUG9zaXRpb24ocmVmZXJlbmNlUmVmLmN1cnJlbnQsIGZsb2F0aW5nUmVmLmN1cnJlbnQsIGNvbmZpZykudGhlbihkYXRhID0+IHtcbiAgICAgIGNvbnN0IGZ1bGxEYXRhID0ge1xuICAgICAgICAuLi5kYXRhLFxuICAgICAgICAvLyBUaGUgZmxvYXRpbmcgZWxlbWVudCdzIHBvc2l0aW9uIG1heSBiZSByZWNvbXB1dGVkIHdoaWxlIGl0J3MgY2xvc2VkXG4gICAgICAgIC8vIGJ1dCBzdGlsbCBtb3VudGVkIChzdWNoIGFzIHdoZW4gdHJhbnNpdGlvbmluZyBvdXQpLiBUbyBlbnN1cmVcbiAgICAgICAgLy8gYGlzUG9zaXRpb25lZGAgd2lsbCBiZSBgZmFsc2VgIGluaXRpYWxseSBvbiB0aGUgbmV4dCBvcGVuLCBhdm9pZFxuICAgICAgICAvLyBzZXR0aW5nIGl0IHRvIGB0cnVlYCB3aGVuIGBvcGVuID09PSBmYWxzZWAgKG11c3QgYmUgc3BlY2lmaWVkKS5cbiAgICAgICAgaXNQb3NpdGlvbmVkOiBvcGVuUmVmLmN1cnJlbnQgIT09IGZhbHNlXG4gICAgICB9O1xuICAgICAgaWYgKGlzTW91bnRlZFJlZi5jdXJyZW50ICYmICFkZWVwRXF1YWwoZGF0YVJlZi5jdXJyZW50LCBmdWxsRGF0YSkpIHtcbiAgICAgICAgZGF0YVJlZi5jdXJyZW50ID0gZnVsbERhdGE7XG4gICAgICAgIFJlYWN0RE9NLmZsdXNoU3luYygoKSA9PiB7XG4gICAgICAgICAgc2V0RGF0YShmdWxsRGF0YSk7XG4gICAgICAgIH0pO1xuICAgICAgfVxuICAgIH0pO1xuICB9LCBbbGF0ZXN0TWlkZGxld2FyZSwgcGxhY2VtZW50LCBzdHJhdGVneSwgcGxhdGZvcm1SZWYsIG9wZW5SZWZdKTtcbiAgaW5kZXgoKCkgPT4ge1xuICAgIGlmIChvcGVuID09PSBmYWxzZSAmJiBkYXRhUmVmLmN1cnJlbnQuaXNQb3NpdGlvbmVkKSB7XG4gICAgICBkYXRhUmVmLmN1cnJlbnQuaXNQb3NpdGlvbmVkID0gZmFsc2U7XG4gICAgICBzZXREYXRhKGRhdGEgPT4gKHtcbiAgICAgICAgLi4uZGF0YSxcbiAgICAgICAgaXNQb3NpdGlvbmVkOiBmYWxzZVxuICAgICAgfSkpO1xuICAgIH1cbiAgfSwgW29wZW5dKTtcbiAgY29uc3QgaXNNb3VudGVkUmVmID0gUmVhY3QudXNlUmVmKGZhbHNlKTtcbiAgaW5kZXgoKCkgPT4ge1xuICAgIGlzTW91bnRlZFJlZi5jdXJyZW50ID0gdHJ1ZTtcbiAgICByZXR1cm4gKCkgPT4ge1xuICAgICAgaXNNb3VudGVkUmVmLmN1cnJlbnQgPSBmYWxzZTtcbiAgICB9O1xuICB9LCBbXSk7XG4gIGluZGV4KCgpID0+IHtcbiAgICBpZiAocmVmZXJlbmNlRWwpIHJlZmVyZW5jZVJlZi5jdXJyZW50ID0gcmVmZXJlbmNlRWw7XG4gICAgaWYgKGZsb2F0aW5nRWwpIGZsb2F0aW5nUmVmLmN1cnJlbnQgPSBmbG9hdGluZ0VsO1xuICAgIGlmIChyZWZlcmVuY2VFbCAmJiBmbG9hdGluZ0VsKSB7XG4gICAgICBpZiAod2hpbGVFbGVtZW50c01vdW50ZWRSZWYuY3VycmVudCkge1xuICAgICAgICByZXR1cm4gd2hpbGVFbGVtZW50c01vdW50ZWRSZWYuY3VycmVudChyZWZlcmVuY2VFbCwgZmxvYXRpbmdFbCwgdXBkYXRlKTtcbiAgICAgIH1cbiAgICAgIHVwZGF0ZSgpO1xuICAgIH1cbiAgfSwgW3JlZmVyZW5jZUVsLCBmbG9hdGluZ0VsLCB1cGRhdGUsIHdoaWxlRWxlbWVudHNNb3VudGVkUmVmLCBoYXNXaGlsZUVsZW1lbnRzTW91bnRlZF0pO1xuICBjb25zdCByZWZzID0gUmVhY3QudXNlTWVtbygoKSA9PiAoe1xuICAgIHJlZmVyZW5jZTogcmVmZXJlbmNlUmVmLFxuICAgIGZsb2F0aW5nOiBmbG9hdGluZ1JlZixcbiAgICBzZXRSZWZlcmVuY2UsXG4gICAgc2V0RmxvYXRpbmdcbiAgfSksIFtzZXRSZWZlcmVuY2UsIHNldEZsb2F0aW5nXSk7XG4gIGNvbnN0IGVsZW1lbnRzID0gUmVhY3QudXNlTWVtbygoKSA9PiAoe1xuICAgIHJlZmVyZW5jZTogcmVmZXJlbmNlRWwsXG4gICAgZmxvYXRpbmc6IGZsb2F0aW5nRWxcbiAgfSksIFtyZWZlcmVuY2VFbCwgZmxvYXRpbmdFbF0pO1xuICBjb25zdCBmbG9hdGluZ1N0eWxlcyA9IFJlYWN0LnVzZU1lbW8oKCkgPT4ge1xuICAgIGNvbnN0IGluaXRpYWxTdHlsZXMgPSB7XG4gICAgICBwb3NpdGlvbjogc3RyYXRlZ3ksXG4gICAgICBsZWZ0OiAwLFxuICAgICAgdG9wOiAwXG4gICAgfTtcbiAgICBpZiAoIWVsZW1lbnRzLmZsb2F0aW5nKSB7XG4gICAgICByZXR1cm4gaW5pdGlhbFN0eWxlcztcbiAgICB9XG4gICAgY29uc3QgeCA9IHJvdW5kQnlEUFIoZWxlbWVudHMuZmxvYXRpbmcsIGRhdGEueCk7XG4gICAgY29uc3QgeSA9IHJvdW5kQnlEUFIoZWxlbWVudHMuZmxvYXRpbmcsIGRhdGEueSk7XG4gICAgaWYgKHRyYW5zZm9ybSkge1xuICAgICAgcmV0dXJuIHtcbiAgICAgICAgLi4uaW5pdGlhbFN0eWxlcyxcbiAgICAgICAgdHJhbnNmb3JtOiBcInRyYW5zbGF0ZShcIiArIHggKyBcInB4LCBcIiArIHkgKyBcInB4KVwiLFxuICAgICAgICAuLi4oZ2V0RFBSKGVsZW1lbnRzLmZsb2F0aW5nKSA+PSAxLjUgJiYge1xuICAgICAgICAgIHdpbGxDaGFuZ2U6ICd0cmFuc2Zvcm0nXG4gICAgICAgIH0pXG4gICAgICB9O1xuICAgIH1cbiAgICByZXR1cm4ge1xuICAgICAgcG9zaXRpb246IHN0cmF0ZWd5LFxuICAgICAgbGVmdDogeCxcbiAgICAgIHRvcDogeVxuICAgIH07XG4gIH0sIFtzdHJhdGVneSwgdHJhbnNmb3JtLCBlbGVtZW50cy5mbG9hdGluZywgZGF0YS54LCBkYXRhLnldKTtcbiAgcmV0dXJuIFJlYWN0LnVzZU1lbW8oKCkgPT4gKHtcbiAgICAuLi5kYXRhLFxuICAgIHVwZGF0ZSxcbiAgICByZWZzLFxuICAgIGVsZW1lbnRzLFxuICAgIGZsb2F0aW5nU3R5bGVzXG4gIH0pLCBbZGF0YSwgdXBkYXRlLCByZWZzLCBlbGVtZW50cywgZmxvYXRpbmdTdHlsZXNdKTtcbn1cblxuLyoqXG4gKiBQcm92aWRlcyBkYXRhIHRvIHBvc2l0aW9uIGFuIGlubmVyIGVsZW1lbnQgb2YgdGhlIGZsb2F0aW5nIGVsZW1lbnQgc28gdGhhdCBpdFxuICogYXBwZWFycyBjZW50ZXJlZCB0byB0aGUgcmVmZXJlbmNlIGVsZW1lbnQuXG4gKiBUaGlzIHdyYXBzIHRoZSBjb3JlIGBhcnJvd2AgbWlkZGxld2FyZSB0byBhbGxvdyBSZWFjdCByZWZzIGFzIHRoZSBlbGVtZW50LlxuICogQHNlZSBodHRwczovL2Zsb2F0aW5nLXVpLmNvbS9kb2NzL2Fycm93XG4gKi9cbmNvbnN0IGFycm93JDEgPSBvcHRpb25zID0+IHtcbiAgZnVuY3Rpb24gaXNSZWYodmFsdWUpIHtcbiAgICByZXR1cm4ge30uaGFzT3duUHJvcGVydHkuY2FsbCh2YWx1ZSwgJ2N1cnJlbnQnKTtcbiAgfVxuICByZXR1cm4ge1xuICAgIG5hbWU6ICdhcnJvdycsXG4gICAgb3B0aW9ucyxcbiAgICBmbihzdGF0ZSkge1xuICAgICAgY29uc3Qge1xuICAgICAgICBlbGVtZW50LFxuICAgICAgICBwYWRkaW5nXG4gICAgICB9ID0gdHlwZW9mIG9wdGlvbnMgPT09ICdmdW5jdGlvbicgPyBvcHRpb25zKHN0YXRlKSA6IG9wdGlvbnM7XG4gICAgICBpZiAoZWxlbWVudCAmJiBpc1JlZihlbGVtZW50KSkge1xuICAgICAgICBpZiAoZWxlbWVudC5jdXJyZW50ICE9IG51bGwpIHtcbiAgICAgICAgICByZXR1cm4gYXJyb3ckMih7XG4gICAgICAgICAgICBlbGVtZW50OiBlbGVtZW50LmN1cnJlbnQsXG4gICAgICAgICAgICBwYWRkaW5nXG4gICAgICAgICAgfSkuZm4oc3RhdGUpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB7fTtcbiAgICAgIH1cbiAgICAgIGlmIChlbGVtZW50KSB7XG4gICAgICAgIHJldHVybiBhcnJvdyQyKHtcbiAgICAgICAgICBlbGVtZW50LFxuICAgICAgICAgIHBhZGRpbmdcbiAgICAgICAgfSkuZm4oc3RhdGUpO1xuICAgICAgfVxuICAgICAgcmV0dXJuIHt9O1xuICAgIH1cbiAgfTtcbn07XG5cbi8qKlxuICogTW9kaWZpZXMgdGhlIHBsYWNlbWVudCBieSB0cmFuc2xhdGluZyB0aGUgZmxvYXRpbmcgZWxlbWVudCBhbG9uZyB0aGVcbiAqIHNwZWNpZmllZCBheGVzLlxuICogQSBudW1iZXIgKHNob3J0aGFuZCBmb3IgYG1haW5BeGlzYCBvciBkaXN0YW5jZSksIG9yIGFuIGF4ZXMgY29uZmlndXJhdGlvblxuICogb2JqZWN0IG1heSBiZSBwYXNzZWQuXG4gKiBAc2VlIGh0dHBzOi8vZmxvYXRpbmctdWkuY29tL2RvY3Mvb2Zmc2V0XG4gKi9cbmNvbnN0IG9mZnNldCA9IChvcHRpb25zLCBkZXBzKSA9PiAoe1xuICAuLi5vZmZzZXQkMShvcHRpb25zKSxcbiAgb3B0aW9uczogW29wdGlvbnMsIGRlcHNdXG59KTtcblxuLyoqXG4gKiBPcHRpbWl6ZXMgdGhlIHZpc2liaWxpdHkgb2YgdGhlIGZsb2F0aW5nIGVsZW1lbnQgYnkgc2hpZnRpbmcgaXQgaW4gb3JkZXIgdG9cbiAqIGtlZXAgaXQgaW4gdmlldyB3aGVuIGl0IHdpbGwgb3ZlcmZsb3cgdGhlIGNsaXBwaW5nIGJvdW5kYXJ5LlxuICogQHNlZSBodHRwczovL2Zsb2F0aW5nLXVpLmNvbS9kb2NzL3NoaWZ0XG4gKi9cbmNvbnN0IHNoaWZ0ID0gKG9wdGlvbnMsIGRlcHMpID0+ICh7XG4gIC4uLnNoaWZ0JDEob3B0aW9ucyksXG4gIG9wdGlvbnM6IFtvcHRpb25zLCBkZXBzXVxufSk7XG5cbi8qKlxuICogQnVpbHQtaW4gYGxpbWl0ZXJgIHRoYXQgd2lsbCBzdG9wIGBzaGlmdCgpYCBhdCBhIGNlcnRhaW4gcG9pbnQuXG4gKi9cbmNvbnN0IGxpbWl0U2hpZnQgPSAob3B0aW9ucywgZGVwcykgPT4gKHtcbiAgLi4ubGltaXRTaGlmdCQxKG9wdGlvbnMpLFxuICBvcHRpb25zOiBbb3B0aW9ucywgZGVwc11cbn0pO1xuXG4vKipcbiAqIE9wdGltaXplcyB0aGUgdmlzaWJpbGl0eSBvZiB0aGUgZmxvYXRpbmcgZWxlbWVudCBieSBmbGlwcGluZyB0aGUgYHBsYWNlbWVudGBcbiAqIGluIG9yZGVyIHRvIGtlZXAgaXQgaW4gdmlldyB3aGVuIHRoZSBwcmVmZXJyZWQgcGxhY2VtZW50KHMpIHdpbGwgb3ZlcmZsb3cgdGhlXG4gKiBjbGlwcGluZyBib3VuZGFyeS4gQWx0ZXJuYXRpdmUgdG8gYGF1dG9QbGFjZW1lbnRgLlxuICogQHNlZSBodHRwczovL2Zsb2F0aW5nLXVpLmNvbS9kb2NzL2ZsaXBcbiAqL1xuY29uc3QgZmxpcCA9IChvcHRpb25zLCBkZXBzKSA9PiAoe1xuICAuLi5mbGlwJDEob3B0aW9ucyksXG4gIG9wdGlvbnM6IFtvcHRpb25zLCBkZXBzXVxufSk7XG5cbi8qKlxuICogUHJvdmlkZXMgZGF0YSB0aGF0IGFsbG93cyB5b3UgdG8gY2hhbmdlIHRoZSBzaXplIG9mIHRoZSBmbG9hdGluZyBlbGVtZW50IOKAlFxuICogZm9yIGluc3RhbmNlLCBwcmV2ZW50IGl0IGZyb20gb3ZlcmZsb3dpbmcgdGhlIGNsaXBwaW5nIGJvdW5kYXJ5IG9yIG1hdGNoIHRoZVxuICogd2lkdGggb2YgdGhlIHJlZmVyZW5jZSBlbGVtZW50LlxuICogQHNlZSBodHRwczovL2Zsb2F0aW5nLXVpLmNvbS9kb2NzL3NpemVcbiAqL1xuY29uc3Qgc2l6ZSA9IChvcHRpb25zLCBkZXBzKSA9PiAoe1xuICAuLi5zaXplJDEob3B0aW9ucyksXG4gIG9wdGlvbnM6IFtvcHRpb25zLCBkZXBzXVxufSk7XG5cbi8qKlxuICogT3B0aW1pemVzIHRoZSB2aXNpYmlsaXR5IG9mIHRoZSBmbG9hdGluZyBlbGVtZW50IGJ5IGNob29zaW5nIHRoZSBwbGFjZW1lbnRcbiAqIHRoYXQgaGFzIHRoZSBtb3N0IHNwYWNlIGF2YWlsYWJsZSBhdXRvbWF0aWNhbGx5LCB3aXRob3V0IG5lZWRpbmcgdG8gc3BlY2lmeSBhXG4gKiBwcmVmZXJyZWQgcGxhY2VtZW50LiBBbHRlcm5hdGl2ZSB0byBgZmxpcGAuXG4gKiBAc2VlIGh0dHBzOi8vZmxvYXRpbmctdWkuY29tL2RvY3MvYXV0b1BsYWNlbWVudFxuICovXG5jb25zdCBhdXRvUGxhY2VtZW50ID0gKG9wdGlvbnMsIGRlcHMpID0+ICh7XG4gIC4uLmF1dG9QbGFjZW1lbnQkMShvcHRpb25zKSxcbiAgb3B0aW9uczogW29wdGlvbnMsIGRlcHNdXG59KTtcblxuLyoqXG4gKiBQcm92aWRlcyBkYXRhIHRvIGhpZGUgdGhlIGZsb2F0aW5nIGVsZW1lbnQgaW4gYXBwbGljYWJsZSBzaXR1YXRpb25zLCBzdWNoIGFzXG4gKiB3aGVuIGl0IGlzIG5vdCBpbiB0aGUgc2FtZSBjbGlwcGluZyBjb250ZXh0IGFzIHRoZSByZWZlcmVuY2UgZWxlbWVudC5cbiAqIEBzZWUgaHR0cHM6Ly9mbG9hdGluZy11aS5jb20vZG9jcy9oaWRlXG4gKi9cbmNvbnN0IGhpZGUgPSAob3B0aW9ucywgZGVwcykgPT4gKHtcbiAgLi4uaGlkZSQxKG9wdGlvbnMpLFxuICBvcHRpb25zOiBbb3B0aW9ucywgZGVwc11cbn0pO1xuXG4vKipcbiAqIFByb3ZpZGVzIGltcHJvdmVkIHBvc2l0aW9uaW5nIGZvciBpbmxpbmUgcmVmZXJlbmNlIGVsZW1lbnRzIHRoYXQgY2FuIHNwYW5cbiAqIG92ZXIgbXVsdGlwbGUgbGluZXMsIHN1Y2ggYXMgaHlwZXJsaW5rcyBvciByYW5nZSBzZWxlY3Rpb25zLlxuICogQHNlZSBodHRwczovL2Zsb2F0aW5nLXVpLmNvbS9kb2NzL2lubGluZVxuICovXG5jb25zdCBpbmxpbmUgPSAob3B0aW9ucywgZGVwcykgPT4gKHtcbiAgLi4uaW5saW5lJDEob3B0aW9ucyksXG4gIG9wdGlvbnM6IFtvcHRpb25zLCBkZXBzXVxufSk7XG5cbi8qKlxuICogUHJvdmlkZXMgZGF0YSB0byBwb3NpdGlvbiBhbiBpbm5lciBlbGVtZW50IG9mIHRoZSBmbG9hdGluZyBlbGVtZW50IHNvIHRoYXQgaXRcbiAqIGFwcGVhcnMgY2VudGVyZWQgdG8gdGhlIHJlZmVyZW5jZSBlbGVtZW50LlxuICogVGhpcyB3cmFwcyB0aGUgY29yZSBgYXJyb3dgIG1pZGRsZXdhcmUgdG8gYWxsb3cgUmVhY3QgcmVmcyBhcyB0aGUgZWxlbWVudC5cbiAqIEBzZWUgaHR0cHM6Ly9mbG9hdGluZy11aS5jb20vZG9jcy9hcnJvd1xuICovXG5jb25zdCBhcnJvdyA9IChvcHRpb25zLCBkZXBzKSA9PiAoe1xuICAuLi5hcnJvdyQxKG9wdGlvbnMpLFxuICBvcHRpb25zOiBbb3B0aW9ucywgZGVwc11cbn0pO1xuXG5leHBvcnQgeyBhcnJvdywgYXV0b1BsYWNlbWVudCwgZmxpcCwgaGlkZSwgaW5saW5lLCBsaW1pdFNoaWZ0LCBvZmZzZXQsIHNoaWZ0LCBzaXplLCB1c2VGbG9hdGluZyB9O1xuIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/react-datepicker/node_modules/@floating-ui/react/node_modules/@floating-ui/react-dom/dist/floating-ui.react-dom.mjs\n");

/***/ })

};
;